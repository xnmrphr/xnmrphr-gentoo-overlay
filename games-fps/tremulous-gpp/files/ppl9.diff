Index: src/sdl/sdl_glimp.c
===================================================================
--- src/sdl/sdl_glimp.c	(Revision 2062)
+++ src/sdl/sdl_glimp.c	(Arbeitskopie)
@@ -33,6 +33,9 @@
 #	else
 #		include <SDL_thread.h>
 #	endif
+#	ifdef SDL_VIDEO_DRIVER_X11
+#		include <X11/Xlib.h>
+#	endif
 #endif
 
 #include <stdarg.h>
@@ -44,20 +47,211 @@
 #include "../client/client.h"
 #include "../sys/sys_local.h"
 #include "sdl_icon.h"
+#include "SDL_syswm.h"
 
 /* Just hack it for now. */
 #ifdef MACOS_X
 #include <OpenGL/OpenGL.h>
+
 typedef CGLContextObj QGLContext;
-#define GLimp_GetCurrentContext() CGLGetCurrentContext()
-#define GLimp_SetCurrentContext(ctx) CGLSetCurrentContext(ctx)
+
+static void GLimp_GetCurrentContext( QGLContext *ctx )
+{
+	*ctx = CGLGetCurrentContext();
+}
+
+static void GLimp_SetCurrentContext( QGLContext *ctx )
+{
+	CGLSetCurrentContext( ctx ? *ctx : NULL );
+}
+static void GLimp_CreateSharedContext( QGLContext *old, qboolean debug,
+				       qboolean nodraw, QGLContext *new ) {
+	// AFAIK debug contexts are not supported
+	CGLCreateContext ( CGLPixelFormatObj pix, *old, new );
+
+	if( nodraw ) {
+		glDrawBuffer( GL_NONE );
+	}
+}
+static void GLimp_DestroyContext( QGLContext *parent, QGLContext *ctx ) {
+	if( *parent != *ctx ) {
+		CGLDestroyContext( *ctx );
+		*ctx = *parent;
+	}
+}
+#elif SDL_VIDEO_DRIVER_X11
+#include <GL/glx.h>
+typedef struct
+{
+	GLXContext      ctx;
+	Display         *dpy;
+	GLXDrawable     drawable;
+} QGLContext;
+
+static void GLimp_GetCurrentContext( QGLContext *ctx )
+{
+	ctx->ctx = glXGetCurrentContext();
+	ctx->dpy = glXGetCurrentDisplay();
+	ctx->drawable = glXGetCurrentDrawable();
+}
+
+static void GLimp_SetCurrentContext( QGLContext *ctx )
+{
+	if( ctx )
+		glXMakeCurrent( ctx->dpy, ctx->drawable, ctx->ctx );
+	else
+		glXMakeCurrent( glXGetCurrentDisplay(), 0, NULL );
+}
+static void GLimp_CreateSharedContext( QGLContext *old, qboolean debug,
+				       qboolean nodraw, QGLContext *new ) {
+	GLubyte *procName = (GLubyte *)"glXCreateContextAttribsARB";
+	GLXContext (APIENTRYP glXCreateContextAttribsARB)( Display *dpy,
+							   GLXFBConfig config,
+							   GLXContext share_context,
+							   Bool direct,
+							   const int *attrib_list);
+	int config_attrib_list[] = {
+		GLX_FBCONFIG_ID, 0,
+		None
+	};
+	int attrib_list[] = {
+		GLX_RENDER_TYPE, GLX_RGBA_TYPE,
+		GLX_CONTEXT_FLAGS_ARB, GLX_CONTEXT_DEBUG_BIT_ARB,
+		None
+	};
+	GLXFBConfig *config;
+	int         count;
+
+	if( glXQueryContext(old->dpy, old->ctx,
+			    GLX_FBCONFIG_ID,
+			    &config_attrib_list[1]) != Success )
+		return;
+
+	config = glXChooseFBConfig( old->dpy, 0,
+				    config_attrib_list,
+				    &count );
+	if( count != 1 )
+		return;
+
+	if( debug ) {
+		glXCreateContextAttribsARB = (void *)glXGetProcAddress(procName);
+		if( !glXCreateContextAttribsARB )
+			debug = qfalse;
+	} else {
+		glXCreateContextAttribsARB = NULL;
+	}
+
+	new->dpy = old->dpy;
+	if( nodraw ) {
+		new->drawable = glXCreatePbuffer(old->dpy,
+						 config[0],
+						 NULL);
+	} else {
+		new->drawable = old->drawable;
+	}
+	if( debug ) {
+		new->ctx = glXCreateContextAttribsARB(old->dpy,
+						      config[0],
+						      old->ctx,
+						      GL_TRUE,
+						      attrib_list);
+	} else {
+		new->ctx = glXCreateNewContext(old->dpy,
+					       config[0],
+					       GLX_RGBA_TYPE,
+					       old->ctx,
+					       GL_TRUE);
+	}
+
+	if( nodraw ) {
+		glDrawBuffer( GL_NONE );
+	}
+}
+static void GLimp_DestroyContext( QGLContext *parent, QGLContext *ctx ) {
+	if( parent->ctx != ctx->ctx ) {
+		glXDestroyContext( ctx->dpy, ctx->ctx );
+		ctx->ctx = parent->ctx;
+	}
+	if( parent->drawable != ctx->drawable ) {
+		glXDestroyPbuffer( ctx->dpy, ctx->drawable );
+		ctx->drawable = parent->drawable;
+	}
+}
+#elif WIN32
+typedef struct
+{
+	HDC             hDC;		// handle to device context
+	HGLRC           hGLRC;		// handle to GL rendering context
+} QGLContext;
+
+static void GLimp_GetCurrentContext( QGLContext *ctx ) {
+	SDL_SysWMinfo info;
+
+	SDL_VERSION(&info.version);
+	if(!SDL_GetWMInfo(&info))
+	{
+		ri.Printf(PRINT_WARNING, "Failed to obtain HWND from SDL (InputRegistry)");
+		return;
+	}
+
+	ctx->hDC = GetDC(info.window);
+	ctx->hGLRC = info.hglrc;
+}
+
+static void GLimp_SetCurrentContext( QGLContext *ctx ) {
+	if( ctx ) {
+		wglMakeCurrent( ctx->hDC, ctx->hGLRC );
+	} else {
+		wglMakeCurrent( NULL, NULL );
+	}
+}
+static void GLimp_CreateSharedContext( QGLContext *old, qboolean debug,
+				       qboolean nodraw, QGLContext *new ) {
+	LPCSTR procName = "wglCreateContextAttribsARB";
+	HGLRC (APIENTRYP wglCreateContextAttribsARB) (HDC hDC,
+						      HGLRC hshareContext,
+						      const int *attribList);
+	int attrib_list[] = {
+		WGL_CONTEXT_FLAGS_ARB, WGL_CONTEXT_DEBUG_BIT_ARB,
+		0
+	};
+
+	if( debug ) {
+		wglCreateContextAttribsARB = (void *)wglGetProcAddress(procName);
+		if( !wglCreateContextAttribsARB )
+			debug = qfalse;
+	}
+
+	new->hDC = old->hDC;
+	if( debug ) {
+		new->hGLRC = wglCreateContextAttribsARB(old->hDC,
+							old->hGLRC,
+							attrib_list);
+	} else {
+		new->hGLRC = wglCreateContext(old->hDC);
+		wglShareLists( old->hGLRC, new->hGLRC );
+	}
+
+	if( nodraw ) {
+		glDrawBuffer( GL_NONE );
+	}
+}
+static void GLimp_DestroyContext( QGLContext *parent, QGLContext *ctx ) {
+	if( parent->hGLRC != ctx->hGLRC ) {
+		wglDeleteContext( ctx->hGLRC );
+		ctx->hGLRC = parent->hGLRC;
+	}
+}
 #else
-typedef void *QGLContext;
-#define GLimp_GetCurrentContext() (NULL)
-#define GLimp_SetCurrentContext(ctx)
+typedef int QGLContext;  // dummy
+static void GLimp_GetCurrentContext( QGLContext *ctx ) {}
+static void GLimp_SetCurrentContext( QGLContext *ctx ) {}
+static void GLimp_CreateSharedContext( QGLContext *old, qboolean debug,
+				       qboolean nodraw, QGLContext *new ) {}
+static void GLimp_DestroyContext( QGLContext *parent, QGLContext *ctx ) {}
 #endif
 
-static QGLContext opengl_context;
+static QGLContext initial_context, frontend_context, backend_context;
 
 typedef enum
 {
@@ -77,13 +271,274 @@
 cvar_t *r_centerWindow;
 cvar_t *r_sdlDriver;
 
+void (APIENTRYP qglDrawRangeElementsEXT) (GLenum mode, GLsizei count, GLuint start, GLuint end, GLenum type, const GLvoid *indices);
+
 void (APIENTRYP qglActiveTextureARB) (GLenum texture);
 void (APIENTRYP qglClientActiveTextureARB) (GLenum texture);
 void (APIENTRYP qglMultiTexCoord2fARB) (GLenum target, GLfloat s, GLfloat t);
+void (APIENTRYP qglMultiTexCoord4fvARB) (GLenum target, GLfloat *v);
 
 void (APIENTRYP qglLockArraysEXT) (GLint first, GLsizei count);
 void (APIENTRYP qglUnlockArraysEXT) (void);
 
+// GL_ARB_texture_compression
+void (APIENTRYP qglCompressedTexImage3DARB) (GLenum target, GLint level,
+					     GLenum internalformat, GLsizei width,
+					     GLsizei height, GLsizei depth,
+					     GLint border, GLsizei imageSize,
+					     const GLvoid *data);
+void (APIENTRYP qglCompressedTexImage2DARB) (GLenum target, GLint level,
+					     GLenum internalformat, GLsizei width,
+					     GLsizei height, GLint border, 
+					     GLsizei imageSize, const GLvoid *data);
+void (APIENTRYP qglCompressedTexImage1DARB) (GLenum target, GLint level,
+					     GLenum internalformat, GLsizei width,
+					     GLint border, GLsizei imageSize,
+					     const GLvoid *data);
+void (APIENTRYP qglCompressedTexSubImage3DARB) (GLenum target, GLint level, 
+						GLint xoffset, GLint yoffset,
+						GLint zoffset, GLsizei width,
+						GLsizei height, GLsizei depth,
+						GLenum format, GLsizei imageSize,
+						const GLvoid *data);
+void (APIENTRYP qglCompressedTexSubImage2DARB) (GLenum target, GLint level, 
+						GLint xoffset, GLint yoffset,
+						GLsizei width, GLsizei height,
+						GLenum format, GLsizei imageSize,
+						const GLvoid *data);
+void (APIENTRYP qglCompressedTexSubImage1DARB) (GLenum target, GLint level, 
+						GLint xoffset, GLsizei width,
+						GLenum format, GLsizei imageSize,
+						const GLvoid *data);
+void (APIENTRYP qglGetCompressedTexImageARB) (GLenum target, GLint lod,
+					      GLvoid *img);
+
+// GL_ARB_vertex_buffer_object
+void (APIENTRYP qglBindBufferARB) (GLenum target, GLuint buffer);
+void (APIENTRYP qglDeleteBuffersARB) (GLsizei n, const GLuint *buffers);
+void (APIENTRYP qglGenBuffersARB) (GLsizei n, GLuint *buffers);
+GLboolean (APIENTRYP qglIsBufferARB) (GLuint buffer);
+void (APIENTRYP qglBufferDataARB) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
+void (APIENTRYP qglBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
+void (APIENTRYP qglGetBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
+GLvoid *(APIENTRYP qglMapBufferARB) (GLenum target, GLenum access);
+GLboolean (APIENTRYP qglUnmapBufferARB) (GLenum target);
+void (APIENTRYP qglGetBufferParameterivARB) (GLenum target, GLenum pname, GLint *params);
+void (APIENTRYP qglGetBufferPointervARB) (GLenum target, GLenum pname, GLvoid **params);
+
+// GL_ARB_shader_objects
+GLvoid (APIENTRYP qglDeleteShader) (GLuint shader);
+GLvoid (APIENTRYP qglDeleteProgram) (GLuint program);
+GLvoid (APIENTRYP qglDetachShader) (GLuint program, GLuint shader);
+GLuint (APIENTRYP qglCreateShader) (GLenum type);
+GLvoid (APIENTRYP qglShaderSource) (GLuint shader, GLsizei count, const char **string,
+				    const GLint *length);
+GLvoid (APIENTRYP qglCompileShader) (GLuint shader);
+GLuint (APIENTRYP qglCreateProgram) (void);
+GLvoid (APIENTRYP qglAttachShader) (GLuint program, GLuint shader);
+GLvoid (APIENTRYP qglLinkProgram) (GLuint program);
+GLvoid (APIENTRYP qglUseProgram) (GLuint program);
+GLvoid (APIENTRYP qglValidateProgram) (GLuint program);
+GLvoid (APIENTRYP qglUniform1f) (GLint location, GLfloat v0);
+GLvoid (APIENTRYP qglUniform2f) (GLint location, GLfloat v0, GLfloat v1);
+GLvoid (APIENTRYP qglUniform3f) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+GLvoid (APIENTRYP qglUniform4f) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+GLvoid (APIENTRYP qglUniform1i) (GLint location, GLint v0);
+GLvoid (APIENTRYP qglUniform2i) (GLint location, GLint v0, GLint v1);
+GLvoid (APIENTRYP qglUniform3i) (GLint location, GLint v0, GLint v1, GLint v2);
+GLvoid (APIENTRYP qglUniform4i) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+GLvoid (APIENTRYP qglUniform1fv) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRYP qglUniform2fv) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRYP qglUniform3fv) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRYP qglUniform4fv) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRYP qglUniform1iv) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRYP qglUniform2iv) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRYP qglUniform3iv) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRYP qglUniform4iv) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRYP qglUniformMatrix2fv) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+GLvoid (APIENTRYP qglUniformMatrix3fv) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+GLvoid (APIENTRYP qglUniformMatrix4fv) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+GLvoid (APIENTRYP qglGetShaderiv) (GLuint shader, GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglGetProgramiv) (GLuint program, GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglGetShaderInfoLog) (GLuint shader, GLsizei maxLength, GLsizei *length, char *infoLog);
+GLvoid (APIENTRYP qglGetProgramInfoLog) (GLuint program, GLsizei maxLength, GLsizei *length, char *infoLog);
+GLvoid (APIENTRYP qglGetAttachedShaders) (GLuint program, GLsizei maxCount, GLsizei *count,
+					  GLuint *shaders);
+GLint (APIENTRYP qglGetUniformLocation) (GLuint program, const char *name);
+GLvoid (APIENTRYP qglGetActiveUniform) (GLuint program, GLuint index, GLsizei maxLength,
+					GLsizei *length, GLint *size, GLenum *type, char *name);
+GLvoid (APIENTRYP qglGetUniformfv) (GLuint program, GLint location, GLfloat *params);
+GLvoid (APIENTRYP qglGetUniformiv) (GLuint program, GLint location, GLint *params);
+GLvoid (APIENTRYP qglGetShaderSource) (GLuint shader, GLsizei maxLength, GLsizei *length,
+				       char *source);
+
+// GL_ARB_vertex_shader
+GLvoid (APIENTRYP qglVertexAttrib1fARB) (GLuint index, GLfloat v0);
+GLvoid (APIENTRYP qglVertexAttrib1sARB) (GLuint index, GLshort v0);
+GLvoid (APIENTRYP qglVertexAttrib1dARB) (GLuint index, GLdouble v0);
+GLvoid (APIENTRYP qglVertexAttrib2fARB) (GLuint index, GLfloat v0, GLfloat v1);
+GLvoid (APIENTRYP qglVertexAttrib2sARB) (GLuint index, GLshort v0, GLshort v1);
+GLvoid (APIENTRYP qglVertexAttrib2dARB) (GLuint index, GLdouble v0, GLdouble v1);
+GLvoid (APIENTRYP qglVertexAttrib3fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);
+GLvoid (APIENTRYP qglVertexAttrib3sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2);
+GLvoid (APIENTRYP qglVertexAttrib3dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
+GLvoid (APIENTRYP qglVertexAttrib4fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+GLvoid (APIENTRYP qglVertexAttrib4sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);
+GLvoid (APIENTRYP qglVertexAttrib4dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
+GLvoid (APIENTRYP qglVertexAttrib4NubARB) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+GLvoid (APIENTRYP qglVertexAttrib1fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRYP qglVertexAttrib1svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib1dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRYP qglVertexAttrib2fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRYP qglVertexAttrib2svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib2dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRYP qglVertexAttrib3fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRYP qglVertexAttrib3svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib3dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRYP qglVertexAttrib4fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRYP qglVertexAttrib4svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib4dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRYP qglVertexAttrib4ivARB) (GLuint index, GLint *v);
+GLvoid (APIENTRYP qglVertexAttrib4bvARB) (GLuint index, GLbyte *v);
+GLvoid (APIENTRYP qglVertexAttrib4ubvARB) (GLuint index, GLubyte *v);
+GLvoid (APIENTRYP qglVertexAttrib4usvARB) (GLuint index, GLushort *v);
+GLvoid (APIENTRYP qglVertexAttrib4uivARB) (GLuint index, GLuint *v);
+GLvoid (APIENTRYP qglVertexAttrib4NbvARB) (GLuint index, const GLbyte *v);
+GLvoid (APIENTRYP qglVertexAttrib4NsvARB) (GLuint index, const GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib4NivARB) (GLuint index, const GLint *v);
+GLvoid (APIENTRYP qglVertexAttrib4NubvARB) (GLuint index, const GLubyte *v);
+GLvoid (APIENTRYP qglVertexAttrib4NusvARB) (GLuint index, const GLushort *v);
+GLvoid (APIENTRYP qglVertexAttrib4NuivARB) (GLuint index, const GLuint *v);
+GLvoid (APIENTRYP qglVertexAttribPointerARB) (GLuint index, GLint size, GLenum type, GLboolean normalized,
+					      GLsizei stride, const GLvoid *pointer);
+GLvoid (APIENTRYP qglEnableVertexAttribArrayARB) (GLuint index);
+GLvoid (APIENTRYP qglDisableVertexAttribArrayARB) (GLuint index);
+GLvoid (APIENTRYP qglBindAttribLocationARB) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
+GLvoid (APIENTRYP qglGetActiveAttribARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
+					  GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+GLint (APIENTRYP qglGetAttribLocationARB) (GLhandleARB programObj, const GLcharARB *name);
+GLvoid (APIENTRYP qglGetVertexAttribdvARB) (GLuint index, GLenum pname, GLdouble *params);
+GLvoid (APIENTRYP qglGetVertexAttribfvARB) (GLuint index, GLenum pname, GLfloat *params);
+GLvoid (APIENTRYP qglGetVertexAttribivARB) (GLuint index, GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglGetVertexAttribPointervARB) (GLuint index, GLenum pname, GLvoid **pointer);
+
+// GL_EXT_geometry_shader4
+GLvoid (APIENTRYP qglProgramParameteriEXT) (GLuint program, GLenum pname, GLint value);
+GLvoid (APIENTRYP qglFramebufferTextureEXT) (GLenum target, GLenum attachment,
+					     GLuint texture, GLint level);
+GLvoid (APIENTRYP qglFramebufferTextureLayerEXT) (GLenum target, GLenum attachment,
+						  GLuint texture, GLint level, int layer);
+GLvoid (APIENTRYP qglFramebufferTextureFaceEXT) (GLenum target, GLenum attachment,
+						 GLuint texture, GLint level, GLenum face);
+
+// GL_EXT_texture3D
+GLvoid (APIENTRYP qglTexImage3DEXT) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+
+// GL_ARB_framebuffer_object
+GLboolean (APIENTRYP qglIsRenderbuffer) (GLuint renderbuffer);
+GLvoid (APIENTRYP qglBindRenderbuffer) (GLenum target, GLuint renderbuffer);
+GLvoid (APIENTRYP qglDeleteRenderbuffers) (GLsizei n, const GLuint *renderbuffers);
+GLvoid (APIENTRYP qglGenRenderbuffers) (GLsizei n, GLuint *renderbuffers);
+GLvoid (APIENTRYP qglRenderbufferStorage) (GLenum target, GLenum internalformat,
+					   GLsizei width, GLsizei height);
+GLvoid (APIENTRYP qglRenderbufferStorageMultisample) (GLenum target, GLsizei samples,
+						      GLenum internalformat,
+						      GLsizei width, GLsizei height);
+GLvoid (APIENTRYP qglGetRenderbufferParameteriv) (GLenum target, GLenum pname, GLint *params);
+GLboolean (APIENTRYP qglIsFramebuffer) (GLuint framebuffer);
+GLvoid (APIENTRYP qglBindFramebuffer) (GLenum target, GLuint framebuffer);
+GLvoid (APIENTRYP qglDeleteFramebuffers) (GLsizei n, const GLuint *framebuffers);
+GLvoid (APIENTRYP qglGenFramebuffers) (GLsizei n, GLuint *framebuffers);
+GLenum (APIENTRYP qglCheckFramebufferStatus) (GLenum target);
+GLvoid (APIENTRYP qglFramebufferTexture1D) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture, GLint level);
+GLvoid (APIENTRYP qglFramebufferTexture2D) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture, GLint level);
+GLvoid (APIENTRYP qglFramebufferTexture3D) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture,
+					    GLint level, GLint layer);
+GLvoid (APIENTRYP qglFramebufferTextureLayer) (GLenum target, GLenum attachment,
+					       GLuint texture, GLint level, GLint layer);
+GLvoid (APIENTRYP qglFramebufferRenderbuffer) (GLenum target, GLenum attachment,
+					       GLenum renderbuffertarget, GLuint renderbuffer);
+GLvoid (APIENTRYP qglGetFramebufferAttachmentParameteriv) (GLenum target, GLenum attachment,
+							   GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglBlitFramebuffer) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
+				       GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
+				       GLbitfield mask, GLenum filter);
+GLvoid (APIENTRYP qglGenerateMipmap) (GLenum target);
+
+// GL_EXT_occlusion_query
+GLvoid (APIENTRYP qglGenQueriesARB) (GLsizei n, GLuint *ids);
+GLvoid (APIENTRYP qglDeleteQueriesARB) (GLsizei n, const GLuint *ids);
+GLboolean (APIENTRYP qglIsQueryARB) (GLuint id);
+GLvoid (APIENTRYP qglBeginQueryARB) (GLenum target, GLuint id);
+GLvoid (APIENTRYP qglEndQueryARB) (GLenum target);
+GLvoid (APIENTRYP qglGetQueryivARB) (GLenum target, GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglGetQueryObjectivARB) (GLuint id, GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglGetQueryObjectuivARB) (GLuint id, GLenum pname, GLuint *params);
+
+// GL_EXT_timer_query
+GLvoid (APIENTRYP qglGetQueryObjecti64vEXT) (GLuint id, GLenum pname, GLint64EXT *params);
+GLvoid (APIENTRYP qglGetQueryObjectui64vEXT) (GLuint id, GLenum pname, GLuint64EXT *params);
+
+// GL_ARB_instanced_arrays
+GLvoid (APIENTRYP qglVertexAttribDivisorARB) (GLuint index, GLuint divisor);
+GLvoid (APIENTRYP qglDrawArraysInstancedARB) (GLenum mode, GLint first, GLsizei count,
+					      GLsizei primcount);
+GLvoid (APIENTRYP qglDrawElementsInstancedARB) (GLenum mode, GLsizei count, GLenum type,
+						const GLvoid *indices, GLsizei primcount);
+
+// GL_ARB_separate_stencil
+GLvoid (APIENTRYP qglStencilOpSeparate) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
+GLvoid (APIENTRYP qglStencilFuncSeparate) (GLenum face, GLenum func, GLint ref, GLuint mask);
+GLvoid (APIENTRYP qglStencilMaskSeparate) (GLenum face, GLuint mask);
+
+// GL_ARB_debug_output, not in core
+GLvoid (APIENTRYP qglDebugMessageControlARB) (GLenum source,
+					      GLenum type,
+					      GLenum severity,
+					      GLsizei count,
+					      const GLuint* ids,
+					      GLboolean enabled);
+GLvoid (APIENTRYP qglDebugMessageInsertARB) (GLenum source,
+					     GLenum type,
+					     GLuint id,
+					     GLenum severity,
+					     GLsizei length, 
+					     const GLchar* buf);
+GLvoid (APIENTRYP qglDebugMessageCallbackARB) (GLDEBUGPROCARB callback,
+					       GLvoid *userParam);
+GLuint (APIENTRYP qglGetDebugMessageLogARB) (GLuint count,
+					     GLsizei bufsize,
+					     GLenum *sources,
+					     GLenum *types,
+					     GLuint *ids,
+					     GLenum *severities,
+					     GLsizei *lengths, 
+					     GLchar *messageLog);
+// GL_AMD_debug_output, predecessor to GL_ARB_debug_output, but has only
+// a category parameter instead of source and type
+GLvoid (APIENTRYP qglDebugMessageEnableAMD) (GLenum category,
+					     GLenum severity,
+					     GLsizei count,
+					     const GLuint* ids,
+					     GLboolean enabled);
+GLvoid (APIENTRYP qglDebugMessageInsertAMD) (GLenum category,
+					     GLuint id,
+					     GLenum severity,
+					     GLsizei length, 
+					     const GLchar* buf);
+GLvoid (APIENTRYP qglDebugMessageCallbackAMD) (GLDEBUGPROCAMD callback,
+					       GLvoid *userParam);
+GLuint (APIENTRYP qglGetDebugMessageLogAMD) (GLuint count,
+					     GLsizei bufsize,
+					     GLenum *categories,
+					     GLuint *ids,
+					     GLenum *severities,
+					     GLsizei *lengths, 
+					     GLchar *messageLog);
+
 /*
 ===============
 GLimp_Shutdown
@@ -93,8 +548,21 @@
 {
 	float oldDisplayAspect = glConfig.displayAspect;
 
+	if( glGlobals.timerQuery ) {
+		qglDeleteQueriesARB( 1, &glGlobals.timerQuery );
+	}
+
 	IN_Shutdown();
 
+	GLimp_SetCurrentContext( &initial_context );
+
+	if( r_smp->integer ) {
+		GLimp_DestroyContext( &backend_context, &frontend_context );
+	}
+	if( r_ext_debug_output->integer ) {
+		GLimp_DestroyContext( &initial_context, &backend_context );
+	}
+
 	SDL_QuitSubSystem( SDL_INIT_VIDEO );
 	screen = NULL;
 
@@ -422,8 +890,27 @@
 			continue;
 		}
 
-		opengl_context = GLimp_GetCurrentContext();
+		GLimp_GetCurrentContext( &initial_context );
+		GLimp_SetCurrentContext( NULL );
 
+		if( r_ext_debug_output->integer ) {
+			GLimp_CreateSharedContext( &initial_context,
+						   qtrue, qfalse,
+						   &backend_context );
+		} else {
+			backend_context = initial_context;
+		}
+		if( r_smp->integer ) {
+			GLimp_CreateSharedContext( &initial_context,
+						   !!r_ext_debug_output->integer,
+						   qtrue,
+						   &frontend_context );
+		} else {
+			frontend_context = backend_context;
+		}
+
+		GLimp_SetCurrentContext( &frontend_context );
+
 		ri.Printf( PRINT_ALL, "Using %d/%d/%d Color bits, %d depth, %d stencil display.\n",
 				sdlcolorbits, sdlcolorbits, sdlcolorbits, tdepthbits, tstencilbits);
 
@@ -508,172 +995,1112 @@
 	return ((*ptr == ' ') || (*ptr == '\0'));  // verify it's complete string.
 }
 
-
 /*
 ===============
 GLimp_InitExtensions
 ===============
 */
-static void GLimp_InitExtensions( void )
+static void GLimp_InitExtensions( int GLversion )
 {
+#define qglGetProc2(var,proc) q##var = (typeof(q##var))SDL_GL_GetProcAddress( #proc )
+#define qglGetProc(name,ext) qglGetProc2(name##ext,name)
+
 	if ( !r_allowExtensions->integer )
 	{
 		ri.Printf( PRINT_ALL, "* IGNORING OPENGL EXTENSIONS *\n" );
-		return;
+		GLversion = 0x0000;
+	} else {
+		ri.Printf( PRINT_DEVELOPER, "Initializing OpenGL extensions\n" );
 	}
 
-	ri.Printf( PRINT_ALL, "Initializing OpenGL extensions\n" );
+	// GL_EXT_draw_range_elements, mandatory since OpenGL 1.2
+	if ( GLversion >= 0x0102 ) {
+		qglGetProc(glDrawRangeElements, EXT );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_EXT_draw_range_elements" ) ) {
+		qglGetProc(glDrawRangeElementsEXT, );
+	} else {
+		qglDrawRangeElementsEXT = NULL;
+	}
 
 	glConfig.textureCompression = TC_NONE;
 
 	// GL_EXT_texture_compression_s3tc
-	if ( GLimp_HaveExtension( "GL_ARB_texture_compression" ) &&
+	if ( GLversion &&
+	     GLimp_HaveExtension( "GL_ARB_texture_compression" ) &&
 	     GLimp_HaveExtension( "GL_EXT_texture_compression_s3tc" ) )
 	{
 		if ( r_ext_compressed_textures->value )
 		{
 			glConfig.textureCompression = TC_S3TC_ARB;
-			ri.Printf( PRINT_ALL, "...using GL_EXT_texture_compression_s3tc\n" );
+			ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_texture_compression_s3tc\n" );
 		}
 		else
 		{
-			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_compression_s3tc\n" );
+			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_texture_compression_s3tc\n" );
 		}
 	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...GL_EXT_texture_compression_s3tc not found\n" );
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_compression_s3tc not found\n" );
 	}
 
 	// GL_S3_s3tc ... legacy extension before GL_EXT_texture_compression_s3tc.
 	if (glConfig.textureCompression == TC_NONE)
 	{
-		if ( GLimp_HaveExtension( "GL_S3_s3tc" ) )
+		if ( GLversion &&
+		     GLimp_HaveExtension( "GL_S3_s3tc" ) )
 		{
 			if ( r_ext_compressed_textures->value )
 			{
 				glConfig.textureCompression = TC_S3TC;
-				ri.Printf( PRINT_ALL, "...using GL_S3_s3tc\n" );
+				ri.Printf( PRINT_DEVELOPER, "...using GL_S3_s3tc\n" );
 			}
 			else
 			{
-				ri.Printf( PRINT_ALL, "...ignoring GL_S3_s3tc\n" );
+				ri.Printf( PRINT_DEVELOPER, "...ignoring GL_S3_s3tc\n" );
 			}
 		}
 		else
 		{
-			ri.Printf( PRINT_ALL, "...GL_S3_s3tc not found\n" );
+			ri.Printf( PRINT_DEVELOPER, "...GL_S3_s3tc not found\n" );
 		}
 	}
 
 
-	// GL_EXT_texture_env_add
-	glConfig.textureEnvAddAvailable = qfalse;
-	if ( GLimp_HaveExtension( "EXT_texture_env_add" ) )
+	// GL_EXT_texture_env_add, mandatory since OpenGL 1.3
+	if ( !r_ext_texture_env_add->integer ) {
+		glConfig.textureEnvAddAvailable = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_texture_env_add\n" );
+	} else if ( GLversion >= 0x0103 ) {
+		glConfig.textureEnvAddAvailable = qtrue;
+		ri.Printf( PRINT_DEVELOPER, "...using GL_texture_env_add\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "EXT_texture_env_add" ) ) {
+		glConfig.textureEnvAddAvailable = qtrue;
+		ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_texture_env_add\n" );
+	}
+	else
 	{
-		if ( r_ext_texture_env_add->integer )
+		glConfig.textureEnvAddAvailable = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_env_add not found\n" );
+	}
+
+	// GL_ARB_multitexture, mandatory since OpenGL 1.3
+	if ( !r_ext_multitexture->value ) {
+		qglMultiTexCoord2fARB = NULL;
+		qglMultiTexCoord4fvARB = NULL;
+		qglActiveTextureARB = NULL;
+		qglClientActiveTextureARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_multitexture\n" );
+	} else if ( GLversion >= 0x0103 ) {
+		qglGetProc(glMultiTexCoord2f, ARB);
+		qglGetProc(glMultiTexCoord4fv, ARB);
+		qglGetProc(glActiveTexture, ARB);
+		qglGetProc(glClientActiveTexture, ARB);
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_multitexture" ) ) {
+		qglGetProc(glMultiTexCoord2fARB, );
+		qglGetProc(glMultiTexCoord4fvARB, );
+		qglGetProc(glActiveTextureARB, );
+		qglGetProc(glClientActiveTextureARB, );
+	} else {
+		qglMultiTexCoord2fARB = NULL;
+		qglMultiTexCoord4fvARB = NULL;
+		qglActiveTextureARB = NULL;
+		qglClientActiveTextureARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_multitexture not found\n" );
+	}
+	if ( qglActiveTextureARB )
+	{
+		qglGetIntegerv( GL_MAX_TEXTURE_UNITS_ARB, &glGlobals.maxTextureUnits );
+		glConfig.numTextureUnits = (int) glGlobals.maxTextureUnits;
+		if ( glConfig.numTextureUnits > NUM_TEXTURE_BUNDLES )
+			glConfig.numTextureUnits = NUM_TEXTURE_BUNDLES;
+		if ( r_ext_multitexture->integer > 1 &&
+		     glConfig.numTextureUnits > r_ext_multitexture->integer )
+			glConfig.numTextureUnits = r_ext_multitexture->integer;
+		if ( glConfig.numTextureUnits > 1 )
 		{
-			glConfig.textureEnvAddAvailable = qtrue;
-			ri.Printf( PRINT_ALL, "...using GL_EXT_texture_env_add\n" );
+			ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_multitexture (%d of %d units)\n", glConfig.numTextureUnits, glGlobals.maxTextureUnits );
 		}
 		else
 		{
-			glConfig.textureEnvAddAvailable = qfalse;
-			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_env_add\n" );
+			qglMultiTexCoord2fARB = NULL;
+			qglActiveTextureARB = NULL;
+			qglClientActiveTextureARB = NULL;
+			ri.Printf( PRINT_DEVELOPER, "...not using GL_ARB_multitexture, < 2 texture units\n" );
 		}
 	}
-	else
-	{
-		ri.Printf( PRINT_ALL, "...GL_EXT_texture_env_add not found\n" );
+	
+	// GL_ARB_texture_compression, mandatory since OpenGL 1.3
+	if( !r_ext_texture_compression->integer ) {
+		qglCompressedTexImage3DARB = NULL;
+		qglCompressedTexImage2DARB = NULL;
+		qglCompressedTexImage1DARB = NULL;
+		qglCompressedTexSubImage3DARB = NULL;
+		qglCompressedTexSubImage2DARB = NULL;
+		qglCompressedTexSubImage1DARB = NULL;
+		qglGetCompressedTexImageARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_texture_compression\n" );
+	} else if ( GLversion >= 0x0103 ) {
+		qglGetProc(glCompressedTexImage3D, ARB);
+		qglGetProc(glCompressedTexImage2D, ARB);
+		qglGetProc(glCompressedTexImage1D, ARB);
+		qglGetProc(glCompressedTexSubImage3D, ARB);
+		qglGetProc(glCompressedTexSubImage2D, ARB);
+		qglGetProc(glCompressedTexSubImage1D, ARB);
+		qglGetProc(glGetCompressedTexImage, ARB);
+		ri.Printf( PRINT_DEVELOPER, "...using GL_texture_compression\n");
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_texture_compression" ) ) {
+		qglGetProc(glCompressedTexImage3DARB, );
+		qglGetProc(glCompressedTexImage2DARB, );
+		qglGetProc(glCompressedTexImage1DARB, );
+		qglGetProc(glCompressedTexSubImage3DARB, );
+		qglGetProc(glCompressedTexSubImage2DARB, );
+		qglGetProc(glCompressedTexSubImage1DARB, );
+		qglGetProc(glGetCompressedTexImageARB, );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_texture_compression\n");
+	} else {
+		qglCompressedTexImage3DARB = NULL;
+		qglCompressedTexImage2DARB = NULL;
+		qglCompressedTexImage1DARB = NULL;
+		qglCompressedTexSubImage3DARB = NULL;
+		qglCompressedTexSubImage2DARB = NULL;
+		qglCompressedTexSubImage1DARB = NULL;
+		qglGetCompressedTexImageARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_texture_compression not found\n" );
 	}
 
-	// GL_ARB_multitexture
-	qglMultiTexCoord2fARB = NULL;
-	qglActiveTextureARB = NULL;
-	qglClientActiveTextureARB = NULL;
-	if ( GLimp_HaveExtension( "GL_ARB_multitexture" ) )
-	{
-		if ( r_ext_multitexture->value )
-		{
-			qglMultiTexCoord2fARB = SDL_GL_GetProcAddress( "glMultiTexCoord2fARB" );
-			qglActiveTextureARB = SDL_GL_GetProcAddress( "glActiveTextureARB" );
-			qglClientActiveTextureARB = SDL_GL_GetProcAddress( "glClientActiveTextureARB" );
+	// GL_ARB_vertex_buffer_object, mandatory since OpenGL 1.5
+	if ( !r_ext_vertex_buffer_object->integer ) {
+		qglBindBufferARB = NULL;
+		qglDeleteBuffersARB = NULL;
+		qglGenBuffersARB = NULL;
+		qglIsBufferARB = NULL;
+		qglBufferDataARB = NULL;
+		qglBufferSubDataARB = NULL;
+		qglGetBufferSubDataARB = NULL;
+		qglMapBufferARB = NULL;
+		qglUnmapBufferARB = NULL;
+		qglGetBufferParameterivARB = NULL;
+		qglGetBufferPointervARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_vertex_buffer_object\n" );
+	} else if ( GLversion >= 0x0105 ) {
+		qglGetProc(glBindBuffer, ARB);
+		qglGetProc(glDeleteBuffers, ARB);
+		qglGetProc(glGenBuffers, ARB);
+		qglGetProc(glIsBuffer, ARB);
+		qglGetProc(glBufferData, ARB);
+		qglGetProc(glBufferSubData, ARB);
+		qglGetProc(glGetBufferSubData, ARB);
+		qglGetProc(glMapBuffer, ARB);
+		qglGetProc(glUnmapBuffer, ARB);
+		qglGetProc(glGetBufferParameteriv, ARB);
+		qglGetProc(glGetBufferPointerv, ARB);
+		ri.Printf( PRINT_DEVELOPER, "...using GL_vertex_buffer_object\n");
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_vertex_buffer_object" ) ) {
+		qglGetProc(glBindBufferARB, );
+		qglGetProc(glDeleteBuffersARB, );
+		qglGetProc(glGenBuffersARB, );
+		qglGetProc(glIsBufferARB, );
+		qglGetProc(glBufferDataARB, );
+		qglGetProc(glBufferSubDataARB, );
+		qglGetProc(glGetBufferSubDataARB, );
+		qglGetProc(glMapBufferARB, );
+		qglGetProc(glUnmapBufferARB, );
+		qglGetProc(glGetBufferParameterivARB, );
+		qglGetProc(glGetBufferPointervARB, );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_vertex_buffer_object\n" );
+	} else {
+		qglBindBufferARB = NULL;
+		qglDeleteBuffersARB = NULL;
+		qglGenBuffersARB = NULL;
+		qglIsBufferARB = NULL;
+		qglBufferDataARB = NULL;
+		qglBufferSubDataARB = NULL;
+		qglGetBufferSubDataARB = NULL;
+		qglMapBufferARB = NULL;
+		qglUnmapBufferARB = NULL;
+		qglGetBufferParameterivARB = NULL;
+		qglGetBufferPointervARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_vertex_buffer_object not found\n" );
+	}
 
-			if ( qglActiveTextureARB )
-			{
-				GLint glint = 0;
-				qglGetIntegerv( GL_MAX_TEXTURE_UNITS_ARB, &glint );
-				glConfig.numTextureUnits = (int) glint;
-				if ( glConfig.numTextureUnits > 1 )
-				{
-					ri.Printf( PRINT_ALL, "...using GL_ARB_multitexture\n" );
-				}
-				else
-				{
-					qglMultiTexCoord2fARB = NULL;
-					qglActiveTextureARB = NULL;
-					qglClientActiveTextureARB = NULL;
-					ri.Printf( PRINT_ALL, "...not using GL_ARB_multitexture, < 2 texture units\n" );
-				}
-			}
+	// GL_ARB_pixel_buffer_object, mandatory since OpenGL 2.1
+	if ( !r_ext_pixel_buffer_object->integer ) {
+		glGlobals.pixelBufferObjects = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_pixel_buffer_object\n" );
+	} else if ( GLversion >= 0x0201 && qglGenBuffersARB ) {
+		glGlobals.pixelBufferObjects = qtrue;
+		ri.Printf( PRINT_DEVELOPER, "...using GL_pixel_buffer_object\n");
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_pixel_buffer_object" ) &&
+		    qglGenBuffersARB ) {
+		glGlobals.pixelBufferObjects = qtrue;
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_pixel_buffer_object\n" );
+	} else {
+		glGlobals.pixelBufferObjects = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_pixel_buffer_object not found\n" );
+	}
+
+	// GL_EXT_compiled_vertex_array
+	if ( !r_ext_compiled_vertex_array->value ) {
+		qglLockArraysEXT = NULL;
+		qglUnlockArraysEXT = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_compiled_vertex_array\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_EXT_compiled_vertex_array" ) ) {
+		qglGetProc(glLockArraysEXT, );
+		qglGetProc(glUnlockArraysEXT, );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_compiled_vertex_array\n" );
+	} else {
+		qglLockArraysEXT = NULL;
+		qglUnlockArraysEXT = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_compiled_vertex_array not found\n" );
+	}
+
+	// GL_EXT_texture_filter_anisotropic
+	if ( !r_ext_texture_filter_anisotropic->integer ) {
+		glConfig.textureFilterAnisotropic = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_texture_filter_anisotropic\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_EXT_texture_filter_anisotropic" ) ) {
+		qglGetIntegerv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, (GLint *)&glConfig.maxAnisotropy );
+		if ( glConfig.maxAnisotropy <= 0 ) {
+			ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_filter_anisotropic not properly supported!\n" );
+			glConfig.maxAnisotropy = 0;
 		}
 		else
 		{
-			ri.Printf( PRINT_ALL, "...ignoring GL_ARB_multitexture\n" );
+			ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_texture_filter_anisotropic (max: %i)\n", glConfig.maxAnisotropy );
+			glConfig.textureFilterAnisotropic = qtrue;
 		}
+	} else {
+		glConfig.textureFilterAnisotropic = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_filter_anisotropic not found\n" );
 	}
+
+	// GLSL support, mandatory since OpenGL 2.0
+	if ( !r_ext_vertex_shader->integer ) {
+		qglDeleteShader = NULL;
+		qglDeleteProgram = NULL;
+		qglDetachShader = NULL;
+		qglCreateShader = NULL;
+		qglShaderSource = NULL;
+		qglCompileShader = NULL;
+		qglCreateProgram = NULL;
+		qglAttachShader = NULL;
+		qglLinkProgram = NULL;
+		qglUseProgram = NULL;
+		qglValidateProgram = NULL;
+		qglUniform1f = NULL;
+		qglUniform2f = NULL;
+		qglUniform3f = NULL;
+		qglUniform4f = NULL;
+		qglUniform1i = NULL;
+		qglUniform2i = NULL;
+		qglUniform3i = NULL;
+		qglUniform4i = NULL;
+		qglUniform1fv = NULL;
+		qglUniform2fv = NULL;
+		qglUniform3fv = NULL;
+		qglUniform4fv = NULL;
+		qglUniform1iv = NULL;
+		qglUniform2iv = NULL;
+		qglUniform3iv = NULL;
+		qglUniform4iv = NULL;
+		qglUniformMatrix2fv = NULL;
+		qglUniformMatrix3fv = NULL;
+		qglUniformMatrix4fv = NULL;
+		qglGetShaderiv = NULL;
+		qglGetProgramiv = NULL;
+		qglGetShaderInfoLog = NULL;
+		qglGetProgramInfoLog = NULL;
+		qglGetAttachedShaders = NULL;
+		qglGetUniformLocation = NULL;
+		qglGetActiveUniform = NULL;
+		qglGetUniformfv = NULL;
+		qglGetUniformiv = NULL;
+		qglGetShaderSource = NULL;
+		
+		qglVertexAttrib1fARB = NULL;
+		qglVertexAttrib1sARB = NULL;
+		qglVertexAttrib1dARB = NULL;
+		qglVertexAttrib2fARB = NULL;
+		qglVertexAttrib2sARB = NULL;
+		qglVertexAttrib2dARB = NULL;
+		qglVertexAttrib3fARB = NULL;
+		qglVertexAttrib3sARB = NULL;
+		qglVertexAttrib3dARB = NULL;
+		qglVertexAttrib4fARB = NULL;
+		qglVertexAttrib4sARB = NULL;
+		qglVertexAttrib4dARB = NULL;
+		qglVertexAttrib4NubARB = NULL;
+		qglVertexAttrib1fvARB = NULL;
+		qglVertexAttrib1svARB = NULL;
+		qglVertexAttrib1dvARB = NULL;
+		qglVertexAttrib2fvARB = NULL;
+		qglVertexAttrib2svARB = NULL;
+		qglVertexAttrib2dvARB = NULL;
+		qglVertexAttrib3fvARB = NULL;
+		qglVertexAttrib3svARB = NULL;
+		qglVertexAttrib3dvARB = NULL;
+		qglVertexAttrib4fvARB = NULL;
+		qglVertexAttrib4svARB = NULL;
+		qglVertexAttrib4dvARB = NULL;
+		qglVertexAttrib4ivARB = NULL;
+		qglVertexAttrib4bvARB = NULL;
+		qglVertexAttrib4ubvARB = NULL;
+		qglVertexAttrib4usvARB = NULL;
+		qglVertexAttrib4uivARB = NULL;
+		qglVertexAttrib4NbvARB = NULL;
+		qglVertexAttrib4NsvARB = NULL;
+		qglVertexAttrib4NivARB = NULL;
+		qglVertexAttrib4NubvARB = NULL;
+		qglVertexAttrib4NusvARB = NULL;
+		qglVertexAttrib4NuivARB = NULL;
+		qglVertexAttribPointerARB = NULL;
+		qglEnableVertexAttribArrayARB = NULL;
+		qglDisableVertexAttribArrayARB = NULL;
+		qglBindAttribLocationARB = NULL;
+		qglGetActiveAttribARB = NULL;
+		qglGetAttribLocationARB = NULL;
+		qglGetVertexAttribdvARB = NULL;
+		qglGetVertexAttribfvARB = NULL;
+		qglGetVertexAttribivARB = NULL;
+		qglGetVertexAttribPointervARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_vertex_shader\n" );
+	} else if ( GLversion >= 0x0200 ) {
+		qglGetProc(glDeleteShader, );
+		qglGetProc(glDeleteProgram, );
+		qglGetProc(glDetachShader, );
+		qglGetProc(glCreateShader, );
+		qglGetProc(glShaderSource, );
+		qglGetProc(glCompileShader, );
+		qglGetProc(glCreateProgram, );
+		qglGetProc(glAttachShader, );
+		qglGetProc(glLinkProgram, );
+		qglGetProc(glUseProgram, );
+		qglGetProc(glValidateProgram, );
+		qglGetProc(glUniform1f, );
+		qglGetProc(glUniform2f, );
+		qglGetProc(glUniform3f, );
+		qglGetProc(glUniform4f, );
+		qglGetProc(glUniform1i, );
+		qglGetProc(glUniform2i, );
+		qglGetProc(glUniform3i, );
+		qglGetProc(glUniform4i, );
+		qglGetProc(glUniform1fv, );
+		qglGetProc(glUniform2fv, );
+		qglGetProc(glUniform3fv, );
+		qglGetProc(glUniform4fv, );
+		qglGetProc(glUniform1iv, );
+		qglGetProc(glUniform2iv, );
+		qglGetProc(glUniform3iv, );
+		qglGetProc(glUniform4iv, );
+		qglGetProc(glUniformMatrix2fv, );
+		qglGetProc(glUniformMatrix3fv, );
+		qglGetProc(glUniformMatrix4fv, );
+		qglGetProc(glGetShaderiv, );
+		qglGetProc(glGetProgramiv, );
+		qglGetProc(glGetShaderInfoLog, );
+		qglGetProc(glGetProgramInfoLog, );
+		qglGetProc(glGetAttachedShaders, );
+		qglGetProc(glGetUniformLocation, );
+		qglGetProc(glGetActiveUniform, );
+		qglGetProc(glGetUniformfv, );
+		qglGetProc(glGetUniformiv, );
+		qglGetProc(glGetShaderSource, );
+		
+		qglGetProc(glVertexAttrib1f, ARB);
+		qglGetProc(glVertexAttrib1s, ARB);
+		qglGetProc(glVertexAttrib1d, ARB);
+		qglGetProc(glVertexAttrib2f, ARB);
+		qglGetProc(glVertexAttrib2s, ARB);
+		qglGetProc(glVertexAttrib2d, ARB);
+		qglGetProc(glVertexAttrib3f, ARB);
+		qglGetProc(glVertexAttrib3s, ARB);
+		qglGetProc(glVertexAttrib3d, ARB);
+		qglGetProc(glVertexAttrib4f, ARB);
+		qglGetProc(glVertexAttrib4s, ARB);
+		qglGetProc(glVertexAttrib4d, ARB);
+		qglGetProc(glVertexAttrib4Nub, ARB);
+		qglGetProc(glVertexAttrib1fv, ARB);
+		qglGetProc(glVertexAttrib1sv, ARB);
+		qglGetProc(glVertexAttrib1dv, ARB);
+		qglGetProc(glVertexAttrib2fv, ARB);
+		qglGetProc(glVertexAttrib2sv, ARB);
+		qglGetProc(glVertexAttrib2dv, ARB);
+		qglGetProc(glVertexAttrib3fv, ARB);
+		qglGetProc(glVertexAttrib3sv, ARB);
+		qglGetProc(glVertexAttrib3dv, ARB);
+		qglGetProc(glVertexAttrib4fv, ARB);
+		qglGetProc(glVertexAttrib4sv, ARB);
+		qglGetProc(glVertexAttrib4dv, ARB);
+		qglGetProc(glVertexAttrib4iv, ARB);
+		qglGetProc(glVertexAttrib4bv, ARB);
+		qglGetProc(glVertexAttrib4ubv, ARB);
+		qglGetProc(glVertexAttrib4usv, ARB);
+		qglGetProc(glVertexAttrib4uiv, ARB);
+		qglGetProc(glVertexAttrib4Nbv, ARB);
+		qglGetProc(glVertexAttrib4Nsv, ARB);
+		qglGetProc(glVertexAttrib4Niv, ARB);
+		qglGetProc(glVertexAttrib4Nubv, ARB);
+		qglGetProc(glVertexAttrib4Nusv, ARB);
+		qglGetProc(glVertexAttrib4Nuiv, ARB);
+		qglGetProc(glVertexAttribPointer, ARB);
+		qglGetProc(glEnableVertexAttribArray, ARB);
+		qglGetProc(glDisableVertexAttribArray, ARB);
+		qglGetProc(glBindAttribLocation, ARB);
+		qglGetProc(glGetActiveAttrib, ARB);
+		qglGetProc(glGetAttribLocation, ARB);
+		qglGetProc(glGetVertexAttribdv, ARB);
+		qglGetProc(glGetVertexAttribfv, ARB);
+		qglGetProc(glGetVertexAttribiv, ARB);
+		qglGetProc(glGetVertexAttribPointerv, ARB);
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_vertex_shader\n" );
+		
+	} else if ( GLversion &&
+	     GLimp_HaveExtension( "GL_ARB_shader_objects" ) &&
+	     GLimp_HaveExtension( "GL_ARB_fragment_shader" ) &&
+	     GLimp_HaveExtension( "GL_ARB_vertex_shader" ) &&
+	     GLimp_HaveExtension( "GL_ARB_shading_language_100" ) )
+	{
+		// many functions have been renamed from the ARB ext to GL 2.0
+		qglGetProc2(glDeleteShader, glDeleteObjectARB);
+		qglGetProc2(glDeleteProgram, glDeleteObjectARB);
+		qglGetProc2(glDetachShader, glDetachObjectARB);
+		qglGetProc2(glCreateShader, glCreateShaderObjectARB);
+		qglGetProc2(glShaderSource, glShaderSourceARB);
+		qglGetProc2(glCompileShader, glCompileShaderARB);
+		qglGetProc2(glCreateProgram, glCreateProgramObjectARB);
+		qglGetProc2(glAttachShader, glAttachObjectARB);
+		qglGetProc2(glLinkProgram, glLinkProgramARB);
+		qglGetProc2(glUseProgram, glUseProgramObjectARB);
+		qglGetProc2(glValidateProgram, glValidateProgramARB);
+		qglGetProc2(glUniform1f, glUniform1fARB);
+		qglGetProc2(glUniform2f, glUniform2fARB);
+		qglGetProc2(glUniform3f, glUniform3fARB);
+		qglGetProc2(glUniform4f, glUniform4fARB);
+		qglGetProc2(glUniform1i, glUniform1iARB);
+		qglGetProc2(glUniform2i, glUniform2iARB);
+		qglGetProc2(glUniform3i, glUniform3iARB);
+		qglGetProc2(glUniform4i, glUniform4iARB);
+		qglGetProc2(glUniform1fv, glUniform1fvARB);
+		qglGetProc2(glUniform2fv, glUniform2fvARB);
+		qglGetProc2(glUniform3fv, glUniform3fvARB);
+		qglGetProc2(glUniform4fv, glUniform4fvARB);
+		qglGetProc2(glUniform1iv, glUniform1ivARB);
+		qglGetProc2(glUniform2iv, glUniform2ivARB);
+		qglGetProc2(glUniform3iv, glUniform3ivARB);
+		qglGetProc2(glUniform4iv, glUniform4ivARB);
+		qglGetProc2(glUniform2fv, glUniformMatrix2fvARB);
+		qglGetProc2(glUniform3fv, glUniformMatrix3fvARB);
+		qglGetProc2(glUniform4fv, glUniformMatrix4fvARB);
+		qglGetProc2(glGetShaderiv, glGetObjectParameterivARB);
+		qglGetProc2(glGetProgramiv, glGetObjectParameterivARB);
+		qglGetProc2(glGetShaderInfoLog, glGetInfoLogARB);
+		qglGetProc2(glGetProgramInfoLog, glGetInfoLogARB);
+		qglGetProc2(glGetAttachedShaders, glGetAttachedObjectsARB);
+		qglGetProc2(glGetUniformLocation, glGetUniformLocationARB);
+		qglGetProc2(glGetActiveUniform, glGetActiveUniformARB);
+		qglGetProc2(glGetUniformfv, glGetUniformfvARB);
+		qglGetProc2(glGetUniformiv, glGetUniformivARB);
+		qglGetProc2(glGetShaderSource, glGetShaderSourceARB);
+		
+		qglGetProc(glVertexAttrib1fARB, );
+		qglGetProc(glVertexAttrib1sARB, );
+		qglGetProc(glVertexAttrib1dARB, );
+		qglGetProc(glVertexAttrib2fARB, );
+		qglGetProc(glVertexAttrib2sARB, );
+		qglGetProc(glVertexAttrib2dARB, );
+		qglGetProc(glVertexAttrib3fARB, );
+		qglGetProc(glVertexAttrib3sARB, );
+		qglGetProc(glVertexAttrib3dARB, );
+		qglGetProc(glVertexAttrib4fARB, );
+		qglGetProc(glVertexAttrib4sARB, );
+		qglGetProc(glVertexAttrib4dARB, );
+		qglGetProc(glVertexAttrib4NubARB, );
+		qglGetProc(glVertexAttrib1fvARB, );
+		qglGetProc(glVertexAttrib1svARB, );
+		qglGetProc(glVertexAttrib1dvARB, );
+		qglGetProc(glVertexAttrib2fvARB, );
+		qglGetProc(glVertexAttrib2svARB, );
+		qglGetProc(glVertexAttrib2dvARB, );
+		qglGetProc(glVertexAttrib3fvARB, );
+		qglGetProc(glVertexAttrib3svARB, );
+		qglGetProc(glVertexAttrib3dvARB, );
+		qglGetProc(glVertexAttrib4fvARB, );
+		qglGetProc(glVertexAttrib4svARB, );
+		qglGetProc(glVertexAttrib4dvARB, );
+		qglGetProc(glVertexAttrib4ivARB, );
+		qglGetProc(glVertexAttrib4bvARB, );
+		qglGetProc(glVertexAttrib4ubvARB, );
+		qglGetProc(glVertexAttrib4usvARB, );
+		qglGetProc(glVertexAttrib4uivARB, );
+		qglGetProc(glVertexAttrib4NbvARB, );
+		qglGetProc(glVertexAttrib4NsvARB, );
+		qglGetProc(glVertexAttrib4NivARB, );
+		qglGetProc(glVertexAttrib4NubvARB, );
+		qglGetProc(glVertexAttrib4NusvARB, );
+		qglGetProc(glVertexAttrib4NuivARB, );
+		qglGetProc(glVertexAttribPointerARB, );
+		qglGetProc(glEnableVertexAttribArrayARB, );
+		qglGetProc(glDisableVertexAttribArrayARB, );
+		qglGetProc(glBindAttribLocationARB, );
+		qglGetProc(glGetActiveAttribARB, );
+		qglGetProc(glGetAttribLocationARB, );
+		qglGetProc(glGetVertexAttribdvARB, );
+		qglGetProc(glGetVertexAttribfvARB, );
+		qglGetProc(glGetVertexAttribivARB, );
+		qglGetProc(glGetVertexAttribPointervARB, );
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_vertex_shader\n" );
+	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...GL_ARB_multitexture not found\n" );
+		qglDeleteShader = NULL;
+		qglDeleteProgram = NULL;
+		qglDetachShader = NULL;
+		qglCreateShader = NULL;
+		qglShaderSource = NULL;
+		qglCompileShader = NULL;
+		qglCreateProgram = NULL;
+		qglAttachShader = NULL;
+		qglLinkProgram = NULL;
+		qglUseProgram = NULL;
+		qglValidateProgram = NULL;
+		qglUniform1f = NULL;
+		qglUniform2f = NULL;
+		qglUniform3f = NULL;
+		qglUniform4f = NULL;
+		qglUniform1i = NULL;
+		qglUniform2i = NULL;
+		qglUniform3i = NULL;
+		qglUniform4i = NULL;
+		qglUniform1fv = NULL;
+		qglUniform2fv = NULL;
+		qglUniform3fv = NULL;
+		qglUniform4fv = NULL;
+		qglUniform1iv = NULL;
+		qglUniform2iv = NULL;
+		qglUniform3iv = NULL;
+		qglUniform4iv = NULL;
+		qglUniformMatrix2fv = NULL;
+		qglUniformMatrix3fv = NULL;
+		qglUniformMatrix4fv = NULL;
+		qglGetShaderiv = NULL;
+		qglGetProgramiv = NULL;
+		qglGetShaderInfoLog = NULL;
+		qglGetProgramInfoLog = NULL;
+		qglGetAttachedShaders = NULL;
+		qglGetUniformLocation = NULL;
+		qglGetActiveUniform = NULL;
+		qglGetUniformfv = NULL;
+		qglGetUniformiv = NULL;
+		qglGetShaderSource = NULL;
+		
+		qglVertexAttrib1fARB = NULL;
+		qglVertexAttrib1sARB = NULL;
+		qglVertexAttrib1dARB = NULL;
+		qglVertexAttrib2fARB = NULL;
+		qglVertexAttrib2sARB = NULL;
+		qglVertexAttrib2dARB = NULL;
+		qglVertexAttrib3fARB = NULL;
+		qglVertexAttrib3sARB = NULL;
+		qglVertexAttrib3dARB = NULL;
+		qglVertexAttrib4fARB = NULL;
+		qglVertexAttrib4sARB = NULL;
+		qglVertexAttrib4dARB = NULL;
+		qglVertexAttrib4NubARB = NULL;
+		qglVertexAttrib1fvARB = NULL;
+		qglVertexAttrib1svARB = NULL;
+		qglVertexAttrib1dvARB = NULL;
+		qglVertexAttrib2fvARB = NULL;
+		qglVertexAttrib2svARB = NULL;
+		qglVertexAttrib2dvARB = NULL;
+		qglVertexAttrib3fvARB = NULL;
+		qglVertexAttrib3svARB = NULL;
+		qglVertexAttrib3dvARB = NULL;
+		qglVertexAttrib4fvARB = NULL;
+		qglVertexAttrib4svARB = NULL;
+		qglVertexAttrib4dvARB = NULL;
+		qglVertexAttrib4ivARB = NULL;
+		qglVertexAttrib4bvARB = NULL;
+		qglVertexAttrib4ubvARB = NULL;
+		qglVertexAttrib4usvARB = NULL;
+		qglVertexAttrib4uivARB = NULL;
+		qglVertexAttrib4NbvARB = NULL;
+		qglVertexAttrib4NsvARB = NULL;
+		qglVertexAttrib4NivARB = NULL;
+		qglVertexAttrib4NubvARB = NULL;
+		qglVertexAttrib4NusvARB = NULL;
+		qglVertexAttrib4NuivARB = NULL;
+		qglVertexAttribPointerARB = NULL;
+		qglEnableVertexAttribArrayARB = NULL;
+		qglDisableVertexAttribArrayARB = NULL;
+		qglBindAttribLocationARB = NULL;
+		qglGetActiveAttribARB = NULL;
+		qglGetAttribLocationARB = NULL;
+		qglGetVertexAttribdvARB = NULL;
+		qglGetVertexAttribfvARB = NULL;
+		qglGetVertexAttribivARB = NULL;
+		qglGetVertexAttribPointervARB = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_vertex_shader not found\n" );
 	}
 
-	// GL_EXT_compiled_vertex_array
-	if ( GLimp_HaveExtension( "GL_EXT_compiled_vertex_array" ) )
-	{
-		if ( r_ext_compiled_vertex_array->value )
-		{
-			ri.Printf( PRINT_ALL, "...using GL_EXT_compiled_vertex_array\n" );
-			qglLockArraysEXT = ( void ( APIENTRY * )( GLint, GLint ) ) SDL_GL_GetProcAddress( "glLockArraysEXT" );
-			qglUnlockArraysEXT = ( void ( APIENTRY * )( void ) ) SDL_GL_GetProcAddress( "glUnlockArraysEXT" );
-			if (!qglLockArraysEXT || !qglUnlockArraysEXT)
-			{
-				ri.Error (ERR_FATAL, "bad getprocaddress");
-			}
+	if ( qglCreateShader ) {
+		// check that fragment shaders may access enough texture image units
+		// to render a whole shader in one pass
+		qglGetIntegerv( GL_MAX_TEXTURE_IMAGE_UNITS_ARB, &glGlobals.maxTextureImageUnits );
+		qglGetIntegerv( GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB, &glGlobals.maxVertexTextureImageUnits );
+		if ( glGlobals.maxTextureImageUnits < MAX_SHADER_STAGES + 4 ||
+		     glGlobals.maxVertexTextureImageUnits < 4 ) {
+			qglDeleteShader = NULL;
+			qglDeleteProgram = NULL;
+			qglDetachShader = NULL;
+			qglCreateShader = NULL;
+			qglShaderSource = NULL;
+			qglCompileShader = NULL;
+			qglCreateProgram = NULL;
+			qglAttachShader = NULL;
+			qglLinkProgram = NULL;
+			qglUseProgram = NULL;
+			qglValidateProgram = NULL;
+			qglUniform1f = NULL;
+			qglUniform2f = NULL;
+			qglUniform3f = NULL;
+			qglUniform4f = NULL;
+			qglUniform1i = NULL;
+			qglUniform2i = NULL;
+			qglUniform3i = NULL;
+			qglUniform4i = NULL;
+			qglUniform1fv = NULL;
+			qglUniform2fv = NULL;
+			qglUniform3fv = NULL;
+			qglUniform4fv = NULL;
+			qglUniform1iv = NULL;
+			qglUniform2iv = NULL;
+			qglUniform3iv = NULL;
+			qglUniform4iv = NULL;
+			qglUniformMatrix2fv = NULL;
+			qglUniformMatrix3fv = NULL;
+			qglUniformMatrix4fv = NULL;
+			qglGetShaderiv = NULL;
+			qglGetProgramiv = NULL;
+			qglGetShaderInfoLog = NULL;
+			qglGetProgramInfoLog = NULL;
+			qglGetAttachedShaders = NULL;
+			qglGetUniformLocation = NULL;
+			qglGetActiveUniform = NULL;
+			qglGetUniformfv = NULL;
+			qglGetUniformiv = NULL;
+			qglGetShaderSource = NULL;
+			
+			qglVertexAttrib1fARB = NULL;
+			qglVertexAttrib1sARB = NULL;
+			qglVertexAttrib1dARB = NULL;
+			qglVertexAttrib2fARB = NULL;
+			qglVertexAttrib2sARB = NULL;
+			qglVertexAttrib2dARB = NULL;
+			qglVertexAttrib3fARB = NULL;
+			qglVertexAttrib3sARB = NULL;
+			qglVertexAttrib3dARB = NULL;
+			qglVertexAttrib4fARB = NULL;
+			qglVertexAttrib4sARB = NULL;
+			qglVertexAttrib4dARB = NULL;
+			qglVertexAttrib4NubARB = NULL;
+			qglVertexAttrib1fvARB = NULL;
+			qglVertexAttrib1svARB = NULL;
+			qglVertexAttrib1dvARB = NULL;
+			qglVertexAttrib2fvARB = NULL;
+			qglVertexAttrib2svARB = NULL;
+			qglVertexAttrib2dvARB = NULL;
+			qglVertexAttrib3fvARB = NULL;
+			qglVertexAttrib3svARB = NULL;
+			qglVertexAttrib3dvARB = NULL;
+			qglVertexAttrib4fvARB = NULL;
+			qglVertexAttrib4svARB = NULL;
+			qglVertexAttrib4dvARB = NULL;
+			qglVertexAttrib4ivARB = NULL;
+			qglVertexAttrib4bvARB = NULL;
+			qglVertexAttrib4ubvARB = NULL;
+			qglVertexAttrib4usvARB = NULL;
+			qglVertexAttrib4uivARB = NULL;
+			qglVertexAttrib4NbvARB = NULL;
+			qglVertexAttrib4NsvARB = NULL;
+			qglVertexAttrib4NivARB = NULL;
+			qglVertexAttrib4NubvARB = NULL;
+			qglVertexAttrib4NusvARB = NULL;
+			qglVertexAttrib4NuivARB = NULL;
+			qglVertexAttribPointerARB = NULL;
+			qglEnableVertexAttribArrayARB = NULL;
+			qglDisableVertexAttribArrayARB = NULL;
+			qglBindAttribLocationARB = NULL;
+			qglGetActiveAttribARB = NULL;
+			qglGetAttribLocationARB = NULL;
+			qglGetVertexAttribdvARB = NULL;
+			qglGetVertexAttribfvARB = NULL;
+			qglGetVertexAttribivARB = NULL;
+			qglGetVertexAttribPointervARB = NULL;
+			
+			ri.Printf( PRINT_DEVELOPER, "Fragment/Vertex shaders support only %d/%d texture image units - disabled\n",
+				   glGlobals.maxTextureImageUnits,
+				   glGlobals.maxVertexTextureImageUnits );
 		}
-		else
-		{
-			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_compiled_vertex_array\n" );
-		}
+	} else {
+		glGlobals.maxTextureImageUnits = glGlobals.maxTextureUnits;
 	}
+
+	// GL_EXT_geometry_shader4, mandatory since OpenGL 3.2
+	if ( !r_ext_geometry_shader->integer ) {
+		qglProgramParameteriEXT = NULL;
+		qglFramebufferTextureEXT = NULL;
+		qglFramebufferTextureLayerEXT = NULL;
+		qglFramebufferTextureFaceEXT = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_geometry_shader4\n" );
+	} else if ( GLversion >= 0x0302 ) {
+		qglGetProc(glProgramParameteri, EXT);
+		qglGetProc(glFramebufferTexture, EXT);
+		qglGetProc(glFramebufferTextureLayer, EXT);
+		qglGetProc(glFramebufferTextureFace, EXT);
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_geometry_shader\n" );
+		
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_EXT_geometry_shader4" ) )
+	{
+		qglGetProc(glProgramParameteriEXT, );
+		qglGetProc(glFramebufferTextureEXT, );
+		qglGetProc(glFramebufferTextureLayerEXT, );
+		qglGetProc(glFramebufferTextureFaceEXT, );
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_geometry_shader4\n" );
+	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...GL_EXT_compiled_vertex_array not found\n" );
+		qglProgramParameteriEXT = NULL;
+		qglFramebufferTextureEXT = NULL;
+		qglFramebufferTextureLayerEXT = NULL;
+		qglFramebufferTextureFaceEXT = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_geometry_shader4 not found\n" );
 	}
 
-	glConfig.textureFilterAnisotropic = qfalse;
-	if ( GLimp_HaveExtension( "GL_EXT_texture_filter_anisotropic" ) )
+	// GL_ARB_texture_float, mandatory since OpenGL 3.0
+	if ( !r_ext_texture_float->integer ) {
+		glGlobals.floatTextures = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_texture_float\n" );
+	} else if ( GLversion >= 0x0300 ) {
+		glGlobals.floatTextures = qtrue;
+		ri.Printf( PRINT_DEVELOPER, "...using GL_texture_float\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_texture_float" ) ) {
+		glGlobals.floatTextures = qtrue;
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_texture_float\n" );
+	} else {
+		glGlobals.floatTextures = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_texture_float not found\n" );
+	}
+
+	// GL_EXT_texture3D, mandatory since OpenGL 1.2
+	if ( !r_ext_texture3D->integer ) {
+		qglTexImage3DEXT = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_texture3D\n" );
+	} else if ( GLversion >= 0x0102 ) {
+		qglGetProc(glTexImage3D, EXT);
+		ri.Printf( PRINT_DEVELOPER, "...using GL_texture3D\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_EXT_texture3D" ) ) {
+		qglGetProc(glTexImage3DEXT, );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_texture3D\n" );
+	} else {
+		qglTexImage3DEXT = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture3D not found\n" );
+	}
+
+	// GL_ARB_framebuffer_object, mandatory since OpenGL 3.0
+	if ( !r_ext_framebuffer_object->integer ) {
+		qglIsRenderbuffer = NULL;
+		qglBindRenderbuffer = NULL;
+		qglDeleteRenderbuffers = NULL;
+		qglGenRenderbuffers = NULL;
+		qglRenderbufferStorage = NULL;
+		qglRenderbufferStorageMultisample = NULL;
+		qglGetRenderbufferParameteriv = NULL;
+		qglIsFramebuffer = NULL;
+		qglBindFramebuffer = NULL;
+		qglDeleteFramebuffers = NULL;
+		qglGenFramebuffers = NULL;
+		qglCheckFramebufferStatus = NULL;
+		qglFramebufferTexture1D = NULL;
+		qglFramebufferTexture2D = NULL;
+		qglFramebufferTexture3D = NULL;
+		qglFramebufferTextureLayer = NULL;
+		qglFramebufferRenderbuffer = NULL;
+		qglGetFramebufferAttachmentParameteriv = NULL;
+		qglBlitFramebuffer = NULL;
+		qglGenerateMipmap = NULL;
+		
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_framebuffer_object\n" );
+	} else if ( GLversion >= 0x0300 ) {
+		qglGetProc(glIsRenderbuffer, );
+		qglGetProc(glBindRenderbuffer, );
+		qglGetProc(glDeleteRenderbuffers, );
+		qglGetProc(glGenRenderbuffers, );
+		qglGetProc(glRenderbufferStorage, );
+		qglGetProc(glRenderbufferStorageMultisample, );
+		qglGetProc(glGetRenderbufferParameteriv, );
+		qglGetProc(glIsFramebuffer, );
+		qglGetProc(glBindFramebuffer, );
+		qglGetProc(glDeleteFramebuffers, );
+		qglGetProc(glGenFramebuffers, );
+		qglGetProc(glCheckFramebufferStatus, );
+		qglGetProc(glFramebufferTexture1D, );
+		qglGetProc(glFramebufferTexture2D, );
+		qglGetProc(glFramebufferTexture3D, );
+		qglGetProc(glFramebufferTextureLayer, );
+		qglGetProc(glFramebufferRenderbuffer, );
+		qglGetProc(glGetFramebufferAttachmentParameteriv, );
+		qglGetProc(glBlitFramebuffer, );
+		qglGetProc(glGenerateMipmap, );
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_framebuffer_object\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_framebuffer_object" ) )
 	{
-		if ( r_ext_texture_filter_anisotropic->integer ) {
-			qglGetIntegerv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, (GLint *)&glConfig.maxAnisotropy );
-			if ( glConfig.maxAnisotropy <= 0 ) {
-				ri.Printf( PRINT_ALL, "...GL_EXT_texture_filter_anisotropic not properly supported!\n" );
-				glConfig.maxAnisotropy = 0;
-			}
-			else
-			{
-				ri.Printf( PRINT_ALL, "...using GL_EXT_texture_filter_anisotropic (max: %i)\n", glConfig.maxAnisotropy );
-				glConfig.textureFilterAnisotropic = qtrue;
-			}
-		}
-		else
-		{
-			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_filter_anisotropic\n" );
-		}
+		qglGetProc(glIsRenderbuffer, );
+		qglGetProc(glBindRenderbuffer, );
+		qglGetProc(glDeleteRenderbuffers, );
+		qglGetProc(glGenRenderbuffers, );
+		qglGetProc(glRenderbufferStorage, );
+		qglGetProc(glRenderbufferStorageMultisample, );
+		qglGetProc(glGetRenderbufferParameteriv, );
+		qglGetProc(glIsFramebuffer, );
+		qglGetProc(glBindFramebuffer, );
+		qglGetProc(glDeleteFramebuffers, );
+		qglGetProc(glGenFramebuffers, );
+		qglGetProc(glCheckFramebufferStatus, );
+		qglGetProc(glFramebufferTexture1D, );
+		qglGetProc(glFramebufferTexture2D, );
+		qglGetProc(glFramebufferTexture3D, );
+		qglGetProc(glFramebufferTextureLayer, );
+		qglGetProc(glFramebufferRenderbuffer, );
+		qglGetProc(glGetFramebufferAttachmentParameteriv, );
+		qglGetProc(glBlitFramebuffer, );
+		qglGetProc(glGenerateMipmap, );
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_framebuffer_object\n" );
 	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...GL_EXT_texture_filter_anisotropic not found\n" );
+		qglIsRenderbuffer = NULL;
+		qglBindRenderbuffer = NULL;
+		qglDeleteRenderbuffers = NULL;
+		qglGenRenderbuffers = NULL;
+		qglRenderbufferStorage = NULL;
+		qglRenderbufferStorageMultisample = NULL;
+		qglGetRenderbufferParameteriv = NULL;
+		qglIsFramebuffer = NULL;
+		qglBindFramebuffer = NULL;
+		qglDeleteFramebuffers = NULL;
+		qglGenFramebuffers = NULL;
+		qglCheckFramebufferStatus = NULL;
+		qglFramebufferTexture1D = NULL;
+		qglFramebufferTexture2D = NULL;
+		qglFramebufferTexture3D = NULL;
+		qglFramebufferTextureLayer = NULL;
+		qglFramebufferRenderbuffer = NULL;
+		qglGetFramebufferAttachmentParameteriv = NULL;
+		qglBlitFramebuffer = NULL;
+		qglGenerateMipmap = NULL;
+		
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_framebuffer_object not found\n" );
 	}
+
+	// GL_ARB_occlusion_query, mandatory since OpenGL 1.5
+	if ( !r_ext_occlusion_query->integer ) {
+		qglGenQueriesARB = NULL;
+		qglDeleteQueriesARB = NULL;
+		qglIsQueryARB = NULL;
+		qglBeginQueryARB = NULL;
+		qglEndQueryARB = NULL;
+		qglGetQueryivARB = NULL;
+		qglGetQueryObjectivARB = NULL;
+		qglGetQueryObjectuivARB = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_occlusion_query\n" );
+	} else if ( GLversion >= 0x0105 ) {
+		qglGetProc(glGenQueries, ARB);
+		qglGetProc(glDeleteQueries, ARB);
+		qglGetProc(glIsQuery, ARB);
+		qglGetProc(glBeginQuery, ARB);
+		qglGetProc(glEndQuery, ARB);
+		qglGetProc(glGetQueryiv, ARB);
+		qglGetProc(glGetQueryObjectiv, ARB);
+		qglGetProc(glGetQueryObjectuiv, ARB);
+		ri.Printf( PRINT_DEVELOPER, "...using GL_occlusion_query\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_occlusion_query" ) ) {
+		qglGetProc(glGenQueriesARB, );
+		qglGetProc(glDeleteQueriesARB, );
+		qglGetProc(glIsQueryARB, );
+		qglGetProc(glBeginQueryARB, );
+		qglGetProc(glEndQueryARB, );
+		qglGetProc(glGetQueryivARB, );
+		qglGetProc(glGetQueryObjectivARB, );
+		qglGetProc(glGetQueryObjectuivARB, );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_occlusion_query\n" );
+	} else {
+		qglGenQueriesARB = NULL;
+		qglDeleteQueriesARB = NULL;
+		qglIsQueryARB = NULL;
+		qglBeginQueryARB = NULL;
+		qglEndQueryARB = NULL;
+		qglGetQueryivARB = NULL;
+		qglGetQueryObjectivARB = NULL;
+		qglGetQueryObjectuivARB = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_occlusion_query not found\n" );
+	}
+
+	// GL_EXT_timer_query, in core since OpenGL 3.3
+	if ( !r_ext_timer_query->integer || !qglGenQueriesARB ) {
+		glGlobals.timerQuery = 0;
+		qglGetQueryObjecti64vEXT = NULL;
+		qglGetQueryObjectui64vEXT = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_timer_query\n" );
+	} else if ( GLversion >= 0x0303 ) {
+		qglGetProc(glGetQueryObjecti64v, EXT);
+		qglGetProc(glGetQueryObjectui64v, EXT);
+		qglGenQueriesARB( 1, &glGlobals.timerQuery );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_timer_query\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_EXT_timer_query" ) ) {
+		qglGetProc(glGetQueryObjecti64vEXT, );
+		qglGetProc(glGetQueryObjectui64vEXT, );
+		qglGenQueriesARB( 1, &glGlobals.timerQuery );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_timer_query\n" );
+	}
+	else
+	{
+		glGlobals.timerQuery = 0;
+		qglGetQueryObjecti64vEXT = NULL;
+		qglGetQueryObjectui64vEXT = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_timer_query not found\n" );
+	}
+
+	// GL_ARB_instanced_arrays, in core since OpenGL 3.3
+	if ( !r_ext_instanced_arrays->integer ) {
+		qglVertexAttribDivisorARB = NULL;
+		qglDrawArraysInstancedARB = NULL;
+		qglDrawElementsInstancedARB = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_instanced_arrays\n" );
+	} else if ( GLversion >= 0x0303 ) {
+		qglGetProc(glVertexAttribDivisor, ARB);
+		qglGetProc(glDrawArraysInstanced, ARB);
+		qglGetProc(glDrawElementsInstanced, ARB);
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_instanced_arrays\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_instanced_arrays" ) ) {
+		qglGetProc(glVertexAttribDivisorARB, );
+		qglGetProc(glDrawArraysInstancedARB, );
+		qglGetProc(glDrawElementsInstancedARB, );
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_instanced_arrays\n" );
+	}
+	else
+	{
+		qglVertexAttribDivisorARB = NULL;
+		qglDrawArraysInstancedARB = NULL;
+		qglDrawElementsInstancedARB = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_instanced_arrays not found\n" );
+	}
+
+	// GL_ARB_separate_stencil, part of 2.0 but not a separate extension
+	if ( !r_ext_separate_stencil->integer ) {
+		qglStencilFuncSeparate = NULL;
+		qglStencilOpSeparate = NULL;
+		qglStencilMaskSeparate = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_separate_stencil\n" );
+	} else if ( GLversion >= 0x0200 ) {
+		qglGetProc(glStencilFuncSeparate, );
+		qglGetProc(glStencilOpSeparate, );
+		qglGetProc(glStencilMaskSeparate, );
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_separate_stencil\n" );
+	} else {
+		qglStencilFuncSeparate = NULL;
+		qglStencilOpSeparate = NULL;
+		qglStencilMaskSeparate = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_separate_stencil not found\n" );
+	}
+
+	// GL_{AMD/ARB}_debug_output, not in core
+	if ( !r_ext_debug_output->integer ) {
+		qglDebugMessageControlARB = NULL;
+		qglDebugMessageInsertARB = NULL;
+		qglDebugMessageCallbackARB = NULL;
+		qglGetDebugMessageLogARB = NULL;
+
+		qglDebugMessageEnableAMD = NULL;
+		qglDebugMessageInsertAMD = NULL;
+		qglDebugMessageCallbackAMD = NULL;
+		qglGetDebugMessageLogAMD = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_debug_output\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_debug_output" ) ) {
+		qglGetProc(glDebugMessageControlARB, );
+		qglGetProc(glDebugMessageInsertARB, );
+		qglGetProc(glDebugMessageCallbackARB, );
+		qglGetProc(glGetDebugMessageLogARB, );
+
+		qglDebugMessageEnableAMD = NULL;
+		qglDebugMessageInsertAMD = NULL;
+		qglDebugMessageCallbackAMD = NULL;
+		qglGetDebugMessageLogAMD = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_debug_output\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_AMD_debug_output" ) ) {
+		qglDebugMessageControlARB = NULL;
+		qglDebugMessageInsertARB = NULL;
+		qglDebugMessageCallbackARB = NULL;
+		qglGetDebugMessageLogARB = NULL;
+
+		qglGetProc(glDebugMessageEnableAMD, );
+		qglGetProc(glDebugMessageInsertAMD, );
+		qglGetProc(glDebugMessageCallbackAMD, );
+		qglGetProc(glGetDebugMessageLogAMD, );
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_AMD_debug_output\n" );
+	} else {
+		qglDebugMessageControlARB = NULL;
+		qglDebugMessageInsertARB = NULL;
+		qglDebugMessageCallbackARB = NULL;
+		qglGetDebugMessageLogARB = NULL;
+
+		qglDebugMessageEnableAMD = NULL;
+		qglDebugMessageInsertAMD = NULL;
+		qglDebugMessageCallbackAMD = NULL;
+		qglGetDebugMessageLogAMD = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_debug_output not found\n" );
+	}
 }
 
 /*
@@ -686,6 +2113,8 @@
 */
 void GLimp_Init( void )
 {
+	int GLmajor, GLminor;
+
 	r_allowSoftwareGL = ri.Cvar_Get( "r_allowSoftwareGL", "0", CVAR_LATCH );
 	r_sdlDriver = ri.Cvar_Get( "r_sdlDriver", "", CVAR_ROM );
 	r_allowResize = ri.Cvar_Get( "r_allowResize", "0", CVAR_ARCHIVE );
@@ -695,6 +2124,10 @@
 
 	Sys_GLimpInit( );
 
+#ifdef SDL_VIDEO_DRIVER_X11
+	XInitThreads( );
+#endif
+
 	// Create the window and set up the context
 	if( GLimp_StartDriverAndSetMode( qfalse, r_fullscreen->integer, r_noborder->integer ) )
 		goto success;
@@ -730,10 +2163,11 @@
 	if (*glConfig.renderer_string && glConfig.renderer_string[strlen(glConfig.renderer_string) - 1] == '\n')
 		glConfig.renderer_string[strlen(glConfig.renderer_string) - 1] = 0;
 	Q_strncpyz( glConfig.version_string, (char *) qglGetString (GL_VERSION), sizeof( glConfig.version_string ) );
+	sscanf( glConfig.version_string, "%d.%d", &GLmajor, &GLminor );
 	Q_strncpyz( glConfig.extensions_string, (char *) qglGetString (GL_EXTENSIONS), sizeof( glConfig.extensions_string ) );
 
 	// initialize extensions
-	GLimp_InitExtensions( );
+	GLimp_InitExtensions( (GLmajor << 8) | GLminor );
 
 	ri.Cvar_Get( "r_availableModes", "", CVAR_ROM );
 
@@ -798,7 +2232,6 @@
 
 
 
-#ifdef SMP
 /*
 ===========================================================
 
@@ -827,6 +2260,12 @@
 */
 static void GLimp_ShutdownRenderThread(void)
 {
+	if (renderThread != NULL)
+	{
+		SDL_WaitThread(renderThread, NULL);
+		renderThread = NULL;
+	}
+
 	if (smpMutex != NULL)
 	{
 		SDL_DestroyMutex(smpMutex);
@@ -855,14 +2294,14 @@
 */
 static int GLimp_RenderThreadWrapper( void *arg )
 {
-	Com_Printf( "Render thread starting\n" );
+	ri.Printf( PRINT_ALL, "Render thread starting\n" );
+	GLimp_SetCurrentContext( &backend_context );
 
 	glimpRenderThread();
 
-	GLimp_SetCurrentContext(NULL);
+	GLimp_SetCurrentContext( NULL );
+	ri.Printf( PRINT_ALL, "Render thread terminating\n" );
 
-	Com_Printf( "Render thread terminating\n" );
-
 	return 0;
 }
 
@@ -876,26 +2315,24 @@
 	static qboolean warned = qfalse;
 	if (!warned)
 	{
-		Com_Printf("WARNING: You enable r_smp at your own risk!\n");
+		ri.Printf( PRINT_ALL, "WARNING: You enable r_smp at your own risk!\n" );
 		warned = qtrue;
 	}
 
-#ifndef MACOS_X
+#if !defined(MACOS_X) && !defined(WIN32) && !defined (SDL_VIDEO_DRIVER_X11)
 	return qfalse;  /* better safe than sorry for now. */
 #endif
 
 	if (renderThread != NULL)  /* hopefully just a zombie at this point... */
 	{
-		Com_Printf("Already a render thread? Trying to clean it up...\n");
-		SDL_WaitThread(renderThread, NULL);
-		renderThread = NULL;
+		ri.Printf( PRINT_ALL, "Already a render thread? Trying to clean it up...\n" );
 		GLimp_ShutdownRenderThread();
 	}
 
 	smpMutex = SDL_CreateMutex();
 	if (smpMutex == NULL)
 	{
-		Com_Printf( "smpMutex creation failed: %s\n", SDL_GetError() );
+		ri.Printf( PRINT_ALL, "smpMutex creation failed: %s\n", SDL_GetError() );
 		GLimp_ShutdownRenderThread();
 		return qfalse;
 	}
@@ -903,7 +2340,7 @@
 	renderCommandsEvent = SDL_CreateCond();
 	if (renderCommandsEvent == NULL)
 	{
-		Com_Printf( "renderCommandsEvent creation failed: %s\n", SDL_GetError() );
+		ri.Printf( PRINT_ALL, "renderCommandsEvent creation failed: %s\n", SDL_GetError() );
 		GLimp_ShutdownRenderThread();
 		return qfalse;
 	}
@@ -911,7 +2348,7 @@
 	renderCompletedEvent = SDL_CreateCond();
 	if (renderCompletedEvent == NULL)
 	{
-		Com_Printf( "renderCompletedEvent creation failed: %s\n", SDL_GetError() );
+		ri.Printf( PRINT_ALL, "renderCompletedEvent creation failed: %s\n", SDL_GetError() );
 		GLimp_ShutdownRenderThread();
 		return qfalse;
 	}
@@ -950,25 +2387,21 @@
 {
 	void  *data = NULL;
 
-	GLimp_SetCurrentContext(NULL);
-
 	SDL_LockMutex(smpMutex);
 	{
 		smpData = NULL;
 		smpDataReady = qfalse;
 
 		// after this, the front end can exit GLimp_FrontEndSleep
-		SDL_CondSignal(renderCompletedEvent);
-
-		while ( !smpDataReady )
+		do {
+			SDL_CondSignal(renderCompletedEvent);
 			SDL_CondWait(renderCommandsEvent, smpMutex);
+		} while( !smpDataReady);
 
 		data = (void *)smpData;
 	}
 	SDL_UnlockMutex(smpMutex);
 
-	GLimp_SetCurrentContext(opengl_context);
-
 	return data;
 }
 
@@ -985,8 +2418,6 @@
 			SDL_CondWait(renderCompletedEvent, smpMutex);
 	}
 	SDL_UnlockMutex(smpMutex);
-
-	GLimp_SetCurrentContext(opengl_context);
 }
 
 /*
@@ -996,8 +2427,6 @@
 */
 void GLimp_WakeRenderer( void *data )
 {
-	GLimp_SetCurrentContext(NULL);
-
 	SDL_LockMutex(smpMutex);
 	{
 		assert( smpData == NULL );
@@ -1010,30 +2439,12 @@
 	SDL_UnlockMutex(smpMutex);
 }
 
-#else
-
-// No SMP - stubs
-void GLimp_RenderThreadWrapper( void *arg )
+/*
+===============
+GLimp_IsSMPActive
+===============
+*/
+qboolean GLimp_IsSMPActive( void )
 {
+	return (renderThread != NULL);
 }
-
-qboolean GLimp_SpawnRenderThread( void (*function)( void ) )
-{
-	ri.Printf( PRINT_WARNING, "ERROR: SMP support was disabled at compile time\n");
-	return qfalse;
-}
-
-void *GLimp_RendererSleep( void )
-{
-	return NULL;
-}
-
-void GLimp_FrontEndSleep( void )
-{
-}
-
-void GLimp_WakeRenderer( void *data )
-{
-}
-
-#endif
Index: src/renderer/tr_mesh.c
===================================================================
--- src/renderer/tr_mesh.c	(Revision 2062)
+++ src/renderer/tr_mesh.c	(Arbeitskopie)
@@ -201,7 +201,7 @@
 		else
 #endif
 		{
-			frame = ( md3Frame_t * ) ( ( ( unsigned char * ) tr.currentModel->md3[0] ) + tr.currentModel->md3[0]->ofsFrames );
+			frame = ( md3Frame_t * ) ( ( ( unsigned char * ) tr.currentModel->modelData.md3.md3[0] ) + tr.currentModel->modelData.md3.md3[0]->ofsFrames );
 
 			frame += ent->e.frame;
 
@@ -298,11 +298,11 @@
 	qboolean		personalModel;
 
 	// don't add third_person objects if not in a portal
-	personalModel = (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.isPortal;
+	personalModel = (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.portalLevel;
 
 	if ( ent->e.renderfx & RF_WRAP_FRAMES ) {
-		ent->e.frame %= tr.currentModel->md3[0]->numFrames;
-		ent->e.oldframe %= tr.currentModel->md3[0]->numFrames;
+		ent->e.frame %= tr.currentModel->modelData.md3.md3[0]->numFrames;
+		ent->e.oldframe %= tr.currentModel->modelData.md3.md3[0]->numFrames;
 	}
 
 	//
@@ -311,9 +311,9 @@
 	// when the surfaces are rendered, they don't need to be
 	// range checked again.
 	//
-	if ( (ent->e.frame >= tr.currentModel->md3[0]->numFrames) 
+	if ( (ent->e.frame >= tr.currentModel->modelData.md3.md3[0]->numFrames) 
 		|| (ent->e.frame < 0)
-		|| (ent->e.oldframe >= tr.currentModel->md3[0]->numFrames)
+		|| (ent->e.oldframe >= tr.currentModel->modelData.md3.md3[0]->numFrames)
 		|| (ent->e.oldframe < 0) ) {
 			ri.Printf( PRINT_DEVELOPER, "R_AddMD3Surfaces: no such frame %d to %d for '%s'\n",
 				ent->e.oldframe, ent->e.frame,
@@ -327,7 +327,7 @@
 	//
 	lod = R_ComputeLOD( ent );
 
-	header = tr.currentModel->md3[lod];
+	header = tr.currentModel->modelData.md3.md3[lod];
 
 	//
 	// cull the entire model if merged bounding box of both frames
@@ -354,8 +354,8 @@
 	// draw all surfaces
 	//
 	surface = (md3Surface_t *)( (byte *)header + header->ofsSurfaces );
+	
 	for ( i = 0 ; i < header->numSurfaces ; i++ ) {
-
 		if ( ent->e.customShader ) {
 			shader = R_GetShaderByHandle( ent->e.customShader );
 		} else if ( ent->e.customSkin > 0 && ent->e.customSkin < tr.numSkins ) {
@@ -396,7 +396,7 @@
 			&& fogNum == 0
 			&& !(ent->e.renderfx & ( RF_NOSHADOW | RF_DEPTHHACK ) ) 
 			&& shader->sort == SS_OPAQUE ) {
-			R_AddDrawSurf( (void *)surface, tr.shadowShader, 0, qfalse );
+			R_AddDrawSurf( (void *)surface, tr.shadowShader, 0, 0, qfalse );
 		}
 
 		// projection shadows work fine with personal models
@@ -404,16 +404,28 @@
 			&& fogNum == 0
 			&& (ent->e.renderfx & RF_SHADOW_PLANE )
 			&& shader->sort == SS_OPAQUE ) {
-			R_AddDrawSurf( (void *)surface, tr.projectionShadowShader, 0, qfalse );
+			R_AddDrawSurf( (void *)surface, tr.projectionShadowShader, 0, 0, qfalse );
 		}
 
 		// don't add third_person objects if not viewing through a portal
 		if ( !personalModel ) {
-			R_AddDrawSurf( (void *)surface, shader, fogNum, qfalse );
+			if( tr.currentModel->modelData.md3.md3srf[lod] &&
+			    shader->lightmapIndex == LIGHTMAP_MD3 &&
+			    shader->GLSLprogram ) {
+				srfMD3Texture_t *surf = &tr.currentModel->modelData.md3.md3srf[lod][i];
+				if( shader->depthShader ) {
+					R_AddDrawSurf( (void *)surf, shader->depthShader, 0, 0, qfalse );
+				}
+				R_AddDrawSurf( (void *)surf, shader, fogNum, 0, qfalse );
+			} else {
+				if( shader->depthShader ) {
+					R_AddDrawSurf( (void *)surface, shader->depthShader, 0, 0, qfalse );
+				}
+				R_AddDrawSurf( (void *)surface, shader, fogNum, 0, qfalse );
+			}
 		}
 
 		surface = (md3Surface_t *)( (byte *)surface + surface->ofsEnd );
 	}
-
 }
 
Index: src/renderer/tr_local.h
===================================================================
--- src/renderer/tr_local.h	(Revision 2062)
+++ src/renderer/tr_local.h	(Arbeitskopie)
@@ -30,9 +30,10 @@
 #include "../qcommon/qcommon.h"
 #include "tr_public.h"
 #include "qgl.h"
+#include "iqm.h"
 
-#define GL_INDEX_TYPE		GL_UNSIGNED_INT
-typedef unsigned int glIndex_t;
+//#define GL_INDEX_TYPE		GL_UNSIGNED_INT
+//typedef unsigned int glIndex_t;
 
 // fast float to int conversion
 #if id386 && !defined(__GNUC__)
@@ -47,6 +48,13 @@
 // parallel on a dual cpu machine
 #define	SMP_FRAMES		2
 
+// To avoid allocating memory in the backend thread
+// I preallocate a fixed size block and just allocate
+// free temp memory within this block. The size can
+// be set with the cVar r_scratchmegs, the default is
+// defined here.
+#define SMP_SCRATCHMEGS		4
+
 // 12 bits
 // see QSORT_SHADERNUM_SHIFT
 #define	MAX_SHADERS				16384
@@ -55,6 +63,8 @@
 #define MAX_STATES_PER_SHADER 32
 #define MAX_STATE_NAME 32
 
+#define NUM_TEXTURE_BUNDLES 4
+
 // can't be increased without changing bit packing for drawsurfs
 
 
@@ -67,7 +77,6 @@
 	int		additive;			// texture detail is lost tho when the lightmap is dark
 } dlight_t;
 
-
 // a trRefEntity_t has all the information passed in by
 // the client game, as well as some locally derived info
 typedef struct {
@@ -103,7 +112,9 @@
 	int			TMU;				// only needed for voodoo2
 
 	qboolean	mipmap;
+	int		maxMipLevel;
 	qboolean	allowPicmip;
+	qboolean        hasAlpha;
 	int			wrapClampMode;		// GL_CLAMP_TO_EDGE or GL_REPEAT
 
 	struct image_s*	next;
@@ -114,6 +125,7 @@
 typedef enum {
 	SS_BAD,
 	SS_PORTAL,			// mirrors, portals, viewscreens
+	SS_DEPTH,		// Z-only pass
 	SS_ENVIRONMENT,		// sky box
 	SS_OPAQUE,			// opaque
 
@@ -284,6 +296,7 @@
 
 typedef struct {
 	image_t			*image[MAX_IMAGE_ANIMATIONS];
+	image_t			*combinedImage;
 	int				numImageAnimations;
 	float			imageAnimationSpeed;
 
@@ -297,10 +310,9 @@
 	qboolean		isLightmap;
 	qboolean		vertexLightmap;
 	qboolean		isVideoMap;
+	int		multitextureEnv;		// 0, GL_MODULATE, GL_ADD
 } textureBundle_t;
 
-#define NUM_TEXTURE_BUNDLES 2
-
 typedef struct {
 	qboolean		active;
 	
@@ -325,7 +337,8 @@
 
 // any change in the LIGHTMAP_* defines here MUST be reflected in
 // R_FindShader() in tr_bsp.c
-#define LIGHTMAP_2D         -4	// shader is for 2D rendering
+#define LIGHTMAP_2D         -5	// shader is for 2D rendering
+#define LIGHTMAP_MD3        -4  // shader for MD3 rendering (interpolation)
 #define LIGHTMAP_BY_VERTEX  -3	// pre-lit triangle models
 #define LIGHTMAP_WHITEIMAGE -2
 #define LIGHTMAP_NONE       -1
@@ -353,6 +366,92 @@
 } fogParms_t;
 
 
+typedef byte color4ub_t[4];
+
+/* This is the interleaved layout of the vertex data in RAM and VBO.
+ * The struct simply stores all known data per vertex, even if
+ * it isn't needed because the shaders doesn't use e.g. normals.
+ * But keeping track of all shaders that may affect a vertex is
+ * simply too much hassle and building a new VBO for each shader
+ * is probably wasting more graphics memory than the unused data
+ * here.
+ */
+typedef struct vaWord1_s {
+  vec2_t	tc1;
+  vec2_t	tc2;
+} vaWord1_t;  // same layout in VBO
+typedef struct vaWord2_s {
+  vec3_t	xyz;
+  float		fogNum;
+} vaWord2_t;  // same layout in VBO
+typedef struct vaWord3_s {
+  vec3_t	normal;
+  float		reserved;
+} vaWord3_t;
+typedef struct vaWord4_s {
+  color4ub_t	color;
+} vaWord4_t;  // same layout in VBO
+
+#define VBOKEY_TYPEMASK	0x70000000
+#define VBOKEY_IDXMASK	0x0fffffff
+#define VBOKEY_VIS	0x10000000
+#define VBOKEY_MODEL	0x20000000
+#define VBOKEY_MD3	0x30000000
+#define VBOKEY_MD3TEX	0x40000000
+
+typedef struct vboInfo_s {
+	struct vboInfo_s *left, *right;
+	struct vboInfo_s *next;
+	int	key;
+	GLuint  vbo;
+	GLuint  ibo;
+	int	numIndexes;
+	int     minIndex;
+	int     maxIndex;
+	vaWord1_t	*offs1;
+	vaWord2_t	*offs2;
+	vaWord3_t	*offs3;
+	vaWord4_t	*offs4;
+	GLushort	*offsIdx;
+} vboInfo_t;
+
+// NVIDIA uses special indexes for built-in Variables,
+// these values are chosen to avoid conflicts with the
+// built-in attributes we use:
+typedef enum {
+	AL_VERTEX = 0,
+	AL_NORMAL = 1,
+	AL_UNUSED = 2,
+	AL_COLOR = 3,
+	AL_TRANSX = 4,
+	AL_TRANSY = 5,
+	AL_TRANSZ = 6,
+	AL_TIMES = 7,
+	AL_TEXCOORD = 8,
+	AL_TEXCOORD2 = 9,
+	AL_TEXCOORD3 = 10,
+	AL_TEXCOORD4 = 11,
+	AL_AMBIENTLIGHT = 12,
+	AL_DIRECTEDLIGHT = 13,
+	AL_LIGHTDIR = 14,
+	AL_CAMERAPOS = 15,
+	AL_NUMATTRIBUTES = 16
+} attribLocation_t;
+
+typedef struct GLSLshader_s {
+	GLhandleARB	handle;
+	unsigned int	hash;
+} GLSLshader_t;
+
+typedef struct GLSLprogram_s {
+	GLhandleARB	handle;
+	GLint		unifFogPlanes;
+	GLint		unifFogColors;
+	GLSLshader_t	*vertex, *geometry, *fragment;
+	unsigned int	attributes;	// bit mask
+	GLuint		QuerySum;
+} GLSLprogram_t;
+
 typedef struct shader_s {
 	char		name[MAX_QPATH];		// game path, including extension
 	int			lightmapIndex;			// for a shader to match, both name and lightmapIndex must match
@@ -376,24 +475,19 @@
 	qboolean	entityMergable;			// merge across entites optimizable (smoke, blood)
 
 	qboolean	isSky;
+	qboolean	isDepth;
 	skyParms_t	sky;
 	fogParms_t	fogParms;
 
 	float		portalRange;			// distance to fog out at
 
-	int			multitextureEnv;		// 0, GL_MODULATE, GL_ADD (FIXME: put in stage)
-
 	cullType_t	cullType;				// CT_FRONT_SIDED, CT_BACK_SIDED, or CT_TWO_SIDED
-	qboolean	polygonOffset;			// set for decals and other items that must be offset 
 	qboolean	noMipMaps;				// for console fonts, 2D elements, etc.
 	qboolean	noPicMip;				// for images that must always be full resolution
 
 	fogPass_t	fogPass;				// draw a blended pass, possibly with depth test equals
 
-	qboolean	needsNormal;			// not all shaders will need all data to be gathered
-	qboolean	needsST1;
-	qboolean	needsST2;
-	qboolean	needsColor;
+	qboolean        useVBO;
 
 	int			numDeforms;
 	deformStage_t	deforms[MAX_SHADER_DEFORMS];
@@ -409,13 +503,19 @@
   int numStates;                                    // if non-zero this is a state shader
   struct shader_s *currentShader;                   // current state if this is a state shader
   struct shader_s *parentShader;                    // current state if this is a state shader
+  struct shader_s *depthShader;			    // associated shader for the Z-pass
   int currentState;                                 // current state index for cycle purposes
   long expireTime;                                  // time in milliseconds this expires
 
   struct shader_s *remappedShader;                  // current shader this one is remapped too
 
   int shaderStates[MAX_STATES_PER_SHADER];          // index to valid shader states
+  vboInfo_t	*VBOs;
 
+  GLuint        QueryID;
+  GLuint	QueryResult;
+  GLSLprogram_t *GLSLprogram;
+
 	struct	shader_s	*next;
 } shader_t;
 
@@ -498,18 +598,22 @@
 	orientationr_t	or;
 	orientationr_t	world;
 	vec3_t		pvsOrigin;			// may be different than or.origin for portals
-	qboolean	isPortal;			// true if this view is through a portal
+	int		portalLevel;			// number of portals we're looking through
 	qboolean	isMirror;			// the portal is a mirror, invert the face culling
+	qboolean	isFirst;			// this is the first view of the scene, so glClear has to be called
+	qboolean	noShadows;			// don't compute shadows, used for portal surfaces
 	int			frameSceneNum;		// copied from tr.frameSceneNum
 	int			frameCount;			// copied from tr.frameCount
 	cplane_t	portalPlane;		// clip anything behind this if mirroring
 	int			viewportX, viewportY, viewportWidth, viewportHeight;
 	float		fovX, fovY;
 	float		projectionMatrix[16];
-	cplane_t	frustum[4];
+	cplane_t	frustum[5];
 	vec3_t		visBounds[2];
 	float		zFar;
 	stereoFrame_t	stereoFrame;
+	int		viewCluster;
+	int		frustPlanes, frustType;
 } viewParms_t;
 
 
@@ -534,17 +638,20 @@
 #ifdef RAVENMD4
 	SF_MDR,
 #endif
+	SF_IQM,
 	SF_FLARE,
 	SF_ENTITY,				// beams, rails, lightning, etc that can be determined by entity
 	SF_DISPLAY_LIST,
+	SF_MD3_TEXTURE,
 
 	SF_NUM_SURFACE_TYPES,
 	SF_MAX = 0x7fffffff			// ensures that sizeof( surfaceType_t ) == sizeof( int )
 } surfaceType_t;
 
 typedef struct drawSurf_s {
-	unsigned			sort;			// bit combination for fast compares
-	surfaceType_t		*surface;		// any of surface*_t
+	unsigned		sort;		// bit combination for fast compares
+	int			shaderIndex;
+	surfaceType_t		*surface;	// any of surface*_t
 } drawSurf_t;
 
 #define	MAX_FACE_POINTS		64
@@ -596,6 +703,7 @@
 
 	// vertexes
 	int				width, height;
+	int			vboStart;
 	float			*widthLodError;
 	float			*heightLodError;
 	drawVert_t		verts[1];		// variable sized
@@ -615,6 +723,7 @@
 	int			numPoints;
 	int			numIndices;
 	int			ofsIndices;
+	int			vboStart;
 	float		points[1][VERTEXSIZE];	// variable sized
 										// there is a variable length list of indices here also
 } srfSurfaceFace_t;
@@ -637,12 +746,56 @@
 	int				*indexes;
 
 	int				numVerts;
+	int				vboStart;
+
 	drawVert_t		*verts;
 } srfTriangles_t;
 
 
-extern	void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])(void *);
+// MD3 surface stored in a texture on the GPU
+typedef struct {
+	surfaceType_t	surfaceType;
+	image_t		*image;
+	vboInfo_t	*VBO;
+	int		framesPerRow;
+	float		scaleX, scaleY;
+} srfMD3Texture_t;
 
+// inter-quake-model
+typedef struct {
+	int		num_vertexes;
+	int		num_triangles;
+	int		num_frames;
+	int		num_surfaces;
+	int		num_joints;
+	struct srfIQModel_s	*surfaces;
+
+	float		*positions;
+	float		*texcoords;
+	float		*normals;
+	float		*tangents;
+	byte		*blendIndexes;
+	byte		*blendWeights;
+	byte		*colors;
+	int		*triangles;
+
+	int		*jointParents;
+	float		*poseMats;
+	char		*names;
+} iqmData_t;
+
+// inter-quake-model surface
+typedef struct srfIQModel_s {
+	surfaceType_t	surfaceType;
+	shader_t	*shader;
+	iqmData_t	*data;
+	int		first_vertex, num_vertexes;
+	int		first_triangle, num_triangles;
+} srfIQModel_t;
+
+
+extern	void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])(surfaceType_t *);
+
 /*
 ==============================================================================
 
@@ -663,7 +816,8 @@
 typedef struct msurface_s {
 	int					viewCount;		// if == tr.viewCount, already added
 	struct shader_s		*shader;
-	int					fogIndex;
+	short			fogIndex;
+	short			type;			// copy of data->surfaceType
 
 	surfaceType_t		*data;			// any of srf*_t
 } msurface_t;
@@ -697,6 +851,10 @@
 } bmodel_t;
 
 typedef struct {
+	vec3_t		mins, maxs;		// for bounding box culling
+} mcluster_t;
+
+typedef struct {
 	char		name[MAX_QPATH];		// ie: maps/tim_dm2.bsp
 	char		baseName[MAX_QPATH];	// ie: tim_dm2
 
@@ -733,6 +891,7 @@
 	int			numClusters;
 	int			clusterBytes;
 	const byte	*vis;			// may be passed in by CM_LoadMap to save space
+	mcluster_t      *clusters;
 
 	byte		*novis;			// clusterBytes of 0xff
 
@@ -748,8 +907,9 @@
 	MOD_MESH,
 	MOD_MD4,
 #ifdef RAVENMD4
-	MOD_MDR
+	MOD_MDR,
 #endif
+	MOD_IQM
 } modtype_t;
 
 typedef struct model_s {
@@ -758,11 +918,26 @@
 	int			index;				// model = tr.models[model->index]
 
 	int			dataSize;			// just for listing purposes
-	bmodel_t	*bmodel;			// only if type == MOD_BRUSH
-	md3Header_t	*md3[MD3_MAX_LODS];	// only if type == MOD_MESH
-	void	*md4;				// only if type == (MOD_MD4 | MOD_MDR)
-
-	int			 numLods;
+	union {
+		struct {
+			// only if type == MOD_BRUSH
+			bmodel_t	*bmodel;
+		} brush;
+		struct {
+			// only if type == MOD_MESH
+			md3Header_t	*md3[MD3_MAX_LODS];
+			srfMD3Texture_t	*md3srf[MD3_MAX_LODS];
+		} md3;
+		struct {
+			// only if type == (MOD_MD4 | MOD_MDR)
+			void	*md4;
+		} md4;
+		struct {
+			// only if type == MOD_IQM
+			iqmData_t	*iqmData;
+		} iqm;
+	}			modelData;
+	int			numLods;
 } model_t;
 
 
@@ -780,7 +955,7 @@
 extern	refimport_t		ri;
 
 #define	MAX_DRAWIMAGES			2048
-#define	MAX_LIGHTMAPS			256
+#define	MAX_LIGHTMAPS			512
 #define	MAX_SKINS				1024
 
 
@@ -804,12 +979,35 @@
 17-31 : sorted shader index
 7-16  : entity index
 2-6   : fog index
-0-1   : dlightmap index
+1     : dlightmap index
+0     : culled
 */
-#define	QSORT_SHADERNUM_SHIFT	17
-#define	QSORT_ENTITYNUM_SHIFT	7
-#define	QSORT_FOGNUM_SHIFT		2
+// sizes of the sort fields
+#define QSORT_SHADERNUM_BITS	15
+#define QSORT_ENTITYNUM_BITS	10
+#define QSORT_FOGNUM_BITS	5
+#define QSORT_DLIGHT_BITS	1
+#define QSORT_CULLED_BITS	1
 
+// derived shifts and masks
+#define QSORT_CULLED_SHIFT	0
+#define QSORT_DLIGHT_SHIFT	(QSORT_CULLED_SHIFT + QSORT_CULLED_BITS)
+#define QSORT_FOGNUM_SHIFT	(QSORT_DLIGHT_SHIFT + QSORT_DLIGHT_BITS)
+#define QSORT_ENTITYNUM_SHIFT	(QSORT_FOGNUM_SHIFT + QSORT_FOGNUM_BITS)
+#define QSORT_SHADERNUM_SHIFT	(QSORT_ENTITYNUM_SHIFT + QSORT_ENTITYNUM_BITS)
+
+#define QSORT_CULLED_MASK	((1 << QSORT_DLIGHT_SHIFT) - (1 << QSORT_CULLED_SHIFT))
+#define QSORT_DLIGHT_MASK	((1 << QSORT_FOGNUM_SHIFT) - (1 << QSORT_DLIGHT_SHIFT))
+#define QSORT_FOGNUM_MASK	((1 << QSORT_ENTITYNUM_SHIFT) - (1 << QSORT_FOGNUM_SHIFT))
+#define QSORT_ENTITYNUM_MASK	((1 << QSORT_SHADERNUM_SHIFT) - (1 << QSORT_ENTITYNUM_SHIFT))
+#define QSORT_SHADERNUM_MASK	(0xffffffff - (1 << QSORT_SHADERNUM_SHIFT) + 1)
+
+#define QSORT_CULLED(sort)	((sort & QSORT_CULLED_MASK) >> QSORT_CULLED_SHIFT)
+#define QSORT_DLIGHT(sort)	((sort & QSORT_DLIGHT_MASK) >> QSORT_DLIGHT_SHIFT)
+#define QSORT_FOGNUM(sort)	((sort & QSORT_FOGNUM_MASK) >> QSORT_FOGNUM_SHIFT)
+#define QSORT_ENTITYNUM(sort)	((sort & QSORT_ENTITYNUM_MASK) >> QSORT_ENTITYNUM_SHIFT)
+#define QSORT_SHADERNUM(sort)	((sort & QSORT_SHADERNUM_MASK) >> QSORT_SHADERNUM_SHIFT)
+
 extern	int			gl_filter_min, gl_filter_max;
 
 /*
@@ -834,14 +1032,65 @@
 
 // the renderer front end should never modify glstate_t
 typedef struct {
-	int			currenttextures[2];
-	int			currenttmu;
+	int			currenttextures[MAX_SHADER_STAGES];
+	qboolean	texEnabled[MAX_SHADER_STAGES];
 	qboolean	finishCalled;
-	int			texEnv[2];
+	int			texEnv[MAX_SHADER_STAGES];
 	int			faceCulling;
 	unsigned long	glStateBits;
+	GLuint		currentVBO, currentIBO;
+	GLSLprogram_t	*currentProgram;
+
+	struct {
+		enum {
+			attrIsUndefined = 0,
+			attrIsPointer,
+			attrIsValue
+		} attrStatus;
+		vec4_t	currentValues;
+		GLuint	vbo;
+		void	*ptr;
+	} glAttribute[ AL_NUMATTRIBUTES ];
 } glstate_t;
 
+// this struct holds all GL state data for a single render call (glDraw*)
+typedef struct {
+	enum {
+		RA_UNSPEC,
+		RA_POINTER,
+		RA_VEC
+	} attrType;
+	GLuint	VBO;
+	GLint	size;
+	GLenum	type;
+	GLsizei	stride;
+	void	*ptr;
+	vec4_t	vec;
+} glRenderAttrib_t;
+typedef struct {
+	unsigned long		stateBits;
+	int			faceCulling;
+	GLSLprogram_t		*program;
+	int			numImages;
+	image_t			*image[MAX_SHADER_STAGES];
+	glRenderAttrib_t	attrib[AL_NUMATTRIBUTES];
+} glRenderState_t;
+#define InitState( st ) Com_Memset( (st), 0, sizeof(glRenderState_t) )
+#define SetAttrPointer( st, ind, vbo, s, t, str, p ) \
+	(st)->attrib[ind].attrType = RA_POINTER;     \
+	(st)->attrib[ind].VBO = (vbo);               \
+	(st)->attrib[ind].size = s;                  \
+	(st)->attrib[ind].type = t;                  \
+	(st)->attrib[ind].stride = str;              \
+	(st)->attrib[ind].ptr = (p)
+#define SetAttrVec4f( st, ind, x, y, z, w )      \
+	(st)->attrib[ind].attrType = RA_VEC;     \
+	(st)->attrib[ind].vec[0] = (x);          \
+	(st)->attrib[ind].vec[1] = (y);          \
+	(st)->attrib[ind].vec[2] = (z);          \
+	(st)->attrib[ind].vec[3] = (w)
+#define SetAttrUnspec( st, ind )                 \
+	(st)->attrib[ind].attrType = RA_UNSPEC
 
 typedef struct {
 	int		c_surfaces, c_shaders, c_vertexes, c_indexes, c_totalIndexes;
@@ -873,6 +1122,14 @@
 	byte		color2D[4];
 	qboolean	vertexes2D;		// shader needs to be finished
 	trRefEntity_t	entity2D;	// currentEntity will point at this when doing 2D rendering
+
+	vboInfo_t	worldVBO;	// VBO containing all world vertexes
+	vboInfo_t	streamVBO;	// VBO for fast streaming of vertexes
+	vboInfo_t	*vboReserve;
+	int		vboReserveCount;
+
+	GLSLprogram_t	*normalProgram;  // GLSL program to render normals
+	GLSLprogram_t	*normalProgramMD3;  // GLSL program to render normals
 } backEndState_t;
 
 /*
@@ -900,6 +1157,8 @@
 	world_t					*world;
 
 	const byte				*externalVisData;	// from RE_SetWorldVisData, shared with CM_Load
+	mcluster_t				*clusters;
+	int					visCluster;
 
 	image_t					*defaultImage;
 	image_t					*scratchImage[32];
@@ -911,12 +1170,18 @@
 
 	shader_t				*defaultShader;
 	shader_t				*shadowShader;
+	shader_t				*preparePortalShader;
+	shader_t				*finalisePortalShader;
 	shader_t				*projectionShadowShader;
 
 	shader_t				*flareShader;
 	shader_t				*sunShader;
+	shader_t				*fogShader;
+	shader_t				*defaultMD3Shader;
 
 	int						numLightmaps;
+	qboolean				hasDeluxemaps;
+	float					deluxeOffset;
 	image_t					*lightmaps[MAX_LIGHTMAPS];
 
 	trRefEntity_t			*currentEntity;
@@ -935,8 +1200,6 @@
 
 	trRefdef_t				refdef;
 
-	int						viewCluster;
-
 	vec3_t					sunLight;			// from the sky shader for this level
 	vec3_t					sunDirection;
 
@@ -961,6 +1224,10 @@
 	int						numShaders;
 	shader_t				*shaders[MAX_SHADERS];
 	shader_t				*sortedShaders[MAX_SHADERS];
+	int					numGLSLshaders;
+	GLSLshader_t				*GLSLshaders[2 * MAX_SHADERS];
+	int					numGLSLprograms;
+	GLSLprogram_t				*GLSLprograms[MAX_SHADERS];
 
 	int						numSkins;
 	skin_t					*skins[MAX_SKINS];
@@ -973,8 +1240,25 @@
 	float					fogTable[FOG_TABLE_SIZE];
 } trGlobals_t;
 
+// globals that are filled in InitOpenGL and should not be cleared in R_Init
+typedef struct {
+	qboolean	floatTextures;
+	qboolean	pixelBufferObjects;
+	GLint	maxTextureUnits;
+	GLint	maxTextureImageUnits;
+	GLint	maxVertexTextureImageUnits;
+	GLuint	timerQuery;
+	GLuint		PBO;
+	GLuint64EXT	timerResult;
+	qboolean	timerRunning;
+	int	portalBits, shadowBits;
+	GLuint	portalMask, shadowMask, portalLevels;
+} glGlobals_t;
+
+
 extern backEndState_t	backEnd;
 extern trGlobals_t	tr;
+extern glGlobals_t      glGlobals;
 extern glconfig_t	glConfig;		// outside of TR since it shouldn't be cleared during ref re-init
 extern glstate_t	glState;		// outside of TR since it shouldn't be cleared during ref re-init
 
@@ -982,6 +1266,7 @@
 //
 // cvars
 //
+extern cvar_t	*r_scratchmegs;
 extern cvar_t	*r_flareSize;
 extern cvar_t	*r_flareFade;
 // coefficient for the flare intensity falloff function.
@@ -1004,22 +1289,17 @@
 extern cvar_t	*r_depthbits;			// number of desired depth bits
 extern cvar_t	*r_colorbits;			// number of desired color bits, only relevant for fullscreen
 extern cvar_t	*r_texturebits;			// number of desired texture bits
+						// 0 = use framebuffer depth
+						// 16 = use 16-bit textures
+						// 32 = use 32-bit textures
+						// all else = error
 extern cvar_t	*r_ext_multisample;
-										// 0 = use framebuffer depth
-										// 16 = use 16-bit textures
-										// 32 = use 32-bit textures
-										// all else = error
 
 extern cvar_t	*r_measureOverdraw;		// enables stencil buffer overdraw measurement
 
 extern cvar_t	*r_lodbias;				// push/pull LOD transitions
 extern cvar_t	*r_lodscale;
 
-extern cvar_t	*r_primitives;			// "0" = based on compiled vertex array existance
-										// "1" = glDrawElemet tristrips
-										// "2" = glDrawElements triangles
-										// "-1" = no drawing
-
 extern cvar_t	*r_inGameVideo;				// controls whether in game video should be draw
 extern cvar_t	*r_fastsky;				// controls whether sky should be cleared or drawn
 extern cvar_t	*r_drawSun;				// controls drawing of sun quad
@@ -1054,6 +1334,19 @@
 
 extern cvar_t	*r_ext_texture_filter_anisotropic;
 extern cvar_t	*r_ext_max_anisotropy;
+extern cvar_t	*r_ext_texture_compression;
+extern cvar_t   *r_ext_vertex_buffer_object;
+extern cvar_t   *r_ext_pixel_buffer_object;
+extern cvar_t   *r_ext_vertex_shader;
+extern cvar_t   *r_ext_geometry_shader;
+extern cvar_t   *r_ext_framebuffer_object;
+extern cvar_t	*r_ext_occlusion_query;
+extern cvar_t	*r_ext_timer_query;
+extern cvar_t	*r_ext_instanced_arrays;
+extern cvar_t   *r_ext_texture_float;
+extern cvar_t	*r_ext_texture3D;
+extern cvar_t	*r_ext_separate_stencil;
+extern cvar_t	*r_ext_debug_output;
 
 extern	cvar_t	*r_nobind;						// turns off binding to appropriate textures
 extern	cvar_t	*r_singleShader;				// make most world faces use default shader
@@ -1117,6 +1410,12 @@
 
 extern	cvar_t	*r_GLlibCoolDownMsec;
 
+extern	cvar_t	*r_flush;
+extern	cvar_t	*r_VBOminSize;
+extern	cvar_t	*r_depthPass;
+extern	cvar_t	*r_perPixelLighting;
+extern	cvar_t	*r_parallax;
+
 //====================================================================
 
 float R_NoiseGet4f( float x, float y, float z, float t );
@@ -1134,12 +1433,9 @@
 
 void R_AddPolygonSurfaces( void );
 
-void R_DecomposeSort( unsigned sort, int *entityNum, shader_t **shader, 
-					 int *fogNum, int *dlightMap );
+void R_AddDrawSurf( surfaceType_t *surface, shader_t *shader, int fogIndex, int dlightMap, qboolean culled );
 
-void R_AddDrawSurf( surfaceType_t *surface, shader_t *shader, int fogIndex, int dlightMap );
 
-
 #define	CULL_IN		0		// completely unclipped
 #define	CULL_CLIP	1		// clipped by one or more planes
 #define	CULL_OUT	2		// completely outside the clipping planes
@@ -1155,15 +1451,47 @@
 /*
 ** GL wrapper/helper functions
 */
-void	GL_Bind( image_t *image );
+void	GL_BindTexture( GLint texnum );
+void	GL_UnbindAllTextures( void );
 void	GL_SetDefaultState (void);
-void	GL_SelectTexture( int unit );
 void	GL_TextureMode( const char *string );
 void	GL_CheckErrors( void );
-void	GL_State( unsigned long stateVector );
-void	GL_TexEnv( int env );
-void	GL_Cull( int cullType );
+void	GL_CheckDebugLog( void );
+void	GL_VBO( GLuint vbo );
+void	GL_IBO( GLuint ibo );
 
+void	RB_InitScratchMemory( void );
+void	*RB_AllocScratch( size_t amount );
+void 	RB_FreeScratch( void *ptr );
+
+GLSLshader_t	*RB_CompileShader( GLenum type, const char **code, int parts );
+GLSLprogram_t	*RB_CompileProgram( const char *name,
+				    const char **VScode, int VSparts,
+				    const char **FScode, int FSparts,
+				    unsigned int attributes );
+GLSLprogram_t	*RB_CompileGSProgram( const char *name,
+				      const char **VScode, int VSparts,
+				      const char **GScode, int GSparts,
+				      int nVerticesOut, int inType, int outType,
+				      const char **FScode, int FSparts,
+				      unsigned int attributes );
+void	GL_Program( GLSLprogram_t *program );
+void	GL_TexEnv( int tmu, int env );
+
+#define QUERY_RUNNING_BIT 0x80000000
+#define QUERY_MASK        0x7fffffff
+#define QUERY_RESULT(q)   (*(q) & QUERY_MASK)
+
+void GL_StartQuery( GLuint query, GLuint *result );
+void GL_EndQuery( GLuint query, GLuint *result );
+void GL_GetQuery( GLuint query, GLuint *result );
+
+void	GL_DrawElements( glRenderState_t *state,
+			 int numIndexes, GLuint IBO, const void *indexes,
+			 GLuint start, GLuint end, GLuint max );
+void	GL_DrawArrays( glRenderState_t *state,
+		       GLenum mode, GLint first, GLuint count );
+
 #define GLS_SRCBLEND_ZERO						0x00000001
 #define GLS_SRCBLEND_ONE						0x00000002
 #define GLS_SRCBLEND_DST_COLOR					0x00000003
@@ -1186,12 +1514,22 @@
 #define		GLS_DSTBLEND_BITS					0x000000f0
 
 #define GLS_DEPTHMASK_TRUE						0x00000100
+#define GLS_COLORMASK_FALSE						0x00000200
+#define GLS_POLYGON_OFFSET						0x00000400
 
 #define GLS_POLYMODE_LINE						0x00001000
 
-#define GLS_DEPTHTEST_DISABLE					0x00010000
+#define GLS_DEPTHTEST_DISABLE						0x00010000
 #define GLS_DEPTHFUNC_EQUAL						0x00020000
+#define GLS_DEPTHFUNC_ALWAYS						0x00040000
+#define GLS_DEPTHFUNC_BITS						0x00060000
 
+#define GLS_DEPTHRANGE_0_TO_1						0x00000000
+#define GLS_DEPTHRANGE_0_TO_0						0x00100000
+#define GLS_DEPTHRANGE_1_TO_1						0x00200000
+#define GLS_DEPTHRANGE_0_TO_03						0x00300000
+#define GLS_DEPTHRANGE_BITS						0x00300000
+
 #define GLS_ATEST_GT_0							0x10000000
 #define GLS_ATEST_LT_80							0x20000000
 #define GLS_ATEST_GE_80							0x40000000
@@ -1216,10 +1554,9 @@
 
 void    	R_Init( void );
 image_t		*R_FindImageFile( const char *name, qboolean mipmap, qboolean allowPicmip, int glWrapClampMode );
+image_t		*R_FindHeightMapFile( const char *name, qboolean mipmap, int glWrapClampMode );
+image_t		*R_CombineImages( int num, image_t **images );
 
-image_t		*R_CreateImage( const char *name, const byte *pic, int width, int height, qboolean mipmap,
-            qboolean allowPicmip, int wrapClampMode );
-
 void		R_SetColorMappings( void );
 void		R_GammaCorrect( byte *buffer, int bufSize );
 
@@ -1253,6 +1590,7 @@
 shader_t	*R_GetShaderByHandle( qhandle_t hShader );
 shader_t	*R_GetShaderByState( int index, long *cycleTime );
 shader_t *R_FindShaderByName( const char *name );
+void		R_SortShaders( void );
 void		R_InitShaders( void );
 void		R_ShaderList_f( void );
 void    R_RemapShader(const char *oldShader, const char *newShader, const char *timeOffset);
@@ -1273,6 +1611,7 @@
 void		*GLimp_RendererSleep( void );
 void		GLimp_FrontEndSleep( void );
 void		GLimp_WakeRenderer( void *data );
+qboolean	GLimp_IsSMPActive( void );
 
 void		GLimp_LogComment( char *comment );
 
@@ -1291,37 +1630,43 @@
 
 ====================================================================
 */
-typedef byte color4ub_t[4];
 
 typedef struct stageVars
 {
-	color4ub_t	colors[SHADER_MAX_VERTEXES];
-	vec2_t		texcoords[NUM_TEXTURE_BUNDLES][SHADER_MAX_VERTEXES];
+	color4ub_t	*colors;
+	vec2_t		*texcoords[NUM_TEXTURE_BUNDLES];
 } stageVars_t;
 
+typedef union indexPtr_u {
+	GLushort	*p16;
+	GLuint		*p32;
+} indexPtr_t;
 
 typedef struct shaderCommands_s 
 {
-	glIndex_t	indexes[SHADER_MAX_INDEXES] ALIGN(16);
-	vec4_t		xyz[SHADER_MAX_VERTEXES] ALIGN(16);
-	vec4_t		normal[SHADER_MAX_VERTEXES] ALIGN(16);
-	vec2_t		texCoords[SHADER_MAX_VERTEXES][2] ALIGN(16);
-	color4ub_t	vertexColors[SHADER_MAX_VERTEXES] ALIGN(16);
-	int			vertexDlightBits[SHADER_MAX_VERTEXES] ALIGN(16);
+	indexPtr_t	indexPtr;
+	vaWord1_t	*vertexPtr1;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
+	vaWord4_t	*vertexPtr4;
+	size_t		indexInc;
+	int		numIndexes;
+	int		numVertexes;
+	int		minIndex, maxIndex;
+	byte		*vertexBuffer, *vertexBufferEnd;
 
-	stageVars_t	svars ALIGN(16);
+	int		dlightBits;	// or together of all vertexDlightBits
+	stageVars_t	svars;
 
-	color4ub_t	constantColor255[SHADER_MAX_VERTEXES] ALIGN(16);
+	vboInfo_t	*streaming;
+	vboInfo_t	*firstVBO;
+	image_t		*dataTexture;
+	float		frameOffs, oldFrameOffs;
 
 	shader_t	*shader;
-  float   shaderTime;
+	float			shaderTime;
 	int			fogNum;
 
-	int			dlightBits;	// or together of all vertexDlightBits
-
-	int			numIndexes;
-	int			numVertexes;
-
 	// info extracted from current shader
 	int			numPasses;
 	void		(*currentStageIteratorFunc)( void );
@@ -1330,15 +1675,23 @@
 
 extern	shaderCommands_t	tess;
 
+void RB_SetGL2D( glRenderState_t *state );
 void RB_BeginSurface(shader_t *shader, int fogNum );
 void RB_EndSurface(void);
-void RB_CheckOverflow( int verts, int indexes );
-#define RB_CHECKOVERFLOW(v,i) if (tess.numVertexes + (v) >= SHADER_MAX_VERTEXES || tess.numIndexes + (i) >= SHADER_MAX_INDEXES ) {RB_CheckOverflow(v,i);}
+void RB_ClearVertexBuffer( void );
+void RB_SetupVertexBuffer(shader_t *shader, vboInfo_t *vbo);
+void RB_FlushVertexBuffer( void );
+vboInfo_t *RB_CreateShaderVBO( vboInfo_t **root, int VBOkey );
+void RB_CopyVBO( vboInfo_t **root, int VBOkeyNew, int VBOkeyOld );
 
 void RB_StageIteratorGeneric( void );
 void RB_StageIteratorSky( void );
 void RB_StageIteratorVertexLitTexture( void );
 void RB_StageIteratorLightmappedMultitexture( void );
+void RB_StageIteratorGLSL( void );
+void RB_StageIteratorPreparePortal( void );
+void RB_StageIteratorFinalisePortal( void );
+void RB_LightSurface( void );
 
 void RB_AddQuadStamp( vec3_t origin, vec3_t left, vec3_t up, byte *color );
 void RB_AddQuadStampExt( vec3_t origin, vec3_t left, vec3_t up, byte *color, float s1, float t1, float s2, float t2 );
@@ -1489,11 +1842,17 @@
 
 // void R_MakeAnimModel( model_t *model );      haven't seen this one really, so not needed I guess.
 void R_AddAnimSurfaces( trRefEntity_t *ent );
-void RB_SurfaceAnim( md4Surface_t *surfType );
+void RB_SurfaceAnim( surfaceType_t *surfType );
 #ifdef RAVENMD4
 void R_MDRAddAnimSurfaces( trRefEntity_t *ent );
-void RB_MDRSurfaceAnim( md4Surface_t *surface );
+void RB_MDRSurfaceAnim( surfaceType_t *surface );
 #endif
+qboolean R_LoadIQM (model_t *mod, void *buffer, int filesize, const char *name );
+void R_AddIQMSurfaces( trRefEntity_t *ent );
+void RB_IQMSurfaceAnim( surfaceType_t *surface );
+int R_IQMLerpTag( orientation_t *tag, iqmData_t *data,
+		  int startFrame, int endFrame, 
+		  float frac, const char *tagName );
 
 /*
 =============================================================
@@ -1502,13 +1861,24 @@
 
 =============================================================
 */
+// image loaders may return several mipmap levels
+typedef struct {
+	GLenum	format;
+	int	numMipmaps;
+	byte	*data[32];
+	int	size[32];
+} texImage_t;
 
-void R_LoadBMP( const char *name, byte **pic, int *width, int *height );
-void R_LoadJPG( const char *name, byte **pic, int *width, int *height );
-void R_LoadPCX( const char *name, byte **pic, int *width, int *height );
-void R_LoadPNG( const char *name, byte **pic, int *width, int *height );
-void R_LoadTGA( const char *name, byte **pic, int *width, int *height );
+void R_LoadBMP( const char *name, texImage_t *pic, int *width, int *height );
+void R_LoadJPG( const char *name, texImage_t *pic, int *width, int *height );
+void R_LoadPCX( const char *name, texImage_t *pic, int *width, int *height );
+void R_LoadPNG( const char *name, texImage_t *pic, int *width, int *height );
+void R_LoadTGA( const char *name, texImage_t *pic, int *width, int *height );
+void R_LoadDDS( const char *name, texImage_t *pic, int *width, int *height );
 
+image_t	*R_CreateImage( const char *name, texImage_t *pic, int width, int height, qboolean mipmap,
+			qboolean allowPicmip, int wrapClampMode );
+
 /*
 =============================================================
 =============================================================
@@ -1519,26 +1889,25 @@
 
 void	RB_DeformTessGeometry( void );
 
-void	RB_CalcEnvironmentTexCoords( float *dstTexCoords );
-void	RB_CalcFogTexCoords( float *dstTexCoords );
-void	RB_CalcScrollTexCoords( const float scroll[2], float *dstTexCoords );
-void	RB_CalcRotateTexCoords( float rotSpeed, float *dstTexCoords );
-void	RB_CalcScaleTexCoords( const float scale[2], float *dstTexCoords );
-void	RB_CalcTurbulentTexCoords( const waveForm_t *wf, float *dstTexCoords );
-void	RB_CalcTransformTexCoords( const texModInfo_t *tmi, float *dstTexCoords );
-void	RB_CalcModulateColorsByFog( unsigned char *dstColors );
-void	RB_CalcModulateAlphasByFog( unsigned char *dstColors );
-void	RB_CalcModulateRGBAsByFog( unsigned char *dstColors );
-void	RB_CalcWaveAlpha( const waveForm_t *wf, unsigned char *dstColors );
-void	RB_CalcWaveColor( const waveForm_t *wf, unsigned char *dstColors );
-void	RB_CalcAlphaFromEntity( unsigned char *dstColors );
-void	RB_CalcAlphaFromOneMinusEntity( unsigned char *dstColors );
-void	RB_CalcStretchTexCoords( const waveForm_t *wf, float *texCoords );
-void	RB_CalcColorFromEntity( unsigned char *dstColors );
-void	RB_CalcColorFromOneMinusEntity( unsigned char *dstColors );
-void	RB_CalcSpecularAlpha( unsigned char *alphas );
-void	RB_CalcDiffuseColor( unsigned char *colors );
-
+void	RB_CalcEnvironmentTexCoords( vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcFogTexCoords( vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcScrollTexCoords( const float scroll[2], vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcRotateTexCoords( float rotSpeed, vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcScaleTexCoords( const float scale[2], vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcTurbulentTexCoords( const waveForm_t *wf, vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcTransformTexCoords( const texModInfo_t *tmi, vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcModulateColorsByFog( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcModulateAlphasByFog( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcModulateRGBAsByFog( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcWaveAlpha( const waveForm_t *wf, color4ub_t *dstColors, int numVertexes );
+void	RB_CalcWaveColor( const waveForm_t *wf, color4ub_t *dstColors, int numVertexes );
+void	RB_CalcAlphaFromEntity( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcAlphaFromOneMinusEntity( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcStretchTexCoords( const waveForm_t *wf, vec2_t *texCoords, int numVertexes );
+void	RB_CalcColorFromEntity( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcColorFromOneMinusEntity( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcSpecularAlpha( color4ub_t *alphas, int numVertexes );
+void	RB_CalcDiffuseColor( color4ub_t *colors, int numVertexes );
 /*
 =============================================================
 
@@ -1603,6 +1972,15 @@
 
 typedef struct {
 	int		commandId;
+	int	client;
+	float	x, y;
+	float	w, h;
+	float	s1, t1;
+	float	s2, t2;
+} stretchRawCommand_t;
+
+typedef struct {
+	int		commandId;
 	trRefdef_t	refdef;
 	viewParms_t	viewParms;
 	drawSurf_t *drawSurfs;
@@ -1644,6 +2022,7 @@
 	RC_END_OF_LIST,
 	RC_SET_COLOR,
 	RC_STRETCH_PIC,
+	RC_STRETCH_RAW,
 	RC_DRAW_SURFS,
 	RC_DRAW_BUFFER,
 	RC_SWAP_BUFFERS,
@@ -1698,7 +2077,7 @@
 void RE_StretchPic ( float x, float y, float w, float h, 
 					  float s1, float t1, float s2, float t2, qhandle_t hShader );
 void RE_BeginFrame( stereoFrame_t stereoFrame );
-void RE_EndFrame( int *frontEndMsec, int *backEndMsec );
+void RE_EndFrame( int *frontEndMsec, int *backEndMsec, int *GLMsec );
 void SaveJPG(char * filename, int quality, int image_width, int image_height, unsigned char *image_buffer);
 int SaveJPGToBuffer( byte *buffer, int quality,
 		int image_width, int image_height,
Index: src/renderer/tr_model.c
===================================================================
--- src/renderer/tr_model.c	(Revision 2062)
+++ src/renderer/tr_model.c	(Arbeitskopie)
@@ -101,7 +101,7 @@
 	}
 
 	if ( strlen( name ) >= MAX_QPATH ) {
-		Com_Printf( "Model name exceeds MAX_QPATH\n" );
+		ri.Printf( PRINT_WARNING, "Model name exceeds MAX_QPATH\n" );
 		return 0;
 	}
 
@@ -180,6 +180,32 @@
 	}
 #endif
 
+	if(!Q_stricmp(fext, "iqm"))
+	{
+		int filesize;
+		
+		filesize = ri.FS_ReadFile(name, (void **) &buf.v);
+		if(!buf.u)
+		{
+			ri.Printf (PRINT_WARNING,"RE_RegisterModel: couldn't load %s\n", name);
+			mod->type = MOD_BAD;
+			return 0;
+		}
+		
+		loaded = R_LoadIQM(mod, buf.u, filesize, name);
+
+		ri.FS_FreeFile (buf.v);
+		
+		if(!loaded)
+		{
+			ri.Printf(PRINT_WARNING,"RE_RegisterModel: couldn't load iqm file %s\n", name);
+			mod->type = MOD_BAD;
+			return 0;
+		}
+		
+		return mod->index;
+	}
+
 	fext = defex;
 
 	for ( lod = MD3_MAX_LODS - 1 ; lod >= 0 ; lod-- ) {
@@ -232,7 +258,7 @@
 		// loaded, in case the user changes r_lodbias on the fly
 		for ( lod-- ; lod >= 0 ; lod-- ) {
 			mod->numLods++;
-			mod->md3[lod] = mod->md3[lod+1];
+			mod->modelData.md3.md3[lod] = mod->modelData.md3.md3[lod+1];
 		}
 
 		return mod->index;
@@ -257,9 +283,9 @@
 =================
 */
 static qboolean R_LoadMD3 (model_t *mod, int lod, void *buffer, const char *mod_name ) {
-	int					i, j;
+	int			i, j, k;
 	md3Header_t			*pinmodel;
-    md3Frame_t			*frame;
+	md3Frame_t			*frame;
 	md3Surface_t		*surf;
 	md3Shader_t			*shader;
 	md3Triangle_t		*tri;
@@ -268,6 +294,8 @@
 	md3Tag_t			*tag;
 	int					version;
 	int					size;
+	int 		numFrames;
+	trRefEntity_t	thisEntity, *oldEntity;
 
 	pinmodel = (md3Header_t *)buffer;
 
@@ -281,72 +309,64 @@
 	mod->type = MOD_MESH;
 	size = LittleLong(pinmodel->ofsEnd);
 	mod->dataSize += size;
-	mod->md3[lod] = ri.Hunk_Alloc( size, h_low );
+	mod->modelData.md3.md3[lod] = ri.Hunk_Alloc( size, h_low );
+	mod->modelData.md3.md3srf[lod] = NULL;
 
-	Com_Memcpy (mod->md3[lod], buffer, LittleLong(pinmodel->ofsEnd) );
+	Com_Memcpy (mod->modelData.md3.md3[lod], buffer, size );
 
-    LL(mod->md3[lod]->ident);
-    LL(mod->md3[lod]->version);
-    LL(mod->md3[lod]->numFrames);
-    LL(mod->md3[lod]->numTags);
-    LL(mod->md3[lod]->numSurfaces);
-    LL(mod->md3[lod]->ofsFrames);
-    LL(mod->md3[lod]->ofsTags);
-    LL(mod->md3[lod]->ofsSurfaces);
-    LL(mod->md3[lod]->ofsEnd);
+	LL(mod->modelData.md3.md3[lod]->ident);
+	LL(mod->modelData.md3.md3[lod]->version);
+	LL(mod->modelData.md3.md3[lod]->numFrames);
+	LL(mod->modelData.md3.md3[lod]->numTags);
+	LL(mod->modelData.md3.md3[lod]->numSurfaces);
+	LL(mod->modelData.md3.md3[lod]->ofsFrames);
+	LL(mod->modelData.md3.md3[lod]->ofsTags);
+	LL(mod->modelData.md3.md3[lod]->ofsSurfaces);
+	LL(mod->modelData.md3.md3[lod]->ofsEnd);
 
-	if ( mod->md3[lod]->numFrames < 1 ) {
+	numFrames = mod->modelData.md3.md3[lod]->numFrames;
+	if ( numFrames < 1 ) {
 		ri.Printf( PRINT_WARNING, "R_LoadMD3: %s has no frames\n", mod_name );
 		return qfalse;
 	}
     
 	// swap all the frames
-    frame = (md3Frame_t *) ( (byte *)mod->md3[lod] + mod->md3[lod]->ofsFrames );
-    for ( i = 0 ; i < mod->md3[lod]->numFrames ; i++, frame++) {
-    	frame->radius = LittleFloat( frame->radius );
-        for ( j = 0 ; j < 3 ; j++ ) {
-            frame->bounds[0][j] = LittleFloat( frame->bounds[0][j] );
-            frame->bounds[1][j] = LittleFloat( frame->bounds[1][j] );
-	    	frame->localOrigin[j] = LittleFloat( frame->localOrigin[j] );
-        }
+	frame = (md3Frame_t *) ( (byte *)mod->modelData.md3.md3[lod] + mod->modelData.md3.md3[lod]->ofsFrames );
+	for ( i = 0 ; i < numFrames ; i++, frame++) {
+		frame->radius = LittleFloat( frame->radius );
+		for ( j = 0 ; j < 3 ; j++ ) {
+			frame->bounds[0][j] = LittleFloat( frame->bounds[0][j] );
+			frame->bounds[1][j] = LittleFloat( frame->bounds[1][j] );
+			frame->localOrigin[j] = LittleFloat( frame->localOrigin[j] );
+		}
 	}
 
 	// swap all the tags
-    tag = (md3Tag_t *) ( (byte *)mod->md3[lod] + mod->md3[lod]->ofsTags );
-    for ( i = 0 ; i < mod->md3[lod]->numTags * mod->md3[lod]->numFrames ; i++, tag++) {
-        for ( j = 0 ; j < 3 ; j++ ) {
+	tag = (md3Tag_t *) ( (byte *)mod->modelData.md3.md3[lod] + mod->modelData.md3.md3[lod]->ofsTags );
+	for ( i = 0 ; i < mod->modelData.md3.md3[lod]->numTags * numFrames ; i++, tag++) {
+		for ( j = 0 ; j < 3 ; j++ ) {
 			tag->origin[j] = LittleFloat( tag->origin[j] );
 			tag->axis[0][j] = LittleFloat( tag->axis[0][j] );
 			tag->axis[1][j] = LittleFloat( tag->axis[1][j] );
 			tag->axis[2][j] = LittleFloat( tag->axis[2][j] );
-        }
+		}
 	}
 
 	// swap all the surfaces
-	surf = (md3Surface_t *) ( (byte *)mod->md3[lod] + mod->md3[lod]->ofsSurfaces );
-	for ( i = 0 ; i < mod->md3[lod]->numSurfaces ; i++) {
+	surf = (md3Surface_t *) ( (byte *)mod->modelData.md3.md3[lod] + mod->modelData.md3.md3[lod]->ofsSurfaces );
+	for ( i = 0 ; i < mod->modelData.md3.md3[lod]->numSurfaces ; i++) {
+		LL(surf->ident);
+		LL(surf->flags);
+		LL(surf->numFrames);
+		LL(surf->numShaders);
+		LL(surf->numTriangles);
+		LL(surf->ofsTriangles);
+		LL(surf->numVerts);
+		LL(surf->ofsShaders);
+		LL(surf->ofsSt);
+		LL(surf->ofsXyzNormals);
+		LL(surf->ofsEnd);
 
-        LL(surf->ident);
-        LL(surf->flags);
-        LL(surf->numFrames);
-        LL(surf->numShaders);
-        LL(surf->numTriangles);
-        LL(surf->ofsTriangles);
-        LL(surf->numVerts);
-        LL(surf->ofsShaders);
-        LL(surf->ofsSt);
-        LL(surf->ofsXyzNormals);
-        LL(surf->ofsEnd);
-		
-		if ( surf->numVerts > SHADER_MAX_VERTEXES ) {
-			ri.Error (ERR_DROP, "R_LoadMD3: %s has more than %i verts on a surface (%i)",
-				mod_name, SHADER_MAX_VERTEXES, surf->numVerts );
-		}
-		if ( surf->numTriangles*3 > SHADER_MAX_INDEXES ) {
-			ri.Error (ERR_DROP, "R_LoadMD3: %s has more than %i triangles on a surface (%i)",
-				mod_name, SHADER_MAX_INDEXES / 3, surf->numTriangles );
-		}
-	
 		// change to surface identifier
 		surf->ident = SF_MD3;
 
@@ -360,19 +380,6 @@
 			surf->name[j-2] = 0;
 		}
 
-        // register the shaders
-        shader = (md3Shader_t *) ( (byte *)surf + surf->ofsShaders );
-        for ( j = 0 ; j < surf->numShaders ; j++, shader++ ) {
-            shader_t	*sh;
-
-            sh = R_FindShader( shader->name, LIGHTMAP_NONE, qtrue );
-			if ( sh->defaultShader ) {
-				shader->shaderIndex = 0;
-			} else {
-				shader->shaderIndex = sh->index;
-			}
-        }
-
 		// swap all the triangles
 		tri = (md3Triangle_t *) ( (byte *)surf + surf->ofsTriangles );
 		for ( j = 0 ; j < surf->numTriangles ; j++, tri++ ) {
@@ -380,30 +387,251 @@
 			LL(tri->indexes[1]);
 			LL(tri->indexes[2]);
 		}
-
+		
 		// swap all the ST
-        st = (md3St_t *) ( (byte *)surf + surf->ofsSt );
-        for ( j = 0 ; j < surf->numVerts ; j++, st++ ) {
-            st->st[0] = LittleFloat( st->st[0] );
-            st->st[1] = LittleFloat( st->st[1] );
-        }
-
+		st = (md3St_t *) ( (byte *)surf + surf->ofsSt );
+		for ( j = 0 ; j < surf->numVerts ; j++, st++ ) {
+			st->st[0] = LittleFloat( st->st[0] );
+			st->st[1] = LittleFloat( st->st[1] );
+		}
+		
 		// swap all the XyzNormals
-        xyz = (md3XyzNormal_t *) ( (byte *)surf + surf->ofsXyzNormals );
-        for ( j = 0 ; j < surf->numVerts * surf->numFrames ; j++, xyz++ ) 
+		xyz = (md3XyzNormal_t *) ( (byte *)surf + surf->ofsXyzNormals );
+		for ( j = 0 ; j < surf->numVerts * surf->numFrames ; j++, xyz++ ) 
 		{
-            xyz->xyz[0] = LittleShort( xyz->xyz[0] );
-            xyz->xyz[1] = LittleShort( xyz->xyz[1] );
-            xyz->xyz[2] = LittleShort( xyz->xyz[2] );
+			xyz->xyz[0] = LittleShort( xyz->xyz[0] );
+			xyz->xyz[1] = LittleShort( xyz->xyz[1] );
+			xyz->xyz[2] = LittleShort( xyz->xyz[2] );
+			
+			xyz->normal = LittleShort( xyz->normal );
+		}
+		surf = (md3Surface_t *)( (byte *)surf + surf->ofsEnd );
+	}
+	
+	// register shaders and create VBOs
+	surf = (md3Surface_t *) ( (byte *)mod->modelData.md3.md3[lod] + mod->modelData.md3.md3[lod]->ofsSurfaces );
+	for ( i = 0 ; i < mod->modelData.md3.md3[lod]->numSurfaces ; i++) {
+		int shadertype = LIGHTMAP_NONE;
 
-            xyz->normal = LittleShort( xyz->normal );
-        }
+		shader = (md3Shader_t *) ( (byte *)surf + surf->ofsShaders );
 
+		if( qglCreateShader && qglGenBuffersARB && glGlobals.floatTextures ) {
+			if( !mod->modelData.md3.md3srf[lod] )
+				mod->modelData.md3.md3srf[lod] = ri.Hunk_Alloc( mod->modelData.md3.md3[lod]->numSurfaces * sizeof(srfMD3Texture_t), h_low );
+			
+			// the vertex coords and normals for all frames are
+			// put into a texture, and one VBO/IBO is
+			// created for the indexes and texture coords for
+			// the first frame.
+			int frameW = 1;
+			int frameH = 1;
+			int texW = 1;
+			int texH = 1;
+			
+			while( frameW * frameH < surf->numVerts ) {
+				frameH *= 2;
+				if( frameW * frameH >= surf->numVerts )
+					break;
+				frameW *= 2;
+			}
+			while( texW * texH < numFrames ) {
+				texW *= 2;
+				if( texW * texH >= numFrames )
+					break;
+				texH *= 2;
+			}
 
+			mod->modelData.md3.md3srf[lod][i].surfaceType = SF_MD3_TEXTURE;
+			mod->modelData.md3.md3srf[lod][i].framesPerRow = texW;
+			mod->modelData.md3.md3srf[lod][i].scaleX = 1.0f / texW;
+			mod->modelData.md3.md3srf[lod][i].scaleY = 1024.0f / texH;
+			RB_CreateShaderVBO( &mod->modelData.md3.md3srf[lod][i].VBO, VBOKEY_MD3TEX );
+			
+			oldEntity = backEnd.currentEntity;
+			backEnd.currentEntity = &thisEntity;
+			
+			qglGenBuffersARB( 1, &mod->modelData.md3.md3srf[lod][i].VBO->vbo );
+			qglGenBuffersARB( 1, &mod->modelData.md3.md3srf[lod][i].VBO->ibo );
+			
+			GL_VBO( mod->modelData.md3.md3srf[lod][i].VBO->vbo );
+			GL_IBO( mod->modelData.md3.md3srf[lod][i].VBO->ibo );
+			
+			// render first frame
+			thisEntity.e.frame = 0;
+			thisEntity.e.oldframe = 0;
+			thisEntity.e.backlerp = 0.0f;
+			tess.fogNum = 0;
+			
+			RB_ClearVertexBuffer( );
+			(*rb_surfaceTable[SF_MD3])((surfaceType_t *)surf);
+			
+			RB_SetupVertexBuffer( NULL, NULL );
+			
+			(*rb_surfaceTable[SF_MD3])((surfaceType_t *)surf);
+			
+			// build VBO, set 2nd texcoord (normally lightmap)
+			// to position of vertex in the data texture
+			float   scaleX = 1.0f / (frameW * texW);
+			float   scaleY = 1.0f / (frameH * texH);
+			for( j = 0; j < tess.numVertexes; j++ ) {
+				tess.vertexPtr1[j].tc2[0] = (0.5f + (j % frameW)) * scaleX ;
+				tess.vertexPtr1[j].tc2[1] = (0.5f + (j / frameW)) * scaleY ;
+			}
+			
+			qglBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB,
+					  tess.indexInc * tess.numIndexes,
+					  tess.indexPtr.p16,
+					  GL_STATIC_DRAW_ARB );
+			qglBufferDataARB( GL_ARRAY_BUFFER_ARB,
+					  sizeof(vaWord1_t) * tess.numVertexes,
+					  tess.vertexPtr1, GL_STATIC_DRAW_ARB );
+			mod->modelData.md3.md3srf[lod][i].VBO->offs1 = NULL;
+			mod->modelData.md3.md3srf[lod][i].VBO->offs2 = NULL;
+			mod->modelData.md3.md3srf[lod][i].VBO->offs3 = NULL;
+			mod->modelData.md3.md3srf[lod][i].VBO->offs4 = NULL;
+			mod->modelData.md3.md3srf[lod][i].VBO->offsIdx = NULL;
+			
+			mod->modelData.md3.md3srf[lod][i].VBO->numIndexes = tess.numIndexes;
+			mod->modelData.md3.md3srf[lod][i].VBO->minIndex = 0;
+			mod->modelData.md3.md3srf[lod][i].VBO->maxIndex = tess.numVertexes - 1;
+
+			// build (sub-)texture
+			image_t *image = R_CreateImage( surf->name, NULL,
+							frameW * texW, frameH * texH,
+							qfalse, qfalse, GL_REPEAT );
+			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+			image->uploadWidth = texW * frameW;
+			image->uploadHeight = texH * frameH;
+			image->internalFormat = GL_RGB32F_ARB;
+			qglTexImage2D( GL_TEXTURE_2D, 0, GL_RGB32F_ARB,
+				       texW * frameW, texH * frameH,
+				       0, GL_RGB, GL_FLOAT, NULL );
+			// a float has 24 significant bits, and we have 4 floats
+			// per texel, so a total 96 bits are available. These
+			// store 3x16 bits for the vertex position and 3x8
+			// bits for the three normal vectors.
+			vec3_t *texData;
+			if( glGlobals.PBO ) {
+				qglBindBufferARB( GL_PIXEL_UNPACK_BUFFER_ARB, glGlobals.PBO );
+				qglBufferDataARB( GL_PIXEL_UNPACK_BUFFER_ARB, frameW * frameH * sizeof(vec3_t), NULL, GL_STREAM_DRAW_ARB );
+				texData = qglMapBufferARB( GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY_ARB );
+			} else {
+				texData = ri.Hunk_AllocateTempMemory(frameW * frameH * sizeof(vec3_t));
+				Com_Memset( texData, 0, frameW * frameH * sizeof(vec3_t) );
+			}
+			for( j = 0; j < tess.numVertexes; j++ ) {
+				vaWord2_t *ptr2 = &tess.vertexPtr2[j];
+				vaWord3_t *ptr3 = &tess.vertexPtr3[j];
+				unsigned short tmpX = (unsigned short)(ptr2->xyz[0] / MD3_XYZ_SCALE + 32768.0f);
+				unsigned short tmpY = (unsigned short)(ptr2->xyz[1] / MD3_XYZ_SCALE + 32768.0f);
+				unsigned short tmpZ = (unsigned short)(ptr2->xyz[2] / MD3_XYZ_SCALE + 32768.0f);
+				unsigned char nrmX = (unsigned char)(ptr3->normal[0] * 127 + 128);
+				unsigned char nrmY = (unsigned char)(ptr3->normal[1] * 127 + 128);
+				unsigned char nrmZ = (unsigned char)(ptr3->normal[2] * 127 + 128);
+				
+				unsigned int int1 = (nrmX << 16) | tmpX;
+				unsigned int int2 = (nrmY << 16) | tmpY;
+				unsigned int int3 = (nrmZ << 16) | tmpZ;
+				
+				texData[j][0] = ((float)int1) * (1.0f / 65536.0f);
+				texData[j][1] = ((float)int2) * (1.0f / 65536.0f);
+				texData[j][2] = ((float)int3) * (1.0f / 65536.0f);
+			}
+			if( glGlobals.PBO ) {
+				qglUnmapBufferARB( GL_PIXEL_UNPACK_BUFFER_ARB );
+				qglTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0,
+						  frameW, frameH,
+						  GL_RGB, GL_FLOAT,
+						  NULL );
+			} else {
+				qglTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0,
+						  frameW, frameH,
+						  GL_RGB, GL_FLOAT,
+						  texData );
+			}
+			RB_ClearVertexBuffer();
+			
+			// render further frames
+			for( k = 1; k < numFrames; k++ ) {
+				thisEntity.e.frame = k;
+				thisEntity.e.oldframe = k;
+				thisEntity.e.backlerp = 0.0f;
+				
+				(*rb_surfaceTable[SF_MD3])((surfaceType_t *)surf);
+				
+				RB_SetupVertexBuffer( NULL, NULL );
+				
+				(*rb_surfaceTable[SF_MD3])((surfaceType_t *)surf);
+				
+				if( glGlobals.PBO ) {
+					qglBufferDataARB( GL_PIXEL_UNPACK_BUFFER_ARB, frameW * frameH * sizeof(vec3_t), NULL, GL_STREAM_DRAW_ARB );
+					texData = qglMapBufferARB( GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY_ARB );
+				}
+
+				for( j = 0; j < tess.numVertexes; j++ ) {
+					vaWord2_t *ptr2 = &tess.vertexPtr2[j];
+					vaWord3_t *ptr3 = &tess.vertexPtr3[j];
+					unsigned short tmpX = (unsigned short)(ptr2->xyz[0] / MD3_XYZ_SCALE + 32768.0f);
+					unsigned short tmpY = (unsigned short)(ptr2->xyz[1] / MD3_XYZ_SCALE + 32768.0f);
+					unsigned short tmpZ = (unsigned short)(ptr2->xyz[2] / MD3_XYZ_SCALE + 32768.0f);
+					unsigned char nrmX = (unsigned char)(ptr3->normal[0] * 127 + 128);
+					unsigned char nrmY = (unsigned char)(ptr3->normal[1] * 127 + 128);
+					unsigned char nrmZ = (unsigned char)(ptr3->normal[2] * 127 + 128);
+
+					unsigned int int1 = (nrmX << 16) | tmpX;
+					unsigned int int2 = (nrmY << 16) | tmpY;
+					unsigned int int3 = (nrmZ << 16) | tmpZ;
+
+					texData[j][0] = ((float)int1) * (1.0f / 65536.0f);
+					texData[j][1] = ((float)int2) * (1.0f / 65536.0f);
+					texData[j][2] = ((float)int3) * (1.0f / 65536.0f);
+				}
+				if( glGlobals.PBO ) {
+					qglUnmapBufferARB( GL_PIXEL_UNPACK_BUFFER_ARB );
+					qglTexSubImage2D( GL_TEXTURE_2D, 0,
+							  (k % texW) * frameW,
+							  (k / texW) * frameH,
+							  frameW, frameH,
+							  GL_RGB, GL_FLOAT,
+							  NULL );
+				} else {
+					qglTexSubImage2D( GL_TEXTURE_2D, 0,
+							  (k % texW) * frameW,
+							  (k / texW) * frameH,
+							  frameW, frameH,
+							  GL_RGB, GL_FLOAT,
+							  texData );
+				}
+				RB_ClearVertexBuffer();
+			}
+			if( glGlobals.PBO ) {
+				qglBindBufferARB( GL_PIXEL_UNPACK_BUFFER_ARB, 0 );
+			} else {
+				ri.Hunk_FreeTempMemory( texData );
+			}
+			
+			mod->modelData.md3.md3srf[lod][i].image = image;
+			shadertype = LIGHTMAP_MD3;
+			backEnd.currentEntity = oldEntity;
+		}
+		
+		// register the shaders
+		for ( j = 0 ; j < surf->numShaders ; j++, shader++ ) {
+			shader_t	*sh;
+			
+			sh = R_FindShader( shader->name, shadertype, qtrue );
+			if ( sh->defaultShader ) {
+				shader->shaderIndex = 0;
+			} else {
+				shader->shaderIndex = sh->index;
+			}
+		}
+		
 		// find the next surface
 		surf = (md3Surface_t *)( (byte *)surf + surf->ofsEnd );
 	}
-    
+
 	return qtrue;
 }
 
@@ -471,7 +699,7 @@
 	}
 
 	mod->dataSize += size;
-	mod->md4 = mdr = ri.Hunk_Alloc( size, h_low );
+	mod->modelData.md4.md4 = mdr = ri.Hunk_Alloc( size, h_low );
 
 	// Copy all the values over from the file and fix endian issues in the process, if necessary.
 	
@@ -612,19 +840,6 @@
 			surf->numTriangles = LittleLong(cursurf->numTriangles);
 			// numBoneReferences and BoneReferences generally seem to be unused
 			
-			// now do the checks that may fail.
-			if ( surf->numVerts > SHADER_MAX_VERTEXES ) 
-			{
-				ri.Printf(PRINT_WARNING, "R_LoadMDR: %s has more than %i verts on a surface (%i)",
-					  mod_name, SHADER_MAX_VERTEXES, surf->numVerts );
-				return qfalse;
-			}
-			if ( surf->numTriangles*3 > SHADER_MAX_INDEXES ) 
-			{
-				ri.Printf(PRINT_WARNING, "R_LoadMDR: %s has more than %i triangles on a surface (%i)",
-					  mod_name, SHADER_MAX_INDEXES / 3, surf->numTriangles );
-				return qfalse;
-			}
 			// lowercase the surface name so skin compares are faster
 			Q_strlwr( surf->name );
 
@@ -780,7 +995,7 @@
 	mod->type = MOD_MD4;
 	size = LittleLong(pinmodel->ofsEnd);
 	mod->dataSize += size;
-	md4 = mod->md4 = ri.Hunk_Alloc( size, h_low );
+	md4 = mod->modelData.md4.md4 = ri.Hunk_Alloc( size, h_low );
 
 	Com_Memcpy(md4, buffer, size);
 
@@ -829,15 +1044,6 @@
 			LL(surf->ofsVerts);
 			LL(surf->ofsEnd);
 			
-			if ( surf->numVerts > SHADER_MAX_VERTEXES ) {
-				ri.Error (ERR_DROP, "R_LoadMD3: %s has more than %i verts on a surface (%i)",
-					mod_name, SHADER_MAX_VERTEXES, surf->numVerts );
-			}
-			if ( surf->numTriangles*3 > SHADER_MAX_INDEXES ) {
-				ri.Error (ERR_DROP, "R_LoadMD3: %s has more than %i triangles on a surface (%i)",
-					mod_name, SHADER_MAX_INDEXES / 3, surf->numTriangles );
-			}
-
 			// change to surface identifier
 			surf->ident = SF_MD4;
 
@@ -902,7 +1108,6 @@
 }
 
 
-
 //=============================================================================
 
 /*
@@ -916,7 +1121,7 @@
 
 	R_SyncRenderThread();
 
-	tr.viewCluster = -1;		// force markleafs to regenerate
+	tr.visCluster = -1;		// force markleafs to regenerate
 	R_ClearFlares();
 	RE_ClearScene();
 
@@ -961,9 +1166,12 @@
 	for ( i = 1 ; i < tr.numModels; i++ ) {
 		mod = tr.models[i];
 		lods = 1;
-		for ( j = 1 ; j < MD3_MAX_LODS ; j++ ) {
-			if ( mod->md3[j] && mod->md3[j] != mod->md3[j-1] ) {
-				lods++;
+		if( mod->type == MOD_MESH ) {
+			for ( j = 1 ; j < MD3_MAX_LODS ; j++ ) {
+				if ( mod->modelData.md3.md3[j] &&
+				     mod->modelData.md3.md3[j] != mod->modelData.md3.md3[j-1] ) {
+					lods++;
+				}
 			}
 		}
 		ri.Printf( PRINT_ALL, "%8i : (%i) %s\n",mod->dataSize, lods, mod->name );
@@ -1068,19 +1276,23 @@
 	model_t		*model;
 
 	model = R_GetModelByHandle( handle );
-	if ( !model->md3[0] )
+	if ( model->type != MOD_MESH )
 	{
 #ifdef RAVENMD4
-		if(model->md4)
+		if( model->type == MOD_MDR || model_>type == MOD_MD4 )
 		{
 			start = &start_space;
 			end = &end_space;
-			R_GetAnimTag((mdrHeader_t *) model->md4, startFrame, tagName, start);
-			R_GetAnimTag((mdrHeader_t *) model->md4, endFrame, tagName, end);
+			R_GetAnimTag((mdrHeader_t *) model->modelData.md4.md4, startFrame, tagName, start);
+			R_GetAnimTag((mdrHeader_t *) model->modelData.md4.md4, endFrame, tagName, end);
 		}
 		else
 #endif
-		{
+		if( model->type == MOD_IQM ) {
+			return R_IQMLerpTag( tag, model->modelData.iqm.iqmData,
+					     startFrame, endFrame,
+					     frac, tagName );
+		} else {
 
 			AxisClear( tag->axis );
 			VectorClear( tag->origin );
@@ -1090,8 +1302,8 @@
 	}
 	else
 	{
-		start = R_GetTag( model->md3[0], startFrame, tagName );
-		end = R_GetTag( model->md3[0], endFrame, tagName );
+		start = R_GetTag( model->modelData.md3.md3[0], startFrame, tagName );
+		end = R_GetTag( model->modelData.md3.md3[0], endFrame, tagName );
 		if ( !start || !end ) {
 			AxisClear( tag->axis );
 			VectorClear( tag->origin );
@@ -1127,19 +1339,19 @@
 
 	model = R_GetModelByHandle( handle );
 
-	if ( model->bmodel ) {
-		VectorCopy( model->bmodel->bounds[0], mins );
-		VectorCopy( model->bmodel->bounds[1], maxs );
+	if ( model->type == MOD_BRUSH ) {
+		VectorCopy( model->modelData.brush.bmodel->bounds[0], mins );
+		VectorCopy( model->modelData.brush.bmodel->bounds[1], maxs );
 		return;
 	}
 
-	if ( !model->md3[0] ) {
+	if ( model->type != MOD_MESH ) {
 		VectorClear( mins );
 		VectorClear( maxs );
 		return;
 	}
 
-	header = model->md3[0];
+	header = model->modelData.md3.md3[0];
 
 	frame = (md3Frame_t *)( (byte *)header + header->ofsFrames );
 
Index: src/renderer/tr_init.c
===================================================================
--- src/renderer/tr_init.c	(Revision 2062)
+++ src/renderer/tr_init.c	(Arbeitskopie)
@@ -29,6 +29,8 @@
 
 static void GfxInfo_f( void );
 
+cvar_t	*r_scratchmegs;
+
 cvar_t	*r_flareSize;
 cvar_t	*r_flareFade;
 cvar_t	*r_flareCoeff;
@@ -88,6 +90,19 @@
 cvar_t	*r_ext_texture_env_add;
 cvar_t	*r_ext_texture_filter_anisotropic;
 cvar_t	*r_ext_max_anisotropy;
+cvar_t	*r_ext_texture_compression;
+cvar_t	*r_ext_vertex_buffer_object;
+cvar_t	*r_ext_pixel_buffer_object;
+cvar_t	*r_ext_vertex_shader;
+cvar_t	*r_ext_geometry_shader;
+cvar_t  *r_ext_framebuffer_object;
+cvar_t	*r_ext_occlusion_query;
+cvar_t	*r_ext_timer_query;
+cvar_t	*r_ext_instanced_arrays;
+cvar_t  *r_ext_texture_float;
+cvar_t	*r_ext_texture3D;
+cvar_t	*r_ext_separate_stencil;
+cvar_t	*r_ext_debug_output;
 
 cvar_t	*r_ignoreGLErrors;
 cvar_t	*r_logFile;
@@ -95,9 +110,8 @@
 cvar_t	*r_stencilbits;
 cvar_t	*r_depthbits;
 cvar_t	*r_colorbits;
-cvar_t	*r_primitives;
 cvar_t	*r_texturebits;
-cvar_t  *r_ext_multisample;
+cvar_t	*r_ext_multisample;
 
 cvar_t	*r_drawBuffer;
 cvar_t	*r_lightmap;
@@ -150,6 +164,12 @@
 cvar_t	*r_printShaders;
 cvar_t	*r_saveFontData;
 
+cvar_t	*r_flush;
+cvar_t	*r_VBOminSize;
+cvar_t	*r_depthPass;
+cvar_t	*r_perPixelLighting;
+cvar_t	*r_parallax;
+
 cvar_t	*r_marksOnTriangleMeshes;
 
 cvar_t	*r_maxpolys;
@@ -285,8 +305,29 @@
 		{
 			glConfig.maxTextureSize = 0;
 		}
+		
+		// reserve some stencil bits for portal/mirror rendering
+		if ( glConfig.stencilBits > 8 ) {
+			temp = 4;
+		} else if ( glConfig.stencilBits > 6 ) {
+			temp = 3;
+		} else if ( glConfig.stencilBits > 4 ) {
+			temp = 2;
+		} else if ( glConfig.stencilBits > 2 ) {
+			temp = 1;
+		} else {
+			temp = 0;
+		}
+		
+		glGlobals.portalBits = temp;
+		glGlobals.shadowBits = glConfig.stencilBits - temp;
+		glGlobals.portalLevels = (1 << temp) - 1;
+		glGlobals.portalMask = glGlobals.portalLevels << glGlobals.shadowBits;
+		glGlobals.shadowMask = (1 << glGlobals.shadowBits) - 1;
 	}
 
+	RB_InitScratchMemory( );
+
 	// init command buffers and SMP
 	R_InitCommandBuffers();
 
@@ -295,10 +336,88 @@
 
 	// set default state
 	GL_SetDefaultState();
+
+	// enable debug_output extension
+	if( qglDebugMessageControlARB ) {
+		if( r_ext_debug_output->integer & 0x4 )
+			qglDebugMessageControlARB( GL_DONT_CARE, GL_DONT_CARE,
+						   GL_DEBUG_SEVERITY_HIGH_ARB,
+						   0, NULL, GL_TRUE );
+		if( r_ext_debug_output->integer & 0x2 )
+			qglDebugMessageControlARB( GL_DONT_CARE, GL_DONT_CARE,
+						   GL_DEBUG_SEVERITY_MEDIUM_ARB,
+						   0, NULL, GL_TRUE );
+		if( r_ext_debug_output->integer & 0x1 )
+			qglDebugMessageControlARB( GL_DONT_CARE, GL_DONT_CARE,
+						   GL_DEBUG_SEVERITY_LOW_ARB,
+						   0, NULL, GL_TRUE );
+		qglDebugMessageInsertARB( GL_DEBUG_SOURCE_APPLICATION_ARB,
+					  GL_DEBUG_TYPE_OTHER_ARB, 1,
+					  GL_DEBUG_SEVERITY_LOW_ARB,
+					  -1, "debug log started" );
+	} else if ( qglDebugMessageEnableAMD ) {
+		if( r_ext_debug_output->integer & 0x4 )
+			qglDebugMessageEnableAMD( 0, GL_DEBUG_SEVERITY_HIGH_AMD,
+						  0, NULL, GL_TRUE );
+		if( r_ext_debug_output->integer & 0x2 )
+			qglDebugMessageEnableAMD( 0, GL_DEBUG_SEVERITY_MEDIUM_AMD,
+						  0, NULL, GL_TRUE );
+		if( r_ext_debug_output->integer & 0x1 )
+			qglDebugMessageEnableAMD( 0, GL_DEBUG_SEVERITY_LOW_AMD,
+						  0, NULL, GL_TRUE );
+		qglDebugMessageInsertAMD( GL_DEBUG_CATEGORY_APPLICATION_AMD,
+					  GL_DEBUG_SEVERITY_LOW_AMD, 1,
+					  0, "debug log started" );
+	}
+
+	if( glGlobals.pixelBufferObjects ) {
+		qglGenBuffersARB( 1, &glGlobals.PBO );
+	} else {
+		glGlobals.PBO = 0;
+	}
+
+#if GL_SGIS_generate_mipmap
+	qglHint( GL_GENERATE_MIPMAP_HINT_SGIS, GL_NICEST );
+	qglGetError();	// ignore error
+#endif
 }
 
+
 /*
 ==================
+GL_CheckDebugLog
+==================
+*/
+void GL_CheckDebugLog( void ) {
+	GLint messagesAvailable;
+	char  message[1024];
+	GLenum source, type, id, severity;
+	GLsizei length;
+
+	if( qglDebugMessageControlARB ) {
+		qglGetIntegerv( GL_DEBUG_LOGGED_MESSAGES_ARB, &messagesAvailable );
+		while( messagesAvailable-- ) {
+			if( qglGetDebugMessageLogARB( 1, sizeof(message),
+						      &source, &type, &id,
+						      &severity, &length, message) ) {
+				ri.Printf( PRINT_ALL, "GL debug: %s\n", message );
+			}
+		}
+	} else if( qglDebugMessageEnableAMD ) {
+		qglGetIntegerv( GL_DEBUG_LOGGED_MESSAGES_AMD, &messagesAvailable );
+		while( messagesAvailable-- ) {
+			if( qglGetDebugMessageLogAMD( 1, sizeof(message),
+						      &type, &id,
+						      &severity, &length, message) ) {
+				ri.Printf( PRINT_ALL, "GL debug: %s\n", message );
+			}
+		}
+	}
+}
+
+
+/*
+==================
 GL_CheckErrors
 ==================
 */
@@ -307,6 +426,9 @@
 	char	s[64];
 
 	err = qglGetError();
+
+	GL_CheckDebugLog();
+
 	if ( err == GL_NO_ERROR ) {
 		return;
 	}
@@ -753,29 +875,22 @@
 
 	qglCullFace(GL_FRONT);
 
-	qglColor4f (1,1,1,1);
-
 	// initialize downstream texture unit if we're running
 	// in a multitexture environment
 	if ( qglActiveTextureARB ) {
-		GL_SelectTexture( 1 );
-		GL_TextureMode( r_textureMode->string );
-		GL_TexEnv( GL_MODULATE );
-		qglDisable( GL_TEXTURE_2D );
-		GL_SelectTexture( 0 );
+		int i;
+		
+		for( i = 1; i < glConfig.numTextureUnits; i++ ) {
+			GL_TexEnv( i, GL_MODULATE );
+		}
 	}
 
-	qglEnable(GL_TEXTURE_2D);
 	GL_TextureMode( r_textureMode->string );
-	GL_TexEnv( GL_MODULATE );
+	GL_TexEnv( 0, GL_MODULATE );
 
 	qglShadeModel( GL_SMOOTH );
 	qglDepthFunc( GL_LEQUAL );
 
-	// the vertex array is always enabled, but the color and texture
-	// arrays are enabled and disabled around the compiled vertex array call
-	qglEnableClientState (GL_VERTEX_ARRAY);
-
 	//
 	// make sure our GL state vector is set correctly
 	//
@@ -815,6 +930,7 @@
 	ri.Printf( PRINT_ALL, "GL_MAX_TEXTURE_SIZE: %d\n", glConfig.maxTextureSize );
 	ri.Printf( PRINT_ALL, "GL_MAX_TEXTURE_UNITS_ARB: %d\n", glConfig.numTextureUnits );
 	ri.Printf( PRINT_ALL, "\nPIXELFORMAT: color(%d-bits) Z(%d-bit) stencil(%d-bits)\n", glConfig.colorBits, glConfig.depthBits, glConfig.stencilBits );
+	ri.Printf( PRINT_ALL, "\nSTENCILFORMAT: portals(%d-bits) shadows(%d-bit)\n", glGlobals.portalBits, glGlobals.shadowBits );
 	ri.Printf( PRINT_ALL, "MODE: %d x %d %s hz:", glConfig.vidWidth, glConfig.vidHeight, fsstrings[r_fullscreen->integer == 1] );
 	if ( glConfig.displayFrequency )
 	{
@@ -833,31 +949,6 @@
 		ri.Printf( PRINT_ALL, "GAMMA: software w/ %d overbright bits\n", tr.overbrightBits );
 	}
 
-	// rendering primitives
-	{
-		int		primitives;
-
-		// default is to use triangles if compiled vertex arrays are present
-		ri.Printf( PRINT_ALL, "rendering primitives: " );
-		primitives = r_primitives->integer;
-		if ( primitives == 0 ) {
-			if ( qglLockArraysEXT ) {
-				primitives = 2;
-			} else {
-				primitives = 1;
-			}
-		}
-		if ( primitives == -1 ) {
-			ri.Printf( PRINT_ALL, "none\n" );
-		} else if ( primitives == 2 ) {
-			ri.Printf( PRINT_ALL, "single glDrawElements\n" );
-		} else if ( primitives == 1 ) {
-			ri.Printf( PRINT_ALL, "multiple glArrayElement\n" );
-		} else if ( primitives == 3 ) {
-			ri.Printf( PRINT_ALL, "multiple glColor4ubv + glTexCoord2fv + glVertex3fv\n" );
-		}
-	}
-
 	ri.Printf( PRINT_ALL, "texturemode: %s\n", r_textureMode->string );
 	ri.Printf( PRINT_ALL, "picmip: %d\n", r_picmip->integer );
 	ri.Printf( PRINT_ALL, "texture bits: %d\n", r_texturebits->integer );
@@ -895,11 +986,26 @@
 	//
 	// latched and archived variables
 	//
+	r_scratchmegs = ri.Cvar_Get( "r_scratchmegs", va( "%d", SMP_SCRATCHMEGS ), CVAR_ARCHIVE | CVAR_LATCH );
+
 	r_allowExtensions = ri.Cvar_Get( "r_allowExtensions", "1", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ext_compressed_textures = ri.Cvar_Get( "r_ext_compressed_textures", "0", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ext_multitexture = ri.Cvar_Get( "r_ext_multitexture", "1", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ext_compiled_vertex_array = ri.Cvar_Get( "r_ext_compiled_vertex_array", "1", CVAR_ARCHIVE | CVAR_LATCH);
 	r_ext_texture_env_add = ri.Cvar_Get( "r_ext_texture_env_add", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_texture_compression = ri.Cvar_Get( "r_ext_texture_compression", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_vertex_buffer_object = ri.Cvar_Get( "r_ext_vertex_buffer_object", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_pixel_buffer_object = ri.Cvar_Get( "r_ext_pixel_buffer_object", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_vertex_shader = ri.Cvar_Get( "r_ext_vertex_shader", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_geometry_shader = ri.Cvar_Get( "r_ext_geometry_shader", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_framebuffer_object = ri.Cvar_Get( "r_ext_framebuffer_object", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_occlusion_query = ri.Cvar_Get( "r_ext_occlusion_query", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_timer_query = ri.Cvar_Get( "r_ext_timer_query", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_instanced_arrays = ri.Cvar_Get( "r_ext_instanced_arrays", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_texture_float = ri.Cvar_Get( "r_ext_texture_float", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_texture3D = ri.Cvar_Get( "r_ext_texture3D", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_separate_stencil = ri.Cvar_Get( "r_ext_separate_stencil", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_debug_output = ri.Cvar_Get( "r_ext_debug_output", "0", CVAR_LATCH);
 
 	r_picmip = ri.Cvar_Get ("r_picmip", GENERIC_HW_R_PICMIP_DEFAULT,
 			CVAR_ARCHIVE | CVAR_LATCH );
@@ -916,7 +1022,7 @@
 	r_stencilbits = ri.Cvar_Get( "r_stencilbits", "8", CVAR_ARCHIVE | CVAR_LATCH );
 	r_depthbits = ri.Cvar_Get( "r_depthbits", "0", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ext_multisample = ri.Cvar_Get( "r_ext_multisample", "0", CVAR_ARCHIVE | CVAR_LATCH );
-	ri.Cvar_CheckRange( r_ext_multisample, 0, 4, qtrue );
+	ri.Cvar_CheckRange( r_ext_multisample, 0, 16, qtrue );
 	r_overBrightBits = ri.Cvar_Get ("r_overBrightBits", "1", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ignorehwgamma = ri.Cvar_Get( "r_ignorehwgamma", "0", CVAR_ARCHIVE | CVAR_LATCH);
 	r_fullscreen = ri.Cvar_Get( "r_fullscreen", "1", CVAR_ARCHIVE );
@@ -969,8 +1075,6 @@
 	r_railCoreWidth = ri.Cvar_Get( "r_railCoreWidth", "6", CVAR_ARCHIVE );
 	r_railSegmentLength = ri.Cvar_Get( "r_railSegmentLength", "32", CVAR_ARCHIVE );
 
-	r_primitives = ri.Cvar_Get( "r_primitives", "0", CVAR_ARCHIVE );
-
 	r_ambientScale = ri.Cvar_Get( "r_ambientScale", "0.6", CVAR_CHEAT );
 	r_directedScale = ri.Cvar_Get( "r_directedScale", "1", CVAR_CHEAT );
 
@@ -1027,6 +1131,12 @@
 	r_maxpolys = ri.Cvar_Get( "r_maxpolys", va("%d", MAX_POLYS), 0);
 	r_maxpolyverts = ri.Cvar_Get( "r_maxpolyverts", va("%d", MAX_POLYVERTS), 0);
 
+	r_flush = ri.Cvar_Get("r_flush","0", 0);
+	r_VBOminSize = ri.Cvar_Get("r_VBOminSize","0",CVAR_ARCHIVE);
+	r_depthPass = ri.Cvar_Get("r_depthPass","0", CVAR_LATCH | CVAR_ARCHIVE);
+	r_perPixelLighting = ri.Cvar_Get("r_perPixelLighting","0", CVAR_LATCH | CVAR_ARCHIVE);
+	r_parallax = ri.Cvar_Get("r_parallax","0",CVAR_LATCH | CVAR_ARCHIVE);
+
 	// make sure all the commands added here are also
 	// removed in R_Shutdown
 	ri.Cmd_AddCommand( "imagelist", R_ImageList_f );
@@ -1050,18 +1160,26 @@
 
 	ri.Printf( PRINT_ALL, "----- R_Init -----\n" );
 
+	if( sizeof(vaWord1_t) != 16 )
+		ri.Printf( PRINT_ERROR, "Incorrect vaWord1 size\n" );
+	if( sizeof(vaWord2_t) != 16 )
+		ri.Printf( PRINT_ERROR, "Incorrect vaWord2 size\n" );
+	if( sizeof(vaWord3_t) != 16 )
+		ri.Printf( PRINT_ERROR, "Incorrect vaWord3 size\n" );
+
 	// clear all our internal state
 	Com_Memset( &tr, 0, sizeof( tr ) );
+	tr.worldEntity.e.axis[0][0] = 1.0f;
+	tr.worldEntity.e.axis[1][1] = 1.0f;
+	tr.worldEntity.e.axis[2][2] = 1.0f;
 	Com_Memset( &backEnd, 0, sizeof( backEnd ) );
 	Com_Memset( &tess, 0, sizeof( tess ) );
+	backEnd.entity2D.e.axis[0][0] = 1.0f;
+	backEnd.entity2D.e.axis[1][1] = 1.0f;
+	backEnd.entity2D.e.axis[2][2] = 1.0f;
 
 //	Swap_Init();
 
-	if ( (intptr_t)tess.xyz & 15 ) {
-		Com_Printf( "WARNING: tess.xyz not 16 byte aligned\n" );
-	}
-	Com_Memset( tess.constantColor255, 255, sizeof( tess.constantColor255 ) );
-
 	//
 	// init function tables
 	//
@@ -1119,6 +1237,10 @@
 
 	InitOpenGL();
 
+	if( qglGenBuffersARB ) {
+		qglGenBuffersARB( 1, &backEnd.streamVBO.ibo );
+	}
+
 	R_InitImages();
 
 	R_InitShaders();
@@ -1137,6 +1259,17 @@
 	ri.Printf( PRINT_ALL, "----- finished R_Init -----\n" );
 }
 
+static void freeVboInfo(vboInfo_t *info) {
+	if( info ) {
+		freeVboInfo( info->left );
+		freeVboInfo( info->right );
+		if ( info->ibo && qglIsBufferARB( info->ibo ) )
+			qglDeleteBuffersARB( 1, &info->ibo );
+		if ( info->vbo && qglIsBufferARB( info->vbo ) )
+			qglDeleteBuffersARB( 1, &info->vbo );
+	}
+}
+
 /*
 ===============
 RE_Shutdown
@@ -1144,7 +1277,7 @@
 */
 void RE_Shutdown( qboolean destroyWindow ) {	
 
-	ri.Printf( PRINT_ALL, "RE_Shutdown( %i )\n", destroyWindow );
+	ri.Printf( PRINT_DEVELOPER, "RE_Shutdown( %i )\n", destroyWindow );
 
 	ri.Cmd_RemoveCommand ("modellist");
 	ri.Cmd_RemoveCommand ("screenshotJPEG");
@@ -1161,8 +1294,88 @@
 		R_SyncRenderThread();
 		R_ShutdownCommandBuffers();
 		R_DeleteTextures();
+
+		if ( qglDeleteQueriesARB && tr.numShaders ) {
+			int shader;
+			
+			for ( shader = 0; shader < tr.numShaders; shader++ ) {
+				if ( tr.shaders[shader]->QueryID ) {
+					qglDeleteQueriesARB( 1, &tr.shaders[shader]->QueryID );
+					tr.shaders[shader]->QueryID = 0;
+				}
+			}
+		}
+
+		GL_VBO( 0 );
+		if ( qglIsBufferARB && tr.numShaders ) {
+			int shader;
+			
+			for ( shader = 0; shader < tr.numShaders; shader++ ) {
+				freeVboInfo( tr.shaders[shader]->VBOs );
+				tr.shaders[shader]->VBOs = NULL;
+			}
+			if ( qglIsBufferARB( backEnd.worldVBO.vbo ) )
+				qglDeleteBuffersARB( 1, &backEnd.worldVBO.vbo );
+		}
+		if ( qglIsBufferARB && tr.numModels ) {
+			int model, lod;
+			
+			for ( model = 0; model < tr.numModels; model++ ) {
+				if ( tr.models[model]->type != MOD_MESH )
+					continue;
+				
+				for ( lod = 0; lod < MD3_MAX_LODS; lod++ ) {
+					if( tr.models[model]->modelData.md3.md3srf[lod] ) {
+						freeVboInfo( tr.models[model]->modelData.md3.md3srf[lod]->VBO );
+						tr.models[model]->modelData.md3.md3srf[lod]->VBO = NULL;
+					}
+				}
+			}
+		}
+		if( qglGenBuffersARB && backEnd.streamVBO.ibo ) 
+			qglDeleteBuffersARB( 1, &backEnd.streamVBO.ibo );
+		if( glGlobals.PBO )
+			qglDeleteBuffersARB( 1, &glGlobals.PBO );
+		
+		if ( tess.vertexBuffer ) {
+			ri.Free( tess.vertexBuffer );
+			tess.vertexBuffer = NULL;
+		}
+
+		if ( qglCreateProgram ) {
+			int i;
+
+			for( i = 1; i < AL_NUMATTRIBUTES; i++ ) {
+				qglDisableVertexAttribArrayARB( i );
+			}
+			
+			GL_Program( NULL );
+			for ( i = 0; i < tr.numGLSLprograms; i++ ) {
+				qglDeleteProgram( tr.GLSLprograms[i]->handle );
+			}
+			for ( i = 0; i < tr.numGLSLshaders; i++ ) {
+				qglDeleteShader( tr.GLSLshaders[i]->handle );
+			}
+		}
 	}
 
+	// disable debugging
+	if( qglDebugMessageControlARB ) {
+		qglDebugMessageInsertARB( GL_DEBUG_SOURCE_APPLICATION_ARB,
+					  GL_DEBUG_TYPE_OTHER_ARB, 1,
+					  GL_DEBUG_SEVERITY_LOW_ARB,
+					  -1, "debug log stopped" );
+		GL_CheckDebugLog();
+		qglDebugMessageControlARB( GL_DONT_CARE, GL_DONT_CARE,
+					   GL_DONT_CARE, 0, NULL, GL_FALSE );
+	} else if ( qglDebugMessageEnableAMD ) {
+		qglDebugMessageInsertAMD( GL_DEBUG_CATEGORY_APPLICATION_AMD,
+					  GL_DEBUG_SEVERITY_LOW_AMD, 1,
+					  0, "debug log stopped" );
+		GL_CheckDebugLog();
+		qglDebugMessageEnableAMD( 0, 0, 0, NULL, GL_FALSE );
+	}
+
 	R_DoneFreeType();
 
 	// shut down platform specific OpenGL stuff
Index: src/renderer/tr_shade_calc.c
===================================================================
--- src/renderer/tr_shade_calc.c	(Revision 2062)
+++ src/renderer/tr_shade_calc.c	(Arbeitskopie)
@@ -87,7 +87,7 @@
 /*
 ** RB_CalcStretchTexCoords
 */
-void RB_CalcStretchTexCoords( const waveForm_t *wf, float *st )
+void RB_CalcStretchTexCoords( const waveForm_t *wf, vec2_t *st, int numVertexes )
 {
 	float p;
 	texModInfo_t tmi;
@@ -102,7 +102,7 @@
 	tmi.matrix[1][1] = p;
 	tmi.translate[1] = 0.5f - 0.5f * p;
 
-	RB_CalcTransformTexCoords( &tmi, st );
+	RB_CalcTransformTexCoords( &tmi, st, numVertexes );
 }
 
 /*
@@ -122,43 +122,44 @@
 void RB_CalcDeformVertexes( deformStage_t *ds )
 {
 	int i;
+	vec3_t	*normal;
 	vec3_t	offset;
 	float	scale;
-	float	*xyz = ( float * ) tess.xyz;
-	float	*normal = ( float * ) tess.normal;
 	float	*table;
 
 	if ( ds->deformationWave.frequency == 0 )
 	{
 		scale = EvalWaveForm( &ds->deformationWave );
 
-		for ( i = 0; i < tess.numVertexes; i++, xyz += 4, normal += 4 )
+		for ( i = 0; i < tess.numVertexes; i++ )
 		{
-			VectorScale( normal, scale, offset );
+			normal = &tess.vertexPtr3[i].normal;
+			VectorScale( *normal, scale, offset );
 			
-			xyz[0] += offset[0];
-			xyz[1] += offset[1];
-			xyz[2] += offset[2];
+			tess.vertexPtr2[i].xyz[0] += offset[0];
+			tess.vertexPtr2[i].xyz[1] += offset[1];
+			tess.vertexPtr2[i].xyz[2] += offset[2];
 		}
 	}
 	else
 	{
 		table = TableForFunc( ds->deformationWave.func );
 
-		for ( i = 0; i < tess.numVertexes; i++, xyz += 4, normal += 4 )
+		for ( i = 0; i < tess.numVertexes; i++ )
 		{
-			float off = ( xyz[0] + xyz[1] + xyz[2] ) * ds->deformationSpread;
+			float off = ( tess.vertexPtr2[i].xyz[0] + tess.vertexPtr2[i].xyz[1] + tess.vertexPtr2[i].xyz[2] ) * ds->deformationSpread;
 
 			scale = WAVEVALUE( table, ds->deformationWave.base, 
 				ds->deformationWave.amplitude,
 				ds->deformationWave.phase + off,
 				ds->deformationWave.frequency );
 
-			VectorScale( normal, scale, offset );
+			normal = &tess.vertexPtr3[i].normal;
+			VectorScale( *normal, scale, offset );
 			
-			xyz[0] += offset[0];
-			xyz[1] += offset[1];
-			xyz[2] += offset[2];
+			tess.vertexPtr2[i].xyz[0] += offset[0];
+			tess.vertexPtr2[i].xyz[1] += offset[1];
+			tess.vertexPtr2[i].xyz[2] += offset[2];
 		}
 	}
 }
@@ -173,26 +174,25 @@
 void RB_CalcDeformNormals( deformStage_t *ds ) {
 	int i;
 	float	scale;
-	float	*xyz = ( float * ) tess.xyz;
-	float	*normal = ( float * ) tess.normal;
+	vec3_t	*normal;
 
-	for ( i = 0; i < tess.numVertexes; i++, xyz += 4, normal += 4 ) {
+	for ( i = 0; i < tess.numVertexes; i++ ) {
+		normal = &tess.vertexPtr3[i].normal;
+
 		scale = 0.98f;
-		scale = R_NoiseGet4f( xyz[0] * scale, xyz[1] * scale, xyz[2] * scale,
+		scale = R_NoiseGet4f( tess.vertexPtr2[i].xyz[0] * scale, tess.vertexPtr2[i].xyz[1] * scale, tess.vertexPtr2[i].xyz[2] * scale,
 			tess.shaderTime * ds->deformationWave.frequency );
-		normal[ 0 ] += ds->deformationWave.amplitude * scale;
+		(*normal)[ 0 ] += ds->deformationWave.amplitude * scale;
 
 		scale = 0.98f;
-		scale = R_NoiseGet4f( 100 + xyz[0] * scale, xyz[1] * scale, xyz[2] * scale,
+		scale = R_NoiseGet4f( 100 + tess.vertexPtr2[i].xyz[0] * scale, tess.vertexPtr2[i].xyz[1] * scale, tess.vertexPtr2[i].xyz[2] * scale,
 			tess.shaderTime * ds->deformationWave.frequency );
-		normal[ 1 ] += ds->deformationWave.amplitude * scale;
+		(*normal)[ 1 ] += ds->deformationWave.amplitude * scale;
 
 		scale = 0.98f;
-		scale = R_NoiseGet4f( 200 + xyz[0] * scale, xyz[1] * scale, xyz[2] * scale,
+		scale = R_NoiseGet4f( 200 + tess.vertexPtr2[i].xyz[0] * scale, tess.vertexPtr2[i].xyz[1] * scale, tess.vertexPtr2[i].xyz[2] * scale,
 			tess.shaderTime * ds->deformationWave.frequency );
-		normal[ 2 ] += ds->deformationWave.amplitude * scale;
-
-		VectorNormalizeFast( normal );
+		(*normal)[ 2 ] += ds->deformationWave.amplitude * scale;
 	}
 }
 
@@ -204,24 +204,23 @@
 */
 void RB_CalcBulgeVertexes( deformStage_t *ds ) {
 	int i;
-	const float *st = ( const float * ) tess.texCoords[0];
-	float		*xyz = ( float * ) tess.xyz;
-	float		*normal = ( float * ) tess.normal;
 	float		now;
 
 	now = backEnd.refdef.time * ds->bulgeSpeed * 0.001f;
 
-	for ( i = 0; i < tess.numVertexes; i++, xyz += 4, st += 4, normal += 4 ) {
+	for ( i = 0; i < tess.numVertexes; i++ ) {
 		int		off;
 		float scale;
+		vec3_t	*normal;
 
-		off = (float)( FUNCTABLE_SIZE / (M_PI*2) ) * ( st[0] * ds->bulgeWidth + now );
+		off = (float)( FUNCTABLE_SIZE / (M_PI*2) ) * ( tess.vertexPtr1[i].tc1[0] * ds->bulgeWidth + now );
 
 		scale = tr.sinTable[ off & FUNCTABLE_MASK ] * ds->bulgeHeight;
-			
-		xyz[0] += normal[0] * scale;
-		xyz[1] += normal[1] * scale;
-		xyz[2] += normal[2] * scale;
+		
+		normal = &tess.vertexPtr3[i].normal;
+		tess.vertexPtr2[i].xyz[0] += (*normal)[0] * scale;
+		tess.vertexPtr2[i].xyz[1] += (*normal)[1] * scale;
+		tess.vertexPtr2[i].xyz[2] += (*normal)[2] * scale;
 	}
 }
 
@@ -235,7 +234,6 @@
 */
 void RB_CalcMoveVertexes( deformStage_t *ds ) {
 	int			i;
-	float		*xyz;
 	float		*table;
 	float		scale;
 	vec3_t		offset;
@@ -249,9 +247,8 @@
 
 	VectorScale( ds->moveVector, scale, offset );
 
-	xyz = ( float * ) tess.xyz;
-	for ( i = 0; i < tess.numVertexes; i++, xyz += 4 ) {
-		VectorAdd( xyz, offset, xyz );
+	for ( i = 0; i < tess.numVertexes; i++ ) {
+		VectorAdd( tess.vertexPtr2[i].xyz, offset, tess.vertexPtr2[i].xyz );
 	}
 }
 
@@ -266,6 +263,7 @@
 void DeformText( const char *text ) {
 	int		i;
 	vec3_t	origin, width, height;
+	vec3_t	*normal;
 	int		len;
 	int		ch;
 	byte	color[4];
@@ -275,19 +273,20 @@
 	height[0] = 0;
 	height[1] = 0;
 	height[2] = -1;
-	CrossProduct( tess.normal[0], height, width );
+	normal = &tess.vertexPtr3[0].normal;
+	CrossProduct( *normal, height, width );
 
 	// find the midpoint of the box
 	VectorClear( mid );
 	bottom = 999999;
 	top = -999999;
 	for ( i = 0 ; i < 4 ; i++ ) {
-		VectorAdd( tess.xyz[i], mid, mid );
-		if ( tess.xyz[i][2] < bottom ) {
-			bottom = tess.xyz[i][2];
+		VectorAdd( tess.vertexPtr2[i].xyz, mid, mid );
+		if ( tess.vertexPtr2[i].xyz[2] < bottom ) {
+			bottom = tess.vertexPtr2[i].xyz[2];
 		}
-		if ( tess.xyz[i][2] > top ) {
-			top = tess.xyz[i][2];
+		if ( tess.vertexPtr2[i].xyz[2] > top ) {
+			top = tess.vertexPtr2[i].xyz[2];
 		}
 	}
 	VectorScale( mid, 0.25f, origin );
@@ -353,7 +352,6 @@
 static void AutospriteDeform( void ) {
 	int		i;
 	int		oldVerts;
-	float	*xyz;
 	vec3_t	mid, delta;
 	float	radius;
 	vec3_t	left, up;
@@ -380,13 +378,11 @@
 
 	for ( i = 0 ; i < oldVerts ; i+=4 ) {
 		// find the midpoint
-		xyz = tess.xyz[i];
+		mid[0] = 0.25f * (tess.vertexPtr2[i].xyz[0] + tess.vertexPtr2[i+1].xyz[0] + tess.vertexPtr2[i+2].xyz[0] + tess.vertexPtr2[i+3].xyz[0]);
+		mid[1] = 0.25f * (tess.vertexPtr2[i].xyz[1] + tess.vertexPtr2[i+1].xyz[1] + tess.vertexPtr2[i+2].xyz[1] + tess.vertexPtr2[i+3].xyz[1]);
+		mid[2] = 0.25f * (tess.vertexPtr2[i].xyz[2] + tess.vertexPtr2[i+1].xyz[2] + tess.vertexPtr2[i+2].xyz[2] + tess.vertexPtr2[i+3].xyz[2]);
 
-		mid[0] = 0.25f * (xyz[0] + xyz[4] + xyz[8] + xyz[12]);
-		mid[1] = 0.25f * (xyz[1] + xyz[5] + xyz[9] + xyz[13]);
-		mid[2] = 0.25f * (xyz[2] + xyz[6] + xyz[10] + xyz[14]);
-
-		VectorSubtract( xyz, mid, delta );
+		VectorSubtract( tess.vertexPtr2[i].xyz, mid, delta );
 		radius = VectorLength( delta ) * 0.707f;		// / sqrt(2)
 
 		VectorScale( leftDir, radius, left );
@@ -396,20 +392,20 @@
 			VectorSubtract( vec3_origin, left, left );
 		}
 
-	  // compensate for scale in the axes if necessary
-  	if ( backEnd.currentEntity->e.nonNormalizedAxes ) {
-      float axisLength;
-		  axisLength = VectorLength( backEnd.currentEntity->e.axis[0] );
-  		if ( !axisLength ) {
-	  		axisLength = 0;
-  		} else {
-	  		axisLength = 1.0f / axisLength;
-  		}
-      VectorScale(left, axisLength, left);
-      VectorScale(up, axisLength, up);
-    }
-
-		RB_AddQuadStamp( mid, left, up, tess.vertexColors[i] );
+		// compensate for scale in the axes if necessary
+		if ( backEnd.currentEntity->e.nonNormalizedAxes ) {
+			float axisLength;
+			axisLength = VectorLength( backEnd.currentEntity->e.axis[0] );
+			if ( !axisLength ) {
+				axisLength = 0;
+			} else {
+				axisLength = 1.0f / axisLength;
+			}
+			VectorScale(left, axisLength, left);
+			VectorScale(up, axisLength, up);
+		}
+		
+		RB_AddQuadStamp( mid, left, up, tess.vertexPtr4[i].color );
 	}
 }
 
@@ -433,7 +429,6 @@
 static void Autosprite2Deform( void ) {
 	int		i, j, k;
 	int		indexes;
-	float	*xyz;
 	vec3_t	forward;
 
 	if ( tess.numVertexes & 3 ) {
@@ -457,11 +452,8 @@
 		int		nums[2];
 		vec3_t	mid[2];
 		vec3_t	major, minor;
-		float	*v1, *v2;
+		vec3_t	*v1, *v2;
 
-		// find the midpoint
-		xyz = tess.xyz[i];
-
 		// identify the two shortest edges
 		nums[0] = nums[1] = 0;
 		lengths[0] = lengths[1] = 999999;
@@ -470,8 +462,8 @@
 			float	l;
 			vec3_t	temp;
 
-			v1 = xyz + 4 * edgeVerts[j][0];
-			v2 = xyz + 4 * edgeVerts[j][1];
+			v1 = &tess.vertexPtr2[edgeVerts[j][0]].xyz;
+			v2 = &tess.vertexPtr2[edgeVerts[j][1]].xyz;
 
 			VectorSubtract( v1, v2, temp );
 			
@@ -488,12 +480,12 @@
 		}
 
 		for ( j = 0 ; j < 2 ; j++ ) {
-			v1 = xyz + 4 * edgeVerts[nums[j]][0];
-			v2 = xyz + 4 * edgeVerts[nums[j]][1];
+			v1 = &tess.vertexPtr2[edgeVerts[j][0]].xyz;
+			v2 = &tess.vertexPtr2[edgeVerts[j][1]].xyz;
 
-			mid[j][0] = 0.5f * (v1[0] + v2[0]);
-			mid[j][1] = 0.5f * (v1[1] + v2[1]);
-			mid[j][2] = 0.5f * (v1[2] + v2[2]);
+			mid[j][0] = 0.5f * ((*v1)[0] + (*v2)[0]);
+			mid[j][1] = 0.5f * ((*v1)[1] + (*v2)[1]);
+			mid[j][2] = 0.5f * ((*v1)[2] + (*v2)[2]);
 		}
 
 		// find the vector of the major axis
@@ -507,26 +499,26 @@
 		for ( j = 0 ; j < 2 ; j++ ) {
 			float	l;
 
-			v1 = xyz + 4 * edgeVerts[nums[j]][0];
-			v2 = xyz + 4 * edgeVerts[nums[j]][1];
+			v1 = &tess.vertexPtr2[edgeVerts[j][0]].xyz;
+			v2 = &tess.vertexPtr2[edgeVerts[j][1]].xyz;
 
 			l = 0.5 * sqrt( lengths[j] );
 			
 			// we need to see which direction this edge
 			// is used to determine direction of projection
 			for ( k = 0 ; k < 5 ; k++ ) {
-				if ( tess.indexes[ indexes + k ] == i + edgeVerts[nums[j]][0]
-					&& tess.indexes[ indexes + k + 1 ] == i + edgeVerts[nums[j]][1] ) {
+				if ( tess.indexPtr.p16[ indexes + k ] == i + edgeVerts[nums[j]][0]
+					&& tess.indexPtr.p16[ indexes + k + 1 ] == i + edgeVerts[nums[j]][1] ) {
 					break;
 				}
 			}
 
 			if ( k == 5 ) {
-				VectorMA( mid[j], l, minor, v1 );
-				VectorMA( mid[j], -l, minor, v2 );
+				VectorMA( mid[j], l, minor, *v1 );
+				VectorMA( mid[j], -l, minor, *v2 );
 			} else {
-				VectorMA( mid[j], -l, minor, v1 );
-				VectorMA( mid[j], l, minor, v2 );
+				VectorMA( mid[j], -l, minor, *v1 );
+				VectorMA( mid[j], l, minor, *v2 );
 			}
 		}
 	}
@@ -547,8 +539,8 @@
 		ds = &tess.shader->deforms[ i ];
 
 		switch ( ds->deformation ) {
-        case DEFORM_NONE:
-            break;
+		case DEFORM_NONE:
+			break;
 		case DEFORM_NORMALS:
 			RB_CalcDeformNormals( ds );
 			break;
@@ -596,7 +588,7 @@
 /*
 ** RB_CalcColorFromEntity
 */
-void RB_CalcColorFromEntity( unsigned char *dstColors )
+void RB_CalcColorFromEntity( color4ub_t *dstColors, int numVertexes )
 {
 	int	i;
 	int *pColors = ( int * ) dstColors;
@@ -607,7 +599,7 @@
 
 	c = * ( int * ) backEnd.currentEntity->e.shaderRGBA;
 
-	for ( i = 0; i < tess.numVertexes; i++, pColors++ )
+	for ( i = 0; i < numVertexes; i++, pColors++ )
 	{
 		*pColors = c;
 	}
@@ -616,7 +608,7 @@
 /*
 ** RB_CalcColorFromOneMinusEntity
 */
-void RB_CalcColorFromOneMinusEntity( unsigned char *dstColors )
+void RB_CalcColorFromOneMinusEntity( color4ub_t *dstColors, int numVertexes )
 {
 	int	i;
 	int *pColors = ( int * ) dstColors;
@@ -633,7 +625,7 @@
 
 	c = * ( int * ) invModulate;
 
-	for ( i = 0; i < tess.numVertexes; i++, pColors++ )
+	for ( i = 0; i < numVertexes; i++, pColors++ )
 	{
 		*pColors = * ( int * ) invModulate;
 	}
@@ -642,52 +634,48 @@
 /*
 ** RB_CalcAlphaFromEntity
 */
-void RB_CalcAlphaFromEntity( unsigned char *dstColors )
+void RB_CalcAlphaFromEntity( color4ub_t *dstColors, int numVertexes )
 {
 	int	i;
 
 	if ( !backEnd.currentEntity )
 		return;
 
-	dstColors += 3;
-
-	for ( i = 0; i < tess.numVertexes; i++, dstColors += 4 )
+	for ( i = 0; i < numVertexes; i++, dstColors++ )
 	{
-		*dstColors = backEnd.currentEntity->e.shaderRGBA[3];
+		(*dstColors)[3] = backEnd.currentEntity->e.shaderRGBA[3];
 	}
 }
 
 /*
 ** RB_CalcAlphaFromOneMinusEntity
 */
-void RB_CalcAlphaFromOneMinusEntity( unsigned char *dstColors )
+void RB_CalcAlphaFromOneMinusEntity( color4ub_t *dstColors, int numVertexes )
 {
 	int	i;
 
 	if ( !backEnd.currentEntity )
 		return;
 
-	dstColors += 3;
-
-	for ( i = 0; i < tess.numVertexes; i++, dstColors += 4 )
+	for ( i = 0; i < numVertexes; i++, dstColors++ )
 	{
-		*dstColors = 0xff - backEnd.currentEntity->e.shaderRGBA[3];
+		(*dstColors)[3] = 0xff - backEnd.currentEntity->e.shaderRGBA[3];
 	}
 }
 
 /*
 ** RB_CalcWaveColor
 */
-void RB_CalcWaveColor( const waveForm_t *wf, unsigned char *dstColors )
+void RB_CalcWaveColor( const waveForm_t *wf, color4ub_t *dstColors, int numVertexes )
 {
 	int i;
 	int v;
 	float glow;
 	int *colors = ( int * ) dstColors;
-	byte	color[4];
+	color4ub_t	color;
 
 
-  if ( wf->func == GF_NOISE ) {
+	if ( wf->func == GF_NOISE ) {
 		glow = wf->base + R_NoiseGet4f( 0, 0, 0, ( tess.shaderTime + wf->phase ) * wf->frequency ) * wf->amplitude;
 	} else {
 		glow = EvalWaveForm( wf ) * tr.identityLight;
@@ -705,7 +693,7 @@
 	color[3] = 255;
 	v = *(int *)color;
 	
-	for ( i = 0; i < tess.numVertexes; i++, colors++ ) {
+	for ( i = 0; i < numVertexes; i++, colors++ ) {
 		*colors = v;
 	}
 }
@@ -713,7 +701,7 @@
 /*
 ** RB_CalcWaveAlpha
 */
-void RB_CalcWaveAlpha( const waveForm_t *wf, unsigned char *dstColors )
+void RB_CalcWaveAlpha( const waveForm_t *wf, color4ub_t *dstColors, int numVertexes )
 {
 	int i;
 	int v;
@@ -723,69 +711,75 @@
 
 	v = 255 * glow;
 
-	for ( i = 0; i < tess.numVertexes; i++, dstColors += 4 )
+	for ( i = 0; i < numVertexes; i++, dstColors++ )
 	{
-		dstColors[3] = v;
+		(*dstColors)[3] = v;
 	}
 }
 
 /*
 ** RB_CalcModulateColorsByFog
 */
-void RB_CalcModulateColorsByFog( unsigned char *colors ) {
+void RB_CalcModulateColorsByFog( color4ub_t *colors, int numVertexes ) {
 	int		i;
-	float	texCoords[SHADER_MAX_VERTEXES][2];
+	vec2_t	*texCoords;
 
 	// calculate texcoords so we can derive density
 	// this is not wasted, because it would only have
 	// been previously called if the surface was opaque
-	RB_CalcFogTexCoords( texCoords[0] );
+	texCoords = RB_AllocScratch( sizeof(vec2_t) * numVertexes );
+	RB_CalcFogTexCoords( texCoords, numVertexes );
 
-	for ( i = 0; i < tess.numVertexes; i++, colors += 4 ) {
+	for ( i = 0; i < numVertexes; i++, colors++ ) {
 		float f = 1.0 - R_FogFactor( texCoords[i][0], texCoords[i][1] );
-		colors[0] *= f;
-		colors[1] *= f;
-		colors[2] *= f;
+		(*colors)[0] *= f;
+		(*colors)[1] *= f;
+		(*colors)[2] *= f;
 	}
+	RB_FreeScratch( texCoords );
 }
 
 /*
 ** RB_CalcModulateAlphasByFog
 */
-void RB_CalcModulateAlphasByFog( unsigned char *colors ) {
+void RB_CalcModulateAlphasByFog( color4ub_t *colors, int numVertexes ) {
 	int		i;
-	float	texCoords[SHADER_MAX_VERTEXES][2];
+	vec2_t	*texCoords;
 
 	// calculate texcoords so we can derive density
 	// this is not wasted, because it would only have
 	// been previously called if the surface was opaque
-	RB_CalcFogTexCoords( texCoords[0] );
+	texCoords = RB_AllocScratch( sizeof(vec2_t) * numVertexes );
+	RB_CalcFogTexCoords( texCoords, numVertexes );
 
-	for ( i = 0; i < tess.numVertexes; i++, colors += 4 ) {
+	for ( i = 0; i < numVertexes; i++, colors++ ) {
 		float f = 1.0 - R_FogFactor( texCoords[i][0], texCoords[i][1] );
-		colors[3] *= f;
+		(*colors)[3] *= f;
 	}
+	RB_FreeScratch( texCoords );
 }
 
 /*
 ** RB_CalcModulateRGBAsByFog
 */
-void RB_CalcModulateRGBAsByFog( unsigned char *colors ) {
+void RB_CalcModulateRGBAsByFog( color4ub_t *colors, int numVertexes ) {
 	int		i;
-	float	texCoords[SHADER_MAX_VERTEXES][2];
+	vec2_t	*texCoords;
 
 	// calculate texcoords so we can derive density
 	// this is not wasted, because it would only have
 	// been previously called if the surface was opaque
-	RB_CalcFogTexCoords( texCoords[0] );
+	texCoords = RB_AllocScratch( sizeof(vec2_t) * numVertexes );
+	RB_CalcFogTexCoords( texCoords, numVertexes );
 
-	for ( i = 0; i < tess.numVertexes; i++, colors += 4 ) {
+	for ( i = 0; i < numVertexes; i++, colors++ ) {
 		float f = 1.0 - R_FogFactor( texCoords[i][0], texCoords[i][1] );
-		colors[0] *= f;
-		colors[1] *= f;
-		colors[2] *= f;
-		colors[3] *= f;
+		(*colors)[0] *= f;
+		(*colors)[1] *= f;
+		(*colors)[2] *= f;
+		(*colors)[3] *= f;
 	}
+	RB_FreeScratch( texCoords );
 }
 
 
@@ -806,9 +800,8 @@
 doesn't fit our shader data.
 ========================
 */
-void RB_CalcFogTexCoords( float *st ) {
+void RB_CalcFogTexCoords( vec2_t *st, int numVertexes ) {
 	int			i;
-	float		*v;
 	float		s, t;
 	float		eyeT;
 	qboolean	eyeOutside;
@@ -858,10 +851,10 @@
 	fogDistanceVector[3] += 1.0/512;
 
 	// calculate density for each point
-	for (i = 0, v = tess.xyz[0] ; i < tess.numVertexes ; i++, v += 4) {
+	for (i = 0 ; i < numVertexes ; i++, st++ ) {
 		// calculate the length in fog
-		s = DotProduct( v, fogDistanceVector ) + fogDistanceVector[3];
-		t = DotProduct( v, fogDepthVector ) + fogDepthVector[3];
+		s = DotProduct( tess.vertexPtr2[i].xyz, fogDistanceVector ) + fogDistanceVector[3];
+		t = DotProduct( tess.vertexPtr2[i].xyz, fogDepthVector ) + fogDepthVector[3];
 
 		// partially clipped fogs use the T axis		
 		if ( eyeOutside ) {
@@ -878,9 +871,8 @@
 			}
 		}
 
-		st[0] = s;
-		st[1] = t;
-		st += 2;
+		(*st)[0] = s;
+		(*st)[1] = t;
 	}
 }
 
@@ -889,70 +881,68 @@
 /*
 ** RB_CalcEnvironmentTexCoords
 */
-void RB_CalcEnvironmentTexCoords( float *st ) 
+void RB_CalcEnvironmentTexCoords( vec2_t *st, int numVertexes )
 {
-	int			i;
-	float		*v, *normal;
+	int		i;
+	vec3_t		*normal;
 	vec3_t		viewer, reflected;
 	float		d;
 
-	v = tess.xyz[0];
-	normal = tess.normal[0];
-
-	for (i = 0 ; i < tess.numVertexes ; i++, v += 4, normal += 4, st += 2 ) 
+	for (i = 0 ; i < numVertexes ; i++, st++ ) 
 	{
-		VectorSubtract (backEnd.or.viewOrigin, v, viewer);
+		VectorSubtract (backEnd.or.viewOrigin, tess.vertexPtr2[i].xyz, viewer);
 		VectorNormalizeFast (viewer);
 
-		d = DotProduct (normal, viewer);
+		normal = &tess.vertexPtr3[i].normal;
+		d = DotProduct (*normal, viewer);
 
-		reflected[0] = normal[0]*2*d - viewer[0];
-		reflected[1] = normal[1]*2*d - viewer[1];
-		reflected[2] = normal[2]*2*d - viewer[2];
+		reflected[0] = (*normal[0])*2*d - viewer[0];
+		reflected[1] = (*normal[1])*2*d - viewer[1];
+		reflected[2] = (*normal[2])*2*d - viewer[2];
 
-		st[0] = 0.5 + reflected[1] * 0.5;
-		st[1] = 0.5 - reflected[2] * 0.5;
+		(*st)[0] = 0.5 + reflected[1] * 0.5;
+		(*st)[1] = 0.5 - reflected[2] * 0.5;
 	}
 }
 
 /*
 ** RB_CalcTurbulentTexCoords
 */
-void RB_CalcTurbulentTexCoords( const waveForm_t *wf, float *st )
+void RB_CalcTurbulentTexCoords( const waveForm_t *wf, vec2_t *st, int numVertexes )
 {
 	int i;
 	float now;
 
 	now = ( wf->phase + tess.shaderTime * wf->frequency );
 
-	for ( i = 0; i < tess.numVertexes; i++, st += 2 )
+	for ( i = 0; i < numVertexes; i++, st++ )
 	{
-		float s = st[0];
-		float t = st[1];
+		float s = (*st)[0];
+		float t = (*st)[1];
 
-		st[0] = s + tr.sinTable[ ( ( int ) ( ( ( tess.xyz[i][0] + tess.xyz[i][2] )* 1.0/128 * 0.125 + now ) * FUNCTABLE_SIZE ) ) & ( FUNCTABLE_MASK ) ] * wf->amplitude;
-		st[1] = t + tr.sinTable[ ( ( int ) ( ( tess.xyz[i][1] * 1.0/128 * 0.125 + now ) * FUNCTABLE_SIZE ) ) & ( FUNCTABLE_MASK ) ] * wf->amplitude;
+		(*st)[0] = s + tr.sinTable[ ( ( int ) ( ( ( tess.vertexPtr2[i].xyz[0] + tess.vertexPtr2[i].xyz[2] )* 1.0/128 * 0.125 + now ) * FUNCTABLE_SIZE ) ) & ( FUNCTABLE_MASK ) ] * wf->amplitude;
+		(*st)[1] = t + tr.sinTable[ ( ( int ) ( ( tess.vertexPtr2[i].xyz[1] * 1.0/128 * 0.125 + now ) * FUNCTABLE_SIZE ) ) & ( FUNCTABLE_MASK ) ] * wf->amplitude;
 	}
 }
 
 /*
 ** RB_CalcScaleTexCoords
 */
-void RB_CalcScaleTexCoords( const float scale[2], float *st )
+void RB_CalcScaleTexCoords( const float scale[2], vec2_t *st, int numVertexes )
 {
 	int i;
 
-	for ( i = 0; i < tess.numVertexes; i++, st += 2 )
+	for ( i = 0; i < numVertexes; i++, st++ )
 	{
-		st[0] *= scale[0];
-		st[1] *= scale[1];
+		(*st)[0] *= scale[0];
+		(*st)[1] *= scale[1];
 	}
 }
 
 /*
 ** RB_CalcScrollTexCoords
 */
-void RB_CalcScrollTexCoords( const float scrollSpeed[2], float *st )
+void RB_CalcScrollTexCoords( const float scrollSpeed[2], vec2_t *st, int numVertexes )
 {
 	int i;
 	float timeScale = tess.shaderTime;
@@ -966,34 +956,34 @@
 	adjustedScrollS = adjustedScrollS - floor( adjustedScrollS );
 	adjustedScrollT = adjustedScrollT - floor( adjustedScrollT );
 
-	for ( i = 0; i < tess.numVertexes; i++, st += 2 )
+	for ( i = 0; i < numVertexes; i++, st++ )
 	{
-		st[0] += adjustedScrollS;
-		st[1] += adjustedScrollT;
+		(*st)[0] += adjustedScrollS;
+		(*st)[1] += adjustedScrollT;
 	}
 }
 
 /*
 ** RB_CalcTransformTexCoords
 */
-void RB_CalcTransformTexCoords( const texModInfo_t *tmi, float *st  )
+void RB_CalcTransformTexCoords( const texModInfo_t *tmi, vec2_t *st, int numVertexes )
 {
 	int i;
 
-	for ( i = 0; i < tess.numVertexes; i++, st += 2 )
+	for ( i = 0; i < numVertexes; i++, st++ )
 	{
-		float s = st[0];
-		float t = st[1];
+		float s = (*st)[0];
+		float t = (*st)[1];
 
-		st[0] = s * tmi->matrix[0][0] + t * tmi->matrix[1][0] + tmi->translate[0];
-		st[1] = s * tmi->matrix[0][1] + t * tmi->matrix[1][1] + tmi->translate[1];
+		(*st)[0] = s * tmi->matrix[0][0] + t * tmi->matrix[1][0] + tmi->translate[0];
+		(*st)[1] = s * tmi->matrix[0][1] + t * tmi->matrix[1][1] + tmi->translate[1];
 	}
 }
 
 /*
 ** RB_CalcRotateTexCoords
 */
-void RB_CalcRotateTexCoords( float degsPerSecond, float *st )
+void RB_CalcRotateTexCoords( float degsPerSecond, vec2_t *st, int numVertexes )
 {
 	float timeScale = tess.shaderTime;
 	float degs;
@@ -1015,7 +1005,7 @@
 	tmi.matrix[1][1] = cosValue;
 	tmi.translate[1] = 0.5 - 0.5 * sinValue - 0.5 * cosValue;
 
-	RB_CalcTransformTexCoords( &tmi, st );
+	RB_CalcTransformTexCoords( &tmi, st, numVertexes );
 }
 
 
@@ -1041,39 +1031,33 @@
 */
 vec3_t lightOrigin = { -960, 1980, 96 };		// FIXME: track dynamically
 
-void RB_CalcSpecularAlpha( unsigned char *alphas ) {
+void RB_CalcSpecularAlpha( color4ub_t *alphas, int numVertexes ) {
 	int			i;
-	float		*v, *normal;
+	vec3_t		*normal;
 	vec3_t		viewer,  reflected;
 	float		l, d;
 	int			b;
 	vec3_t		lightDir;
-	int			numVertexes;
 
-	v = tess.xyz[0];
-	normal = tess.normal[0];
-
-	alphas += 3;
-
-	numVertexes = tess.numVertexes;
-	for (i = 0 ; i < numVertexes ; i++, v += 4, normal += 4, alphas += 4) {
+	for (i = 0 ; i < numVertexes ; i++, alphas++) {
 		float ilength;
 
-		VectorSubtract( lightOrigin, v, lightDir );
+		VectorSubtract( lightOrigin, tess.vertexPtr2[i].xyz, lightDir );
 //		ilength = Q_rsqrt( DotProduct( lightDir, lightDir ) );
 		VectorNormalizeFast( lightDir );
 
 		// calculate the specular color
-		d = DotProduct (normal, lightDir);
+		normal = &tess.vertexPtr3[i].normal;
+		d = DotProduct (*normal, lightDir);
 //		d *= ilength;
 
 		// we don't optimize for the d < 0 case since this tends to
 		// cause visual artifacts such as faceted "snapping"
-		reflected[0] = normal[0]*2*d - lightDir[0];
-		reflected[1] = normal[1]*2*d - lightDir[1];
-		reflected[2] = normal[2]*2*d - lightDir[2];
+		reflected[0] = (*normal)[0]*2*d - lightDir[0];
+		reflected[1] = (*normal)[1]*2*d - lightDir[1];
+		reflected[2] = (*normal)[2]*2*d - lightDir[2];
 
-		VectorSubtract (backEnd.or.viewOrigin, v, viewer);
+		VectorSubtract (backEnd.or.viewOrigin, tess.vertexPtr2[i].xyz, viewer);
 		ilength = Q_rsqrt( DotProduct( viewer, viewer ) );
 		l = DotProduct (reflected, viewer);
 		l *= ilength;
@@ -1089,7 +1073,7 @@
 			}
 		}
 
-		*alphas = b;
+		(*alphas)[3] = b;
 	}
 }
 
@@ -1099,14 +1083,12 @@
 ** The basic vertex lighting calc
 */
 #if idppc_altivec
-static void RB_CalcDiffuseColor_altivec( unsigned char *colors )
+static void RB_CalcDiffuseColor_altivec( color4ub_t *colors, int numVertexes )
 {
 	int				i;
-	float			*v, *normal;
 	trRefEntity_t	*ent;
 	int				ambientLightInt;
 	vec3_t			lightDir;
-	int				numVertexes;
 	vector unsigned char vSel = VECCONST_UINT8(0x00, 0x00, 0x00, 0xff,
                                                0x00, 0x00, 0x00, 0xff,
                                                0x00, 0x00, 0x00, 0xff,
@@ -1142,14 +1124,10 @@
 	zero = (vector float)vec_splat_s8(0);
 	VectorCopy( ent->lightDir, lightDir );
 
-	v = tess.xyz[0];
-	normal = tess.normal[0];
-
-	normalPerm = vec_lvsl(0,normal);
-	numVertexes = tess.numVertexes;
-	for (i = 0 ; i < numVertexes ; i++, v += 4, normal += 4) {
-		normalVec0 = vec_ld(0,(vector float *)normal);
-		normalVec1 = vec_ld(11,(vector float *)normal);
+	normalPerm = vec_lvsl(0,&tess.vertexPtr3[0].normal);
+	for (i = 0 ; i < numVertexes ; i++) {
+		normalVec0 = vec_ld(0,(vector float *)&tess.vertexPtr3[i].normal);
+		normalVec1 = vec_ld(11,(vector float *)&tess.vertexPtr3[i].normal);
 		normalVec0 = vec_perm(normalVec0,normalVec1,normalPerm);
 		incomingVec0 = vec_madd(normalVec0, lightDirVec, zero);
 		incomingVec1 = vec_sld(incomingVec0,incomingVec0,4);
@@ -1164,69 +1142,65 @@
 		jVecShort = vec_pack(jVecInt,jVecInt);		// RGBxRGBx
 		jVecChar = vec_packsu(jVecShort,jVecShort);	// RGBxRGBxRGBxRGBx
 		jVecChar = vec_sel(jVecChar,vSel,vSel);		// RGBARGBARGBARGBA replace alpha with 255
-		vec_ste((vector unsigned int)jVecChar,0,(unsigned int *)&colors[i*4]);	// store color
+		vec_ste((vector unsigned int)jVecChar,0,(unsigned int *)&colors[i]);	// store color
 	}
 }
 #endif
 
-static void RB_CalcDiffuseColor_scalar( unsigned char *colors )
+static void RB_CalcDiffuseColor_scalar( color4ub_t *colors, int numVertexes )
 {
 	int				i, j;
-	float			*v, *normal;
 	float			incoming;
 	trRefEntity_t	*ent;
 	int				ambientLightInt;
+	vec3_t			*normal;
 	vec3_t			ambientLight;
 	vec3_t			lightDir;
 	vec3_t			directedLight;
-	int				numVertexes;
 	ent = backEnd.currentEntity;
 	ambientLightInt = ent->ambientLightInt;
 	VectorCopy( ent->ambientLight, ambientLight );
 	VectorCopy( ent->directedLight, directedLight );
 	VectorCopy( ent->lightDir, lightDir );
 
-	v = tess.xyz[0];
-	normal = tess.normal[0];
-
-	numVertexes = tess.numVertexes;
-	for (i = 0 ; i < numVertexes ; i++, v += 4, normal += 4) {
-		incoming = DotProduct (normal, lightDir);
+	for (i = 0 ; i < numVertexes ; i++) {
+		normal = &tess.vertexPtr3[i].normal;
+		incoming = DotProduct (*normal, lightDir);
 		if ( incoming <= 0 ) {
-			*(int *)&colors[i*4] = ambientLightInt;
-			continue;
-		} 
-		j = myftol( ambientLight[0] + incoming * directedLight[0] );
-		if ( j > 255 ) {
-			j = 255;
+			*(int *)&colors[i] = ambientLightInt;
+		} else {
+			j = myftol( ambientLight[0] + incoming * directedLight[0] );
+			if ( j > 255 ) {
+				j = 255;
+			}
+			colors[i][0] = j;
+			
+			j = myftol( ambientLight[1] + incoming * directedLight[1] );
+			if ( j > 255 ) {
+				j = 255;
+			}
+			colors[i][1] = j;
+			
+			j = myftol( ambientLight[2] + incoming * directedLight[2] );
+			if ( j > 255 ) {
+				j = 255;
+			}
+			colors[i][2] = j;
+			
+			colors[i][3] = 255;
 		}
-		colors[i*4+0] = j;
-
-		j = myftol( ambientLight[1] + incoming * directedLight[1] );
-		if ( j > 255 ) {
-			j = 255;
-		}
-		colors[i*4+1] = j;
-
-		j = myftol( ambientLight[2] + incoming * directedLight[2] );
-		if ( j > 255 ) {
-			j = 255;
-		}
-		colors[i*4+2] = j;
-
-		colors[i*4+3] = 255;
 	}
 }
 
-void RB_CalcDiffuseColor( unsigned char *colors )
+void RB_CalcDiffuseColor( color4ub_t *colors, int numVertexes )
 {
 #if idppc_altivec
 	if (com_altivec->integer) {
 		// must be in a seperate function or G3 systems will crash.
-		RB_CalcDiffuseColor_altivec( colors );
+	  RB_CalcDiffuseColor_altivec( colors, numVertexes );
 		return;
 	}
 #endif
-	RB_CalcDiffuseColor_scalar( colors );
+	RB_CalcDiffuseColor_scalar( colors, numVertexes );
 }
 
Index: src/renderer/tr_font.c
===================================================================
--- src/renderer/tr_font.c	(Revision 2062)
+++ src/renderer/tr_font.c	(Arbeitskopie)
@@ -117,14 +117,14 @@
   if ( glyph->format == ft_glyph_format_outline ) {
     size   = pitch*height; 
 
-    bit2 = Z_Malloc(sizeof(FT_Bitmap));
+    bit2 = ri.Malloc(sizeof(FT_Bitmap));
 
     bit2->width      = width;
     bit2->rows       = height;
     bit2->pitch      = pitch;
     bit2->pixel_mode = ft_pixel_mode_grays;
     //bit2->pixel_mode = ft_pixel_mode_mono;
-    bit2->buffer     = Z_Malloc(pitch*height);
+    bit2->buffer     = ri.Malloc(pitch*height);
     bit2->num_grays = 256;
 
     Com_Memset( bit2->buffer, 0, size );
@@ -150,7 +150,7 @@
 	byte	*buffer;
 	int		i, c;
 
-	buffer = Z_Malloc(width*height*4 + 18);
+	buffer = ri.Malloc(width*height*4 + 18);
 	Com_Memset (buffer, 0, 18);
 	buffer[2] = 2;		// uncompressed type
 	buffer[12] = width&255;
@@ -175,7 +175,7 @@
 	//fwrite (buffer, 1, c, f);
 	//fclose (f);
 
-	Z_Free (buffer);
+	ri.Free (buffer);
 }
 
 static glyphInfo_t *RE_ConstructGlyphInfo(unsigned char *imageOut, int *xOut, int *yOut, int *maxHeight, FT_Face face, const unsigned char c, qboolean calcHeight) {
@@ -201,8 +201,8 @@
     }
 
     if (calcHeight) {
-      Z_Free(bitmap->buffer);
-      Z_Free(bitmap);
+      ri.Free(bitmap->buffer);
+      ri.Free(bitmap);
       return &glyph;
     }
 
@@ -223,8 +223,8 @@
       if (*yOut + *maxHeight + 1 >= 255) {
         *yOut = -1;
         *xOut = -1;
-        Z_Free(bitmap->buffer);
-        Z_Free(bitmap);
+        ri.Free(bitmap->buffer);
+        ri.Free(bitmap);
         return &glyph;
       } else {
         *xOut = 0;
@@ -233,8 +233,8 @@
     } else if (*yOut + *maxHeight + 1 >= 255) {
       *yOut = -1;
       *xOut = -1;
-      Z_Free(bitmap->buffer);
-      Z_Free(bitmap);
+      ri.Free(bitmap->buffer);
+      ri.Free(bitmap);
       return &glyph;
     }
 
@@ -289,8 +289,8 @@
     *xOut += scaled_width + 1;
   }
 
-  Z_Free(bitmap->buffer);
-  Z_Free(bitmap);
+  ri.Free(bitmap->buffer);
+  ri.Free(bitmap);
 
   return &glyph;
 }
@@ -333,6 +333,7 @@
   int j, k, xOut, yOut, lastStart, imageNumber;
   int scaledSize, newSize, maxHeight, left, satLevels;
   unsigned char *out, *imageBuff;
+  texImage_t	pic;
   glyphInfo_t *glyph;
   image_t *image;
   qhandle_t h;
@@ -436,9 +437,9 @@
   // make a 256x256 image buffer, once it is full, register it, clean it and keep going 
   // until all glyphs are rendered
 
-  out = Z_Malloc(1024*1024);
+  out = ri.Malloc(1024*1024);
   if (out == NULL) {
-    ri.Printf(PRINT_ALL, "RE_RegisterFont: Z_Malloc failure during output image creation.\n");
+    ri.Printf(PRINT_ALL, "RE_RegisterFont: Malloc failure during output image creation.\n");
     return;
   }
   Com_Memset(out, 0, 1024*1024);
@@ -466,7 +467,7 @@
 
       scaledSize = 256*256;
       newSize = scaledSize * 4;
-      imageBuff = Z_Malloc(newSize);
+      imageBuff = ri.Malloc(newSize);
       left = 0;
       max = 0;
       satLevels = 255;
@@ -494,8 +495,13 @@
 			}
 
     	//Com_sprintf (name, sizeof(name), "fonts/fontImage_%i_%i", imageNumber++, pointSize);
-      image = R_CreateImage(name, imageBuff, 256, 256, qfalse, qfalse, GL_CLAMP_TO_EDGE);
-      h = RE_RegisterShaderFromImage(name, LIGHTMAP_2D, image, qfalse);
+	pic.format = GL_RGBA8;
+	pic.numMipmaps = 1;
+	pic.data[0] = imageBuff;
+
+	image = R_CreateImage(name, &pic, 256, 256, qfalse, qfalse, GL_CLAMP_TO_EDGE);
+	h = RE_RegisterShaderFromImage(name, LIGHTMAP_2D, image, qfalse);
+
       for (j = lastStart; j < i; j++) {
         font->glyphs[j].glyph = h;
 				Q_strncpyz(font->glyphs[j].shaderName, name, sizeof(font->glyphs[j].shaderName));
@@ -504,7 +510,7 @@
 		  Com_Memset(out, 0, 1024*1024);
       xOut = 0;
       yOut = 0;
-      Z_Free(imageBuff);
+      ri.Free(imageBuff);
 			i++;
     } else {
       Com_Memcpy(&font->glyphs[i], glyph, sizeof(glyphInfo_t));
@@ -520,7 +526,7 @@
 		ri.FS_WriteFile(va("fonts/fontImage_%i.dat", pointSize), font, sizeof(fontInfo_t));
 	}
 
-  Z_Free(out);
+  ri.Free(out);
   
   ri.FS_FreeFile(faceData);
 #endif
Index: src/renderer/tr_shadows.c
===================================================================
--- src/renderer/tr_shadows.c	(Revision 2062)
+++ src/renderer/tr_shadows.c	(Arbeitskopie)
@@ -42,9 +42,9 @@
 
 #define	MAX_EDGE_DEFS	32
 
-static	edgeDef_t	edgeDefs[SHADER_MAX_VERTEXES][MAX_EDGE_DEFS];
-static	int			numEdgeDefs[SHADER_MAX_VERTEXES];
-static	int			facing[SHADER_MAX_INDEXES/3];
+static	edgeDef_t	*edgeDefs;
+static	int		*numEdgeDefs;
+static	int		*facing;
 
 void R_AddEdgeDef( int i1, int i2, int facing ) {
 	int		c;
@@ -53,42 +53,122 @@
 	if ( c == MAX_EDGE_DEFS ) {
 		return;		// overflow
 	}
-	edgeDefs[ i1 ][ c ].i2 = i2;
-	edgeDefs[ i1 ][ c ].facing = facing;
+	edgeDefs[ i1 * MAX_EDGE_DEFS + c ].i2 = i2;
+	edgeDefs[ i1 * MAX_EDGE_DEFS + c ].facing = facing;
 
 	numEdgeDefs[ i1 ]++;
 }
 
-void R_RenderShadowEdges( void ) {
-	int		i;
+void R_RenderShadowEdges( glRenderState_t *state ) {
+	int		i, idx = 0;
+	int		numTris, numShadowTris;
 
+	numTris = tess.numIndexes / 3;
+	numShadowTris = numTris * 6;
+
+	state->program = tr.shadowShader->GLSLprogram;
+	SetAttrVec4f( state, AL_TRANSX,
+		      backEnd.currentEntity->e.axis[0][0],
+		      backEnd.currentEntity->e.axis[1][0],
+		      backEnd.currentEntity->e.axis[2][0],
+		      backEnd.currentEntity->e.origin[0] );
+	SetAttrVec4f( state, AL_TRANSY,
+		      backEnd.currentEntity->e.axis[0][1],
+		      backEnd.currentEntity->e.axis[1][1],
+		      backEnd.currentEntity->e.axis[2][1],
+		      backEnd.currentEntity->e.origin[1] );
+	SetAttrVec4f( state, AL_TRANSZ,
+		      backEnd.currentEntity->e.axis[0][2],
+		      backEnd.currentEntity->e.axis[1][2],
+		      backEnd.currentEntity->e.axis[2][2],
+		      backEnd.currentEntity->e.origin[2] );
 #if 0
-	int		numTris;
 
 	// dumb way -- render every triangle's edges
-	numTris = tess.numIndexes / 3;
+	SetAttrPointer( state, AL_VERTEX, 0,
+			3, GL_FLOAT, sizeof(vaWord2_t),
+			&tess.vertexPtr2[0].xyz );
+	
+	if ( tess.indexInc == sizeof( GLuint ) ) {
+		GLuint *indexPtr32 = tess.indexPtr.p32;
+		GLuint *indexes;
+		
+		indexes = RB_AllocScratch( 3 * numShadowTris * sizeof( GLuint ) );
+	
+		for ( i = 0 ; i < numTris ; i++ ) {
+			int		i1, i2, i3;
+			
+			if ( !facing[i] ) {
+				continue;
+			}
 
-	for ( i = 0 ; i < numTris ; i++ ) {
-		int		i1, i2, i3;
+			i1 = indexPtr32[ i*3 + 0 ];
+			i2 = indexPtr32[ i*3 + 1 ];
+			i3 = indexPtr32[ i*3 + 2 ];
+			
+			indexes32[idx++] = i1;
+			indexes32[idx++] = i1 + tess.numVertexes;
+			indexes32[idx++] = i2;
+			indexes32[idx++] = i2;
+			indexes32[idx++] = i1 + tess.numVertexes;
+			indexes32[idx++] = i2 + tess.numVertexes;
 
-		if ( !facing[i] ) {
-			continue;
+			indexes32[idx++] = i2;
+			indexes32[idx++] = i2 + tess.numVertexes;
+			indexes32[idx++] = i3;
+			indexes32[idx++] = i3;
+			indexes32[idx++] = i2 + tess.numVertexes;
+			indexes32[idx++] = i3 + tess.numVertexes;
+
+			indexes32[idx++] = i3;
+			indexes32[idx++] = i3 + tess.numVertexes;
+			indexes32[idx++] = i1;
+			indexes32[idx++] = i1;
+			indexes32[idx++] = i3 + tess.numVertexes;
+			indexes32[idx++] = i1 + tess.numVertexes;
 		}
+		GL_DrawElements( state, idx, 0, indexes32, 0, idx-1, 65537 );
+		RB_FreeScratch( indexes );
+	} else {
+		GLushort	*indexPtr = tess.indexPtr.p16;
+		GLushort	*indexes;
+		
+		indexes = RB_AllocScratch( 3 * numShadowTris * sizeof( GLushort ) );
+	
+		for ( i = 0 ; i < numTris ; i++ ) {
+			int		i1, i2, i3;
+			
+			if ( !facing[i] ) {
+				continue;
+			}
 
-		i1 = tess.indexes[ i*3 + 0 ];
-		i2 = tess.indexes[ i*3 + 1 ];
-		i3 = tess.indexes[ i*3 + 2 ];
+			i1 = indexPtr[ i*3 + 0 ];
+			i2 = indexPtr[ i*3 + 1 ];
+			i3 = indexPtr[ i*3 + 2 ];
 
-		qglBegin( GL_TRIANGLE_STRIP );
-		qglVertex3fv( tess.xyz[ i1 ] );
-		qglVertex3fv( tess.xyz[ i1 + tess.numVertexes ] );
-		qglVertex3fv( tess.xyz[ i2 ] );
-		qglVertex3fv( tess.xyz[ i2 + tess.numVertexes ] );
-		qglVertex3fv( tess.xyz[ i3 ] );
-		qglVertex3fv( tess.xyz[ i3 + tess.numVertexes ] );
-		qglVertex3fv( tess.xyz[ i1 ] );
-		qglVertex3fv( tess.xyz[ i1 + tess.numVertexes ] );
-		qglEnd();
+			indexes[idx++] = i1;
+			indexes[idx++] = i1 + tess.numVertexes;
+			indexes[idx++] = i2;
+			indexes[idx++] = i2;
+			indexes[idx++] = i1 + tess.numVertexes;
+			indexes[idx++] = i2 + tess.numVertexes;
+
+			indexes[idx++] = i2;
+			indexes[idx++] = i2 + tess.numVertexes;
+			indexes[idx++] = i3;
+			indexes[idx++] = i3;
+			indexes[idx++] = i2 + tess.numVertexes;
+			indexes[idx++] = i3 + tess.numVertexes;
+
+			indexes[idx++] = i3;
+			indexes[idx++] = i3 + tess.numVertexes;
+			indexes[idx++] = i1;
+			indexes[idx++] = i1;
+			indexes[idx++] = i3 + tess.numVertexes;
+			indexes[idx++] = i1 + tess.numVertexes;
+		}
+		GL_DrawElements( state, idx, 0, indexes, 0, idx-1, 0 );
+		RB_FreeScratch( indexes );
 	}
 #else
 	int		c, c2;
@@ -103,39 +183,92 @@
 	// but lots of models have dangling edges or overfanned edges
 	c_edges = 0;
 	c_rejected = 0;
+	SetAttrPointer( state, AL_VERTEX, 0,
+			3, GL_FLOAT, sizeof(vaWord2_t),
+			&tess.vertexPtr2[0].xyz );
 
-	for ( i = 0 ; i < tess.numVertexes ; i++ ) {
-		c = numEdgeDefs[ i ];
-		for ( j = 0 ; j < c ; j++ ) {
-			if ( !edgeDefs[ i ][ j ].facing ) {
-				continue;
+	if ( tess.indexInc == sizeof( GLuint ) ) {
+		GLuint	*indexes32;
+	
+		indexes32 = RB_AllocScratch( 3 * numShadowTris * sizeof( GLuint ) );
+		
+		for ( i = 0 ; i < tess.numVertexes ; i++ ) {
+			c = numEdgeDefs[ i ];
+			for ( j = 0 ; j < c ; j++ ) {
+				if ( !edgeDefs[ i * MAX_EDGE_DEFS + j ].facing ) {
+					continue;
+				}
+				
+				hit[0] = 0;
+				hit[1] = 0;
+				
+				i2 = edgeDefs[ i * MAX_EDGE_DEFS + j ].i2;
+				c2 = numEdgeDefs[ i2 ];
+				for ( k = 0 ; k < c2 ; k++ ) {
+					if ( edgeDefs[ i2 * MAX_EDGE_DEFS + k ].i2 == i ) {
+						hit[ edgeDefs[ i2 * MAX_EDGE_DEFS + k ].facing ]++;
+					}
+				}
+				
+				// if it doesn't share the edge with another front facing
+				// triangle, it is a sil edge
+				if ( hit[ 1 ] == 0 ) {
+					indexes32[idx++] = i;
+					indexes32[idx++] = i + tess.numVertexes;
+					indexes32[idx++] = i2;
+					indexes32[idx++] = i2;
+					indexes32[idx++] = i + tess.numVertexes;
+					indexes32[idx++] = i2 + tess.numVertexes;
+					c_edges++;
+				} else {
+					c_rejected++;
+				}
 			}
-
-			hit[0] = 0;
-			hit[1] = 0;
-
-			i2 = edgeDefs[ i ][ j ].i2;
-			c2 = numEdgeDefs[ i2 ];
-			for ( k = 0 ; k < c2 ; k++ ) {
-				if ( edgeDefs[ i2 ][ k ].i2 == i ) {
-					hit[ edgeDefs[ i2 ][ k ].facing ]++;
+		}
+		GL_DrawElements( state, idx, 0, indexes32,
+				 0, 2*tess.numVertexes - 1, 65537 );
+		RB_FreeScratch( indexes32 );
+	} else {
+		GLushort	*indexes;
+	
+		indexes = RB_AllocScratch( 3 * numShadowTris * sizeof( GLushort ) );
+		
+		for ( i = 0 ; i < tess.numVertexes ; i++ ) {
+			c = numEdgeDefs[ i ];
+			for ( j = 0 ; j < c ; j++ ) {
+				if ( !edgeDefs[ i * MAX_EDGE_DEFS + j ].facing ) {
+					continue;
 				}
+				
+				hit[0] = 0;
+				hit[1] = 0;
+				
+				i2 = edgeDefs[ i * MAX_EDGE_DEFS + j ].i2;
+				c2 = numEdgeDefs[ i2 ];
+				for ( k = 0 ; k < c2 ; k++ ) {
+					if ( edgeDefs[ i2 * MAX_EDGE_DEFS + k ].i2 == i ) {
+						hit[ edgeDefs[ i2 * MAX_EDGE_DEFS + k ].facing ]++;
+					}
+				}
+				
+				// if it doesn't share the edge with another front facing
+				// triangle, it is a sil edge
+				if ( hit[ 1 ] == 0 ) {
+					indexes[idx++] = i;
+					indexes[idx++] = i + tess.numVertexes;
+					indexes[idx++] = i2;
+					indexes[idx++] = i2;
+					indexes[idx++] = i + tess.numVertexes;
+					indexes[idx++] = i2 + tess.numVertexes;
+					c_edges++;
+				} else {
+					c_rejected++;
+				}
 			}
-
-			// if it doesn't share the edge with another front facing
-			// triangle, it is a sil edge
-			if ( hit[ 1 ] == 0 ) {
-				qglBegin( GL_TRIANGLE_STRIP );
-				qglVertex3fv( tess.xyz[ i ] );
-				qglVertex3fv( tess.xyz[ i + tess.numVertexes ] );
-				qglVertex3fv( tess.xyz[ i2 ] );
-				qglVertex3fv( tess.xyz[ i2 + tess.numVertexes ] );
-				qglEnd();
-				c_edges++;
-			} else {
-				c_rejected++;
-			}
 		}
+		GL_DrawElements( state, idx, 0, indexes,
+				 0, 2*tess.numVertexes - 1, 0 );
+		RB_FreeScratch( indexes );
 	}
 #endif
 }
@@ -156,13 +289,8 @@
 	int		i;
 	int		numTris;
 	vec3_t	lightDir;
-	GLboolean rgba[4];
+	glRenderState_t state;
 
-	// we can only do this if we have enough space in the vertex buffers
-	if ( tess.numVertexes >= SHADER_MAX_VERTEXES / 2 ) {
-		return;
-	}
-
 	if ( glConfig.stencilBits < 4 ) {
 		return;
 	}
@@ -171,29 +299,41 @@
 
 	// project vertexes away from light direction
 	for ( i = 0 ; i < tess.numVertexes ; i++ ) {
-		VectorMA( tess.xyz[i], -512, lightDir, tess.xyz[i+tess.numVertexes] );
+		VectorMA( tess.vertexPtr2[i].xyz, -512,
+			  lightDir, tess.vertexPtr2[i+tess.numVertexes].xyz );
 	}
 
 	// decide which triangles face the light
-	Com_Memset( numEdgeDefs, 0, 4 * tess.numVertexes );
+	numEdgeDefs = RB_AllocScratch( sizeof( int ) * tess.numVertexes );
+	edgeDefs = RB_AllocScratch( sizeof( edgeDef_t ) * tess.numVertexes * MAX_EDGE_DEFS );
+	facing = RB_AllocScratch( sizeof( int ) * tess.numIndexes / 3 );
+	Com_Memset( numEdgeDefs, 0, sizeof(int) * tess.numVertexes );
 
 	numTris = tess.numIndexes / 3;
 	for ( i = 0 ; i < numTris ; i++ ) {
-		int		i1, i2, i3;
+		GLushort	i1, i2, i3;
 		vec3_t	d1, d2, normal;
-		float	*v1, *v2, *v3;
+		vec3_t	*v1, *v2, *v3;
 		float	d;
 
-		i1 = tess.indexes[ i*3 + 0 ];
-		i2 = tess.indexes[ i*3 + 1 ];
-		i3 = tess.indexes[ i*3 + 2 ];
+		if ( tess.indexInc == sizeof( GLuint ) ) {
+			GLuint *indexPtr32 = tess.indexPtr.p32;
+			i1 = indexPtr32[ i*3 + 0 ];
+			i2 = indexPtr32[ i*3 + 1 ];
+			i3 = indexPtr32[ i*3 + 2 ];
+		} else {
+			GLushort *indexPtr = tess.indexPtr.p16;
+			i1 = indexPtr[ i*3 + 0 ];
+			i2 = indexPtr[ i*3 + 1 ];
+			i3 = indexPtr[ i*3 + 2 ];
+		}
+		
+		v1 = &tess.vertexPtr2[i1].xyz;
+		v2 = &tess.vertexPtr2[i2].xyz;
+		v3 = &tess.vertexPtr2[i3].xyz;
 
-		v1 = tess.xyz[ i1 ];
-		v2 = tess.xyz[ i2 ];
-		v3 = tess.xyz[ i3 ];
-
-		VectorSubtract( v2, v1, d1 );
-		VectorSubtract( v3, v1, d2 );
+		VectorSubtract( *v2, *v1, d1 );
+		VectorSubtract( *v3, *v1, d2 );
 		CrossProduct( d1, d2, normal );
 
 		d = DotProduct( normal, lightDir );
@@ -210,45 +350,42 @@
 	}
 
 	// draw the silhouette edges
+	InitState( &state );
 
-	GL_Bind( tr.whiteImage );
-	qglEnable( GL_CULL_FACE );
-	GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ZERO );
-	qglColor3f( 0.2f, 0.2f, 0.2f );
+	state.numImages = 1;
+	state.image[0] = tr.whiteImage;
+	state.stateBits = GLS_COLORMASK_FALSE;
+	SetAttrVec4f( &state, AL_COLOR, 1.0f, 0.2f, 1.0f, 1.0f );
 
-	// don't write to the color buffer
-	qglGetBooleanv(GL_COLOR_WRITEMASK, rgba);
-	qglColorMask( GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE );
+	if( !backEnd.viewParms.portalLevel ) {
+		qglEnable( GL_STENCIL_TEST );
+		qglStencilFunc( GL_ALWAYS, 1, glGlobals.shadowMask );
+	}
+	qglStencilMask( glGlobals.shadowMask );
 
-	qglEnable( GL_STENCIL_TEST );
-	qglStencilFunc( GL_ALWAYS, 1, 255 );
-
-	// mirrors have the culling order reversed
-	if ( backEnd.viewParms.isMirror ) {
-		qglCullFace( GL_FRONT );
-		qglStencilOp( GL_KEEP, GL_KEEP, GL_INCR );
-
-		R_RenderShadowEdges();
-
-		qglCullFace( GL_BACK );
-		qglStencilOp( GL_KEEP, GL_KEEP, GL_DECR );
-
-		R_RenderShadowEdges();
+	if( qglStencilOpSeparate ) {
+		// single pass, doesn't matter if we incr or decr as we check
+		// for != 0...
+		state.faceCulling = CT_TWO_SIDED;
+		qglStencilOpSeparate( GL_BACK, GL_KEEP, GL_KEEP, GL_INCR_WRAP );
+		qglStencilOpSeparate( GL_FRONT, GL_KEEP, GL_KEEP, GL_DECR_WRAP );
 	} else {
-		qglCullFace( GL_BACK );
+		// two passes for front/back faces
+		state.faceCulling = CT_BACK_SIDED;
 		qglStencilOp( GL_KEEP, GL_KEEP, GL_INCR );
 
-		R_RenderShadowEdges();
+		R_RenderShadowEdges( &state );
 
-		qglCullFace( GL_FRONT );
+		state.faceCulling = CT_FRONT_SIDED;
 		qglStencilOp( GL_KEEP, GL_KEEP, GL_DECR );
-
-		R_RenderShadowEdges();
 	}
+	R_RenderShadowEdges( &state );
 
+	qglStencilOp( GL_KEEP, GL_KEEP, GL_KEEP );
 
-	// reenable writing to the color buffer
-	qglColorMask(rgba[0], rgba[1], rgba[2], rgba[3]);
+	RB_FreeScratch( facing );
+	RB_FreeScratch( edgeDefs );
+	RB_FreeScratch( numEdgeDefs );
 }
 
 
@@ -263,6 +400,14 @@
 =================
 */
 void RB_ShadowFinish( void ) {
+	static vec3_t	vertexes[4] = {
+		{ -100,  100, -10 },
+		{  100,  100, -10 },
+		{  100, -100, -10 },
+		{ -100, -100, -10 }
+	};
+	glRenderState_t state;
+	
 	if ( r_shadows->integer != 2 ) {
 		return;
 	}
@@ -270,30 +415,39 @@
 		return;
 	}
 	qglEnable( GL_STENCIL_TEST );
-	qglStencilFunc( GL_NOTEQUAL, 0, 255 );
+	qglStencilFunc( GL_NOTEQUAL, 0, glGlobals.shadowMask );
+	qglStencilMask( glGlobals.shadowMask );
+	qglStencilOp( GL_ZERO, GL_ZERO, GL_ZERO );
 
-	qglDisable (GL_CLIP_PLANE0);
-	qglDisable (GL_CULL_FACE);
+	InitState( &state );
+	state.faceCulling = CT_TWO_SIDED;
 
-	GL_Bind( tr.whiteImage );
+	state.numImages = 1;
+	state.image[0] = tr.whiteImage;
 
-    qglLoadIdentity ();
+	qglLoadIdentity ();
 
-	qglColor3f( 0.6f, 0.6f, 0.6f );
-	GL_State( GLS_DEPTHMASK_TRUE | GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO );
+	state.program = NULL;
+	SetAttrVec4f( &state, AL_COLOR, 0.6f, 0.6f, 0.6f, 1.0f );
+	state.stateBits = GLS_DEPTHMASK_TRUE |
+		GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
 
-//	qglColor3f( 1, 0, 0 );
-//	GL_State( GLS_DEPTHMASK_TRUE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ZERO );
+	SetAttrPointer( &state, AL_VERTEX, 0,
+			3, GL_FLOAT, sizeof(vec3_t),
+			vertexes );
+	GL_DrawArrays( &state, GL_QUADS, 0, 4 );
 
-	qglBegin( GL_QUADS );
-	qglVertex3f( -100, 100, -10 );
-	qglVertex3f( 100, 100, -10 );
-	qglVertex3f( 100, -100, -10 );
-	qglVertex3f( -100, -100, -10 );
-	qglEnd ();
-
-	qglColor4f(1,1,1,1);
-	qglDisable( GL_STENCIL_TEST );
+	if( !backEnd.viewParms.portalLevel ) {
+		qglDisable( GL_STENCIL_TEST );
+	} else {
+		int		level;
+		GLuint		stencilVal;
+		level = backEnd.viewParms.portalLevel;
+		stencilVal = (level ^ (level >> 1)) << glGlobals.shadowBits;
+		
+		qglStencilFunc( GL_EQUAL, stencilVal, glGlobals.portalMask );
+		qglStencilOp( GL_KEEP, GL_KEEP, GL_KEEP );
+	}
 }
 
 
@@ -304,7 +458,6 @@
 =================
 */
 void RB_ProjectionShadowDeform( void ) {
-	float	*xyz;
 	int		i;
 	float	h;
 	vec3_t	ground;
@@ -313,8 +466,6 @@
 	float	d;
 	vec3_t	lightDir;
 
-	xyz = ( float * ) tess.xyz;
-
 	ground[0] = backEnd.or.axis[0][2];
 	ground[1] = backEnd.or.axis[1][2];
 	ground[2] = backEnd.or.axis[2][2];
@@ -334,11 +485,11 @@
 	light[1] = lightDir[1] * d;
 	light[2] = lightDir[2] * d;
 
-	for ( i = 0; i < tess.numVertexes; i++, xyz += 4 ) {
-		h = DotProduct( xyz, ground ) + groundDist;
+	for ( i = 0; i < tess.numVertexes; i++ ) {
+		h = DotProduct( tess.vertexPtr2[i].xyz, ground ) + groundDist;
 
-		xyz[0] -= light[0] * h;
-		xyz[1] -= light[1] * h;
-		xyz[2] -= light[2] * h;
+		tess.vertexPtr2[i].xyz[0] -= light[0] * h;
+		tess.vertexPtr2[i].xyz[1] -= light[1] * h;
+		tess.vertexPtr2[i].xyz[2] -= light[2] * h;
 	}
 }
Index: src/renderer/tr_flares.c
===================================================================
--- src/renderer/tr_flares.c	(Revision 2062)
+++ src/renderer/tr_flares.c	(Arbeitskopie)
@@ -63,7 +63,7 @@
 
 	int			addedFrame;
 
-	qboolean	inPortal;				// true if in a portal view of the scene
+	int		portalLevel;				// portalLevel if in a portal view of the scene
 	int			frameSceneNum;
 	void		*surface;
 	int			fogNum;
@@ -156,7 +156,7 @@
 	oldest = r_flareStructs;
 	for ( f = r_activeFlares ; f ; f = f->next ) {
 		if ( f->surface == surface && f->frameSceneNum == backEnd.viewParms.frameSceneNum
-			&& f->inPortal == backEnd.viewParms.isPortal ) {
+			&& f->portalLevel == backEnd.viewParms.portalLevel ) {
 			break;
 		}
 	}
@@ -174,7 +174,7 @@
 
 		f->surface = surface;
 		f->frameSceneNum = backEnd.viewParms.frameSceneNum;
-		f->inPortal = backEnd.viewParms.isPortal;
+		f->portalLevel = backEnd.viewParms.portalLevel;
 		f->addedFrame = -1;
 	}
 
@@ -314,7 +314,8 @@
 	vec3_t			color;
 	int				iColor[3];
 	float distance, intensity, factor;
-	byte fogFactors[3] = {255, 255, 255};
+	color4ub_t fogFactors = {255, 255, 255, 255};
+	static GLushort indexes[6] = { 0, 1, 2, 0, 2, 3 };
 
 	backEnd.pc.c_flareRenders++;
 
@@ -354,18 +355,29 @@
 
 	VectorScale(f->color, f->drawIntensity * intensity, color);
 
-// Calculations for fogging
+	tess.numVertexes = 4;
+	tess.numIndexes  = 6;
+	RB_SetupVertexBuffer( tr.flareShader, NULL );
+	
+	// Calculations for fogging
 	if(tr.world && f->fogNum < tr.world->numfogs)
 	{
 		tess.numVertexes = 1;
-		VectorCopy(f->origin, tess.xyz[0]);
+		tess.numIndexes = 0;
+
+		VectorCopy(f->origin, tess.vertexPtr2->xyz);
 		tess.fogNum = f->fogNum;
 	
-		RB_CalcModulateColorsByFog(fogFactors);
+		RB_CalcModulateColorsByFog( &fogFactors, 1);
 		
 		// We don't need to render the flare if colors are 0 anyways.
-		if(!(fogFactors[0] || fogFactors[1] || fogFactors[2]))
+		if(!(fogFactors[0] || fogFactors[1] || fogFactors[2])) {
+			RB_FlushVertexBuffer ();
+			RB_ClearVertexBuffer ();
 			return;
+		}
+		tess.numVertexes = 4;
+		tess.numIndexes  = 6;
 	}
 
 	iColor[0] = color[0] * fogFactors[0];
@@ -375,54 +387,62 @@
 	RB_BeginSurface( tr.flareShader, f->fogNum );
 
 	// FIXME: use quadstamp?
-	tess.xyz[tess.numVertexes][0] = f->windowX - size;
-	tess.xyz[tess.numVertexes][1] = f->windowY - size;
-	tess.texCoords[tess.numVertexes][0][0] = 0;
-	tess.texCoords[tess.numVertexes][0][1] = 0;
-	tess.vertexColors[tess.numVertexes][0] = iColor[0];
-	tess.vertexColors[tess.numVertexes][1] = iColor[1];
-	tess.vertexColors[tess.numVertexes][2] = iColor[2];
-	tess.vertexColors[tess.numVertexes][3] = 255;
-	tess.numVertexes++;
+	tess.vertexPtr2[0].xyz[0] = f->windowX - size;
+	tess.vertexPtr2[0].xyz[1] = f->windowY - size;
+	tess.vertexPtr2[0].xyz[2] = 0.0f;
+	tess.vertexPtr2[0].fogNum = 0.0f;
+	tess.vertexPtr1[0].tc1[0] = 0.0f;
+	tess.vertexPtr1[0].tc1[1] = 0.0f;
+	tess.vertexPtr1[0].tc2[0] = 0.0f;
+	tess.vertexPtr1[0].tc2[1] = 0.0f;
+	tess.vertexPtr4[0].color[0] = iColor[0];
+	tess.vertexPtr4[0].color[1] = iColor[1];
+	tess.vertexPtr4[0].color[2] = iColor[2];
+	tess.vertexPtr4[0].color[3] = 255;
 
-	tess.xyz[tess.numVertexes][0] = f->windowX - size;
-	tess.xyz[tess.numVertexes][1] = f->windowY + size;
-	tess.texCoords[tess.numVertexes][0][0] = 0;
-	tess.texCoords[tess.numVertexes][0][1] = 1;
-	tess.vertexColors[tess.numVertexes][0] = iColor[0];
-	tess.vertexColors[tess.numVertexes][1] = iColor[1];
-	tess.vertexColors[tess.numVertexes][2] = iColor[2];
-	tess.vertexColors[tess.numVertexes][3] = 255;
-	tess.numVertexes++;
+	tess.vertexPtr2[1].xyz[0] = f->windowX - size;
+	tess.vertexPtr2[1].xyz[1] = f->windowY + size;
+	tess.vertexPtr2[1].xyz[2] = 0.0f;
+	tess.vertexPtr2[1].fogNum = 0.0f;
+	tess.vertexPtr1[1].tc1[0] = 0.0f;
+	tess.vertexPtr1[1].tc1[1] = 1.0f;
+	tess.vertexPtr1[1].tc2[0] = 0.0f;
+	tess.vertexPtr1[1].tc2[1] = 1.0f;
+	tess.vertexPtr4[1].color[0] = iColor[0];
+	tess.vertexPtr4[1].color[1] = iColor[1];
+	tess.vertexPtr4[1].color[2] = iColor[2];
+	tess.vertexPtr4[1].color[3] = 255;
 
-	tess.xyz[tess.numVertexes][0] = f->windowX + size;
-	tess.xyz[tess.numVertexes][1] = f->windowY + size;
-	tess.texCoords[tess.numVertexes][0][0] = 1;
-	tess.texCoords[tess.numVertexes][0][1] = 1;
-	tess.vertexColors[tess.numVertexes][0] = iColor[0];
-	tess.vertexColors[tess.numVertexes][1] = iColor[1];
-	tess.vertexColors[tess.numVertexes][2] = iColor[2];
-	tess.vertexColors[tess.numVertexes][3] = 255;
-	tess.numVertexes++;
+	tess.vertexPtr2[2].xyz[0] = f->windowX + size;
+	tess.vertexPtr2[2].xyz[1] = f->windowY + size;
+	tess.vertexPtr2[2].xyz[2] = 0.0f;
+	tess.vertexPtr2[2].fogNum = 0.0f;
+	tess.vertexPtr1[2].tc1[0] = 1.0f;
+	tess.vertexPtr1[2].tc1[1] = 1.0f;
+	tess.vertexPtr1[2].tc2[0] = 1.0f;
+	tess.vertexPtr1[2].tc2[1] = 1.0f;
+	tess.vertexPtr4[2].color[0] = iColor[0];
+	tess.vertexPtr4[2].color[1] = iColor[1];
+	tess.vertexPtr4[2].color[2] = iColor[2];
+	tess.vertexPtr4[2].color[3] = 255;
 
-	tess.xyz[tess.numVertexes][0] = f->windowX + size;
-	tess.xyz[tess.numVertexes][1] = f->windowY - size;
-	tess.texCoords[tess.numVertexes][0][0] = 1;
-	tess.texCoords[tess.numVertexes][0][1] = 0;
-	tess.vertexColors[tess.numVertexes][0] = iColor[0];
-	tess.vertexColors[tess.numVertexes][1] = iColor[1];
-	tess.vertexColors[tess.numVertexes][2] = iColor[2];
-	tess.vertexColors[tess.numVertexes][3] = 255;
-	tess.numVertexes++;
+	tess.vertexPtr2[3].xyz[0] = f->windowX + size;
+	tess.vertexPtr2[3].xyz[1] = f->windowY - size;
+	tess.vertexPtr2[3].xyz[2] = 0.0f;
+	tess.vertexPtr2[3].fogNum = 0.0f;
+	tess.vertexPtr1[3].tc1[0] = 1.0f;
+	tess.vertexPtr1[3].tc1[1] = 0.0f;
+	tess.vertexPtr1[3].tc2[0] = 1.0f;
+	tess.vertexPtr1[3].tc2[1] = 0.0f;
+	tess.vertexPtr4[3].color[0] = iColor[0];
+	tess.vertexPtr4[3].color[1] = iColor[1];
+	tess.vertexPtr4[3].color[2] = iColor[2];
+	tess.vertexPtr4[3].color[3] = 255;
 
-	tess.indexes[tess.numIndexes++] = 0;
-	tess.indexes[tess.numIndexes++] = 1;
-	tess.indexes[tess.numIndexes++] = 2;
-	tess.indexes[tess.numIndexes++] = 0;
-	tess.indexes[tess.numIndexes++] = 2;
-	tess.indexes[tess.numIndexes++] = 3;
+	Com_Memcpy( tess.indexPtr.p16, indexes, 6 * sizeof(GLushort) );
 
 	RB_EndSurface();
+	RB_ClearVertexBuffer();
 }
 
 /*
@@ -482,7 +502,7 @@
 		// don't draw any here that aren't from this scene / portal
 		f->drawIntensity = 0;
 		if ( f->frameSceneNum == backEnd.viewParms.frameSceneNum
-			&& f->inPortal == backEnd.viewParms.isPortal ) {
+			&& f->portalLevel == backEnd.viewParms.portalLevel ) {
 			RB_TestFlare( f );
 			if ( f->drawIntensity ) {
 				draw = qtrue;
@@ -502,10 +522,6 @@
 		return;		// none visible
 	}
 
-	if ( backEnd.viewParms.isPortal ) {
-		qglDisable (GL_CLIP_PLANE0);
-	}
-
 	qglPushMatrix();
     qglLoadIdentity();
 	qglMatrixMode( GL_PROJECTION );
@@ -517,7 +533,7 @@
 
 	for ( f = r_activeFlares ; f ; f = f->next ) {
 		if ( f->frameSceneNum == backEnd.viewParms.frameSceneNum
-			&& f->inPortal == backEnd.viewParms.isPortal
+			&& f->portalLevel == backEnd.viewParms.portalLevel
 			&& f->drawIntensity ) {
 			RB_RenderFlare( f );
 		}
Index: src/renderer/tr_marks.c
===================================================================
--- src/renderer/tr_marks.c	(Revision 2062)
+++ src/renderer/tr_marks.c	(Arbeitskopie)
@@ -164,7 +164,7 @@
 			surf->viewCount = tr.viewCount;
 		}
 		// extra check for surfaces to avoid list overflows
-		else if (*(surf->data) == SF_FACE) {
+		else if (surf->type == SF_FACE) {
 			// the face plane should go through the box
 			s = BoxOnPlaneSide( mins, maxs, &(( srfSurfaceFace_t * ) surf->data)->plane );
 			if (s == 1 || s == 2) {
@@ -174,8 +174,7 @@
 				surf->viewCount = tr.viewCount;
 			}
 		}
-		else if (*(surfaceType_t *) (surf->data) != SF_GRID &&
-			 *(surfaceType_t *) (surf->data) != SF_TRIANGLES)
+		else if (surf->type != SF_GRID)
 			surf->viewCount = tr.viewCount;
 		// check the viewCount because the surface may have
 		// already been added if it spans multiple leafs
@@ -266,6 +265,7 @@
 	vec3_t			clipPoints[2][MAX_VERTS_ON_POLY];
 	int				numClipPoints;
 	float			*v;
+	srfSurfaceFace_t *surf;
 	srfGridMesh_t	*cv;
 	drawVert_t		*dv;
 	vec3_t			normal;
@@ -401,8 +401,7 @@
 		}
 		else if (*surfaces[i] == SF_FACE) {
 
-			srfSurfaceFace_t *surf = ( srfSurfaceFace_t * ) surfaces[i];
-
+			surf = ( srfSurfaceFace_t * ) surfaces[i];
 			// check the normal of this face
 			if (DotProduct(surf->plane.normal, projectionDir) > -0.5) {
 				continue;
Index: src/renderer/tr_image_tga.c
===================================================================
--- src/renderer/tr_image_tga.c	(Revision 2062)
+++ src/renderer/tr_image_tga.c	(Arbeitskopie)
@@ -39,7 +39,7 @@
 	unsigned char	pixel_size, attributes;
 } TargaHeader;
 
-void R_LoadTGA ( const char *name, byte **pic, int *width, int *height)
+void R_LoadTGA ( const char *name, texImage_t *pic, int *width, int *height)
 {
 	unsigned	columns, rows, numPixels;
 	byte	*pixbuf;
@@ -54,7 +54,7 @@
 	byte		*targa_rgba;
 	int length;
 
-	*pic = NULL;
+	pic->numMipmaps = 0;
 
 	if(width)
 		*width = 0;
@@ -315,7 +315,9 @@
   if (height)
 	  *height = rows;
 
-  *pic = targa_rgba;
+  pic->format = GL_RGBA8;
+  pic->numMipmaps = 1;
+  pic->data[0] = targa_rgba;
 
   ri.FS_FreeFile (buffer.v);
 }
Index: src/renderer/tr_image_bmp.c
===================================================================
--- src/renderer/tr_image_bmp.c	(Revision 2062)
+++ src/renderer/tr_image_bmp.c	(Arbeitskopie)
@@ -43,7 +43,7 @@
 	unsigned char palette[256][4];
 } BMPHeader_t;
 
-void R_LoadBMP( const char *name, byte **pic, int *width, int *height )
+void R_LoadBMP( const char *name, texImage_t *pic, int *width, int *height )
 {
 	int		columns, rows;
 	unsigned	numPixels;
@@ -59,7 +59,7 @@
 	BMPHeader_t bmpHeader;
 	byte		*bmpRGBA;
 
-	*pic = NULL;
+	pic->numMipmaps = 0;
 
 	if(width)
 		*width = 0;
@@ -181,9 +181,10 @@
 		*height = rows;
 
 	bmpRGBA = ri.Malloc( numPixels * 4 );
-	*pic = bmpRGBA;
+	pic->format = GL_RGBA8;
+	pic->numMipmaps = 1;
+	pic->data[0] = bmpRGBA;
 
-
 	for ( row = rows-1; row >= 0; row-- )
 	{
 		pixbuf = bmpRGBA + row*columns*4;
Index: src/renderer/tr_bsp.c
===================================================================
--- src/renderer/tr_bsp.c	(Revision 2062)
+++ src/renderer/tr_bsp.c	(Arbeitskopie)
@@ -39,6 +39,7 @@
 
 int			c_subdivisions;
 int			c_gridVerts;
+int			lightmapWidth, lightmapHeight;
 
 //===============================================================================
 
@@ -133,11 +134,14 @@
 ===============
 */
 #define	LIGHTMAP_SIZE	128
-static	void R_LoadLightmaps( lump_t *l ) {
+static	void R_LoadLightmaps( lump_t *l, lump_t *surfs ) {
 	byte		*buf, *buf_p;
+	dsurface_t	*surf;
 	int			len;
-	byte		image[LIGHTMAP_SIZE*LIGHTMAP_SIZE*4];
-	int			i, j;
+	int		offs;
+	byte		*image, *image_p;
+	texImage_t	pic;
+	int			i, j, k, x, y;
 	float maxIntensity = 0;
 	double sumIntensity = 0;
 
@@ -150,67 +154,145 @@
 	// we are about to upload textures
 	R_SyncRenderThread();
 
-	// create all the lightmaps
+	// compute the number of lightmaps
 	tr.numLightmaps = len / (LIGHTMAP_SIZE * LIGHTMAP_SIZE * 3);
-	if ( tr.numLightmaps == 1 ) {
-		//FIXME: HACK: maps with only one lightmap turn up fullbright for some reason.
-		//this avoids this, but isn't the correct solution.
-		tr.numLightmaps++;
-	} else if ( tr.numLightmaps >= MAX_LIGHTMAPS ) { // 20051020 misantropia
+	if ( tr.numLightmaps >= MAX_LIGHTMAPS ) { // 20051020 misantropia
 		ri.Printf( PRINT_WARNING, "WARNING: number of lightmaps > MAX_LIGHTMAPS\n" );
 		tr.numLightmaps = MAX_LIGHTMAPS;
 	}
+	// if all odd indexes are unused, we probably have deluxemaps
+	tr.hasDeluxemaps = (tr.numLightmaps > 1);
+	for( i = 0, surf = (dsurface_t *)(fileBase + surfs->fileofs);
+	     i < surfs->filelen / sizeof(dsurface_t); i++, surf++ ) {
+		int lightmapNum = LittleLong( surf->lightmapNum );
+		if ( lightmapNum >= 0 && (lightmapNum & 1) != 0 ) {
+			tr.hasDeluxemaps = qfalse;
+			break;
+		}
+	}
 
 	// if we are in r_vertexLight mode, we don't need the lightmaps at all
 	if ( r_vertexLight->integer || glConfig.hardwareType == GLHW_PERMEDIA2 ) {
+		lightmapWidth = lightmapHeight = 1;
 		return;
 	}
+	
+	// see how many lightmaps we can stuff into one texture
+	lightmapWidth = lightmapHeight = 1;
+	while ( lightmapWidth * LIGHTMAP_SIZE < glConfig.maxTextureSize &&
+		lightmapWidth * lightmapHeight < tr.numLightmaps ) {
+		lightmapWidth *= 2;
+		if ( lightmapWidth * lightmapHeight >= tr.numLightmaps )
+			break;
+		lightmapHeight *= 2;
+	}
 
-	for ( i = 0 ; i < tr.numLightmaps ; i++ ) {
-		// expand the 24 bit on-disk to 32 bit
-		buf_p = buf + i * LIGHTMAP_SIZE*LIGHTMAP_SIZE * 3;
+	// calculate number of resulting lightmap textures
+	tr.numLightmaps = (tr.numLightmaps + lightmapWidth * lightmapHeight - 1)
+		/ (lightmapWidth * lightmapHeight);
 
-		if ( r_lightmap->integer == 2 )
-		{	// color code by intensity as development tool	(FIXME: check range)
-			for ( j = 0; j < LIGHTMAP_SIZE * LIGHTMAP_SIZE; j++ )
-			{
-				float r = buf_p[j*3+0];
-				float g = buf_p[j*3+1];
-				float b = buf_p[j*3+2];
-				float intensity;
-				float out[3] = {0.0, 0.0, 0.0};
+	image = ri.Hunk_AllocateTempMemory( lightmapWidth * lightmapHeight *
+	                                    LIGHTMAP_SIZE * LIGHTMAP_SIZE * 4 );
+	Com_Memset( image, 0, lightmapWidth * lightmapHeight *
+	            LIGHTMAP_SIZE * LIGHTMAP_SIZE * 4);
 
-				intensity = 0.33f * r + 0.685f * g + 0.063f * b;
+	offs = 0;
+	for ( i = 0 ; i < tr.numLightmaps; i++ ) {
+		for ( y = 0; y < lightmapHeight; y++ ) {
+			if ( offs >= len)
+				break;
+			
+			for ( x = 0; x < lightmapWidth; x++ ) {
+				if ( offs >= len )
+					break;
+			
+				// expand the 24 bit on-disk to 32 bit
+				buf_p = buf + offs;
+				image_p = image + (y * LIGHTMAP_SIZE * lightmapWidth + x) * LIGHTMAP_SIZE * 4;
 
-				if ( intensity > 255 )
-					intensity = 1.0f;
-				else
-					intensity /= 255.0f;
+				if ( r_lightmap->integer == 2 )
+				{	// color code by intensity as development tool	(FIXME: check range)
+					for ( j = 0; j < LIGHTMAP_SIZE ; j++ ) {
+						for ( k = 0; k < LIGHTMAP_SIZE; k++ ) {
+							float r = buf_p[(j * LIGHTMAP_SIZE + k)*3+0];
+							float g = buf_p[(j * LIGHTMAP_SIZE + k)*3+1];
+							float b = buf_p[(j * LIGHTMAP_SIZE + k)*3+2];
+							float intensity;
+							float out[3] = {0.0, 0.0, 0.0};
 
-				if ( intensity > maxIntensity )
-					maxIntensity = intensity;
+							intensity = 0.33f * r + 0.685f * g + 0.063f * b;
 
-				HSVtoRGB( intensity, 1.00, 0.50, out );
+							if ( intensity > 255 )
+								intensity = 1.0f;
+							else
+								intensity /= 255.0f;
 
-				image[j*4+0] = out[0] * 255;
-				image[j*4+1] = out[1] * 255;
-				image[j*4+2] = out[2] * 255;
-				image[j*4+3] = 255;
+							if ( intensity > maxIntensity )
+								maxIntensity = intensity;
 
-				sumIntensity += intensity;
+							HSVtoRGB( intensity, 1.00, 0.50, out );
+
+							image_p[k*4+0] = out[0] * 255;
+							image_p[k*4+1] = out[1] * 255;
+							image_p[k*4+2] = out[2] * 255;
+							image_p[k*4+3] = 255;
+
+							sumIntensity += intensity;
+						}
+						// go to next line
+						image_p += lightmapWidth*LIGHTMAP_SIZE*4;
+					}
+				} else {
+					for ( j = 0; j < LIGHTMAP_SIZE ; j++ ) {
+						for ( k = 0; k < LIGHTMAP_SIZE; k++ ) {
+							R_ColorShiftLightingBytes( &buf_p[(j * LIGHTMAP_SIZE + k)*3], &image_p[k*4+0] );
+							image_p[k*4+3] = 255;
+						}
+						// go to next line
+						image_p += lightmapWidth*LIGHTMAP_SIZE*4;
+					}
+				}
+				if ( tr.hasDeluxemaps ) {
+					offs += LIGHTMAP_SIZE * LIGHTMAP_SIZE * 3;
+					buf_p = buf + offs;
+					image_p = image + (y * LIGHTMAP_SIZE * lightmapWidth + ++x) * LIGHTMAP_SIZE * 4;
+					
+					for ( j = 0; j < LIGHTMAP_SIZE ; j++ ) {
+						for ( k = 0; k < LIGHTMAP_SIZE; k++ ) {
+							// copy deluxemap data
+							image_p[k*4+0] = buf_p[(j * LIGHTMAP_SIZE + k)*3+0];
+							image_p[k*4+1] = buf_p[(j * LIGHTMAP_SIZE + k)*3+1];
+							image_p[k*4+2] = buf_p[(j * LIGHTMAP_SIZE + k)*3+2];
+							image_p[k*4+3] = 255;
+						}
+						// go to next line
+						image_p += lightmapWidth*LIGHTMAP_SIZE*4;
+					}
+				}
+				offs += LIGHTMAP_SIZE * LIGHTMAP_SIZE * 3;
 			}
-		} else {
-			for ( j = 0 ; j < LIGHTMAP_SIZE * LIGHTMAP_SIZE; j++ ) {
-				R_ColorShiftLightingBytes( &buf_p[j*3], &image[j*4] );
-				image[j*4+3] = 255;
-			}
 		}
-		tr.lightmaps[i] = R_CreateImage( va("*lightmap%d",i), image, 
-			LIGHTMAP_SIZE, LIGHTMAP_SIZE, qfalse, qfalse, GL_CLAMP_TO_EDGE );
+		pic.format = GL_RGBA8;
+		pic.numMipmaps = 1;
+		pic.data[0] = image;
+
+		tr.lightmaps[i] = R_CreateImage( va("*lightmap%d",i), &pic, 
+						 LIGHTMAP_SIZE * lightmapWidth, LIGHTMAP_SIZE * lightmapHeight,
+						 qfalse, qfalse, GL_CLAMP_TO_EDGE );
+		ri.Printf( PRINT_DEVELOPER, "lightmaps[%i]=%i\n", i, tr.lightmaps[i]->texnum);
 	}
+	// dummy lightmap
+	pic.format = GL_RGBA8;
+	pic.numMipmaps = 1;
+	pic.data[0] = image;
+	tr.lightmaps[i] = R_CreateImage( va("*lightmap%d",i), &pic, 
+					 LIGHTMAP_SIZE, LIGHTMAP_SIZE,
+					 qfalse, qfalse, GL_CLAMP_TO_EDGE );
+	tr.deluxeOffset = 1.0f / lightmapWidth;
+	ri.Hunk_FreeTempMemory( image );
 
 	if ( r_lightmap->integer == 2 )	{
-		ri.Printf( PRINT_ALL, "Brightest lightmap value: %d\n", ( int ) ( maxIntensity * 255 ) );
+		ri.Printf( PRINT_DEVELOPER, "Brightest lightmap value: %d\n", ( int ) ( maxIntensity * 255 ) );
 	}
 }
 
@@ -308,13 +390,20 @@
 	int			i, j;
 	srfSurfaceFace_t	*cv;
 	int			numPoints, numIndexes;
-	int			lightmapNum;
+	int			lightmapNum, lightmapX, lightmapY;
 	int			sfaceSize, ofsIndexes;
 
 	lightmapNum = LittleLong( ds->lightmapNum );
+	if (lightmapNum >= 0) {
+		lightmapX = lightmapNum & (lightmapWidth - 1);
+		lightmapNum /= lightmapWidth;
+		lightmapY = lightmapNum & (lightmapHeight - 1);
+		lightmapNum /= lightmapHeight;
+	}
 
 	// get fog volume
-	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+	surf->fogIndex = (short)LittleLong( ds->fogNum ) + 1;
+	surf->type = (short)SF_FACE;
 
 	// get shader value
 	surf->shader = ShaderForShaderNum( ds->shaderNum, lightmapNum );
@@ -352,6 +441,12 @@
 			cv->points[i][5+j] = LittleFloat( verts[i].lightmap[j] );
 		}
 		R_ColorShiftLightingBytes( verts[i].color, (byte *)&cv->points[i][7] );
+
+		if (lightmapNum >= 0) {
+			// adjust lightmap coords
+			cv->points[i][5] = (cv->points[i][5] + lightmapX) / lightmapWidth;
+			cv->points[i][6] = (cv->points[i][6] + lightmapY) / lightmapHeight;
+		}
 	}
 
 	indexes += LittleLong( ds->firstIndex );
@@ -381,15 +476,23 @@
 	int				i, j;
 	int				width, height, numPoints;
 	drawVert_t points[MAX_PATCH_SIZE*MAX_PATCH_SIZE];
-	int				lightmapNum;
+	int				lightmapNum, lightmapX, lightmapY;
 	vec3_t			bounds[2];
 	vec3_t			tmpVec;
 	static surfaceType_t	skipData = SF_SKIP;
 
 	lightmapNum = LittleLong( ds->lightmapNum );
+	if (lightmapNum >= 0) {
+		lightmapX = lightmapNum & (lightmapWidth - 1);
+		lightmapNum /= lightmapWidth;
+		lightmapY = lightmapNum & (lightmapHeight - 1);
+		lightmapNum /= lightmapHeight;
+	} else {
+		lightmapX = lightmapY = 0;
+	}
 
 	// get fog volume
-	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+	surf->fogIndex = (short)LittleLong( ds->fogNum ) + 1;
 
 	// get shader value
 	surf->shader = ShaderForShaderNum( ds->shaderNum, lightmapNum );
@@ -400,6 +503,7 @@
 	// we may have a nodraw surface, because they might still need to
 	// be around for movement clipping
 	if ( s_worldData.shaders[ LittleLong( ds->shaderNum ) ].surfaceFlags & SURF_NODRAW ) {
+		surf->type = (short)SF_SKIP;
 		surf->data = &skipData;
 		return;
 	}
@@ -419,10 +523,17 @@
 			points[i].lightmap[j] = LittleFloat( verts[i].lightmap[j] );
 		}
 		R_ColorShiftLightingBytes( verts[i].color, points[i].color );
+
+		if (lightmapNum >= 0) {
+			// adjust lightmap coords
+			points[i].lightmap[0] = (points[i].lightmap[0] + lightmapX) / lightmapWidth;
+			points[i].lightmap[1] = (points[i].lightmap[1] + lightmapY) / lightmapHeight;
+		}
 	}
 
 	// pre-tesseleate
 	grid = R_SubdividePatchToGrid( width, height, points );
+	surf->type = (short)(grid->surfaceType);
 	surf->data = (surfaceType_t *)grid;
 
 	// copy the level of detail origin, which is the center
@@ -449,7 +560,8 @@
 	int				numVerts, numIndexes;
 
 	// get fog volume
-	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+	surf->fogIndex = (short)LittleLong( ds->fogNum ) + 1;
+	surf->type = (short)SF_TRIANGLES;
 
 	// get shader
 	surf->shader = ShaderForShaderNum( ds->shaderNum, LIGHTMAP_BY_VERTEX );
@@ -507,7 +619,8 @@
 	int				i;
 
 	// get fog volume
-	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+	surf->fogIndex = (short)LittleLong( ds->fogNum ) + 1;
+	surf->type = (short)SF_FLARE;
 
 	// get shader
 	surf->shader = ShaderForShaderNum( ds->shaderNum, LIGHTMAP_BY_VERTEX );
@@ -1188,7 +1301,7 @@
 		}
 	}
 	while (stitched);
-	ri.Printf( PRINT_ALL, "stitched %d LoD cracks\n", numstitches );
+	ri.Printf( PRINT_DEVELOPER, "stitched %d LoD cracks\n", numstitches );
 }
 
 /*
@@ -1228,6 +1341,9 @@
 R_LoadSurfaces
 ===============
 */
+static int sortByShader(const void *a, const void *b) {
+	return ((msurface_t *)a)->shader - ((msurface_t *)b)->shader;
+}
 static	void R_LoadSurfaces( lump_t *surfs, lump_t *verts, lump_t *indexLump ) {
 	dsurface_t	*in;
 	msurface_t	*out;
@@ -1293,8 +1409,69 @@
 	R_MovePatchSurfacesToHunk();
 #endif
 
-	ri.Printf( PRINT_ALL, "...loaded %d faces, %i meshes, %i trisurfs, %i flares\n", 
+	ri.Printf( PRINT_DEVELOPER, "...loaded %d faces, %i meshes, %i trisurfs, %i flares\n", 
 		numFaces, numMeshes, numTriSurfs, numFlares );
+
+	if ( qglGenBuffersARB ) {
+		// sort surfaces by shader for improved locality
+		msurface_t *sortBuffer = ri.Hunk_AllocateTempMemory( count * sizeof(msurface_t) );
+		Com_Memcpy( sortBuffer, s_worldData.surfaces, count * sizeof(msurface_t) );
+		qsort( sortBuffer, count, sizeof(msurface_t),
+		       sortByShader );
+
+		// render all vertexes into a VBO
+		RB_ClearVertexBuffer( );
+		tess.shader = NULL;
+		
+		for ( i = 0, out = sortBuffer; i < count; i++, out++ ) {
+			switch( out->type ) {
+			case SF_FACE:
+				(*rb_surfaceTable[out->type])(out->data);
+				break;
+			case SF_GRID:
+				(*rb_surfaceTable[out->type])(out->data);
+				break;
+			case SF_TRIANGLES:
+				(*rb_surfaceTable[out->type])(out->data);
+				break;
+			default:
+				break;
+			}
+		}
+		
+		qglGenBuffersARB( 1, &backEnd.worldVBO.vbo );
+		backEnd.worldVBO.ibo = 0;
+		RB_SetupVertexBuffer( NULL, &backEnd.worldVBO );
+		for ( i = 0, out = sortBuffer; i < count; i++, out++ ) {
+			tess.fogNum = out->fogIndex;
+			switch( out->type ) {
+			case SF_FACE:
+				((srfSurfaceFace_t *)(out->data))->vboStart = tess.numVertexes;
+				(*rb_surfaceTable[out->type])(out->data);
+				break;
+			case SF_GRID:
+				((srfGridMesh_t *)(out->data))->vboStart = tess.numVertexes;
+				(*rb_surfaceTable[out->type])(out->data);
+				break;
+			case SF_TRIANGLES:
+				((srfTriangles_t *)(out->data))->vboStart = tess.numVertexes;
+				(*rb_surfaceTable[out->type])(out->data);
+				break;
+			default:
+				break;
+			}
+		}
+		
+		backEnd.worldVBO.maxIndex = tess.numVertexes - 1;
+		backEnd.worldVBO.offs1 = (vaWord1_t *)((intptr_t)tess.vertexPtr1 - (intptr_t)tess.vertexPtr1);
+		backEnd.worldVBO.offs2 = (vaWord2_t *)((intptr_t)tess.vertexPtr2 - (intptr_t)tess.vertexPtr1);
+		backEnd.worldVBO.offs3 = (vaWord3_t *)((intptr_t)tess.vertexPtr3 - (intptr_t)tess.vertexPtr1);
+		backEnd.worldVBO.offs4 = (vaWord4_t *)((intptr_t)tess.vertexPtr4 - (intptr_t)tess.vertexPtr1);
+		
+		RB_FlushVertexBuffer( );
+
+		ri.Hunk_FreeTempMemory( sortBuffer );
+	}
 }
 
 
@@ -1327,7 +1504,7 @@
 		}
 
 		model->type = MOD_BRUSH;
-		model->bmodel = out;
+		model->modelData.brush.bmodel = out;
 		Com_sprintf( model->name, sizeof( model->name ), "*%d", i );
 
 		for (j=0 ; j<3 ; j++) {
@@ -1368,6 +1545,7 @@
 	dnode_t		*in;
 	dleaf_t		*inLeaf;
 	mnode_t 	*out;
+	mcluster_t	*clusters;
 	int			numNodes, numLeafs;
 
 	in = (void *)(fileBase + nodeLump->fileofs);
@@ -1432,6 +1610,20 @@
 
 	// chain decendants
 	R_SetParent (s_worldData.nodes, NULL);
+
+	// calculate cluster bounds
+	clusters = ri.Hunk_Alloc ( s_worldData.numClusters * sizeof(mcluster_t), h_low);
+	tr.clusters = s_worldData.clusters = clusters;
+	for ( i = 0; i < s_worldData.numClusters; i++ ) {
+		ClearBounds( clusters[i].mins, clusters[i].maxs );
+	}
+	out = s_worldData.nodes + numNodes;
+	for ( i = 0; i < numLeafs; i++ ) {
+		if ( ( j = out[i].cluster ) >= 0 ) {
+			AddPointToBounds( out[i].mins, clusters[j].mins, clusters[j].maxs );
+			AddPointToBounds( out[i].maxs, clusters[j].mins, clusters[j].maxs );
+		}
+	}
 }
 
 //=============================================================================
@@ -1557,10 +1749,6 @@
 	s_worldData.fogs = ri.Hunk_Alloc ( s_worldData.numfogs*sizeof(*out), h_low);
 	out = s_worldData.fogs + 1;
 
-	if ( !count ) {
-		return;
-	}
-
 	brushes = (void *)(fileBase + brushesLump->fileofs);
 	if (brushesLump->filelen % sizeof(*brushes)) {
 		ri.Error (ERR_DROP, "LoadMap: funny lump size in %s",s_worldData.name);
@@ -1638,7 +1826,6 @@
 
 		out++;
 	}
-
 }
 
 
@@ -1851,7 +2038,7 @@
 
 	// load into heap
 	R_LoadShaders( &header->lumps[LUMP_SHADERS] );
-	R_LoadLightmaps( &header->lumps[LUMP_LIGHTMAPS] );
+	R_LoadLightmaps( &header->lumps[LUMP_LIGHTMAPS], &header->lumps[LUMP_SURFACES] );
 	R_LoadPlanes (&header->lumps[LUMP_PLANES]);
 	R_LoadFogs( &header->lumps[LUMP_FOGS], &header->lumps[LUMP_BRUSHES], &header->lumps[LUMP_BRUSHSIDES] );
 	R_LoadSurfaces( &header->lumps[LUMP_SURFACES], &header->lumps[LUMP_DRAWVERTS], &header->lumps[LUMP_DRAWINDEXES] );
Index: src/renderer/tr_cmds.c
===================================================================
--- src/renderer/tr_cmds.c	(Revision 2062)
+++ src/renderer/tr_cmds.c	(Arbeitskopie)
@@ -53,7 +53,7 @@
 			tr.pc.c_sphere_cull_md3_in, tr.pc.c_sphere_cull_md3_clip, tr.pc.c_sphere_cull_md3_out, 
 			tr.pc.c_box_cull_md3_in, tr.pc.c_box_cull_md3_clip, tr.pc.c_box_cull_md3_out );
 	} else if (r_speeds->integer == 3) {
-		ri.Printf (PRINT_ALL, "viewcluster: %i\n", tr.viewCluster );
+		ri.Printf (PRINT_ALL, "viewcluster: %i\n", tr.viewParms.viewCluster );
 	} else if (r_speeds->integer == 4) {
 		if ( backEnd.pc.c_dlightVertexes ) {
 			ri.Printf (PRINT_ALL, "dlight srf:%i  culled:%i  verts:%i  tris:%i\n", 
@@ -265,8 +265,83 @@
 	cmd->color[3] = rgba[3];
 }
 
+
 /*
 =============
+RE_StretchRaw
+
+Stretches a raw 32 bit power of 2 bitmap image over the given screen rectangle.
+Used for cinematics.
+=============
+*/
+void RE_StretchRaw (int x, int y, int w, int h,
+		    int cols, int rows, const byte *data,
+		    int client, qboolean dirty) {
+	int			i, j;
+	int			start, end;
+	stretchRawCommand_t	*cmd;
+
+	if ( !tr.registered ) {
+		return;
+	}
+	R_SyncRenderThread();
+
+	start = end = 0;
+	if ( r_speeds->integer ) {
+		start = ri.Milliseconds();
+	}
+
+	// make sure rows and cols are powers of 2
+	for ( i = 0 ; ( 1 << i ) < cols ; i++ ) {
+	}
+	for ( j = 0 ; ( 1 << j ) < rows ; j++ ) {
+	}
+	if ( ( 1 << i ) != cols || ( 1 << j ) != rows) {
+		ri.Error (ERR_DROP, "Draw_StretchRaw: size not a power of 2: %i by %i", cols, rows);
+	}
+
+	// if the scratchImage isn't in the format we want, specify it as a new texture
+	GL_BindTexture( tr.scratchImage[client]->texnum );
+
+	if ( cols != tr.scratchImage[client]->width || rows != tr.scratchImage[client]->height ) {
+		tr.scratchImage[client]->width = tr.scratchImage[client]->uploadWidth = cols;
+		tr.scratchImage[client]->height = tr.scratchImage[client]->uploadHeight = rows;
+		qglTexImage2D( GL_TEXTURE_2D, 0, GL_RGB8, cols, rows, 0, GL_RGBA, GL_UNSIGNED_BYTE, data );
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );	
+	} else {
+		if (dirty) {
+			// otherwise, just subimage upload it so that drivers can tell we are going to be changing
+			// it and don't try and do a texture compression
+			qglTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, cols, rows, GL_RGBA, GL_UNSIGNED_BYTE, data );
+		}
+	}
+
+	if ( r_speeds->integer ) {
+		end = ri.Milliseconds();
+		ri.Printf( PRINT_ALL, "qglTexSubImage2D %i, %i: %i msec\n", cols, rows, end - start );
+	}
+
+	cmd = R_GetCommandBuffer( sizeof( *cmd ) );
+	if ( !cmd ) {
+		return;
+	}
+	cmd->commandId = RC_STRETCH_RAW;
+	cmd->client = client;
+	cmd->x = x;
+	cmd->y = y;
+	cmd->w = w;
+	cmd->h = h;
+	cmd->s1 = 0.5f / cols;
+	cmd->t1 = 0.5f / rows;
+	cmd->s2 = 1.0f - cmd->s1;
+	cmd->t2 = 1.0f - cmd->t1;
+}
+
+/*
+=============
 R_ClipRegion
 =============
 */
@@ -437,7 +512,7 @@
 	//
 	if ( r_measureOverdraw->integer )
 	{
-		if ( glConfig.stencilBits < 4 )
+		if ( glGlobals.shadowBits < 4 )
 		{
 			ri.Printf( PRINT_ALL, "Warning: not enough stencil bits to measure overdraw: %d\n", glConfig.stencilBits );
 			ri.Cvar_Set( "r_measureOverdraw", "0" );
@@ -453,7 +528,7 @@
 		{
 			R_SyncRenderThread();
 			qglEnable( GL_STENCIL_TEST );
-			qglStencilMask( ~0U );
+			qglStencilMask( glGlobals.shadowMask );
 			qglClearStencil( 0U );
 			qglStencilFunc( GL_ALWAYS, 0U, ~0U );
 			qglStencilOp( GL_KEEP, GL_INCR, GL_INCR );
@@ -584,6 +659,11 @@
 	}
 	
 	tr.refdef.stereoFrame = stereoFrame;
+
+	// sort shaders by size of occluded area
+	if ( qglGenQueriesARB && stereoFrame != STEREO_RIGHT ) {
+		R_SortShaders( );
+	}
 }
 
 
@@ -594,9 +674,11 @@
 Returns the number of msec spent in the back end
 =============
 */
-void RE_EndFrame( int *frontEndMsec, int *backEndMsec ) {
+void RE_EndFrame( int *frontEndMsec, int *backEndMsec, int *GLMsec ) {
 	swapBuffersCommand_t	*cmd;
 
+	GL_CheckDebugLog();
+
 	if ( !tr.registered ) {
 		return;
 	}
@@ -606,8 +688,29 @@
 	}
 	cmd->commandId = RC_SWAP_BUFFERS;
 
-	R_IssueRenderCommands( qtrue );
+	if( glGlobals.timerQuery &&
+	    qglIsQueryARB( glGlobals.timerQuery ) ) {
+		GLuint available;
+		qglGetQueryObjectuivARB( glGlobals.timerQuery,
+					 GL_QUERY_RESULT_AVAILABLE_ARB,
+					 &available );
+		if( available ) {
+			qglGetQueryObjectui64vEXT( glGlobals.timerQuery,
+						   GL_QUERY_RESULT_ARB,
+						   &glGlobals.timerResult );
+			glGlobals.timerRunning = qfalse;
+		}
+	}
 
+	if( glGlobals.timerQuery && !glGlobals.timerRunning ) {
+		qglBeginQueryARB( GL_TIME_ELAPSED_EXT, glGlobals.timerQuery );
+		R_IssueRenderCommands( qtrue );
+		qglEndQueryARB( GL_TIME_ELAPSED_EXT );
+		glGlobals.timerRunning = qtrue;
+	} else {
+		R_IssueRenderCommands( qtrue );
+	}
+
 	// use the other buffers next frame, because another CPU
 	// may still be rendering into the current ones
 	R_ToggleSmpFrame();
@@ -620,6 +723,9 @@
 		*backEndMsec = backEnd.pc.msec;
 	}
 	backEnd.pc.msec = 0;
+	if ( GLMsec ) {
+		*GLMsec = glGlobals.timerResult / 1000000;
+	}
 }
 
 /*
Index: src/renderer/tr_iqm.c
===================================================================
--- src/renderer/tr_iqm.c	(Revision 0)
+++ src/renderer/tr_iqm.c	(Revision 0)
@@ -0,0 +1,799 @@
+/* copyright */
+
+#include "tr_local.h"
+
+#define	LL(x) x=LittleLong(x)
+
+static qboolean IQM_CheckRange( iqmHeader_t *header, int offset,
+				int count,int size ) {
+	// return true if the range specified by offset, count and size
+	// doesn't fit into the file
+	return ( count <= 0 ||
+		 offset < 0 ||
+		 offset > header->filesize ||
+		 offset + count * size < 0 ||
+		 offset + count * size > header->filesize );
+}
+// "multiply" 3x4 matrices, these are assumed to be the top 3 rows
+// of a 4x4 matrix with the last row = (0 0 0 1)
+static void Matrix34Multiply( float *a, float *b, float *out ) {
+	out[ 0] = a[0] * b[0] + a[1] * b[4] + a[ 2] * b[ 8];
+	out[ 1] = a[0] * b[1] + a[1] * b[5] + a[ 2] * b[ 9];
+	out[ 2] = a[0] * b[2] + a[1] * b[6] + a[ 2] * b[10];
+	out[ 3] = a[0] * b[3] + a[1] * b[7] + a[ 2] * b[11] + a[ 3];
+	out[ 4] = a[4] * b[0] + a[5] * b[4] + a[ 6] * b[ 8];
+	out[ 5] = a[4] * b[1] + a[5] * b[5] + a[ 6] * b[ 9];
+	out[ 6] = a[4] * b[2] + a[5] * b[6] + a[ 6] * b[10];
+	out[ 7] = a[4] * b[3] + a[5] * b[7] + a[ 6] * b[11] + a[ 7];
+	out[ 8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[ 8];
+	out[ 9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[ 9];
+	out[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10];
+	out[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11];
+}
+static void InterpolateMatrix( float *a, float *b, float lerp, float *mat ) {
+	float unLerp = 1.0f - lerp;
+
+	mat[ 0] = a[ 0] * unLerp + b[ 0] * lerp;
+	mat[ 1] = a[ 1] * unLerp + b[ 1] * lerp;
+	mat[ 2] = a[ 2] * unLerp + b[ 2] * lerp;
+	mat[ 3] = a[ 3] * unLerp + b[ 3] * lerp;
+	mat[ 4] = a[ 4] * unLerp + b[ 4] * lerp;
+	mat[ 5] = a[ 5] * unLerp + b[ 5] * lerp;
+	mat[ 6] = a[ 6] * unLerp + b[ 6] * lerp;
+	mat[ 7] = a[ 7] * unLerp + b[ 7] * lerp;
+	mat[ 8] = a[ 8] * unLerp + b[ 8] * lerp;
+	mat[ 9] = a[ 9] * unLerp + b[ 9] * lerp;
+	mat[10] = a[10] * unLerp + b[10] * lerp;
+	mat[11] = a[11] * unLerp + b[11] * lerp;
+}
+
+/*
+=================
+R_LoadIQM
+=================
+Load an IQM model and compute the joint matrices for every frame.
+*/
+qboolean R_LoadIQM( model_t *mod, void *buffer, int filesize, const char *mod_name ) {
+	iqmHeader_t		*header;
+	iqmVertexArray_t	*vertexarray;
+	iqmTriangle_t		*triangle;
+	iqmMesh_t		*mesh;
+	iqmJoint_t		*joint;
+	iqmPose_t		*pose;
+	unsigned short		*framedata;
+	char			*str;
+	int			i, j;
+	float			*jointMats, *mat;
+	size_t			size, joint_names;
+	iqmData_t		*iqmData;
+	srfIQModel_t		*surface;
+
+	if( filesize < sizeof(iqmHeader_t) ) {
+		return qfalse;
+	}
+
+	header = (iqmHeader_t *)buffer;
+	if( Q_strncmp( header->magic, IQM_MAGIC, sizeof(header->magic) ) ) {
+		return qfalse;
+	}
+
+	LL( header->version );
+	if( header->version != IQM_VERSION ) {
+		return qfalse;
+	}
+
+	LL( header->filesize );
+	if( header->filesize > filesize || header->filesize > 16<<20 ) {
+		return qfalse;
+	}
+
+	LL( header->flags );
+	LL( header->num_text );
+	LL( header->ofs_text );
+	LL( header->num_meshes );
+	LL( header->ofs_meshes );
+	LL( header->num_vertexarrays );
+	LL( header->num_vertexes );
+	LL( header->ofs_vertexarrays );
+	LL( header->num_triangles );
+	LL( header->ofs_triangles );
+	LL( header->ofs_adjacency );
+	LL( header->num_joints );
+	LL( header->ofs_joints );
+	LL( header->num_poses );
+	LL( header->ofs_poses );
+	LL( header->num_anims );
+	LL( header->ofs_anims );
+	LL( header->num_frames );
+	LL( header->num_framechannels );
+	LL( header->ofs_frames );
+	LL( header->ofs_bounds );
+	LL( header->num_comment );
+	LL( header->ofs_comment );
+	LL( header->num_extensions );
+	LL( header->ofs_extensions );
+
+	// check and swap vertex arrays
+	if( IQM_CheckRange( header, header->ofs_vertexarrays,
+			    header->num_vertexarrays,
+			    sizeof(iqmVertexArray_t) ) ) {
+		return qfalse;
+	}
+	vertexarray = (iqmVertexArray_t *)((byte *)header + header->ofs_vertexarrays);
+	for( i = 0; i < header->num_vertexarrays; i++, vertexarray++ ) {
+		int	j, n, *intPtr;
+
+		if( vertexarray->size <= 0 || vertexarray->size > 4 ) {
+			return qfalse;
+		}
+
+		// total number of values
+		n = header->num_vertexes * vertexarray->size;
+
+		switch( vertexarray->format ) {
+		case IQM_BYTE:
+		case IQM_UBYTE:
+			// 1 byte, no swapping necessary
+			if( IQM_CheckRange( header, vertexarray->offset,
+					    n, sizeof(byte) ) ) {
+				return qfalse;
+			}
+			break;
+		case IQM_INT:
+		case IQM_UINT:
+		case IQM_FLOAT:
+			// 4-byte swap
+			if( IQM_CheckRange( header, vertexarray->offset,
+					    n, sizeof(float) ) ) {
+				return qfalse;
+			}
+			intPtr = (int *)((byte *)header + vertexarray->offset);
+			for( j = 0; j < n; j++, intPtr++ ) {
+				LL( *intPtr );
+			}
+			break;
+		default:
+			// not supported
+			return qfalse;
+			break;
+		}
+
+		switch( vertexarray->type ) {
+		case IQM_POSITION:
+		case IQM_NORMAL:
+			if( vertexarray->format != IQM_FLOAT ||
+			    vertexarray->size != 3 ) {
+				return qfalse;
+			}
+			break;
+		case IQM_TANGENT:
+			if( vertexarray->format != IQM_FLOAT ||
+			    vertexarray->size != 4 ) {
+				return qfalse;
+			}
+			break;
+		case IQM_TEXCOORD:
+			if( vertexarray->format != IQM_FLOAT ||
+			    vertexarray->size != 2 ) {
+				return qfalse;
+			}
+			break;
+		case IQM_BLENDINDEXES:
+		case IQM_BLENDWEIGHTS:
+			if( vertexarray->format != IQM_UBYTE ||
+			    vertexarray->size != 4 ) {
+				return qfalse;
+			}
+			break;
+		case IQM_COLOR:
+			if( vertexarray->format != IQM_UBYTE ||
+			    vertexarray->size != 4 ) {
+				return qfalse;
+			}
+			break;
+		}
+	}
+
+	// check and swap triangles
+	if( IQM_CheckRange( header, header->ofs_triangles,
+			    header->num_triangles, sizeof(iqmTriangle_t) ) ) {
+		return qfalse;
+	}
+	triangle = (iqmTriangle_t *)((byte *)header + header->ofs_triangles);
+	for( i = 0; i < header->num_triangles; i++, triangle++ ) {
+		LL( triangle->vertex[0] );
+		LL( triangle->vertex[1] );
+		LL( triangle->vertex[2] );
+		
+		if( triangle->vertex[0] < 0 || triangle->vertex[0] > header->num_vertexes ||
+		    triangle->vertex[1] < 0 || triangle->vertex[1] > header->num_vertexes ||
+		    triangle->vertex[2] < 0 || triangle->vertex[2] > header->num_vertexes ) {
+			return qfalse;
+		}
+	}
+
+	// check and swap meshes
+	if( IQM_CheckRange( header, header->ofs_meshes,
+			    header->num_meshes, sizeof(iqmMesh_t) ) ) {
+		return qfalse;
+	}
+	mesh = (iqmMesh_t *)((byte *)header + header->ofs_meshes);
+	for( i = 0; i < header->num_meshes; i++, mesh++) {
+		LL( mesh->name );
+		LL( mesh->material );
+		LL( mesh->first_vertex );
+		LL( mesh->num_vertexes );
+		LL( mesh->first_triangle );
+		LL( mesh->num_triangles );
+		
+		if( mesh->first_vertex >= header->num_vertexes ||
+		    mesh->first_vertex + mesh->num_vertexes > header->num_vertexes ||
+		    mesh->first_triangle >= header->num_triangles ||
+		    mesh->first_triangle + mesh->num_triangles > header->num_triangles ||
+		    mesh->name < 0 ||
+		    mesh->name >= header->num_text ||
+		    mesh->material < 0 ||
+		    mesh->material >= header->num_text ) {
+			return qfalse;
+		}
+	}
+
+	// check and swap joints
+	if( IQM_CheckRange( header, header->ofs_joints,
+			    header->num_joints, sizeof(iqmJoint_t) ) ) {
+		return qfalse;
+	}
+	joint = (iqmJoint_t *)((byte *)header + header->ofs_joints);
+	joint_names = 0;
+	for( i = 0; i < header->num_joints; i++, joint++ ) {
+		LL( joint->name );
+		LL( joint->parent );
+		LL( joint->translate[0] );
+		LL( joint->translate[1] );
+		LL( joint->translate[2] );
+		LL( joint->rotate[0] );
+		LL( joint->rotate[1] );
+		LL( joint->rotate[2] );
+		LL( joint->scale[0] );
+		LL( joint->scale[1] );
+		LL( joint->scale[2] );
+
+		if( joint->parent < -1 ||
+		    joint->parent >= header->num_joints ||
+		    joint->name < 0 ||
+		    joint->name >= header->num_text ) {
+			return qfalse;
+		}
+		joint_names += strlen( (char *)header + header->ofs_text +
+				       joint->name ) + 1;
+	}
+
+	// check and swap poses
+	if( header->num_poses != header->num_joints ) {
+		return qfalse;
+	}
+	if( IQM_CheckRange( header, header->ofs_poses,
+			    header->num_poses, sizeof(iqmPose_t) ) ) {
+		return qfalse;
+	}
+	pose = (iqmPose_t *)((byte *)header + header->ofs_poses);
+	for( i = 0; i < header->num_poses; i++, pose++ ) {
+		LL( pose->parent );
+		LL( pose->mask );
+		LL( pose->channeloffset[0] );
+		LL( pose->channeloffset[1] );
+		LL( pose->channeloffset[2] );
+		LL( pose->channeloffset[3] );
+		LL( pose->channeloffset[4] );
+		LL( pose->channeloffset[5] );
+		LL( pose->channeloffset[6] );
+		LL( pose->channeloffset[7] );
+		LL( pose->channeloffset[8] );
+		LL( pose->channelscale[0] );
+		LL( pose->channelscale[1] );
+		LL( pose->channelscale[2] );
+		LL( pose->channelscale[3] );
+		LL( pose->channelscale[4] );
+		LL( pose->channelscale[5] );
+		LL( pose->channelscale[6] );
+		LL( pose->channelscale[7] );
+		LL( pose->channelscale[8] );
+	}
+
+	// allocate the model and copy the data
+	size = sizeof(iqmData_t);
+	size += header->num_meshes * sizeof( srfIQModel_t );
+	size += header->num_joints * header->num_frames * 12 * sizeof( float );
+	size += header->num_vertexes * 3 * sizeof(float); // positions
+	size += header->num_vertexes * 2 * sizeof(float); // texcoords
+	size += header->num_vertexes * 3 * sizeof(float); // normals
+	size += header->num_vertexes * 4 * sizeof(float); // tangents
+	size += header->num_vertexes * 4 * sizeof(byte);  // blendIndexes
+	size += header->num_vertexes * 4 * sizeof(byte);  // blendWeights
+	size += header->num_vertexes * 4 * sizeof(byte);  // colors
+	size += header->num_joints * sizeof(int);         // parents
+	size += header->num_triangles * 3 * sizeof(int);  // triangles
+	size += joint_names;                              // joint names
+
+	mod->type = MOD_IQM;
+	iqmData = (iqmData_t *)ri.Hunk_Alloc( size, h_low );
+	mod->modelData.iqm.iqmData = iqmData;
+
+	// fill header
+	iqmData->num_vertexes = header->num_vertexes;
+	iqmData->num_triangles = header->num_triangles;
+	iqmData->num_frames   = header->num_frames;
+	iqmData->num_surfaces = header->num_meshes;
+	iqmData->num_joints   = header->num_joints;
+	iqmData->surfaces     = (srfIQModel_t *)(iqmData + 1);
+	iqmData->poseMats     = (float *)(iqmData->surfaces + iqmData->num_surfaces);
+	iqmData->positions    = iqmData->poseMats + 12 * header->num_joints * header->num_frames;
+	iqmData->texcoords    = iqmData->positions + 3 * header->num_vertexes;
+	iqmData->normals      = iqmData->texcoords + 2 * header->num_vertexes;
+	iqmData->tangents     = iqmData->normals + 3 * header->num_vertexes;
+	iqmData->blendIndexes = (byte *)(iqmData->tangents + 4 * header->num_vertexes);
+	iqmData->blendWeights = iqmData->blendIndexes + 4 * header->num_vertexes;
+	iqmData->colors       = iqmData->blendWeights + 4 * header->num_vertexes;
+	iqmData->jointParents = (int *)(iqmData->colors + 4 * header->num_vertexes);
+	iqmData->triangles    = iqmData->jointParents + header->num_joints;
+	iqmData->names        = (char *)(iqmData->triangles + 3 * header->num_triangles);
+
+	// calculate joint matrices and their inverses
+	// they are needed only until the pose matrices are calculated
+	jointMats = (float *)ri.Hunk_AllocateTempMemory( header->num_joints * 2 * 3 * 4 * sizeof(float) );
+	mat = jointMats;
+	joint = (iqmJoint_t *)((byte *)header + header->ofs_joints);
+	for( i = 0; i < header->num_joints; i++, joint++ ) {
+		float tmpMat[12];
+
+		float rotW = DotProduct(joint->rotate, joint->rotate);
+		rotW = -SQRTFAST(1.0f - rotW);
+
+		float xx = 2.0f * joint->rotate[0] * joint->rotate[0];
+		float yy = 2.0f * joint->rotate[1] * joint->rotate[1];
+		float zz = 2.0f * joint->rotate[2] * joint->rotate[2];
+		float xy = 2.0f * joint->rotate[0] * joint->rotate[1];
+		float xz = 2.0f * joint->rotate[0] * joint->rotate[2];
+		float yz = 2.0f * joint->rotate[1] * joint->rotate[2];
+		float wx = 2.0f * rotW * joint->rotate[0];
+		float wy = 2.0f * rotW * joint->rotate[1];
+		float wz = 2.0f * rotW * joint->rotate[2];
+
+		tmpMat[ 0] = joint->scale[0] * (1.0f - (yy + zz));
+		tmpMat[ 1] = joint->scale[0] * (xy - wz);
+		tmpMat[ 2] = joint->scale[0] * (xz + wy);
+		tmpMat[ 3] = joint->translate[0];
+		tmpMat[ 4] = joint->scale[1] * (xy + wz);
+		tmpMat[ 5] = joint->scale[1] * (1.0f - (xx + zz));
+		tmpMat[ 6] = joint->scale[1] * (yz - wx);
+		tmpMat[ 7] = joint->translate[1];
+		tmpMat[ 8] = joint->scale[2] * (xz - wy);
+		tmpMat[ 9] = joint->scale[2] * (yz + wx);
+		tmpMat[10] = joint->scale[2] * (1.0f - (xx + yy));
+		tmpMat[11] = joint->translate[2];
+
+		if( joint->parent >= 0 ) {
+			// premultiply with parent-matrix
+			Matrix34Multiply( jointMats + 2 * 12 * joint->parent,
+					  tmpMat, mat);
+		} else {
+			Com_Memcpy( mat, tmpMat, sizeof(tmpMat) );
+		}
+
+		mat += 12;
+
+		// compute the inverse matrix by combining the
+		// inverse scale, rotation and translation
+		tmpMat[ 0] = joint->scale[0] * (1.0f - (yy + zz));
+		tmpMat[ 1] = joint->scale[1] * (xy + wz);
+		tmpMat[ 2] = joint->scale[2] * (xz - wy);
+		tmpMat[ 3] = -DotProduct((tmpMat + 0), joint->translate);
+		tmpMat[ 4] = joint->scale[0] * (xy - wz);
+		tmpMat[ 5] = joint->scale[1] * (1.0f - (xx + zz));
+		tmpMat[ 6] = joint->scale[2] * (yz + wx);
+		tmpMat[ 7] = -DotProduct((tmpMat + 4), joint->translate);
+		tmpMat[ 8] = joint->scale[0] * (xz + wy);
+		tmpMat[ 9] = joint->scale[1] * (yz - wx);
+		tmpMat[10] = joint->scale[2] * (1.0f - (xx + yy));
+		tmpMat[11] = -DotProduct((tmpMat + 8), joint->translate);
+
+		if( joint->parent >= 0 ) {
+			// premultiply with inverse parent-matrix
+			Matrix34Multiply( tmpMat,
+					  jointMats + 2 * 12 * joint->parent + 12,
+					  mat);
+		} else {
+			Com_Memcpy( mat, tmpMat, sizeof(tmpMat) );
+		}
+
+		mat += 12;
+	}
+
+	// calculate pose matrices
+	framedata = (unsigned short *)((byte *)header + header->ofs_frames);
+	mat = iqmData->poseMats;
+	for( i = 0; i < header->num_frames; i++ ) {
+		pose = (iqmPose_t *)((byte *)header + header->ofs_poses);
+		for( j = 0; j < header->num_poses; j++, pose++ ) {
+			vec3_t	translate, rotate, scale;
+			float	mat1[12], mat2[12];
+
+			translate[0] = pose->channeloffset[0];
+			if( pose->mask & 0x001)
+				translate[0] += *framedata++ * pose->channelscale[0];
+			translate[1] = pose->channeloffset[1];
+			if( pose->mask & 0x002)
+				translate[1] += *framedata++ * pose->channelscale[1];
+			translate[2] = pose->channeloffset[2];
+			if( pose->mask & 0x004)
+				translate[2] += *framedata++ * pose->channelscale[2];
+			rotate[0] = pose->channeloffset[3];
+			if( pose->mask & 0x008)
+				rotate[0] += *framedata++ * pose->channelscale[3];
+			rotate[1] = pose->channeloffset[4];
+			if( pose->mask & 0x010)
+				rotate[1] += *framedata++ * pose->channelscale[4];
+			rotate[2] = pose->channeloffset[5];
+			if( pose->mask & 0x020)
+				rotate[2] += *framedata++ * pose->channelscale[5];
+			scale[0] = pose->channeloffset[6];
+			if( pose->mask & 0x040)
+				scale[0] += *framedata++ * pose->channelscale[6];
+			scale[1] = pose->channeloffset[7];
+			if( pose->mask & 0x080)
+				scale[1] += *framedata++ * pose->channelscale[7];
+			scale[2] = pose->channeloffset[8];
+			if( pose->mask & 0x100)
+				scale[2] += *framedata++ * pose->channelscale[8];
+
+			// construct transformation matrix
+			float rotW = DotProduct(rotate, rotate);
+			rotW = -SQRTFAST(1.0f - rotW);
+
+			float xx = 2.0f * rotate[0] * rotate[0];
+			float yy = 2.0f * rotate[1] * rotate[1];
+			float zz = 2.0f * rotate[2] * rotate[2];
+			float xy = 2.0f * rotate[0] * rotate[1];
+			float xz = 2.0f * rotate[0] * rotate[2];
+			float yz = 2.0f * rotate[1] * rotate[2];
+			float wx = 2.0f * rotW * rotate[0];
+			float wy = 2.0f * rotW * rotate[1];
+			float wz = 2.0f * rotW * rotate[2];
+
+			mat1[ 0] = scale[0] * (1.0f - (yy + zz));
+			mat1[ 1] = scale[0] * (xy - wz);
+			mat1[ 2] = scale[0] * (xz + wy);
+			mat1[ 3] = translate[0];
+			mat1[ 4] = scale[1] * (xy + wz);
+			mat1[ 5] = scale[1] * (1.0f - (xx + zz));
+			mat1[ 6] = scale[1] * (yz - wx);
+			mat1[ 7] = translate[1];
+			mat1[ 8] = scale[2] * (xz - wy);
+			mat1[ 9] = scale[2] * (yz + wx);
+			mat1[10] = scale[2] * (1.0f - (xx + yy));
+			mat1[11] = translate[2];
+			
+			if( pose->parent >= 0 ) {
+				Matrix34Multiply( jointMats + 12 * 2 * pose->parent,
+						  mat1, mat2 );
+			} else {
+				Com_Memcpy( mat2, mat1, sizeof(mat1) );
+			}
+			
+			Matrix34Multiply( mat2, jointMats + 12 * (2 * j + 1), mat );
+			mat += 12;
+		}
+	}
+	ri.Hunk_FreeTempMemory( jointMats );
+
+	// register shaders
+	// overwrite the material offset with the shader index
+	mesh = (iqmMesh_t *)((byte *)header + header->ofs_meshes);
+	surface = iqmData->surfaces;
+	str = (char *)header + header->ofs_text;
+	for( i = 0; i < header->num_meshes; i++, mesh++, surface++ ) {
+		surface->surfaceType = SF_IQM;
+		surface->shader = R_FindShader( str + mesh->material, LIGHTMAP_NONE, qtrue );
+		if( surface->shader->defaultShader )
+			surface->shader = tr.defaultShader;
+		surface->data = iqmData;
+		surface->first_vertex = mesh->first_vertex;
+		surface->num_vertexes = mesh->num_vertexes;
+		surface->first_triangle = mesh->first_triangle;
+		surface->num_triangles = mesh->num_triangles;
+        }
+
+	// copy vertexarrays and indexes
+	vertexarray = (iqmVertexArray_t *)((byte *)header + header->ofs_vertexarrays);
+	for( i = 0; i < header->num_vertexarrays; i++, vertexarray++ ) {
+		int	n;
+
+		// total number of values
+		n = header->num_vertexes * vertexarray->size;
+
+		switch( vertexarray->type ) {
+		case IQM_POSITION:
+			Com_Memcpy( iqmData->positions,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(float) );
+			break;
+		case IQM_NORMAL:
+			Com_Memcpy( iqmData->normals,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(float) );
+			break;
+		case IQM_TANGENT:
+			Com_Memcpy( iqmData->tangents,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(float) );
+			break;
+		case IQM_TEXCOORD:
+			Com_Memcpy( iqmData->texcoords,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(float) );
+			break;
+		case IQM_BLENDINDEXES:
+			Com_Memcpy( iqmData->blendIndexes,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(byte) );
+			break;
+		case IQM_BLENDWEIGHTS:
+			Com_Memcpy( iqmData->blendWeights,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(byte) );
+			break;
+		case IQM_COLOR:
+			Com_Memcpy( iqmData->colors,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(byte) );
+			break;
+		}
+	}
+
+	// copy joint parents
+	joint = (iqmJoint_t *)((byte *)header + header->ofs_joints);
+	for( i = 0; i < header->num_joints; i++, joint++ ) {
+		iqmData->jointParents[i] = joint->parent;
+	}
+
+	// copy triangles
+	triangle = (iqmTriangle_t *)((byte *)header + header->ofs_triangles);
+	for( i = 0; i < header->num_triangles; i++, triangle++ ) {
+		iqmData->triangles[3*i+0] = triangle->vertex[0];
+		iqmData->triangles[3*i+1] = triangle->vertex[1];
+		iqmData->triangles[3*i+2] = triangle->vertex[2];
+	}
+
+	// copy joint names
+	str = iqmData->names;
+	for( i = 0; i < header->num_joints; i++ ) {
+		char *name = (char *)header + header->ofs_text +
+			joint->name;
+		int len = strlen( name ) + 1;
+		Com_Memcpy( str, name, len );
+		str += len;
+	}
+
+	return qtrue;
+}
+
+/*
+=================
+R_AddIQMSurfaces
+=================
+Add all surfaces of this model
+*/
+void R_AddIQMSurfaces( trRefEntity_t *ent ) {
+	iqmData_t		*data;
+	srfIQModel_t		*surface;
+	int			i;
+
+	data = tr.currentModel->modelData.iqm.iqmData;
+	surface = data->surfaces;
+
+	R_SetupEntityLighting( &tr.refdef, ent );
+
+	for ( i = 0 ; i < data->num_surfaces ; i++ ) {
+		R_AddDrawSurf( &surface->surfaceType,
+			       surface->shader->depthShader, 0, 0, qfalse );
+		R_AddDrawSurf( &surface->surfaceType,
+			       surface->shader, 0 /*fogNum*/, 0, qfalse );
+		surface++;
+	}
+}
+
+
+static void ComputeJointMats( iqmData_t *data, int frame, int oldframe,
+			      float backlerp, float *mat ) {
+	float	*mat1, *mat2;
+	int	*joint = data->jointParents;
+	int	i;
+
+	if (  oldframe == frame ) {
+		mat1 = mat2 = data->poseMats + 12 * data->num_joints * frame;
+		for( i = 0; i < data->num_joints; i++, joint++ ) {
+			if( *joint >= 0 ) {
+				Matrix34Multiply( mat + 12 * *joint,
+						  mat1 + 12*i, mat + 12*i );
+			} else {
+				Com_Memcpy( mat + 12*i, mat1 + 12*i, 12 * sizeof(float) );
+			}
+		}
+	} else  {
+		mat1 = data->poseMats + 12 * data->num_joints * frame;
+		mat2 = data->poseMats + 12 * data->num_joints * oldframe;
+		
+		for( i = 0; i < 12 * data->num_joints; i++, joint++ ) {
+			if( *joint >= 0 ) {
+				float tmpMat[12];
+				InterpolateMatrix( mat1 + 12*i, mat2 + 12*i,
+						   backlerp, tmpMat );
+				Matrix34Multiply( mat + 12 * *joint,
+						  tmpMat, mat + 12*i );
+				
+			} else {
+				InterpolateMatrix( mat1 + 12*i, mat2 + 12*i,
+						   backlerp, mat );
+			}
+		}
+	}
+}
+
+
+/*
+=================
+RB_AddIQMSurfaces
+=================
+Compute vertices for this model surface
+*/
+void RB_IQMSurfaceAnim( surfaceType_t *surface ) {
+	srfIQModel_t	*surf = (srfIQModel_t *)surface;
+	iqmData_t	*data = surf->data;
+	int		i;
+
+	if( tess.vertexPtr1 ) {
+		vaWord1_t	*ptr1 = tess.vertexPtr1 + tess.numVertexes;
+		vaWord2_t	*ptr2 = tess.vertexPtr2 + tess.numVertexes;
+		vaWord3_t	*ptr3 = tess.vertexPtr3 + tess.numVertexes;
+		vaWord4_t	*ptr4 = tess.vertexPtr4 + tess.numVertexes;
+
+		float	*mat;
+		int	frame = backEnd.currentEntity->e.frame % data->num_frames;
+		int	oldframe = backEnd.currentEntity->e.oldframe % data->num_frames;
+		float	backlerp = backEnd.currentEntity->e.backlerp;
+
+		// compute interpolated joint matrices
+		mat = (float *)RB_AllocScratch( data->num_joints * 12 * sizeof( float ) );
+		ComputeJointMats( data, frame, oldframe, backlerp, mat );
+
+		// transform vertexes and fill other data
+		for( i = 0; i < surf->num_vertexes; i++, ptr1++, ptr2++, ptr3++, ptr4++ ) {
+			int	j, k;
+			float	vtxMat[12];
+			float	nrmMat[9];
+			int	vtx = i + surf->first_vertex;
+
+			// compute the vertex matrix by blending the up to
+			// four blend weights
+			for( k = 0; k < 12; k++ )
+				vtxMat[k] = data->blendWeights[4*vtx]
+					* mat[12*data->blendIndexes[4*vtx] + k];
+			for( j = 1; j < 4; j++ ) {
+				if( data->blendWeights[4*vtx + j] <= 0 )
+					break;
+				for( k = 0; k < 12; k++ )
+					vtxMat[k] += data->blendWeights[4*vtx + j]
+						* mat[12*data->blendIndexes[4*vtx + j] + k];
+			}
+			for( k = 0; k < 12; k++ )
+				vtxMat[k] *= 1.0f / 255.0f;
+
+			// compute the normal matrix as transpose of the adjoint
+			// of the vertex matrix
+			nrmMat[ 0] = vtxMat[ 5]*vtxMat[10] - vtxMat[ 6]*vtxMat[ 9];
+			nrmMat[ 1] = vtxMat[ 6]*vtxMat[ 8] - vtxMat[ 4]*vtxMat[10];
+			nrmMat[ 2] = vtxMat[ 4]*vtxMat[ 9] - vtxMat[ 5]*vtxMat[ 8];
+			nrmMat[ 3] = vtxMat[ 2]*vtxMat[ 9] - vtxMat[ 1]*vtxMat[10];
+			nrmMat[ 4] = vtxMat[ 0]*vtxMat[10] - vtxMat[ 2]*vtxMat[ 8];
+			nrmMat[ 5] = vtxMat[ 1]*vtxMat[ 8] - vtxMat[ 0]*vtxMat[ 9];
+			nrmMat[ 6] = vtxMat[ 1]*vtxMat[ 6] - vtxMat[ 2]*vtxMat[ 5];
+			nrmMat[ 7] = vtxMat[ 2]*vtxMat[ 4] - vtxMat[ 0]*vtxMat[ 6];
+			nrmMat[ 8] = vtxMat[ 0]*vtxMat[ 5] - vtxMat[ 1]*vtxMat[ 4];
+
+			ptr1->tc1[0] = data->texcoords[2*vtx + 0];
+			ptr1->tc1[1] = data->texcoords[2*vtx + 1];
+			ptr1->tc2[0] = ptr1->tc1[0];
+			ptr1->tc2[1] = ptr1->tc1[1];
+
+			ptr2->xyz[0] =
+				vtxMat[ 0] * data->positions[3*vtx+0] +
+				vtxMat[ 1] * data->positions[3*vtx+1] +
+				vtxMat[ 2] * data->positions[3*vtx+2] +
+				vtxMat[ 3];
+			ptr2->xyz[1] =
+				vtxMat[ 4] * data->positions[3*vtx+0] +
+				vtxMat[ 5] * data->positions[3*vtx+1] +
+				vtxMat[ 6] * data->positions[3*vtx+2] +
+				vtxMat[ 7];
+			ptr2->xyz[2] =
+				vtxMat[ 8] * data->positions[3*vtx+0] +
+				vtxMat[ 9] * data->positions[3*vtx+1] +
+				vtxMat[10] * data->positions[3*vtx+2] +
+				vtxMat[11];
+			ptr2->fogNum = 0.0f;
+
+			ptr3->normal[0] =
+				nrmMat[ 0] * data->normals[3*vtx+0] +
+				nrmMat[ 1] * data->normals[3*vtx+1] +
+				nrmMat[ 2] * data->normals[3*vtx+2];
+			ptr3->normal[1] =
+				nrmMat[ 3] * data->normals[3*vtx+0] +
+				nrmMat[ 4] * data->normals[3*vtx+1] +
+				nrmMat[ 5] * data->normals[3*vtx+2];
+			ptr3->normal[2] =
+				nrmMat[ 6] * data->normals[3*vtx+0] +
+				nrmMat[ 7] * data->normals[3*vtx+1] +
+				nrmMat[ 8] * data->normals[3*vtx+2];
+			ptr3->reserved = 0.0f;
+
+			ptr4->color[0] = data->colors[4*vtx+0];
+			ptr4->color[1] = data->colors[4*vtx+1];
+			ptr4->color[2] = data->colors[4*vtx+2];
+			ptr4->color[3] = data->colors[4*vtx+3];
+		}
+
+		RB_FreeScratch( mat );
+	}
+
+	if( tess.indexPtr.p16 ) {
+		int	*tri = data->triangles;
+		tri += 3 * surf->first_triangle;
+
+		GLushort	*ptr = tess.indexPtr.p16 + tess.numIndexes;
+		GLushort	base = tess.numVertexes;
+
+		for( i = 0; i < surf->num_triangles; i++ ) {
+			*ptr++ = base + (GLushort)(*tri++ - surf->first_vertex);
+			*ptr++ = base + (GLushort)(*tri++ - surf->first_vertex);
+			*ptr++ = base + (GLushort)(*tri++ - surf->first_vertex);
+		}
+	}
+
+	tess.numIndexes += 3 * surf->num_triangles;
+	tess.numVertexes += surf->num_vertexes;
+}
+
+int R_IQMLerpTag( orientation_t *tag, iqmData_t *data,
+		  int startFrame, int endFrame, 
+		  float frac, const char *tagName ) {
+	int	joint;
+	char	*names = data->names;
+	float	*mat;
+
+	// get joint number by reading the joint names
+	for( joint = 0; joint < data->num_joints; joint++ ) {
+		if( !strcmp( tagName, names ) )
+			break;
+		names += strlen( names ) + 1;
+	}
+	if( joint >= data->num_joints )
+		return qfalse;
+
+	mat = (float *)ri.Hunk_AllocateTempMemory( data->num_joints * 12 * sizeof( float ) );
+	ComputeJointMats( data, startFrame, endFrame, frac, mat );
+	tag->axis[0][0] = mat[12 * joint + 0];
+	tag->axis[1][0] = mat[12 * joint + 1];
+	tag->axis[2][0] = mat[12 * joint + 2];
+	tag->origin[0] = mat[12 * joint + 3];
+	tag->axis[0][1] = mat[12 * joint + 4];
+	tag->axis[1][1] = mat[12 * joint + 5];
+	tag->axis[2][1] = mat[12 * joint + 6];
+	tag->origin[1] = mat[12 * joint + 7];
+	tag->axis[0][2] = mat[12 * joint + 8];
+	tag->axis[1][2] = mat[12 * joint + 9];
+	tag->axis[2][2] = mat[12 * joint + 10];
+	tag->origin[0] = mat[12 * joint + 11];
+	ri.Hunk_FreeTempMemory( mat );
+
+	return qfalse;
+}
Index: src/renderer/tr_surface.c
===================================================================
--- src/renderer/tr_surface.c	(Revision 2062)
+++ src/renderer/tr_surface.c	(Arbeitskopie)
@@ -46,96 +46,115 @@
 
 /*
 ==============
-RB_CheckOverflow
-==============
-*/
-void RB_CheckOverflow( int verts, int indexes ) {
-	if (tess.numVertexes + verts < SHADER_MAX_VERTEXES
-		&& tess.numIndexes + indexes < SHADER_MAX_INDEXES) {
-		return;
-	}
-
-	RB_EndSurface();
-
-	if ( verts >= SHADER_MAX_VERTEXES ) {
-		ri.Error(ERR_DROP, "RB_CheckOverflow: verts > MAX (%d > %d)", verts, SHADER_MAX_VERTEXES );
-	}
-	if ( indexes >= SHADER_MAX_INDEXES ) {
-		ri.Error(ERR_DROP, "RB_CheckOverflow: indices > MAX (%d > %d)", indexes, SHADER_MAX_INDEXES );
-	}
-
-	RB_BeginSurface(tess.shader, tess.fogNum );
-}
-
-
-/*
-==============
 RB_AddQuadStampExt
 ==============
 */
 void RB_AddQuadStampExt( vec3_t origin, vec3_t left, vec3_t up, byte *color, float s1, float t1, float s2, float t2 ) {
-	vec3_t		normal;
 	int			ndx;
 
-	RB_CHECKOVERFLOW( 4, 6 );
+	if ( tess.vertexPtr1 ) {
+		ndx = tess.numVertexes;
+		
+		tess.vertexPtr2[ndx+0].xyz[0] = origin[0] + left[0] + up[0];
+		tess.vertexPtr2[ndx+0].xyz[1] = origin[1] + left[1] + up[1];
+		tess.vertexPtr2[ndx+0].xyz[2] = origin[2] + left[2] + up[2];
+		tess.vertexPtr2[ndx+0].fogNum = (float)tess.fogNum;
+		
+		tess.vertexPtr2[ndx+1].xyz[0] = origin[0] - left[0] + up[0];
+		tess.vertexPtr2[ndx+1].xyz[1] = origin[1] - left[1] + up[1];
+		tess.vertexPtr2[ndx+1].xyz[2] = origin[2] - left[2] + up[2];
+		tess.vertexPtr2[ndx+1].fogNum = (float)tess.fogNum;
+		
+		tess.vertexPtr2[ndx+2].xyz[0] = origin[0] - left[0] - up[0];
+		tess.vertexPtr2[ndx+2].xyz[1] = origin[1] - left[1] - up[1];
+		tess.vertexPtr2[ndx+2].xyz[2] = origin[2] - left[2] - up[2];
+		tess.vertexPtr2[ndx+2].fogNum = (float)tess.fogNum;
+		
+		tess.vertexPtr2[ndx+3].xyz[0] = origin[0] + left[0] - up[0];
+		tess.vertexPtr2[ndx+3].xyz[1] = origin[1] + left[1] - up[1];
+		tess.vertexPtr2[ndx+3].xyz[2] = origin[2] + left[2] - up[2];
+		tess.vertexPtr2[ndx+3].fogNum = (float)tess.fogNum;
+		
+		// sprites don't use normal, so I reuse it to store the
+		// shadertimes
+		tess.vertexPtr3[ndx+0].normal[0] = tess.shaderTime;
+		tess.vertexPtr3[ndx+0].normal[1] = 0.0f;
+		tess.vertexPtr3[ndx+0].normal[2] = 0.0f;
+		tess.vertexPtr3[ndx+0].reserved = 0.0f;
+ 		tess.vertexPtr3[ndx+1].normal[0] = tess.shaderTime;
+		tess.vertexPtr3[ndx+1].normal[1] = 0.0f;
+		tess.vertexPtr3[ndx+1].normal[2] = 0.0f;
+		tess.vertexPtr3[ndx+1].reserved = 0.0f;
+		tess.vertexPtr3[ndx+2].normal[0] = tess.shaderTime;
+		tess.vertexPtr3[ndx+2].normal[1] = 0.0f;
+		tess.vertexPtr3[ndx+2].normal[2] = 0.0f;
+		tess.vertexPtr3[ndx+2].reserved = 0.0f;
+		tess.vertexPtr3[ndx+3].normal[0] = tess.shaderTime;
+		tess.vertexPtr3[ndx+3].normal[1] = 0.0f;
+		tess.vertexPtr3[ndx+3].normal[2] = 0.0f;
+		tess.vertexPtr3[ndx+3].reserved = 0.0f;
+		
+		// standard square texture coordinates
+		tess.vertexPtr1[ndx].tc1[0] = tess.vertexPtr1[ndx].tc2[0] = s1;
+		tess.vertexPtr1[ndx].tc1[1] = tess.vertexPtr1[ndx].tc2[1] = t1;
+		
+		tess.vertexPtr1[ndx+1].tc1[0] = tess.vertexPtr1[ndx+1].tc2[0] = s2;
+		tess.vertexPtr1[ndx+1].tc1[1] = tess.vertexPtr1[ndx+1].tc2[1] = t1;
+		
+		tess.vertexPtr1[ndx+2].tc1[0] = tess.vertexPtr1[ndx+2].tc2[0] = s2;
+		tess.vertexPtr1[ndx+2].tc1[1] = tess.vertexPtr1[ndx+2].tc2[1] = t2;
+		
+		tess.vertexPtr1[ndx+3].tc1[0] = tess.vertexPtr1[ndx+3].tc2[0] = s1;
+		tess.vertexPtr1[ndx+3].tc1[1] = tess.vertexPtr1[ndx+3].tc2[1] = t2;
+		
+		// constant color all the way around
+		// should this be identity and let the shader specify from entity?
+		tess.vertexPtr4[ndx].color[0] = color[0];
+		tess.vertexPtr4[ndx].color[1] = color[1];
+		tess.vertexPtr4[ndx].color[2] = color[2];
+		tess.vertexPtr4[ndx].color[3] = color[3];
+		tess.vertexPtr4[ndx+1].color[0] = color[0];
+		tess.vertexPtr4[ndx+1].color[1] = color[1];
+		tess.vertexPtr4[ndx+1].color[2] = color[2];
+		tess.vertexPtr4[ndx+1].color[3] = color[3];
+		tess.vertexPtr4[ndx+2].color[0] = color[0];
+		tess.vertexPtr4[ndx+2].color[1] = color[1];
+		tess.vertexPtr4[ndx+2].color[2] = color[2];
+		tess.vertexPtr4[ndx+2].color[3] = color[3];
+		tess.vertexPtr4[ndx+3].color[0] = color[0];
+		tess.vertexPtr4[ndx+3].color[1] = color[1];
+		tess.vertexPtr4[ndx+3].color[2] = color[2];
+		tess.vertexPtr4[ndx+3].color[3] = color[3];
+	} else {
+		ndx = 0; // should never be in a VBO
+	}
 
-	ndx = tess.numVertexes;
-
-	// triangle indexes for a simple quad
-	tess.indexes[ tess.numIndexes ] = ndx;
-	tess.indexes[ tess.numIndexes + 1 ] = ndx + 1;
-	tess.indexes[ tess.numIndexes + 2 ] = ndx + 3;
-
-	tess.indexes[ tess.numIndexes + 3 ] = ndx + 3;
-	tess.indexes[ tess.numIndexes + 4 ] = ndx + 1;
-	tess.indexes[ tess.numIndexes + 5 ] = ndx + 2;
-
-	tess.xyz[ndx][0] = origin[0] + left[0] + up[0];
-	tess.xyz[ndx][1] = origin[1] + left[1] + up[1];
-	tess.xyz[ndx][2] = origin[2] + left[2] + up[2];
-
-	tess.xyz[ndx+1][0] = origin[0] - left[0] + up[0];
-	tess.xyz[ndx+1][1] = origin[1] - left[1] + up[1];
-	tess.xyz[ndx+1][2] = origin[2] - left[2] + up[2];
-
-	tess.xyz[ndx+2][0] = origin[0] - left[0] - up[0];
-	tess.xyz[ndx+2][1] = origin[1] - left[1] - up[1];
-	tess.xyz[ndx+2][2] = origin[2] - left[2] - up[2];
-
-	tess.xyz[ndx+3][0] = origin[0] + left[0] - up[0];
-	tess.xyz[ndx+3][1] = origin[1] + left[1] - up[1];
-	tess.xyz[ndx+3][2] = origin[2] + left[2] - up[2];
-
-
-	// constant normal all the way around
-	VectorSubtract( vec3_origin, backEnd.viewParms.or.axis[0], normal );
-
-	tess.normal[ndx][0] = tess.normal[ndx+1][0] = tess.normal[ndx+2][0] = tess.normal[ndx+3][0] = normal[0];
-	tess.normal[ndx][1] = tess.normal[ndx+1][1] = tess.normal[ndx+2][1] = tess.normal[ndx+3][1] = normal[1];
-	tess.normal[ndx][2] = tess.normal[ndx+1][2] = tess.normal[ndx+2][2] = tess.normal[ndx+3][2] = normal[2];
+	if ( tess.indexPtr.p16 ) {
+		if ( tess.minIndex > ndx )
+			tess.minIndex = ndx;
+		if ( tess.maxIndex < ndx + 3 )
+			tess.maxIndex = ndx + 3;
+		
+		// triangle indexes for a simple quad
+		if ( tess.indexInc == sizeof(GLuint) ) {
+			tess.indexPtr.p32[ tess.numIndexes ] = ndx;
+			tess.indexPtr.p32[ tess.numIndexes + 1 ] = ndx + 1;
+			tess.indexPtr.p32[ tess.numIndexes + 2 ] = ndx + 3;
+			
+			tess.indexPtr.p32[ tess.numIndexes + 3 ] = ndx + 3;
+			tess.indexPtr.p32[ tess.numIndexes + 4 ] = ndx + 1;
+			tess.indexPtr.p32[ tess.numIndexes + 5 ] = ndx + 2;
+		} else {
+			tess.indexPtr.p16[ tess.numIndexes ] = ndx;
+			tess.indexPtr.p16[ tess.numIndexes + 1 ] = ndx + 1;
+			tess.indexPtr.p16[ tess.numIndexes + 2 ] = ndx + 3;
+			
+			tess.indexPtr.p16[ tess.numIndexes + 3 ] = ndx + 3;
+			tess.indexPtr.p16[ tess.numIndexes + 4 ] = ndx + 1;
+			tess.indexPtr.p16[ tess.numIndexes + 5 ] = ndx + 2;
+		}
+	}
 	
-	// standard square texture coordinates
-	tess.texCoords[ndx][0][0] = tess.texCoords[ndx][1][0] = s1;
-	tess.texCoords[ndx][0][1] = tess.texCoords[ndx][1][1] = t1;
-
-	tess.texCoords[ndx+1][0][0] = tess.texCoords[ndx+1][1][0] = s2;
-	tess.texCoords[ndx+1][0][1] = tess.texCoords[ndx+1][1][1] = t1;
-
-	tess.texCoords[ndx+2][0][0] = tess.texCoords[ndx+2][1][0] = s2;
-	tess.texCoords[ndx+2][0][1] = tess.texCoords[ndx+2][1][1] = t2;
-
-	tess.texCoords[ndx+3][0][0] = tess.texCoords[ndx+3][1][0] = s1;
-	tess.texCoords[ndx+3][0][1] = tess.texCoords[ndx+3][1][1] = t2;
-
-	// constant color all the way around
-	// should this be identity and let the shader specify from entity?
-	* ( unsigned int * ) &tess.vertexColors[ndx] = 
-	* ( unsigned int * ) &tess.vertexColors[ndx+1] = 
-	* ( unsigned int * ) &tess.vertexColors[ndx+2] = 
-	* ( unsigned int * ) &tess.vertexColors[ndx+3] = 
-		* ( unsigned int * )color;
-
-
 	tess.numVertexes += 4;
 	tess.numIndexes += 6;
 }
@@ -190,32 +209,66 @@
 RB_SurfacePolychain
 =============
 */
-static void RB_SurfacePolychain( srfPoly_t *p ) {
+static void RB_SurfacePolychain( surfaceType_t *surface ) {
+	srfPoly_t *p = (srfPoly_t *)surface;
 	int		i;
 	int		numv;
+	vaWord1_t	*vertexPtr1;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
+	vaWord4_t	*vertexPtr4;
 
-	RB_CHECKOVERFLOW( p->numVerts, 3*(p->numVerts - 2) );
-
-	// fan triangles into the tess array
-	numv = tess.numVertexes;
-	for ( i = 0; i < p->numVerts; i++ ) {
-		VectorCopy( p->verts[i].xyz, tess.xyz[numv] );
-		tess.texCoords[numv][0][0] = p->verts[i].st[0];
-		tess.texCoords[numv][0][1] = p->verts[i].st[1];
-		*(int *)&tess.vertexColors[numv] = *(int *)p->verts[ i ].modulate;
-
-		numv++;
+	if ( tess.vertexPtr1 ) {
+		vertexPtr1 = tess.vertexPtr1 + tess.numVertexes;
+		vertexPtr2 = tess.vertexPtr2 + tess.numVertexes;
+		vertexPtr3 = tess.vertexPtr3 + tess.numVertexes;
+		vertexPtr4 = tess.vertexPtr4 + tess.numVertexes;
+		
+		// fan triangles into the tess array
+		numv = tess.numVertexes;
+		for ( i = 0; i < p->numVerts; i++ ) {
+			VectorCopy ( p->verts[i].xyz, *(vec3_t *)vertexPtr2->xyz );
+			Vector2Copy( p->verts[i].st,  vertexPtr1->tc1 );
+			*(int *)(&vertexPtr4->color) = *(int *)p->verts[ i ].modulate;
+			vertexPtr2->fogNum = tess.fogNum;
+			
+			vertexPtr1++;
+			vertexPtr2++;
+			vertexPtr3++;
+			vertexPtr4++;
+		}
+	} else {
+		numv = 0; //ERROR, should never have coordinates in VBO
 	}
 
-	// generate fan indexes into the tess array
-	for ( i = 0; i < p->numVerts-2; i++ ) {
-		tess.indexes[tess.numIndexes + 0] = tess.numVertexes;
-		tess.indexes[tess.numIndexes + 1] = tess.numVertexes + i + 1;
-		tess.indexes[tess.numIndexes + 2] = tess.numVertexes + i + 2;
-		tess.numIndexes += 3;
+	if ( tess.indexPtr.p16 ) {
+		if ( tess.minIndex > numv )
+			tess.minIndex = numv;
+		if ( tess.maxIndex < numv + p->numVerts - 1 )
+			tess.maxIndex = numv + p->numVerts - 1;
+		
+		// generate fan indexes into the tess array
+		if ( tess.indexInc == sizeof(GLushort) ) {
+			GLushort	*indexPtr = tess.indexPtr.p16 + tess.numIndexes;
+			for ( i = 0; i < p->numVerts-2; i++ ) {
+				indexPtr[0] = (GLushort)numv;
+				indexPtr[1] = (GLushort)(numv + i + 1);
+				indexPtr[2] = (GLushort)(numv + i + 2);
+				indexPtr += 3;
+			}
+		} else {
+			GLuint		*indexPtr32 = tess.indexPtr.p32 + tess.numIndexes;
+			for ( i = 0; i < p->numVerts-2; i++ ) {
+				indexPtr32[0] = numv;
+				indexPtr32[1] = numv + i + 1;
+				indexPtr32[2] = numv+ i + 2;
+				indexPtr32 += 3;
+			}
+		}
 	}
-
-	tess.numVertexes = numv;
+	
+	tess.numVertexes += p->numVerts;
+	tess.numIndexes  += 3*(p->numVerts - 2);
 }
 
 
@@ -224,57 +277,73 @@
 RB_SurfaceTriangles
 =============
 */
-static void RB_SurfaceTriangles( srfTriangles_t *srf ) {
+static void RB_SurfaceTriangles( surfaceType_t *surface ) {
+	srfTriangles_t *srf = (srfTriangles_t *)surface;
 	int			i;
 	drawVert_t	*dv;
-	float		*xyz, *normal, *texCoords;
-	byte		*color;
 	int			dlightBits;
-	qboolean	needsNormal;
+	GLushort	*indexPtr;
+	GLuint		*indexPtr32;
+	vaWord1_t	*vertexPtr1;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
+	vaWord4_t	*vertexPtr4;
+	int             numv;
 
 	dlightBits = srf->dlightBits[backEnd.smpFrame];
 	tess.dlightBits |= dlightBits;
 
-	RB_CHECKOVERFLOW( srf->numVerts, srf->numIndexes );
+	if ( tess.vertexPtr1 ) {
+		numv = tess.numVertexes;
+		
+		vertexPtr1 = tess.vertexPtr1 + numv;
+		vertexPtr2 = tess.vertexPtr2 + numv;
+		vertexPtr3 = tess.vertexPtr3 + numv;
+		vertexPtr4 = tess.vertexPtr4 + numv;
 
-	for ( i = 0 ; i < srf->numIndexes ; i += 3 ) {
-		tess.indexes[ tess.numIndexes + i + 0 ] = tess.numVertexes + srf->indexes[ i + 0 ];
-		tess.indexes[ tess.numIndexes + i + 1 ] = tess.numVertexes + srf->indexes[ i + 1 ];
-		tess.indexes[ tess.numIndexes + i + 2 ] = tess.numVertexes + srf->indexes[ i + 2 ];
+		dv = srf->verts;
+		
+		for ( i = 0 ; i < srf->numVerts ; i++, dv++ ) {
+			VectorCopy( dv->xyz, *(vec3_t *)vertexPtr2->xyz );
+			VectorCopy( dv->normal, vertexPtr3->normal );
+			Vector2Copy( dv->st,       vertexPtr1->tc1 );
+			Vector2Copy( dv->lightmap, vertexPtr1->tc2 );
+			*(int *)&vertexPtr4->color = *(int *)dv->color;
+			vertexPtr2->fogNum = tess.fogNum;
+			vertexPtr1++;
+			vertexPtr2++;
+			vertexPtr3++;
+			vertexPtr4++;
+		}
+	} else {
+		numv = srf->vboStart;
 	}
-	tess.numIndexes += srf->numIndexes;
 
-	dv = srf->verts;
-	xyz = tess.xyz[ tess.numVertexes ];
-	normal = tess.normal[ tess.numVertexes ];
-	texCoords = tess.texCoords[ tess.numVertexes ][0];
-	color = tess.vertexColors[ tess.numVertexes ];
-	needsNormal = tess.shader->needsNormal;
-
-	for ( i = 0 ; i < srf->numVerts ; i++, dv++, xyz += 4, normal += 4, texCoords += 4, color += 4 ) {
-		xyz[0] = dv->xyz[0];
-		xyz[1] = dv->xyz[1];
-		xyz[2] = dv->xyz[2];
-
-		if ( needsNormal ) {
-			normal[0] = dv->normal[0];
-			normal[1] = dv->normal[1];
-			normal[2] = dv->normal[2];
+	if ( tess.indexPtr.p16 ) {
+		if ( tess.minIndex > numv )
+			tess.minIndex = numv;
+		if ( tess.maxIndex < numv + srf->numVerts - 1 )
+			tess.maxIndex = numv + srf->numVerts - 1;
+		
+		if ( tess.indexInc == sizeof(GLushort) ) {
+			indexPtr = tess.indexPtr.p16 + tess.numIndexes;
+			
+			for ( i = 0 ; i < srf->numIndexes ; i += 3 ) {
+				indexPtr[ i + 0 ] = (GLushort)(numv + srf->indexes[ i + 0 ]);
+				indexPtr[ i + 1 ] = (GLushort)(numv + srf->indexes[ i + 1 ]);
+				indexPtr[ i + 2 ] = (GLushort)(numv + srf->indexes[ i + 2 ]);
+			}
+		} else {
+			indexPtr32 = tess.indexPtr.p32 + tess.numIndexes;
+			for ( i = 0 ; i < srf->numIndexes ; i += 3 ) {
+				indexPtr32[ i + 0 ] = numv + srf->indexes[ i + 0 ];
+				indexPtr32[ i + 1 ] = numv + srf->indexes[ i + 1 ];
+				indexPtr32[ i + 2 ] = numv + srf->indexes[ i + 2 ];
+			}
 		}
-
-		texCoords[0] = dv->st[0];
-		texCoords[1] = dv->st[1];
-
-		texCoords[2] = dv->lightmap[0];
-		texCoords[3] = dv->lightmap[1];
-
-		*(int *)color = *(int *)dv->color;
 	}
 
-	for ( i = 0 ; i < srf->numVerts ; i++ ) {
-		tess.vertexDlightBits[ tess.numVertexes + i] = dlightBits;
-	}
-
+	tess.numIndexes += srf->numIndexes;
 	tess.numVertexes += srf->numVerts;
 }
 
@@ -285,15 +354,17 @@
 RB_SurfaceBeam
 ==============
 */
-static void RB_SurfaceBeam( void )
+static void RB_SurfaceBeam( void ) 
 {
 #define NUM_BEAM_SEGS 6
 	refEntity_t *e;
 	int	i;
 	vec3_t perpvec;
 	vec3_t direction, normalized_direction;
-	vec3_t	start_points[NUM_BEAM_SEGS], end_points[NUM_BEAM_SEGS];
+	vec3_t	points[2 * (NUM_BEAM_SEGS+1)];
+	vec3_t	*start_point, *end_point;
 	vec3_t oldorigin, origin;
+	glRenderState_t state;
 
 	e = &backEnd.currentEntity->e;
 
@@ -316,25 +387,32 @@
 
 	VectorScale( perpvec, 4, perpvec );
 
+	start_point = &points[0];
+	end_point = &points[1];
 	for ( i = 0; i < NUM_BEAM_SEGS ; i++ )
 	{
-		RotatePointAroundVector( start_points[i], normalized_direction, perpvec, (360.0/NUM_BEAM_SEGS)*i );
-//		VectorAdd( start_points[i], origin, start_points[i] );
-		VectorAdd( start_points[i], direction, end_points[i] );
+		RotatePointAroundVector( *start_point, normalized_direction, perpvec, (360.0/NUM_BEAM_SEGS)*i );
+//		VectorAdd( *start_point, origin, *start_point );
+		VectorAdd( *start_point, direction, *end_point );
+
+		start_point += 2; end_point += 2;
 	}
+	VectorCopy( points[0], *start_point );
+	VectorCopy( points[1], *end_point );
 
-	GL_Bind( tr.whiteImage );
+	InitState( &state );
 
-	GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE );
+	state.numImages = 1;
+	state.image[0] = tr.whiteImage;
 
-	qglColor3f( 1, 0, 0 );
+	state.stateBits = GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE;
 
-	qglBegin( GL_TRIANGLE_STRIP );
-	for ( i = 0; i <= NUM_BEAM_SEGS; i++ ) {
-		qglVertex3fv( start_points[ i % NUM_BEAM_SEGS] );
-		qglVertex3fv( end_points[ i % NUM_BEAM_SEGS] );
-	}
-	qglEnd();
+	SetAttrVec4f( &state, AL_COLOR, 0.0f, 0.0f, 0.0f, 1.0f );
+
+	SetAttrPointer( &state, AL_VERTEX, 0,
+			3, GL_FLOAT, sizeof(vec3_t),
+			points );
+	GL_DrawArrays( &state, GL_TRIANGLE_STRIP, 0, 2*(NUM_BEAM_SEGS+1) );
 }
 
 //================================================================================
@@ -345,51 +423,55 @@
 	int			vbase;
 	float		t = len / 256.0f;
 
-	vbase = tess.numVertexes;
-
 	spanWidth2 = -spanWidth;
 
-	// FIXME: use quad stamp?
-	VectorMA( start, spanWidth, up, tess.xyz[tess.numVertexes] );
-	tess.texCoords[tess.numVertexes][0][0] = 0;
-	tess.texCoords[tess.numVertexes][0][1] = 0;
-	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0] * 0.25;
-	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1] * 0.25;
-	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2] * 0.25;
-	tess.numVertexes++;
+	if ( tess.vertexPtr1 ) {
+		vbase = tess.numVertexes;
+		
+		// FIXME: use quad stamp?
+		VectorMA( start, spanWidth, up, tess.vertexPtr2[vbase].xyz );
+		tess.vertexPtr1[vbase].tc1[0] = 0;
+		tess.vertexPtr1[vbase].tc1[1] = 0;
+		tess.vertexPtr4[vbase].color[0] = backEnd.currentEntity->e.shaderRGBA[0] * 0.25;
+		tess.vertexPtr4[vbase].color[1] = backEnd.currentEntity->e.shaderRGBA[1] * 0.25;
+		tess.vertexPtr4[vbase].color[2] = backEnd.currentEntity->e.shaderRGBA[2] * 0.25;
 
-	VectorMA( start, spanWidth2, up, tess.xyz[tess.numVertexes] );
-	tess.texCoords[tess.numVertexes][0][0] = 0;
-	tess.texCoords[tess.numVertexes][0][1] = 1;
-	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0];
-	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1];
-	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2];
-	tess.numVertexes++;
+		VectorMA( start, spanWidth2, up, tess.vertexPtr2[vbase+1].xyz );
+		tess.vertexPtr1[vbase+1].tc1[0] = 0;
+		tess.vertexPtr1[vbase+1].tc1[1] = 1;
+		tess.vertexPtr4[vbase+1].color[0] = backEnd.currentEntity->e.shaderRGBA[0];
+		tess.vertexPtr4[vbase+1].color[1] = backEnd.currentEntity->e.shaderRGBA[1];
+		tess.vertexPtr4[vbase+1].color[2] = backEnd.currentEntity->e.shaderRGBA[2];
+		
+		VectorMA( start, spanWidth, up, tess.vertexPtr2[vbase+2].xyz );
+		tess.vertexPtr1[vbase+2].tc1[0] = t;
+		tess.vertexPtr1[vbase+2].tc1[1] = 0;
+		tess.vertexPtr4[vbase+2].color[0] = backEnd.currentEntity->e.shaderRGBA[0];
+		tess.vertexPtr4[vbase+2].color[1] = backEnd.currentEntity->e.shaderRGBA[1];
+		tess.vertexPtr4[vbase+2].color[2] = backEnd.currentEntity->e.shaderRGBA[2];
+		
+		VectorMA( start, spanWidth, up, tess.vertexPtr2[vbase+3].xyz );
+		tess.vertexPtr1[vbase+3].tc1[0] = t;
+		tess.vertexPtr1[vbase+3].tc1[1] = 1;
+		tess.vertexPtr4[vbase+3].color[0] = backEnd.currentEntity->e.shaderRGBA[0];
+		tess.vertexPtr4[vbase+3].color[1] = backEnd.currentEntity->e.shaderRGBA[1];
+		tess.vertexPtr4[vbase+3].color[2] = backEnd.currentEntity->e.shaderRGBA[2];
+	} else {
+		vbase = 0;
+	}
+	
+	if ( tess.indexPtr.p16 ) {
+		tess.indexPtr.p16[tess.numIndexes] = vbase;
+		tess.indexPtr.p16[tess.numIndexes+1] = vbase + 1;
+		tess.indexPtr.p16[tess.numIndexes+2] = vbase + 2;
+		
+		tess.indexPtr.p16[tess.numIndexes+3] = vbase + 2;
+		tess.indexPtr.p16[tess.numIndexes+4] = vbase + 1;
+		tess.indexPtr.p16[tess.numIndexes+5] = vbase + 3;
+	}
 
-	VectorMA( end, spanWidth, up, tess.xyz[tess.numVertexes] );
-
-	tess.texCoords[tess.numVertexes][0][0] = t;
-	tess.texCoords[tess.numVertexes][0][1] = 0;
-	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0];
-	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1];
-	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2];
-	tess.numVertexes++;
-
-	VectorMA( end, spanWidth2, up, tess.xyz[tess.numVertexes] );
-	tess.texCoords[tess.numVertexes][0][0] = t;
-	tess.texCoords[tess.numVertexes][0][1] = 1;
-	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0];
-	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1];
-	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2];
-	tess.numVertexes++;
-
-	tess.indexes[tess.numIndexes++] = vbase;
-	tess.indexes[tess.numIndexes++] = vbase + 1;
-	tess.indexes[tess.numIndexes++] = vbase + 2;
-
-	tess.indexes[tess.numIndexes++] = vbase + 2;
-	tess.indexes[tess.numIndexes++] = vbase + 1;
-	tess.indexes[tess.numIndexes++] = vbase + 3;
+	tess.numVertexes += 4;
+	tess.numIndexes += 6;
 }
 
 static void DoRailDiscs( int numSegs, const vec3_t start, const vec3_t dir, const vec3_t right, const vec3_t up )
@@ -398,16 +480,15 @@
 	vec3_t	pos[4];
 	vec3_t	v;
 	int		spanWidth = r_railWidth->integer;
+	int		vbase;
 	float c, s;
-	float		scale;
+	float		scale = 0.25;
 
 	if ( numSegs > 1 )
 		numSegs--;
 	if ( !numSegs )
 		return;
 
-	scale = 0.25;
-
 	for ( i = 0; i < 4; i++ )
 	{
 		c = cos( DEG2RAD( 45 + i * 90 ) );
@@ -424,32 +505,46 @@
 		}
 	}
 
-	for ( i = 0; i < numSegs; i++ )
-	{
-		int j;
+	if ( tess.vertexPtr1 ) {
+		vbase = tess.numVertexes;
+		for ( i = 0; i < numSegs; i++ )
+		{
+			int j;
+			
+			for ( j = 0; j < 4; j++ )
+			{
+				VectorCopy( pos[j], tess.vertexPtr2[vbase].xyz );
+				tess.vertexPtr1[vbase].tc1[0] = ( j < 2 );
+				tess.vertexPtr1[vbase].tc1[1] = ( j && j != 3 );
+				tess.vertexPtr4[vbase].color[0] = backEnd.currentEntity->e.shaderRGBA[0];
+				tess.vertexPtr4[vbase].color[1] = backEnd.currentEntity->e.shaderRGBA[1];
+				tess.vertexPtr4[vbase].color[2] = backEnd.currentEntity->e.shaderRGBA[2];
+				vbase++;
+				
+				VectorAdd( pos[j], dir, pos[j] );
+			}
+		}
+		vbase = tess.numVertexes;
+	} else {
+		vbase = 0;
+	}
 
-		RB_CHECKOVERFLOW( 4, 6 );
-
-		for ( j = 0; j < 4; j++ )
+	if ( tess.indexPtr.p16 ) {
+		for ( i = 0; i < numSegs; i++ )
 		{
-			VectorCopy( pos[j], tess.xyz[tess.numVertexes] );
-			tess.texCoords[tess.numVertexes][0][0] = ( j < 2 );
-			tess.texCoords[tess.numVertexes][0][1] = ( j && j != 3 );
-			tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0];
-			tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1];
-			tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2];
-			tess.numVertexes++;
-
-			VectorAdd( pos[j], dir, pos[j] );
+			int iwrite = tess.numIndexes;
+			tess.indexPtr.p16[iwrite++] = vbase + 0;
+			tess.indexPtr.p16[iwrite++] = vbase + 1;
+			tess.indexPtr.p16[iwrite++] = vbase + 3;
+			tess.indexPtr.p16[iwrite++] = vbase + 3;
+			tess.indexPtr.p16[iwrite++] = vbase + 1;
+			tess.indexPtr.p16[iwrite++] = vbase + 2;
+			vbase += 4;
 		}
+	}
 
-		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 0;
-		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 1;
-		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 3;
-		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 3;
-		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 1;
-		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 2;
-	}
+	tess.numVertexes += numSegs * 4;
+	tess.numIndexes += numSegs * 6;
 }
 
 /*
@@ -550,64 +645,8 @@
 	}
 }
 
-/*
-** VectorArrayNormalize
-*
-* The inputs to this routing seem to always be close to length = 1.0 (about 0.6 to 2.0)
-* This means that we don't have to worry about zero length or enormously long vectors.
-*/
-static void VectorArrayNormalize(vec4_t *normals, unsigned int count)
-{
-//    assert(count);
-        
-#if idppc
-    {
-        register float half = 0.5;
-        register float one  = 1.0;
-        float *components = (float *)normals;
-        
-        // Vanilla PPC code, but since PPC has a reciprocal square root estimate instruction,
-        // runs *much* faster than calling sqrt().  We'll use a single Newton-Raphson
-        // refinement step to get a little more precision.  This seems to yeild results
-        // that are correct to 3 decimal places and usually correct to at least 4 (sometimes 5).
-        // (That is, for the given input range of about 0.6 to 2.0).
-        do {
-            float x, y, z;
-            float B, y0, y1;
-            
-            x = components[0];
-            y = components[1];
-            z = components[2];
-            components += 4;
-            B = x*x + y*y + z*z;
 
-#ifdef __GNUC__            
-            asm("frsqrte %0,%1" : "=f" (y0) : "f" (B));
-#else
-			y0 = __frsqrte(B);
-#endif
-            y1 = y0 + half*y0*(one - B*y0*y0);
 
-            x = x * y1;
-            y = y * y1;
-            components[-4] = x;
-            z = z * y1;
-            components[-3] = y;
-            components[-2] = z;
-        } while(count--);
-    }
-#else // No assembly version for this architecture, or C_ONLY defined
-	// given the input, it's safe to call VectorNormalizeFast
-    while (count--) {
-        VectorNormalizeFast(normals[0]);
-        normals++;
-    }
-#endif
-
-}
-
-
-
 /*
 ** LerpMeshVertexes
 */
@@ -615,7 +654,8 @@
 static void LerpMeshVertexes_altivec(md3Surface_t *surf, float backlerp)
 {
 	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
-	float	*outXyz, *outNormal;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
 	float	oldXyzScale ALIGN(16);
 	float   newXyzScale ALIGN(16);
 	float	oldNormalScale ALIGN(16);
@@ -624,8 +664,8 @@
 	unsigned lat, lng;
 	int		numVerts;
 
-	outXyz = tess.xyz[tess.numVertexes];
-	outNormal = tess.normal[tess.numVertexes];
+	vertexPtr2 = tess.vertexPtr2 + tess.numVertexes;
+	vertexPtr3 = tess.vertexPtr3 + tess.numVertexes;
 
 	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
 		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
@@ -657,8 +697,8 @@
 		// just copy the vertexes
 		//
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
-			newXyz += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+		       newXyz += 4, newNormals += 4,
+		       vertexPtr2++, vertexPtr3++ )
 		{
 			newNormalsLoadPermute = vec_lvsl(0,newXyz);
 			newNormalsStorePermute = vec_lvsr(0,outXyz);
@@ -682,13 +722,14 @@
 			// decode Y as sin( lat ) * sin( long )
 			// decode Z as cos( long )
 
-			outNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
-			outNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
-			outNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+			vertexPtr3->normal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
+			vertexPtr3->normal[1] = tr.sinTable[lat] * tr.sinTable[lng];
+			vertexPtr3->normal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+			vertexPtr3->reserved = 0.0f;
 
-			vec_ste(newNormalsFloatVec,0,outXyz);
-			vec_ste(newNormalsFloatVec,4,outXyz);
-			vec_ste(newNormalsFloatVec,8,outXyz);
+			vec_ste(newNormalsFloatVec,0,vertexPtr2->xyz);
+			vec_ste(newNormalsFloatVec,4,vertexPtr2->xyz);
+			vec_ste(newNormalsFloatVec,8,vertexPtr2->xyz);
 		}
 	} else {
 		//
@@ -702,15 +743,15 @@
 		oldNormalScale = backlerp;
 
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
-			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+			     oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
+			     vertexPtr2++, vertexPtr3++ )
 		{
 			vec3_t uncompressedOldNormal, uncompressedNewNormal;
 
 			// interpolate the xyz
-			outXyz[0] = oldXyz[0] * oldXyzScale + newXyz[0] * newXyzScale;
-			outXyz[1] = oldXyz[1] * oldXyzScale + newXyz[1] * newXyzScale;
-			outXyz[2] = oldXyz[2] * oldXyzScale + newXyz[2] * newXyzScale;
+			vertexPtr2->xyz[0] = oldXyz[0] * oldXyzScale + newXyz[0] * newXyzScale;
+			vertexPtr2->xyz[1] = oldXyz[1] * oldXyzScale + newXyz[1] * newXyzScale;
+			vertexPtr2->xyz[2] = oldXyz[2] * oldXyzScale + newXyz[2] * newXyzScale;
 
 			// FIXME: interpolate lat/long instead?
 			lat = ( newNormals[0] >> 8 ) & 0xff;
@@ -730,13 +771,13 @@
 			uncompressedOldNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
 			uncompressedOldNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
 
-			outNormal[0] = uncompressedOldNormal[0] * oldNormalScale + uncompressedNewNormal[0] * newNormalScale;
-			outNormal[1] = uncompressedOldNormal[1] * oldNormalScale + uncompressedNewNormal[1] * newNormalScale;
-			outNormal[2] = uncompressedOldNormal[2] * oldNormalScale + uncompressedNewNormal[2] * newNormalScale;
+			vertexPtr3->normal[0] = uncompressedOldNormal[0] * oldNormalScale + uncompressedNewNormal[0] * newNormalScale;
+			vertexPtr3->normal[1] = uncompressedOldNormal[1] * oldNormalScale + uncompressedNewNormal[1] * newNormalScale;
+			vertexPtr3->normal[2] = uncompressedOldNormal[2] * oldNormalScale + uncompressedNewNormal[2] * newNormalScale;
+			vertexPtr3->reserved = 0.0f;
 
-//			VectorNormalize (outNormal);
+			VectorNormalize (vertexPtr3->normal);
 		}
-    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
    	}
 }
 #endif
@@ -744,15 +785,16 @@
 static void LerpMeshVertexes_scalar(md3Surface_t *surf, float backlerp)
 {
 	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
-	float	*outXyz, *outNormal;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
 	float	oldXyzScale, newXyzScale;
 	float	oldNormalScale, newNormalScale;
 	int		vertNum;
 	unsigned lat, lng;
 	int		numVerts;
 
-	outXyz = tess.xyz[tess.numVertexes];
-	outNormal = tess.normal[tess.numVertexes];
+	vertexPtr2 = tess.vertexPtr2 + tess.numVertexes;
+	vertexPtr3 = tess.vertexPtr3 + tess.numVertexes;
 
 	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
 		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
@@ -768,13 +810,13 @@
 		// just copy the vertexes
 		//
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
-			newXyz += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+			     newXyz += 4, newNormals += 4,
+			     vertexPtr2++, vertexPtr3++ )
 		{
 
-			outXyz[0] = newXyz[0] * newXyzScale;
-			outXyz[1] = newXyz[1] * newXyzScale;
-			outXyz[2] = newXyz[2] * newXyzScale;
+			vertexPtr2->xyz[0] = newXyz[0] * newXyzScale;
+			vertexPtr2->xyz[1] = newXyz[1] * newXyzScale;
+			vertexPtr2->xyz[2] = newXyz[2] * newXyzScale;
 
 			lat = ( newNormals[0] >> 8 ) & 0xff;
 			lng = ( newNormals[0] & 0xff );
@@ -785,9 +827,10 @@
 			// decode Y as sin( lat ) * sin( long )
 			// decode Z as cos( long )
 
-			outNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
-			outNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
-			outNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+			vertexPtr3->normal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
+			vertexPtr3->normal[1] = tr.sinTable[lat] * tr.sinTable[lng];
+			vertexPtr3->normal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+			vertexPtr3->reserved = 0.0f;
 		}
 	} else {
 		//
@@ -801,15 +844,15 @@
 		oldNormalScale = backlerp;
 
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
-			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+			     oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
+			     vertexPtr2++, vertexPtr3++ )
 		{
 			vec3_t uncompressedOldNormal, uncompressedNewNormal;
 
 			// interpolate the xyz
-			outXyz[0] = oldXyz[0] * oldXyzScale + newXyz[0] * newXyzScale;
-			outXyz[1] = oldXyz[1] * oldXyzScale + newXyz[1] * newXyzScale;
-			outXyz[2] = oldXyz[2] * oldXyzScale + newXyz[2] * newXyzScale;
+			vertexPtr2->xyz[0] = oldXyz[0] * oldXyzScale + newXyz[0] * newXyzScale;
+			vertexPtr2->xyz[1] = oldXyz[1] * oldXyzScale + newXyz[1] * newXyzScale;
+			vertexPtr2->xyz[2] = oldXyz[2] * oldXyzScale + newXyz[2] * newXyzScale;
 
 			// FIXME: interpolate lat/long instead?
 			lat = ( newNormals[0] >> 8 ) & 0xff;
@@ -829,13 +872,13 @@
 			uncompressedOldNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
 			uncompressedOldNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
 
-			outNormal[0] = uncompressedOldNormal[0] * oldNormalScale + uncompressedNewNormal[0] * newNormalScale;
-			outNormal[1] = uncompressedOldNormal[1] * oldNormalScale + uncompressedNewNormal[1] * newNormalScale;
-			outNormal[2] = uncompressedOldNormal[2] * oldNormalScale + uncompressedNewNormal[2] * newNormalScale;
+			vertexPtr3->normal[0] = uncompressedOldNormal[0] * oldNormalScale + uncompressedNewNormal[0] * newNormalScale;
+			vertexPtr3->normal[1] = uncompressedOldNormal[1] * oldNormalScale + uncompressedNewNormal[1] * newNormalScale;
+			vertexPtr3->normal[2] = uncompressedOldNormal[2] * oldNormalScale + uncompressedNewNormal[2] * newNormalScale;
+			vertexPtr3->reserved = 0.0f;
 
-//			VectorNormalize (outNormal);
+			VectorNormalize (vertexPtr3->normal);
 		}
-    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
    	}
 }
 
@@ -857,14 +900,18 @@
 RB_SurfaceMesh
 =============
 */
-static void RB_SurfaceMesh(md3Surface_t *surface) {
+void RB_SurfaceMesh( surfaceType_t *surf) {
+	md3Surface_t *surface = (md3Surface_t *)surf;
 	int				j;
 	float			backlerp;
 	int				*triangles;
 	float			*texCoords;
 	int				indexes;
-	int				Bob, Doug;
+	int				Doug;
 	int				numVerts;
+	vaWord1_t		*vertexPtr1;
+	vaWord2_t		*vertexPtr2;
+	vaWord4_t		*vertexPtr4;
 
 	if (  backEnd.currentEntity->e.oldframe == backEnd.currentEntity->e.frame ) {
 		backlerp = 0;
@@ -872,30 +919,52 @@
 		backlerp = backEnd.currentEntity->e.backlerp;
 	}
 
-	RB_CHECKOVERFLOW( surface->numVerts, surface->numTriangles*3 );
+	if ( tess.vertexPtr1 ) {
+		LerpMeshVertexes (surface, backlerp);
+		
+		Doug = tess.numVertexes;
+		texCoords = (float *) ((byte *)surface + surface->ofsSt);
+		vertexPtr1 = tess.vertexPtr1 + Doug;
+		vertexPtr2 = tess.vertexPtr2 + Doug;
+		vertexPtr4 = tess.vertexPtr4 + Doug;
 
-	LerpMeshVertexes (surface, backlerp);
-
-	triangles = (int *) ((byte *)surface + surface->ofsTriangles);
-	indexes = surface->numTriangles * 3;
-	Bob = tess.numIndexes;
-	Doug = tess.numVertexes;
-	for (j = 0 ; j < indexes ; j++) {
-		tess.indexes[Bob + j] = Doug + triangles[j];
+		numVerts = surface->numVerts;
+		for ( j = 0; j < numVerts; j++, vertexPtr1++, vertexPtr2++, vertexPtr4++ ) {
+			vertexPtr1->tc1[0] = vertexPtr1->tc2[0] = texCoords[j*2+0];
+			vertexPtr1->tc1[1] = vertexPtr1->tc2[1] = texCoords[j*2+1];
+			vertexPtr2->fogNum = tess.fogNum;
+			vertexPtr4->color[0] = 255;
+			vertexPtr4->color[1] = 255;
+			vertexPtr4->color[2] = 255;
+			vertexPtr4->color[3] = 255;
+		}
+	} else {
+		Doug = 0;
 	}
-	tess.numIndexes += indexes;
+	
+	if ( tess.indexPtr.p16 ) {
+		if ( tess.minIndex > Doug )
+			tess.minIndex = Doug;
+		if ( tess.maxIndex < Doug + surface->numVerts - 1 )
+			tess.maxIndex = Doug + surface->numVerts - 1;
 
-	texCoords = (float *) ((byte *)surface + surface->ofsSt);
+		triangles = (int *) ((byte *)surface + surface->ofsTriangles);
+		indexes = surface->numTriangles * 3;
 
-	numVerts = surface->numVerts;
-	for ( j = 0; j < numVerts; j++ ) {
-		tess.texCoords[Doug + j][0][0] = texCoords[j*2+0];
-		tess.texCoords[Doug + j][0][1] = texCoords[j*2+1];
-		// FIXME: fill in lightmapST for completeness?
+		if ( tess.indexInc == sizeof(GLushort) ) {
+			GLushort *indexPtr = tess.indexPtr.p16 + tess.numIndexes;
+			for (j = 0 ; j < indexes ; j++) {
+				*indexPtr++ = Doug + triangles[j];
+			}
+		} else {
+			GLuint *indexPtr32 = tess.indexPtr.p32 + tess.numIndexes;
+			for (j = 0 ; j < indexes ; j++) {
+				*indexPtr32++ = Doug + triangles[j];
+			}
+		}
 	}
-
 	tess.numVertexes += surface->numVerts;
-
+	tess.numIndexes  += 3*surface->numTriangles;
 }
 
 
@@ -904,56 +973,71 @@
 RB_SurfaceFace
 ==============
 */
-static void RB_SurfaceFace( srfSurfaceFace_t *surf ) {
+static void RB_SurfaceFace( surfaceType_t *surface ) {
+	srfSurfaceFace_t *surf = (srfSurfaceFace_t *)surface;
 	int			i;
-	unsigned	*indices, *tessIndexes;
+	unsigned	*indices;
 	float		*v;
-	float		*normal;
-	int			ndx;
 	int			Bob;
 	int			numPoints;
 	int			dlightBits;
+	vaWord1_t	*vertexPtr1;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
+	vaWord4_t	*vertexPtr4;
 
-	RB_CHECKOVERFLOW( surf->numPoints, surf->numIndices );
-
 	dlightBits = surf->dlightBits[backEnd.smpFrame];
 	tess.dlightBits |= dlightBits;
 
-	indices = ( unsigned * ) ( ( ( char  * ) surf ) + surf->ofsIndices );
+	if ( tess.vertexPtr1 ) {
+		Bob = tess.numVertexes;
 
-	Bob = tess.numVertexes;
-	tessIndexes = tess.indexes + tess.numIndexes;
-	for ( i = surf->numIndices-1 ; i >= 0  ; i-- ) {
-		tessIndexes[i] = indices[i] + Bob;
+		v = surf->points[0];
+		
+		numPoints = surf->numPoints;
+		
+		vertexPtr1 = tess.vertexPtr1 + tess.numVertexes;
+		vertexPtr2 = tess.vertexPtr2 + tess.numVertexes;
+		vertexPtr3 = tess.vertexPtr3 + tess.numVertexes;
+		vertexPtr4 = tess.vertexPtr4 + tess.numVertexes;
+		
+		for ( i = 0, v = surf->points[0]; i < numPoints; i++, v += VERTEXSIZE,
+			      vertexPtr1++, vertexPtr2++, vertexPtr3++, vertexPtr4++ ) {
+			VectorCopy( surf->plane.normal, vertexPtr3->normal );
+			vertexPtr3->reserved = 0.0f;
+			
+			VectorCopy ( v, *(vec3_t *)&vertexPtr2->xyz);
+			vertexPtr2->fogNum = tess.fogNum;
+			Vector2Copy( v+3, vertexPtr1->tc1 );
+			Vector2Copy( v+5, vertexPtr1->tc2 );
+			*(unsigned int *)&vertexPtr4->color = *(unsigned int *)&v[7];
+		}
+	} else {
+		Bob = surf->vboStart;
 	}
 
-	tess.numIndexes += surf->numIndices;
-
-	v = surf->points[0];
-
-	ndx = tess.numVertexes;
-
-	numPoints = surf->numPoints;
-
-	if ( tess.shader->needsNormal ) {
-		normal = surf->plane.normal;
-		for ( i = 0, ndx = tess.numVertexes; i < numPoints; i++, ndx++ ) {
-			VectorCopy( normal, tess.normal[ndx] );
+	if ( tess.indexPtr.p16 ) {
+		if ( tess.minIndex > Bob )
+			tess.minIndex = Bob;
+		if ( tess.maxIndex < Bob + surf->numPoints - 1 )
+			tess.maxIndex = Bob + surf->numPoints - 1;
+		
+		indices = ( unsigned * ) ( ( ( char  * ) surf ) + surf->ofsIndices );
+		if ( tess.indexInc == sizeof(GLushort) ) {
+			GLushort *indexPtr = tess.indexPtr.p16 + tess.numIndexes;
+			for ( i = surf->numIndices-1 ; i >= 0  ; i-- ) {
+				indexPtr[i] = (GLushort)(indices[i] + Bob);
+			}
+		} else {
+			GLuint *indexPtr32 = tess.indexPtr.p32 + tess.numIndexes;
+			for ( i = surf->numIndices-1 ; i >= 0  ; i-- ) {
+				indexPtr32[i] = indices[i] + Bob;
+			}
 		}
 	}
 
-	for ( i = 0, v = surf->points[0], ndx = tess.numVertexes; i < numPoints; i++, v += VERTEXSIZE, ndx++ ) {
-		VectorCopy( v, tess.xyz[ndx]);
-		tess.texCoords[ndx][0][0] = v[3];
-		tess.texCoords[ndx][0][1] = v[4];
-		tess.texCoords[ndx][1][0] = v[5];
-		tess.texCoords[ndx][1][1] = v[6];
-		* ( unsigned int * ) &tess.vertexColors[ndx] = * ( unsigned int * ) &v[7];
-		tess.vertexDlightBits[ndx] = dlightBits;
-	}
-
-
 	tess.numVertexes += surf->numPoints;
+	tess.numIndexes  += surf->numIndices;
 }
 
 
@@ -994,29 +1078,31 @@
 Just copy the grid of points and triangulate
 =============
 */
-static void RB_SurfaceGrid( srfGridMesh_t *cv ) {
+static void RB_SurfaceGrid( surfaceType_t *surface ) {
+	srfGridMesh_t *cv = (srfGridMesh_t *)surface;
 	int		i, j;
-	float	*xyz;
-	float	*texCoords;
-	float	*normal;
-	unsigned char *color;
+	vaWord1_t	*vertexPtr1;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
+	vaWord4_t	*vertexPtr4;
 	drawVert_t	*dv;
-	int		rows, irows, vrows;
-	int		used;
 	int		widthTable[MAX_GRID_SIZE];
 	int		heightTable[MAX_GRID_SIZE];
 	float	lodError;
 	int		lodWidth, lodHeight;
-	int		numVertexes;
+	int		baseVertex;
 	int		dlightBits;
-	int		*vDlightBits;
-	qboolean	needsNormal;
 
 	dlightBits = cv->dlightBits[backEnd.smpFrame];
 	tess.dlightBits |= dlightBits;
 
 	// determine the allowable discrepance
-	lodError = LodErrorForVolume( cv->lodOrigin, cv->lodRadius );
+	if ( r_ext_vertex_buffer_object->integer ) {
+		// always render max res for VBOs
+		lodError = r_lodCurveError->value;
+	} else {
+		lodError = LodErrorForVolume( cv->lodOrigin, cv->lodRadius );
+	}
 
 	// determine which rows and columns of the subdivision
 	// we are actually going to use
@@ -1042,107 +1128,92 @@
 	heightTable[lodHeight] = cv->height-1;
 	lodHeight++;
 
-
-	// very large grids may have more points or indexes than can be fit
-	// in the tess structure, so we may have to issue it in multiple passes
-
-	used = 0;
-	rows = 0;
-	while ( used < lodHeight - 1 ) {
-		// see how many rows of both verts and indexes we can add without overflowing
-		do {
-			vrows = ( SHADER_MAX_VERTEXES - tess.numVertexes ) / lodWidth;
-			irows = ( SHADER_MAX_INDEXES - tess.numIndexes ) / ( lodWidth * 6 );
-
-			// if we don't have enough space for at least one strip, flush the buffer
-			if ( vrows < 2 || irows < 1 ) {
-				RB_EndSurface();
-				RB_BeginSurface(tess.shader, tess.fogNum );
-			} else {
-				break;
-			}
-		} while ( 1 );
+	if ( tess.vertexPtr1 ) {
+		baseVertex = tess.numVertexes;
+		vertexPtr1 = tess.vertexPtr1 + baseVertex;
+		vertexPtr2 = tess.vertexPtr2 + baseVertex;
+		vertexPtr3 = tess.vertexPtr3 + baseVertex;
+		vertexPtr4 = tess.vertexPtr4 + baseVertex;
 		
-		rows = irows;
-		if ( vrows < irows + 1 ) {
-			rows = vrows - 1;
-		}
-		if ( used + rows > lodHeight ) {
-			rows = lodHeight - used;
-		}
-
-		numVertexes = tess.numVertexes;
-
-		xyz = tess.xyz[numVertexes];
-		normal = tess.normal[numVertexes];
-		texCoords = tess.texCoords[numVertexes][0];
-		color = ( unsigned char * ) &tess.vertexColors[numVertexes];
-		vDlightBits = &tess.vertexDlightBits[numVertexes];
-		needsNormal = tess.shader->needsNormal;
-
-		for ( i = 0 ; i < rows ; i++ ) {
-			for ( j = 0 ; j < lodWidth ; j++ ) {
-				dv = cv->verts + heightTable[ used + i ] * cv->width
+		for ( i = 0 ; i < lodHeight ; i++ ) {
+			for ( j = 0 ; j < lodWidth ; j++,
+				      vertexPtr1++, vertexPtr2++,
+				      vertexPtr3++, vertexPtr4++ ) {
+				dv = cv->verts + heightTable[ i ] * cv->width
 					+ widthTable[ j ];
-
-				xyz[0] = dv->xyz[0];
-				xyz[1] = dv->xyz[1];
-				xyz[2] = dv->xyz[2];
-				texCoords[0] = dv->st[0];
-				texCoords[1] = dv->st[1];
-				texCoords[2] = dv->lightmap[0];
-				texCoords[3] = dv->lightmap[1];
-				if ( needsNormal ) {
-					normal[0] = dv->normal[0];
-					normal[1] = dv->normal[1];
-					normal[2] = dv->normal[2];
-				}
-				* ( unsigned int * ) color = * ( unsigned int * ) dv->color;
-				*vDlightBits++ = dlightBits;
-				xyz += 4;
-				normal += 4;
-				texCoords += 4;
-				color += 4;
+				
+				VectorCopy( dv->xyz, vertexPtr2->xyz );
+				Vector2Copy ( dv->st, vertexPtr1->tc1 );
+				Vector2Copy ( dv->lightmap, vertexPtr1->tc2 );
+				VectorCopy( dv->normal, vertexPtr3->normal );
+				vertexPtr3->reserved = 0.0f;
+				*(unsigned int *)&vertexPtr4->color = *(unsigned int *)dv->color;
+				vertexPtr2->fogNum = tess.fogNum;
 			}
 		}
+	} else {
+		baseVertex = cv->vboStart;
+	}
+	
+	if ( tess.indexPtr.p16 ) {
+		if ( tess.minIndex > baseVertex )
+			tess.minIndex = baseVertex;
+		if ( tess.maxIndex < baseVertex + lodWidth*lodHeight - 1 )
+			tess.maxIndex = baseVertex + lodWidth*lodHeight - 1;
 
-
 		// add the indexes
-		{
-			int		numIndexes;
-			int		w, h;
-
-			h = rows - 1;
-			w = lodWidth - 1;
-			numIndexes = tess.numIndexes;
+		int		w, h;
+		
+		h = lodHeight - 1;
+		w = lodWidth - 1;
+		
+		if ( tess.indexInc == sizeof(GLushort) ) {
+			GLushort *indexPtr = tess.indexPtr.p16 + tess.numIndexes;
 			for (i = 0 ; i < h ; i++) {
 				for (j = 0 ; j < w ; j++) {
 					int		v1, v2, v3, v4;
 			
 					// vertex order to be reckognized as tristrips
-					v1 = numVertexes + i*lodWidth + j + 1;
+					v1 = baseVertex + i*lodWidth + j + 1;
 					v2 = v1 - 1;
 					v3 = v2 + lodWidth;
 					v4 = v3 + 1;
-
-					tess.indexes[numIndexes] = v2;
-					tess.indexes[numIndexes+1] = v3;
-					tess.indexes[numIndexes+2] = v1;
 					
-					tess.indexes[numIndexes+3] = v1;
-					tess.indexes[numIndexes+4] = v3;
-					tess.indexes[numIndexes+5] = v4;
-					numIndexes += 6;
+					*indexPtr++ = v2;
+					*indexPtr++ = v3;
+					*indexPtr++ = v1;
+					
+					*indexPtr++ = v1;
+					*indexPtr++ = v3;
+					*indexPtr++ = v4;
 				}
 			}
-
-			tess.numIndexes = numIndexes;
+		} else {
+			GLuint *indexPtr32 = tess.indexPtr.p32 + tess.numIndexes;
+			for (i = 0 ; i < h ; i++) {
+				for (j = 0 ; j < w ; j++) {
+					int		v1, v2, v3, v4;
+					
+					// vertex order to be reckognized as tristrips
+					v1 = baseVertex + i*lodWidth + j + 1;
+					v2 = v1 - 1;
+					v3 = v2 + lodWidth;
+					v4 = v3 + 1;
+					
+					*indexPtr32++ = v2;
+					*indexPtr32++ = v3;
+					*indexPtr32++ = v1;
+					
+					*indexPtr32++ = v1;
+					*indexPtr32++ = v3;
+					*indexPtr32++ = v4;
+				}
+			}
 		}
-
-		tess.numVertexes += rows * lodWidth;
-
-		used += rows - 1;
 	}
+	
+	tess.numVertexes += lodWidth * lodHeight;
+	tess.numIndexes  += 6 * (lodWidth - 1) * (lodHeight - 1);
 }
 
 
@@ -1162,19 +1233,36 @@
 ===================
 */
 static void RB_SurfaceAxis( void ) {
-	GL_Bind( tr.whiteImage );
+	static vec3_t vertexes[6] = {
+		{  0,  0,  0 },
+		{ 16,  0,  0 },
+		{  0,  0,  0 },
+		{  0, 16,  0 },
+		{  0,  0,  0 },
+		{  0,  0, 16 }
+	};
+	static color4ub_t colors[6] = {
+		{ 255,   0,   0, 255 },
+		{ 255,   0,   0, 255 },
+		{   0, 255,   0, 255 },
+		{   0, 255,   0, 255 },
+		{   0,   0, 255, 255 },
+		{   0,   0, 255, 255 }
+	};
+	glRenderState_t state;
+
+	InitState( &state );
+
+	state.numImages = 1;
+	state.image[0] = tr.whiteImage;
 	qglLineWidth( 3 );
-	qglBegin( GL_LINES );
-	qglColor3f( 1,0,0 );
-	qglVertex3f( 0,0,0 );
-	qglVertex3f( 16,0,0 );
-	qglColor3f( 0,1,0 );
-	qglVertex3f( 0,0,0 );
-	qglVertex3f( 0,16,0 );
-	qglColor3f( 0,0,1 );
-	qglVertex3f( 0,0,0 );
-	qglVertex3f( 0,0,16 );
-	qglEnd();
+	SetAttrPointer( &state, AL_VERTEX, 0,
+			3, GL_FLOAT, 0,
+			vertexes );
+	SetAttrPointer( &state, AL_COLOR, 0,
+			4, GL_UNSIGNED_BYTE, sizeof(color4ub_t),
+			colors );
+	GL_DrawArrays( &state, GL_LINES, 0, 6 );
 	qglLineWidth( 1 );
 }
 
@@ -1211,39 +1299,47 @@
 	return;
 }
 
+static void RB_SurfaceMD3Texture( surfaceType_t *surf ) {
+}
+
 static void RB_SurfaceBad( surfaceType_t *surfType ) {
 	ri.Printf( PRINT_ALL, "Bad surface tesselated.\n" );
 }
 
-static void RB_SurfaceFlare(srfFlare_t *surf)
+static void RB_SurfaceFlare( surfaceType_t *surface )
 {
+	srfFlare_t *surf = (srfFlare_t *)surface;
+
 	if (r_flares->integer)
 		RB_AddFlare(surf, tess.fogNum, surf->origin, surf->color, surf->normal);
 }
 
-static void RB_SurfaceDisplayList( srfDisplayList_t *surf ) {
+static void RB_SurfaceDisplayList( surfaceType_t *surface ) {
+	srfDisplayList_t *surf = (srfDisplayList_t *)surface;
 	// all apropriate state must be set in RB_BeginSurface
 	// this isn't implemented yet...
 	qglCallList( surf->listNum );
 }
 
-static void RB_SurfaceSkip( void *surf ) {
+static void RB_SurfaceSkip( surfaceType_t *surf ) {
 }
 
 
-void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])( void *) = {
-	(void(*)(void*))RB_SurfaceBad,			// SF_BAD, 
-	(void(*)(void*))RB_SurfaceSkip,			// SF_SKIP, 
-	(void(*)(void*))RB_SurfaceFace,			// SF_FACE,
-	(void(*)(void*))RB_SurfaceGrid,			// SF_GRID,
-	(void(*)(void*))RB_SurfaceTriangles,		// SF_TRIANGLES,
-	(void(*)(void*))RB_SurfacePolychain,		// SF_POLY,
-	(void(*)(void*))RB_SurfaceMesh,			// SF_MD3,
-	(void(*)(void*))RB_SurfaceAnim,			// SF_MD4,
+void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])( surfaceType_t * ) = {
+	RB_SurfaceBad,			// SF_BAD, 
+	RB_SurfaceSkip,			// SF_SKIP, 
+	RB_SurfaceFace,			// SF_FACE,
+	RB_SurfaceGrid,			// SF_GRID,
+	RB_SurfaceTriangles,		// SF_TRIANGLES,
+	RB_SurfacePolychain,		// SF_POLY,
+	RB_SurfaceMesh,			// SF_MD3,
+	RB_SurfaceAnim,			// SF_MD4,
 #ifdef RAVENMD4
-	(void(*)(void*))RB_MDRSurfaceAnim,		// SF_MDR,
+	RB_MDRSurfaceAnim,		// SF_MDR,
 #endif
-	(void(*)(void*))RB_SurfaceFlare,		// SF_FLARE,
-	(void(*)(void*))RB_SurfaceEntity,		// SF_ENTITY
-	(void(*)(void*))RB_SurfaceDisplayList		// SF_DISPLAY_LIST
+	RB_IQMSurfaceAnim,		// SF_IQM,
+	RB_SurfaceFlare,		// SF_FLARE,
+	RB_SurfaceEntity,		// SF_ENTITY
+	RB_SurfaceDisplayList,		// SF_DISPLAY_LIST
+	RB_SurfaceMD3Texture		// SF_MD3_TEXTURE
 };
Index: src/renderer/tr_image_pcx.c
===================================================================
--- src/renderer/tr_image_pcx.c	(Revision 2062)
+++ src/renderer/tr_image_pcx.c	(Arbeitskopie)
@@ -49,7 +49,7 @@
 	unsigned char	data[];
 } pcx_t;
 
-void R_LoadPCX ( const char *filename, byte **pic, int *width, int *height)
+void R_LoadPCX ( const char *filename, texImage_t *pic, int *width, int *height)
 {
 	union {
 		byte *b;
@@ -70,7 +70,7 @@
 		*width = 0;
 	if (height)
 		*height = 0;
-	*pic = NULL;
+	pic->numMipmaps = 0;
 
 	//
 	// load the file
@@ -169,7 +169,9 @@
 	if (height)
 		*height = h;
 
-	*pic = out;
+	pic->format = GL_RGBA8;
+	pic->numMipmaps = 1;
+	pic->data[0] = out;
 
 	ri.FS_FreeFile (pcx);
 	ri.Free (pic8);
Index: src/renderer/tr_scene.c
===================================================================
--- src/renderer/tr_scene.c	(Revision 2062)
+++ src/renderer/tr_scene.c	(Arbeitskopie)
@@ -106,7 +106,7 @@
 
 	for ( i = 0, poly = tr.refdef.polys; i < tr.refdef.numPolys ; i++, poly++ ) {
 		sh = R_GetShaderByHandle( poly->hShader );
-		R_AddDrawSurf( ( void * )poly, sh, poly->fogIndex, qfalse );
+		R_AddDrawSurf( ( void * )poly, sh, poly->fogIndex, 0, qfalse );
 	}
 }
 
@@ -206,6 +206,8 @@
 =====================
 */
 void RE_AddRefEntityToScene( const refEntity_t *ent ) {
+	trRefEntity_t		*trEnt;
+
 	if ( !tr.registered ) {
 		return;
 	}
@@ -216,7 +218,7 @@
 		static qboolean firstTime = qtrue;
 		if (firstTime) {
 			firstTime = qfalse;
-			Com_DPrintf(S_COLOR_YELLOW "WARNING: RE_AddRefEntityToScene passed a refEntity which has an origin with a NaN component\n");
+			ri.Printf(PRINT_WARNING, "RE_AddRefEntityToScene passed a refEntity which has an origin with a NaN component\n");
 		}
 		return;
 	}
@@ -224,8 +226,9 @@
 		ri.Error( ERR_DROP, "RE_AddRefEntityToScene: bad reType %i", ent->reType );
 	}
 
-	backEndData[tr.smpFrame]->entities[r_numentities].e = *ent;
-	backEndData[tr.smpFrame]->entities[r_numentities].lightingCalculated = qfalse;
+	trEnt = &backEndData[tr.smpFrame]->entities[r_numentities];
+	trEnt->e = *ent;
+	trEnt->lightingCalculated = qfalse;
 
 	r_numentities++;
 }
@@ -393,7 +396,8 @@
 	parms.viewportY = glConfig.vidHeight - ( tr.refdef.y + tr.refdef.height );
 	parms.viewportWidth = tr.refdef.width;
 	parms.viewportHeight = tr.refdef.height;
-	parms.isPortal = qfalse;
+	parms.portalLevel = 0;
+	parms.isFirst = qtrue;
 
 	parms.fovX = tr.refdef.fov_x;
 	parms.fovY = tr.refdef.fov_y;
Index: src/renderer/tr_shader.c
===================================================================
--- src/renderer/tr_shader.c	(Revision 2062)
+++ src/renderer/tr_shader.c	(Arbeitskopie)
@@ -697,6 +697,10 @@
 					stage->bundle[0].numImageAnimations++;
 				}
 			}
+			if( stage->bundle[0].numImageAnimations > 1 ) {
+				stage->bundle[0].combinedImage = R_CombineImages(stage->bundle[0].numImageAnimations,
+										 stage->bundle[0].image);
+			}
 		}
 		else if ( !Q_stricmp( token, "videoMap" ) )
 		{
@@ -835,7 +839,10 @@
 			}
 			else if ( !Q_stricmp( token, "identityLighting" ) )
 			{
-				stage->rgbGen = CGEN_IDENTITY_LIGHTING;
+				if ( r_overBrightBits->integer == 0 )
+					stage->rgbGen = CGEN_IDENTITY;
+				else
+					stage->rgbGen = CGEN_IDENTITY_LIGHTING;
 			}
 			else if ( !Q_stricmp( token, "entity" ) )
 			{
@@ -1010,6 +1017,43 @@
 		}
 	}
 
+	// I assume DST_ALPHA is always 1, so I just replace it with GL_ONE
+	if ( blendSrcBits == GLS_SRCBLEND_DST_ALPHA )
+		blendSrcBits = GLS_SRCBLEND_ONE;
+	else if ( blendSrcBits == GLS_SRCBLEND_ONE_MINUS_DST_ALPHA )
+		blendSrcBits = GLS_SRCBLEND_ZERO;
+
+	if ( blendDstBits == GLS_DSTBLEND_DST_ALPHA )
+		blendDstBits = GLS_DSTBLEND_ONE;
+	else if ( blendDstBits == GLS_DSTBLEND_ONE_MINUS_DST_ALPHA )
+		blendDstBits = GLS_DSTBLEND_ZERO;
+
+	// If the image has no (real) alpha channel, we can do the same
+	// for SRC_ALPHA
+	if ( !stage->bundle[0].image[0]->hasAlpha &&
+	     stage->alphaGen == AGEN_IDENTITY) {
+		if ( blendSrcBits == GLS_SRCBLEND_SRC_ALPHA )
+			blendSrcBits = GLS_SRCBLEND_ONE;
+		else if ( blendSrcBits == GLS_SRCBLEND_ONE_MINUS_SRC_ALPHA )
+			blendSrcBits = GLS_SRCBLEND_ZERO;
+		
+		if ( blendDstBits == GLS_DSTBLEND_SRC_ALPHA )
+			blendDstBits = GLS_DSTBLEND_ONE;
+		else if ( blendDstBits == GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA )
+			blendDstBits = GLS_DSTBLEND_ZERO;
+
+		// also alphaFunc makes no sense without alpha
+		atestBits = 0;
+	} else {
+		// image has alpha, if we use alpha blending we can optimise
+		// alphafunc NONE to alphafunc GT0
+		if ( blendSrcBits == GLS_SRCBLEND_SRC_ALPHA &&
+		     blendDstBits == GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA &&
+		     atestBits == 0 ) {
+			atestBits = GLS_ATEST_GT_0;
+		}
+	}
+
 	//
 	// if cgen isn't explicitly specified, use either identity or identitylighting
 	//
@@ -1023,7 +1067,6 @@
 		}
 	}
 
-
 	//
 	// implicitly assume that a GL_ONE GL_ZERO blend mask disables blending
 	//
@@ -1035,7 +1078,7 @@
 	}
 
 	// decide which agens we can skip
-	if ( stage->alphaGen == CGEN_IDENTITY ) {
+	if ( stage->alphaGen == AGEN_IDENTITY ) {
 		if ( stage->rgbGen == CGEN_IDENTITY
 			|| stage->rgbGen == CGEN_LIGHTING_DIFFUSE ) {
 			stage->alphaGen = AGEN_SKIP;
@@ -1403,6 +1446,7 @@
 {
 	char *token;
 	int s;
+	qboolean	polygonOffset = qfalse;
 
 	s = 0;
 
@@ -1518,7 +1562,7 @@
 		// polygonOffset
 		else if ( !Q_stricmp( token, "polygonOffset" ) )
 		{
-			shader.polygonOffset = qtrue;
+			polygonOffset = qtrue;
 			continue;
 		}
 		// entityMergable, allowing sprite surfaces from multiple entities
@@ -1611,6 +1655,13 @@
 		return qfalse;
 	}
 
+	if ( polygonOffset ) {
+		int i;
+		for( i = 0; i < s; i++ ) {
+			stages[i].stateBits |= GLS_POLYGON_OFFSET;
+		}
+	}
+
 	shader.explicitlyDefined = qtrue;
 
 	return qtrue;
@@ -1634,6 +1685,11 @@
 */
 static void ComputeStageIteratorFunc( void )
 {
+	int stage;
+	int units = glConfig.numTextureUnits;
+
+	if (!units) units = 1;
+	
 	shader.optimalStageIteratorFunc = RB_StageIteratorGeneric;
 
 	//
@@ -1645,6 +1701,137 @@
 		goto done;
 	}
 
+	if ( qglGenBuffersARB &&
+	     !r_greyscale->integer &&
+	     shader.lightmapIndex != LIGHTMAP_2D ) {
+		shader.useVBO = qtrue;
+	}
+	
+	// check all deformation stages
+	for ( stage = 0; stage < shader.numDeforms; stage ++ ) {
+		switch ( shader.deforms[stage].deformation ) {
+		case DEFORM_NONE:
+			break;
+		case DEFORM_WAVE:
+		case DEFORM_NORMALS:
+		case DEFORM_BULGE:
+			shader.useVBO = qfalse;
+			break;
+		case DEFORM_MOVE:
+		case DEFORM_PROJECTION_SHADOW:
+		case DEFORM_AUTOSPRITE:
+		case DEFORM_AUTOSPRITE2:
+		case DEFORM_TEXT0:
+		case DEFORM_TEXT1:
+		case DEFORM_TEXT2:
+		case DEFORM_TEXT3:
+		case DEFORM_TEXT4:
+		case DEFORM_TEXT5:
+		case DEFORM_TEXT6:
+		case DEFORM_TEXT7:
+			shader.useVBO = qfalse;
+			break;
+		}
+	}
+	
+	// check all shader stages
+	for ( stage = 0; stage < MAX_SHADER_STAGES; stage++ )
+	{
+		shaderStage_t *pStage = &stages[stage];
+		int           bundle;
+		
+		if ( !pStage->active )
+		{
+			break;
+		}
+		
+		switch ( pStage->rgbGen ) {
+		case CGEN_IDENTITY_LIGHTING:
+		case CGEN_IDENTITY:
+		case CGEN_ENTITY:
+		case CGEN_ONE_MINUS_ENTITY:
+		case CGEN_CONST:
+		case CGEN_WAVEFORM:
+			// constant color, VBO possible
+			break;
+		case CGEN_EXACT_VERTEX:
+		case CGEN_VERTEX:
+			// vertex colors, VBO possible
+			break;
+		case CGEN_LIGHTING_DIFFUSE:
+			// normals needed, no VBO possible
+			shader.useVBO = qfalse;
+			break;
+		case CGEN_ONE_MINUS_VERTEX:
+			// vertex colors needed, no VBO
+			shader.useVBO = qfalse;
+			break;
+		case CGEN_BAD:
+		case CGEN_FOG:
+			// no vertex colors needed, no VBO
+			shader.useVBO = qfalse;
+			break;
+		}
+
+		switch ( pStage->alphaGen ) {
+		case AGEN_SKIP:
+			break;
+		case AGEN_IDENTITY:
+		case AGEN_ENTITY:
+		case AGEN_ONE_MINUS_ENTITY:
+		case AGEN_CONST:
+		case AGEN_WAVEFORM:
+			if ( pStage->rgbGen == CGEN_VERTEX ||
+			     pStage->rgbGen == CGEN_EXACT_VERTEX ) {
+				// cannot combine const alpha with vertex color
+				shader.useVBO = qfalse;
+			}
+			break;
+		case AGEN_VERTEX:
+			if ( pStage->rgbGen != CGEN_VERTEX &&
+			     pStage->rgbGen != CGEN_EXACT_VERTEX ) {
+				// cannot combine vertex alpha with const color
+				shader.useVBO = qfalse;
+			}
+			break;
+		case AGEN_ONE_MINUS_VERTEX:
+			shader.useVBO = qfalse;
+			break;
+		case AGEN_LIGHTING_SPECULAR:
+		case AGEN_PORTAL:
+			shader.useVBO = qfalse;
+			break;
+		}
+		
+		for ( bundle = 0; bundle < units; bundle++ ) {
+			if ( bundle > 0 && !pStage->bundle[bundle].multitextureEnv )
+				break;
+			
+			switch ( pStage->bundle[bundle].tcGen ) {
+			case TCGEN_BAD:
+				break;
+			case TCGEN_IDENTITY:
+			case TCGEN_VECTOR:
+			case TCGEN_FOG:
+				shader.useVBO = qfalse;
+				break;
+			case TCGEN_LIGHTMAP:
+				break;
+			case TCGEN_TEXTURE:
+				break;
+			case TCGEN_ENVIRONMENT_MAPPED:
+				shader.useVBO = qfalse;
+				break;
+			}
+			if ( pStage->bundle[bundle].numTexMods > 0 )
+				shader.useVBO = qfalse;
+		}
+	}
+
+	// no VBOs for 0-stage shaders (fog)
+	if ( stage == 0 )
+		shader.useVBO = qfalse;
+
 	if ( r_ignoreFastPath->integer )
 	{
 		return;
@@ -1661,15 +1848,12 @@
 			{
 				if ( stages[0].bundle[0].tcGen == TCGEN_TEXTURE )
 				{
-					if ( !shader.polygonOffset )
+					if ( !stages[0].bundle[1].multitextureEnv )
 					{
-						if ( !shader.multitextureEnv )
+						if ( !shader.numDeforms )
 						{
-							if ( !shader.numDeforms )
-							{
-								shader.optimalStageIteratorFunc = RB_StageIteratorVertexLitTexture;
-								goto done;
-							}
+							shader.optimalStageIteratorFunc = RB_StageIteratorVertexLitTexture;
+							goto done;
 						}
 					}
 				}
@@ -1687,15 +1871,12 @@
 			if ( stages[0].bundle[0].tcGen == TCGEN_TEXTURE && 
 				stages[0].bundle[1].tcGen == TCGEN_LIGHTMAP )
 			{
-				if ( !shader.polygonOffset )
+				if ( !shader.numDeforms )
 				{
-					if ( !shader.numDeforms )
+					if ( stages[0].bundle[1].multitextureEnv )
 					{
-						if ( shader.multitextureEnv )
-						{
-							shader.optimalStageIteratorFunc = RB_StageIteratorLightmappedMultitexture;
-							goto done;
-						}
+						shader.optimalStageIteratorFunc = RB_StageIteratorLightmappedMultitexture;
+						goto done;
 					}
 				}
 			}
@@ -1749,225 +1930,252 @@
 ================
 CollapseMultitexture
 
-Attempt to combine two stages into a single multitexture stage
+Attempt to combine several stages into a single multitexture stage
 FIXME: I think modulated add + modulated add collapses incorrectly
 =================
 */
-static qboolean CollapseMultitexture( void ) {
+static int CollapseMultitexture( void ) {
+	int stage, bundle;
 	int abits, bbits;
 	int i;
 	textureBundle_t tmpBundle;
 
-	if ( !qglActiveTextureARB ) {
-		return qfalse;
-	}
+	stage = 0;
+	bundle = 0;
 
-	// make sure both stages are active
-	if ( !stages[0].active || !stages[1].active ) {
-		return qfalse;
-	}
+	while( stage < MAX_SHADER_STAGES && stages[stage].active ) {
+		if ( bundle + 1 >= glConfig.numTextureUnits ) {
+			// can't add next stage, no more texture units
+			stage++;
+			bundle = 0;
+			continue;
+		}
+		
+		// make sure both stages are active
+		if ( !stages[stage + 1].active ) {
+			// can't add next stage, it doesn't exist
+			stage++;
+			bundle = 0;
+			continue;
+		}
 
-	// on voodoo2, don't combine different tmus
-	if ( glConfig.driverType == GLDRV_VOODOO ) {
-		if ( stages[0].bundle[0].image[0]->TMU ==
-			 stages[1].bundle[0].image[0]->TMU ) {
-			return qfalse;
+		// on voodoo2, don't combine different tmus
+		if ( glConfig.driverType == GLDRV_VOODOO ) {
+			if ( stages[stage].bundle[0].image[0]->TMU ==
+			     stages[stage + 1].bundle[0].image[0]->TMU ) {
+				stage++;
+				bundle = 0;
+				continue;
+			}
 		}
-	}
 
-	abits = stages[0].stateBits;
-	bbits = stages[1].stateBits;
+		abits = stages[stage].stateBits;
+		bbits = stages[stage + 1].stateBits;
+		/*
+		// can't combine if the second stage has an alpha test
+		if ( bbits & GLS_ATEST_BITS ) {
+			stage++;
+			bundle = 0;
+			continue;
+		}
 
-	// make sure that both stages have identical state other than blend modes
-	if ( ( abits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) !=
-		( bbits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) ) {
-		return qfalse;
-	}
-
-	abits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
-	bbits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
-
-	// search for a valid multitexture blend function
-	for ( i = 0; collapse[i].blendA != -1 ; i++ ) {
-		if ( abits == collapse[i].blendA
-			&& bbits == collapse[i].blendB ) {
-			break;
+		// can combine alphafunc only if depthwrite is enabled and
+		// the second stage has depthfunc equal
+		if ( abits & GLS_ATEST_BITS ) {
+			if (!((abits & GLS_DEPTHMASK_TRUE) &&
+			      (bbits & GLS_DEPTHFUNC_EQUAL)) ) {
+				stage++;
+				bundle = 0;
+				continue;
+			}
+		} else {
+			if ( (abits & GLS_DEPTHFUNC_EQUAL) !=
+			     (bbits & GLS_DEPTHFUNC_EQUAL) ) {
+				stage++;
+				bundle = 0;
+				continue;
+			}
 		}
-	}
-
-	// nothing found
-	if ( collapse[i].blendA == -1 ) {
-		return qfalse;
-	}
-
-	// GL_ADD is a separate extension
-	if ( collapse[i].multitextureEnv == GL_ADD && !glConfig.textureEnvAddAvailable ) {
-		return qfalse;
-	}
-
-	// make sure waveforms have identical parameters
-	if ( ( stages[0].rgbGen != stages[1].rgbGen ) ||
-		( stages[0].alphaGen != stages[1].alphaGen ) )  {
-		return qfalse;
-	}
-
-	// an add collapse can only have identity colors
-	if ( collapse[i].multitextureEnv == GL_ADD && stages[0].rgbGen != CGEN_IDENTITY ) {
-		return qfalse;
-	}
-
-	if ( stages[0].rgbGen == CGEN_WAVEFORM )
-	{
-		if ( memcmp( &stages[0].rgbWave,
-					 &stages[1].rgbWave,
-					 sizeof( stages[0].rgbWave ) ) )
+		*/
+		// make sure that both stages have identical state other than blend modes
+		if ( ( abits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) !=
+		     ( bbits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) ) {
+			stage++;
+			bundle = 0;
+			continue;
+		}
+		
+		abits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+		bbits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+		
+		// search for a valid multitexture blend function
+		for ( i = 0; collapse[i].blendA != -1 ; i++ ) {
+			if ( abits == collapse[i].blendA
+			     && bbits == collapse[i].blendB ) {
+				break;
+			}
+		}
+		
+		// nothing found
+		if ( collapse[i].blendA == -1 ) {
+			stage++;
+			bundle = 0;
+			continue;
+		}
+		
+		// GL_ADD is a separate extension
+		if ( collapse[i].multitextureEnv == GL_ADD && !glConfig.textureEnvAddAvailable ) {
+			stage++;
+			bundle = 0;
+			continue;
+		}
+		
+		// make sure waveforms have identical parameters
+		if ( ( stages[stage].rgbGen != stages[stage + 1].rgbGen ) ||
+		     ( stages[stage].alphaGen != stages[stage + 1].alphaGen ) )  {
+			stage++;
+			bundle = 0;
+			continue;
+		}
+		
+		// an add collapse can only have identity colors
+		if ( collapse[i].multitextureEnv == GL_ADD && stages[stage].rgbGen != CGEN_IDENTITY ) {
+			stage++;
+			bundle = 0;
+			continue;
+		}
+		
+		if ( stages[stage].rgbGen == CGEN_WAVEFORM )
 		{
-			return qfalse;
+			if ( memcmp( &stages[stage].rgbWave,
+				     &stages[stage + 1].rgbWave,
+				     sizeof( stages[stage].rgbWave ) ) )
+			{
+				stage++;
+				bundle = 0;
+				continue;
+			}
 		}
-	}
-	if ( stages[0].alphaGen == CGEN_WAVEFORM )
-	{
-		if ( memcmp( &stages[0].alphaWave,
-					 &stages[1].alphaWave,
-					 sizeof( stages[0].alphaWave ) ) )
+		if ( stages[stage].alphaGen == AGEN_WAVEFORM )
 		{
-			return qfalse;
+			if ( memcmp( &stages[stage].alphaWave,
+				     &stages[stage + 1].alphaWave,
+				     sizeof( stages[stage].alphaWave ) ) )
+			{
+				stage++;
+				bundle = 0;
+				continue;
+			}
 		}
-	}
+		
+		
+		// make sure that lightmaps are in bundle 1 for 3dfx
+		if ( bundle == 0 && stages[stage].bundle[0].isLightmap )
+		{
+			tmpBundle = stages[stage].bundle[0];
+			stages[stage].bundle[0] = stages[stage + 1].bundle[0];
+			stages[stage].bundle[1] = tmpBundle;
+		}
+		else
+		{
+			stages[stage].bundle[bundle + 1] = stages[stage + 1].bundle[0];
+		}
+		
+		// set the new blend state bits
+		stages[stage].bundle[bundle + 1].multitextureEnv = collapse[i].multitextureEnv;
+		stages[stage].stateBits &= ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+		stages[stage].stateBits |= collapse[i].multitextureBlend;
 
+		bundle++;
 
-	// make sure that lightmaps are in bundle 1 for 3dfx
-	if ( stages[0].bundle[0].isLightmap )
-	{
-		tmpBundle = stages[0].bundle[0];
-		stages[0].bundle[0] = stages[1].bundle[0];
-		stages[0].bundle[1] = tmpBundle;
+		//
+		// move down subsequent shaders
+		//
+		memmove( &stages[stage + 1], &stages[stage + 2], sizeof( stages[0] ) * ( MAX_SHADER_STAGES - stage - 2 ) );
+		Com_Memset( &stages[MAX_SHADER_STAGES-1], 0, sizeof( stages[0] ) );
 	}
-	else
-	{
-		stages[0].bundle[1] = stages[1].bundle[0];
-	}
 
-	// set the new blend state bits
-	shader.multitextureEnv = collapse[i].multitextureEnv;
-	stages[0].stateBits &= ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
-	stages[0].stateBits |= collapse[i].multitextureBlend;
-
-	//
-	// move down subsequent shaders
-	//
-	memmove( &stages[1], &stages[2], sizeof( stages[0] ) * ( MAX_SHADER_STAGES - 2 ) );
-	Com_Memset( &stages[MAX_SHADER_STAGES-1], 0, sizeof( stages[0] ) );
-
-	return qtrue;
+	return stage;
 }
 
 /*
-=============
+==============
+R_SortShaders
 
-FixRenderCommandList
-https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=493
-Arnout: this is a nasty issue. Shaders can be registered after drawsurfaces are generated
-but before the frame is rendered. This will, for the duration of one frame, cause drawsurfaces
-to be rendered with bad shaders. To fix this, need to go through all render commands and fix
-sortedIndex.
+Positions all shaders in the tr.sortedShaders[]
+array so that the shader->sort key is sorted relative
+to the other shaders. If shaders use the same GLSL
+program, sort them all to the max occluder to avoid
+expensive program switches later.
+
+Uses a stable, in-place variant of odd-even mergeSort
+which is O(n log^2 n) worst case, but should be more
+cache-friendly than pure merge or radix sort, because
+makes several linear passes over the buffer.
+
+Sets shader->sortedIndex
 ==============
 */
-static void FixRenderCommandList( int newShader ) {
-	renderCommandList_t	*cmdList = &backEndData[tr.smpFrame]->commands;
+static ID_INLINE int cmpShader( int left, int right )
+{
+	shader_t	*l, *r;
+	int		diff;
+	GLuint		resultL, resultR;
+	
+	l = tr.sortedShaders[left];
+	r = tr.sortedShaders[right];
+	
+	diff = l->sort - r->sort;
+	if( !diff ) {
+		if( l->GLSLprogram )
+			resultL = l->GLSLprogram->QuerySum;
+		else
+			resultL = l->QueryResult;
 
-	if( cmdList ) {
-		const void *curCmd = cmdList->cmds;
+		if( r->GLSLprogram )
+			resultR = r->GLSLprogram->QuerySum;
+		else
+			resultR = r->QueryResult;
 
-		while ( 1 ) {
-			switch ( *(const int *)curCmd ) {
-			case RC_SET_COLOR:
-				{
-				const setColorCommand_t *sc_cmd = (const setColorCommand_t *)curCmd;
-				curCmd = (const void *)(sc_cmd + 1);
-				break;
-				}
-			case RC_STRETCH_PIC:
-				{
-				const stretchPicCommand_t *sp_cmd = (const stretchPicCommand_t *)curCmd;
-				curCmd = (const void *)(sp_cmd + 1);
-				break;
-				}
-			case RC_DRAW_SURFS:
-				{
-				int i;
-				drawSurf_t	*drawSurf;
-				shader_t	*shader;
-				int			fogNum;
-				int			entityNum;
-				int			dlightMap;
-				int			sortedIndex;
-				const drawSurfsCommand_t *ds_cmd =  (const drawSurfsCommand_t *)curCmd;
-
-				for( i = 0, drawSurf = ds_cmd->drawSurfs; i < ds_cmd->numDrawSurfs; i++, drawSurf++ ) {
-					R_DecomposeSort( drawSurf->sort, &entityNum, &shader, &fogNum, &dlightMap );
-                    sortedIndex = (( drawSurf->sort >> QSORT_SHADERNUM_SHIFT ) & (MAX_SHADERS-1));
-					if( sortedIndex >= newShader ) {
-						sortedIndex++;
-						drawSurf->sort = (sortedIndex << QSORT_SHADERNUM_SHIFT) | entityNum | ( fogNum << QSORT_FOGNUM_SHIFT ) | (int)dlightMap;
-					}
-				}
-				curCmd = (const void *)(ds_cmd + 1);
-				break;
-				}
-			case RC_DRAW_BUFFER:
-				{
-				const drawBufferCommand_t *db_cmd = (const drawBufferCommand_t *)curCmd;
-				curCmd = (const void *)(db_cmd + 1);
-				break;
-				}
-			case RC_SWAP_BUFFERS:
-				{
-				const swapBuffersCommand_t *sb_cmd = (const swapBuffersCommand_t *)curCmd;
-				curCmd = (const void *)(sb_cmd + 1);
-				break;
-				}
-			case RC_END_OF_LIST:
-			default:
-				return;
-			}
-		}
+		diff = resultR - resultL;
 	}
+	if( !diff ) {
+		diff = l->GLSLprogram - r->GLSLprogram;
+	}
+	if( !diff ) {
+		diff = r->QueryResult - l->QueryResult;
+	}
+	if( !diff ) {
+		diff = l->index - r->index;
+	}
+	return diff;
 }
+void R_SortShaders( void ) {
+	int i, j, k;
+	shader_t *tmp;
 
-/*
-==============
-SortNewShader
+	for( i = 1; i < tr.numShaders; i++ ) {
+		if( cmpShader( i-1, i ) > 0 ) {
+			tmp = tr.sortedShaders[i];
 
-Positions the most recently created shader in the tr.sortedShaders[]
-array so that the shader->sort key is sorted reletive to the other
-shaders.
+			j = 0;
+			k = i;
+			while( j < k ) {
+				int mid = (j + k) >> 1;
+				if( cmpShader( mid, i ) > 0 )
+					k = mid;
+				else
+					j = mid+1;
+			}
 
-Sets shader->sortedIndex
-==============
-*/
-static void SortNewShader( void ) {
-	int		i;
-	float	sort;
-	shader_t	*newShader;
-
-	newShader = tr.shaders[ tr.numShaders - 1 ];
-	sort = newShader->sort;
-
-	for ( i = tr.numShaders - 2 ; i >= 0 ; i-- ) {
-		if ( tr.sortedShaders[ i ]->sort <= sort ) {
-			break;
+			for( k = i; k > j; k-- ) {
+				tr.sortedShaders[k] = tr.sortedShaders[k-1];
+				tr.sortedShaders[k]->sortedIndex = k;
+			}
+			tr.sortedShaders[j] = tmp;
+			tr.sortedShaders[j]->sortedIndex = j;
 		}
-		tr.sortedShaders[i+1] = tr.sortedShaders[i];
-		tr.sortedShaders[i+1]->sortedIndex++;
 	}
-
-	// Arnout: fix rendercommandlist
-	// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=493
-	FixRenderCommandList( i+1 );
-
-	newShader->sortedIndex = i+1;
-	tr.sortedShaders[i+1] = newShader;
 }
 
 
@@ -2017,9 +2225,21 @@
 			Com_Memcpy( newShader->stages[i]->bundle[b].texMods, stages[i].bundle[b].texMods, size );
 		}
 	}
+	if( shader.optimalStageIteratorFunc == RB_StageIteratorGLSL ) {
+		newShader->stages[0]->stateBits &= ~GLS_ATEST_BITS;
+	}
 
-	SortNewShader();
+	R_SortShaders();
 
+	// prepare occlusion queries for shaders that write to depth buffer
+	if ( qglGenQueriesARB && !newShader->isDepth &&
+	     newShader->stages[0] &&
+	     (newShader->stages[0]->stateBits & GLS_DEPTHMASK_TRUE) &&
+	     !(newShader->stages[0]->stateBits & GLS_COLORMASK_FALSE) ) {
+		qglGenQueriesARB( 1, &newShader->QueryID );
+		newShader->QueryResult = 0;
+	}
+
 	hash = generateHashValue(newShader->name, FILE_HASH_SIZE);
 	newShader->next = hashTable[hash];
 	hashTable[hash] = newShader;
@@ -2029,6 +2249,1593 @@
 
 /*
 =================
+CollapseGLSL
+
+Try to compile a GLSL vertex and fragment shader that
+computes the same effect as a multipass fixed function shader.
+=================
+*/
+static unsigned short GLSLversion = 0x0000;
+static char GLSLTexNames[MAX_SHADER_STAGES][6];
+static int CollapseGLSL( void ) {
+	enum VSFeatures {
+		vsfShaderTime = 0x00000001,
+		vsfNormal     = 0x00000002,
+		vsfColor      = 0x00000004,
+		vsfTexCoord   = 0x00000008,
+		vsfCameraPos  = 0x00000010,
+		vsfEntLight   = 0x00000080,
+		vsfLightDir   = 0x00000100,
+		vsfGenSin     = 0x00001000,
+		vsfGenSquare  = 0x00002000,
+		vsfGenTri     = 0x00004000,
+		vsfGenSaw     = 0x00008000,
+		vsfGenInvSaw  = 0x00010000,
+		vsfGenNoise   = 0x00020000
+	} vsFeatures = 0;
+	enum FSFeatures {
+		fsfShaderTime = 0x00000001,
+		fsfVertex     = 0x00000002,
+		fsfReflView   = 0x00000004,
+		fsfLightDir   = 0x00000008,
+		fsfNormal     = 0x00000100,
+		fsfTangents   = 0x00000200,
+		fsfDiffuse    = 0x00000400,
+		fsfSpecular   = 0x00000800,
+		fsfGenSin     = 0x00001000,
+		fsfGenSquare  = 0x00002000,
+		fsfGenTri     = 0x00004000,
+		fsfGenSaw     = 0x00008000,
+		fsfGenInvSaw  = 0x00010000,
+		fsfGenNoise   = 0x00020000,
+		fsfGenRotate  = 0x00040000,
+		fsfCameraPos  = 0x00080000
+	} fsFeatures = 0;
+	unsigned int attributes = (1 << AL_VERTEX) |
+		(1 << AL_TRANSX) | (1 << AL_TRANSY) | (1 << AL_TRANSZ);
+
+	const char *VS[1000];
+	const char *FS[1000];
+	byte        constantColor[MAX_SHADER_STAGES][4];
+	int         texIndex[MAX_SHADER_STAGES];
+	char        shaderConsts[100][20];
+	int         VSidx = 0;
+	int         FSidx = 0;
+	int         constidx = 0;
+	int         i, j;
+	int         lightmapStage = -1;
+	int         normalStage = -1;
+	int         materialStage = -1;
+	alphaGen_t  aGen;
+	enum {
+		REPLACE,
+		BLEND,
+		FILTER
+	} blendMode;
+
+	// helper macros to build the Vertex and Fragment Shaders
+#define VSText(text) VS[VSidx++] = text
+#define VSConst(format, value) VS[VSidx++] = shaderConsts[constidx]; Com_sprintf( shaderConsts[constidx++], sizeof(shaderConsts[0]), format, value)
+
+#define FSText(text) FS[FSidx++] = text
+#define FSConst(format, value) FS[FSidx++] = shaderConsts[constidx]; Com_sprintf( shaderConsts[constidx++], sizeof(shaderConsts[0]), format, value)
+#define FSGenFunc(wave) FSText("(");					\
+			FSConst("%f", wave.base);			\
+			FSText(" + ");					\
+			FSConst("%f", wave.amplitude);			\
+			switch( wave.func ) {				\
+			case GF_NONE:					\
+				return qfalse;				\
+			case GF_SIN:					\
+				FSText(" * genFuncSin(");		\
+				break;					\
+			case GF_SQUARE:					\
+				FSText(" * genFuncSquare(");		\
+				break;					\
+			case GF_TRIANGLE:				\
+				FSText(" * genFuncTriangle(");		\
+				break;					\
+			case GF_SAWTOOTH:				\
+				FSText(" * genFuncSawtooth(");		\
+				break;					\
+			case GF_INVERSE_SAWTOOTH:			\
+				FSText(" * genFuncInverseSawtooth(");	\
+				break;					\
+			case GF_NOISE:					\
+				FSText(" * genFuncNoise(");		\
+				break;					\
+			}						\
+			FSConst("%f", wave.phase);			\
+			FSText(" + ");					\
+			FSConst("%f", wave.frequency);			\
+			FSText("* vShadertime))");
+
+	if( !(qglCreateShader && stages[0].active) || shader.isSky ) {
+		// single stage can be rendered without GLSL
+		return qfalse;
+	}
+
+	if( shader.lightmapIndex == LIGHTMAP_MD3 && !qglGenBuffersARB ) {
+		// frame interpolation requires VBOs
+		return qfalse;
+	}
+
+	if( !GLSLversion ) {
+		const char *GLSLString = (const char *)glGetString( GL_SHADING_LANGUAGE_VERSION_ARB );
+		int major, minor;
+
+		sscanf( GLSLString, "%d.%d", &major, &minor );
+		GLSLversion = (unsigned short)(major << 8 | minor);
+		
+		for( i = 0; i < MAX_SHADER_STAGES; i++ ) {
+			Com_sprintf( GLSLTexNames[i], sizeof(GLSLTexNames[i]),
+				     "tex%02d", i );
+		}
+	}
+	
+#ifdef HACK_MEDISTAT_SHADER
+	if( (stages[0].stateBits & GLS_SRCBLEND_BITS) == GLS_SRCBLEND_ONE_MINUS_DST_COLOR &&
+	    (stages[0].stateBits & GLS_DSTBLEND_BITS) == GLS_DSTBLEND_ONE) {
+		stages[0].stateBits &= ~GLS_SRCBLEND_BITS;
+		stages[0].stateBits |= GLS_SRCBLEND_ONE;
+	}
+#endif
+
+	// *** compute required features ***
+	if( (stages[0].stateBits & GLS_SRCBLEND_BITS) == GLS_SRCBLEND_ONE_MINUS_DST_COLOR ||
+	    (stages[0].stateBits & GLS_DSTBLEND_BITS) == GLS_DSTBLEND_ONE_MINUS_SRC_COLOR ) {
+		return qfalse;
+	} else if( (stages[0].stateBits & GLS_SRCBLEND_BITS) == GLS_SRCBLEND_DST_COLOR ) {
+		blendMode = FILTER;
+	} else if( (stages[0].stateBits & GLS_DSTBLEND_BITS) == 0 ||
+		   (stages[0].stateBits & GLS_DSTBLEND_BITS) == GLS_DSTBLEND_ZERO ) {
+		blendMode = REPLACE;
+	} else {
+		blendMode = BLEND;
+	}
+
+	// deforms
+	for( i = 0; i < shader.numDeforms; i++ ) {
+		switch( shader.deforms[i].deformation ) {
+		case DEFORM_NONE:
+			break;
+		case DEFORM_WAVE:
+			vsFeatures |= vsfNormal;
+			// fall through
+		case DEFORM_MOVE:
+			switch( shader.deforms[i].deformationWave.func ) {
+			case GF_NONE:
+				return qfalse;
+			case GF_SIN:
+				vsFeatures |= vsfShaderTime | vsfGenSin;
+				break;
+			case GF_SQUARE:
+				vsFeatures |= vsfShaderTime | vsfGenSquare;
+				break;
+			case GF_TRIANGLE:
+				vsFeatures |= vsfShaderTime | vsfGenTri;
+				break;
+			case GF_SAWTOOTH:
+				vsFeatures |= vsfShaderTime | vsfGenSaw;
+				break;
+			case GF_INVERSE_SAWTOOTH:
+				vsFeatures |= vsfShaderTime | vsfGenInvSaw;
+				break;
+			case GF_NOISE:
+				vsFeatures |= vsfShaderTime | vsfGenNoise;
+				break;
+			}
+			break;
+		case DEFORM_NORMALS:
+			vsFeatures |= vsfShaderTime;
+			break;
+		case DEFORM_BULGE:
+			vsFeatures |= vsfTexCoord | vsfNormal | vsfShaderTime;
+			break;
+		default:
+			return qfalse;
+		}
+	}
+	// textures
+	for( i = 0; i < MAX_SHADER_STAGES; i++ ) {
+		shaderStage_t *pStage = &stages[i];
+		
+		if( !pStage->active ) {
+			break;
+		}
+
+		if( pStage->bundle[0].isLightmap ) {
+			lightmapStage = i;
+		}
+
+		if( (pStage->stateBits & GLS_SRCBLEND_BITS) == GLS_SRCBLEND_DST_COLOR &&
+		    (blendMode == BLEND) ) {
+			//return qfalse;
+		} else if( blendMode == FILTER &&
+			   (pStage->stateBits & GLS_SRCBLEND_BITS) != GLS_SRCBLEND_DST_COLOR ) {
+			return qfalse;
+		}
+		
+		// this is called before CollapseMultitexture,
+		// so each stages has at most one bundle
+		switch( pStage->bundle[0].tcGen ) {
+		case TCGEN_IDENTITY:
+			break;
+		case TCGEN_LIGHTMAP:
+			vsFeatures |= vsfTexCoord;
+			break;
+		case TCGEN_TEXTURE:
+			vsFeatures |= vsfTexCoord;
+			break;
+		case TCGEN_ENVIRONMENT_MAPPED:
+			vsFeatures |= vsfNormal | vsfCameraPos;
+			fsFeatures |= fsfNormal | fsfReflView | fsfCameraPos;
+			break;
+		case TCGEN_FOG:
+			return qfalse;
+		case TCGEN_VECTOR:
+			fsFeatures |= fsfVertex;
+			break;
+		default:
+			return qfalse;
+		}
+		
+		for( j = 0; j < pStage->bundle[0].numTexMods; j++ ) {
+			texModInfo_t *pTexMod = &(pStage->bundle[0].texMods[j]);
+			
+			switch( pTexMod->type ) {
+			case TMOD_NONE:
+				break;
+			case TMOD_TRANSFORM:
+				break;
+			case TMOD_TURBULENT:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfVertex;
+				break;
+			case TMOD_SCROLL:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime;
+				break;
+			case TMOD_SCALE:
+				break;
+			case TMOD_STRETCH:
+				switch( pTexMod->wave.func ) {
+				case GF_NONE:
+					return qfalse;
+				case GF_SIN:
+					vsFeatures |= vsfShaderTime;
+					fsFeatures |= fsfShaderTime | fsfGenSin;
+					break;
+				case GF_SQUARE:
+					vsFeatures |= vsfShaderTime;
+					fsFeatures |= fsfShaderTime | fsfGenSquare;
+					break;
+				case GF_TRIANGLE:
+					vsFeatures |= vsfShaderTime;
+					fsFeatures |= fsfShaderTime | fsfGenTri;
+					break;
+				case GF_SAWTOOTH:
+					vsFeatures |= vsfShaderTime;
+					fsFeatures |= fsfShaderTime | fsfGenSaw;
+					break;
+				case GF_INVERSE_SAWTOOTH:
+					vsFeatures |= vsfShaderTime;
+					fsFeatures |= fsfShaderTime | fsfGenInvSaw;
+					break;
+				case GF_NOISE:
+					vsFeatures |= vsfShaderTime;
+					fsFeatures |= fsfShaderTime | fsfGenNoise;
+					break;
+				}
+				break;
+			case TMOD_ROTATE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenRotate;
+				break;
+			case TMOD_ENTITY_TRANSLATE:
+				return qfalse;
+			default:
+				return qfalse;
+			}
+		}
+		if( pStage->bundle[0].combinedImage ) {
+			vsFeatures |= vsfShaderTime;
+			fsFeatures |= fsfShaderTime;
+		}
+
+		switch( pStage->rgbGen ) {
+		case CGEN_IDENTITY_LIGHTING:
+			constantColor[i][0] =
+			constantColor[i][1] =
+			constantColor[i][2] = tr.identityLightByte;
+			aGen = AGEN_IDENTITY;
+			break;
+		case CGEN_IDENTITY:
+			constantColor[i][0] =
+			constantColor[i][1] =
+			constantColor[i][2] = 255;
+			aGen = AGEN_IDENTITY;
+			break;
+		case CGEN_ENTITY:
+			aGen = AGEN_ENTITY;
+			vsFeatures |= vsfColor;
+			break;
+		case CGEN_ONE_MINUS_ENTITY:
+			aGen = AGEN_ONE_MINUS_ENTITY;
+			vsFeatures |= vsfColor;
+			break;
+		case CGEN_EXACT_VERTEX:
+			aGen = AGEN_VERTEX;
+			vsFeatures |= vsfColor;
+			break;
+		case CGEN_VERTEX:
+			aGen = AGEN_VERTEX;
+			vsFeatures |= vsfColor;
+			break;
+		case CGEN_ONE_MINUS_VERTEX:
+			aGen = AGEN_ONE_MINUS_VERTEX;
+			vsFeatures |= vsfColor;
+			break;
+		case CGEN_WAVEFORM:
+			switch( pStage->rgbWave.func ) {
+			case GF_NONE:
+				return qfalse;
+			case GF_SIN:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenSin;
+				break;
+			case GF_SQUARE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenSquare;
+				break;
+			case GF_TRIANGLE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenTri;
+				break;
+			case GF_SAWTOOTH:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenSaw;
+				break;
+			case GF_INVERSE_SAWTOOTH:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenInvSaw;
+				break;
+			case GF_NOISE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenNoise;
+				break;
+			};
+			aGen = AGEN_IDENTITY;
+			break;
+		case CGEN_LIGHTING_DIFFUSE:
+			aGen = AGEN_IDENTITY;
+			vsFeatures |= vsfEntLight | vsfLightDir | vsfNormal;
+			fsFeatures |= fsfLightDir | fsfNormal | fsfDiffuse;
+			break;
+		case CGEN_FOG:
+			aGen = AGEN_IDENTITY;
+			return qfalse;
+		case CGEN_CONST:
+			constantColor[i][0] = pStage->constantColor[0];
+			constantColor[i][1] = pStage->constantColor[1];
+			constantColor[i][2] = pStage->constantColor[2];
+			aGen = AGEN_IDENTITY;
+			break;
+		default:
+			return qfalse;
+		}
+
+		if ( pStage->alphaGen == AGEN_SKIP )
+			pStage->alphaGen = aGen;
+
+		switch( pStage->alphaGen ) {
+		case AGEN_IDENTITY:
+			constantColor[i][3] = 255;
+			break;
+		case AGEN_ENTITY:
+			vsFeatures |= vsfColor;
+			break;
+		case AGEN_ONE_MINUS_ENTITY:
+			vsFeatures |= vsfColor;
+			break;
+		case AGEN_VERTEX:
+			vsFeatures |= vsfColor;
+			break;
+		case AGEN_ONE_MINUS_VERTEX:
+			vsFeatures |= vsfColor;
+			break;
+		case AGEN_LIGHTING_SPECULAR:
+			vsFeatures |= vsfNormal | vsfLightDir | vsfCameraPos;
+			fsFeatures |= fsfNormal | fsfReflView | fsfCameraPos | fsfSpecular | fsfLightDir;
+			break;
+		case AGEN_WAVEFORM:
+			switch( pStage->alphaWave.func ) {
+			case GF_NONE:
+				return qfalse;
+			case GF_SIN:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenSin;
+				break;
+			case GF_SQUARE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenSquare;
+				break;
+			case GF_TRIANGLE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenTri;
+				break;
+			case GF_SAWTOOTH:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenSaw;
+				break;
+			case GF_INVERSE_SAWTOOTH:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenInvSaw;
+				break;
+			case GF_NOISE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenNoise;
+				break;
+			};
+			break;
+		case AGEN_PORTAL:
+			vsFeatures |= vsfCameraPos | vsfNormal;
+			fsFeatures |= fsfCameraPos;
+			break;
+		case AGEN_CONST:
+			constantColor[i][3] = pStage->constantColor[3];
+			break;
+		default:
+
+			return qfalse;
+		}
+	}
+	if( stages[0].bundle[0].isLightmap ) {
+		j = 1;
+	} else {
+		j = 0;
+	}
+	if( i < MAX_SHADER_STAGES &&
+	    r_perPixelLighting->integer &&
+	    stages[j].active &&
+	    stages[j].bundle[0].tcGen == TCGEN_TEXTURE &&
+	    stages[j].bundle[0].numTexMods == 0 &&
+	    stages[j].bundle[0].image[0] &&
+	    *stages[j].bundle[0].image[0]->imgName > '/' ) {
+		// check if a normal/bump map exists, skip if
+		// the base texture has texture mods (rotation etc.)
+		char name[MAX_QPATH];
+		if( stages[0].bundle[0].isLightmap ) {
+			COM_StripExtension( stages[1].bundle[0].image[0]->imgName, name, sizeof(name) );
+		} else {
+			COM_StripExtension( stages[0].bundle[0].image[0]->imgName, name, sizeof(name) );
+		}
+		strcat( name, "_nm" );
+		stages[i].bundle[0].image[0] = R_FindHeightMapFile( name, qtrue, GL_REPEAT );
+		if( stages[i].bundle[0].image[0] ) {
+			normalStage = i++;
+			stages[normalStage].active = qtrue;
+			stages[normalStage].bundle[0].tcGen = TCGEN_TEXTURE;
+			vsFeatures |= vsfNormal | vsfCameraPos;
+			fsFeatures |= fsfVertex | fsfNormal | fsfTangents | fsfCameraPos;
+		}
+	}
+	if( i < MAX_SHADER_STAGES &&
+	    stages[j].active &&
+	    stages[j].bundle[0].tcGen == TCGEN_TEXTURE &&
+	    stages[j].bundle[0].numTexMods == 0 &&
+	    stages[j].bundle[0].image[0] &&
+	    *stages[j].bundle[0].image[0]->imgName > '/' ) {
+		// check if a material map exists, skip if
+		// the base texture has texture mods (rotation etc.)
+		char name[MAX_QPATH];
+		if( stages[0].bundle[0].isLightmap ) {
+			COM_StripExtension( stages[1].bundle[0].image[0]->imgName, name, sizeof(name) );
+		} else {
+			COM_StripExtension( stages[0].bundle[0].image[0]->imgName, name, sizeof(name) );
+		}
+		strcat( name, "_mat" );
+		stages[i].bundle[0].image[0] = R_FindImageFile( name, qtrue, qtrue, GL_REPEAT );
+		if( stages[i].bundle[0].image[0] ) {
+			materialStage = i++;
+			stages[materialStage].active = qtrue;
+			stages[materialStage].bundle[0].tcGen = TCGEN_TEXTURE;
+			vsFeatures |= vsfNormal | vsfLightDir | vsfCameraPos;
+			fsFeatures |= fsfNormal | fsfReflView | fsfCameraPos | fsfSpecular | fsfLightDir;
+		}
+	}
+
+	// *** assemble shader fragments ***
+	// version pragma
+	if ( GLSLversion < 0x010a ) {
+		return qfalse;
+	}
+	VSText("#version 110\n"
+	       "\n");
+	//VSText("/*");VSText(shader.name);VSText("*/\n");
+	FSText("#version 110\n"
+	       "\n"
+	       "const vec3 constants = vec3( 0.0, 1.0, ");
+	FSConst("%f", tr.identityLight );
+	FSText(" );\n\n");
+	
+	// attributes
+	VSText("// attribute vec4 aVertex;\n"
+	       "#define aVertex gl_Vertex\n");
+	if( vsFeatures & vsfTexCoord ) {
+		VSText("//attribute vec4 aTexCoord;\n"
+		       "#define aTexCoord gl_MultiTexCoord0\n");
+	}
+	if( vsFeatures & vsfColor ) {
+		VSText("// attribute vec4 aColor;\n"
+		       "#define aColor gl_Color\n");
+	}
+	if( shader.lightmapIndex == LIGHTMAP_MD3 ||
+	    (vsFeatures & vsfShaderTime) ) {
+		VSText("attribute vec4  aTimes;\n");
+	}
+	
+	if( shader.lightmapIndex != LIGHTMAP_MD3 ) {
+		if( vsFeatures & vsfNormal ) {
+			VSText("// attribute vec3 aNormal;\n"
+			       "#define aNormal gl_Normal\n");
+		}
+	}
+	VSText("attribute vec4 aTransX, aTransY, aTransZ;\n");
+	if( vsFeatures & vsfEntLight ) {
+		VSText("attribute vec3 aAmbientLight;\n");
+		VSText("attribute vec3 aDirectedLight;\n");
+	}
+	if( vsFeatures & vsfLightDir ) {
+		VSText("attribute vec4 aLightDir;\n");
+	}
+	if( vsFeatures & vsfCameraPos ) {
+		VSText("\nattribute vec3 aCameraPos;\n");
+	}
+	
+	// varyings
+	if( vsFeatures & vsfTexCoord ) {
+		VSText("varying vec4 vTexCoord;\n");
+		FSText("varying vec4 vTexCoord;\n");
+	}
+	if( vsFeatures & vsfColor ) {
+		VSText("varying vec4 vColor;\n");
+		FSText("varying vec4 vColor;\n");
+	}
+	if( fsFeatures & fsfVertex ) {
+		VSText("varying vec3 vVertex;\n");
+		FSText("varying vec3 vVertex;\n");
+	}
+	if( fsFeatures & fsfNormal ) {
+		VSText("varying vec3 vNormal;\n");
+		FSText("varying vec3 vNormal;\n");
+	}
+	if( fsFeatures & fsfLightDir ) {
+		if( r_perPixelLighting->integer ) {
+			VSText("varying vec4 vLightDir;\n");
+			FSText("varying vec4 vLightDir;\n");
+			if( fsFeatures & fsfDiffuse ) {
+				// per pixel diffuse light
+				VSText("varying vec3 vAmbientLight, vDirectedLight;\n");
+				FSText("varying vec3 vAmbientLight, vDirectedLight;\n");
+			}
+		} else {
+			if( fsFeatures & fsfDiffuse ) {
+				// interpolated diffuse
+				VSText("varying vec3 vDiffuse;\n");
+				FSText("varying vec3 vDiffuse;\n");
+			}
+			if( fsFeatures & fsfSpecular ) {
+				// interpolated specular
+				VSText("varying float vSpecular;\n");
+				FSText("varying float vSpecular;\n");
+			}
+		}
+	}
+	if( fsFeatures & fsfReflView ) {
+		if( r_perPixelLighting->integer ) {
+			// calculated in fragment shader
+		} else {
+			// interpolated
+			VSText("varying vec3 vReflView;\n");
+			FSText("varying vec3 vReflView;\n");
+		}
+	}
+	if( fsFeatures & fsfShaderTime ) {
+		VSText("varying float vShadertime;\n");
+		FSText("varying float vShadertime;\n");
+	}
+	if( fsFeatures & fsfCameraPos ) {
+		VSText("varying vec3 vCameraPos;\n");
+		FSText("varying vec3 vCameraPos;\n");
+	}
+	
+	// uniforms
+	if( shader.lightmapIndex == LIGHTMAP_MD3 ) {
+		VSText("uniform sampler2D texData;\n");
+	}
+	for( i = 0; i < MAX_SHADER_STAGES; i++ ) {
+		shaderStage_t *pStage = &stages[i];
+		
+		if( !pStage->active )
+			break;
+		
+		for( j = 0; j < i; j++ ) {
+			if( pStage->bundle[0].image[0] == stages[j].bundle[0].image[0] )
+				break;
+		}
+		if( j < i ) {
+			texIndex[i] = j;
+		} else {
+			texIndex[i] = i;
+			FSText("uniform sampler2D ");
+			FSText(GLSLTexNames[i]);
+			FSText(";\n");
+		}
+	}
+	if( normalStage >= 0 ) {
+		FSText("const int HMLevels = ");
+		FSConst("%d", stages[normalStage].bundle[0].image[0]->maxMipLevel);
+		FSText(";\n"
+		       "const float HMSize = ");
+		FSConst("%f", (float)stages[normalStage].bundle[0].image[0]->uploadWidth);
+		FSText(";\n"
+		       "\n");
+	}
+	
+	// functions
+	VSText("\n"
+	       "vec3 transform3(vec3 vector) {\n"
+	       "  return vec3( dot( aTransX.xyz, vector ),\n"
+	       "               dot( aTransY.xyz, vector ),\n"
+	       "               dot( aTransZ.xyz, vector ) );\n"
+	       "}\n"
+	       "vec3 transform4(vec4 point) {\n"
+	       "  return vec3( dot( aTransX, point ),\n"
+	       "               dot( aTransY, point ),\n"
+	       "               dot( aTransZ, point ) );\n"
+	       "}\n");
+
+	if( vsFeatures & vsfGenSin ) {
+		VSText("float genFuncSin(in float x) {\n"
+		       "  return sin(6.283185308 * x);\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenSin ) {
+		FSText("float genFuncSin(in float x) {\n"
+		       "  return sin(6.283185308 * x);\n"
+		       "}\n\n");
+	}
+	if( vsFeatures & vsfGenSquare ) {
+		VSText("float genFuncSquare(in float x) {\n"
+		       "  return sign(fract(x) - 0.5);\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenSquare ) {
+		FSText("float genFuncSquare(in float x) {\n"
+		       "  return sign(fract(x) - 0.5);\n"
+		       "}\n\n");
+	}
+	if( vsFeatures & vsfGenTri ) {
+		VSText("float genFuncTriangle(in float x) {\n"
+		       "  return 4.0 * abs(fract(x - 0.25) - 0.5) - 1.0;\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenTri ) {
+		FSText("float genFuncTriangle(in float x) {\n"
+		       "  return 4.0 * abs(fract(x - 0.25) - 0.5) - 1.0;\n"
+		       "}\n\n");
+	}
+	if( vsFeatures & vsfGenSaw ) {
+		VSText("float genFuncSawtooth(in float x) {\n"
+		       "  return fract(x);\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenSaw ) {
+		FSText("float genFuncSawtooth(in float x) {\n"
+		       "  return fract(x);\n"
+		       "}\n\n");
+	}
+	if( vsFeatures & vsfGenInvSaw ) {
+		VSText("float genFuncInverseSawtooth(in float x) {\n"
+		       "  return 1.0 - fract(x);\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenInvSaw ) {
+		FSText("float genFuncInverseSawtooth(in float x) {\n"
+		       "  return 1.0 - fract(x);\n"
+		       "}\n\n");
+	}
+	if( vsFeatures & vsfGenNoise ) {
+		VSText("float genFuncNoise(in float x) {\n"
+		       "  return noise1(x);\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenNoise ) {
+		FSText("float genFuncNoise(in float x) {\n"
+		       "  return noise1(x);\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenRotate ) {
+		FSText("mat2 genFuncRotate(in float x) {\n"
+		       "  vec2 sincos = sin(6.283185308 / 360.0 * vec2(x, x + 90.0));\n"
+		       "  return mat2(sincos.y, -sincos.x, sincos.x, sincos.y);\n"
+		       "}\n\n");
+	}
+	if( normalStage >= 0 && r_parallax->integer == 1 ) {
+		FSText("vec3 intersectHeightMap(const vec3 startPos, const vec3 traceVec) {\n"
+		       "  vec3 tracePos = startPos;\n"
+		       "  vec4 sample = texture2D(");
+		FSText(GLSLTexNames[texIndex[normalStage]]);
+		FSText(", tracePos.xy);\n"
+		       "  float depth = 1.0 - sample.a;\n"
+		       "  tracePos = startPos + traceVec * depth;\n"
+		       "  sample = texture2D(");
+		FSText(GLSLTexNames[texIndex[normalStage]]);
+		FSText(", tracePos.xy);\n"
+		       "  depth = mix(depth, 1.0 - sample.a, 0.5);\n"
+		       "  tracePos = startPos + traceVec * depth;\n"
+		       "  sample = texture2D(");
+		FSText(GLSLTexNames[texIndex[normalStage]]);
+		FSText(", tracePos.xy);\n"
+		       "  depth = mix(depth, 1.0 - sample.a, 0.5);\n"
+		       "  tracePos = startPos + traceVec * depth;\n"
+		       "  return tracePos;\n"
+		       "}\n\n");
+	}
+	if( normalStage >= 0 && r_parallax->integer == 2 ) {
+		FSText("float getHMLevel(const vec2 tc, const float scale, const float invScale) {\n"
+		       "  vec2 texel = (floor(tc * scale) + 0.5) * invScale;\n"
+		       "  if( scale < HMSize * 0.75 ) texel -= 0.5 / HMSize;\n"
+		       "  vec4 tmp = texture2D(");
+		FSText(GLSLTexNames[texIndex[normalStage]]);
+		FSText(", texel);\n"
+		       "  if( scale >= HMSize * 0.75 )\n"
+		       "    return tmp.w;\n"
+		       "  else\n"
+		       "    return tmp.z;\n"
+		       "}\n"
+		       "\n"
+		       "vec3 intersectHeightMap(const vec3 startPos, const vec3 traceVec) {\n"
+		       "  vec3 tracePos = startPos;\n"
+		       "  vec2 border = (sign(traceVec.xy) + 1.0 ) * 0.5;\n"
+		       "  vec2 slope = 1.0 / traceVec.xy;\n"
+		       "  int level = HMLevels, crossings = 20;\n"
+		       "  float scale = 1.0;\n"
+		       "  float invScale = 1.0;\n"
+		       "  \n"
+		       "  vec2 crossPos;\n"
+		       "  float crossDepth;\n"
+		       "  \n"
+		       "  while( level >= 0 ) {\n"
+		       "    float h = getHMLevel(tracePos.xy, scale, invScale);\n"
+		       "    crossPos = 1.0 - (floor(scale * tracePos.xy + border) * invScale - startPos.xy) * slope;\n"
+		       "    crossDepth = max(crossPos.x, crossPos.y);\n"
+		       "    if( h < crossDepth ) {\n"
+		       "      h = crossDepth - 0.0001;\n"
+		       "      tracePos = startPos + (1.0 - h) * traceVec;\n"
+		       "      if( --crossings == 0 ) break;\n"  // just to prevent infinite loops
+		       "    } else {\n"
+		       "      if( h < tracePos.z )\n"
+		       "        tracePos = startPos + (1.0 - h) * traceVec;\n"
+		       "      scale *= 2.0;\n"
+		       "      invScale *= 0.5;\n"
+		       "      level--;\n"
+		       "    }\n"
+		       "  }\n"
+		       "  \n"
+		       "  vec2 posIn  = 1.0 - (floor(tracePos.xy * scale + 1.0 - border) * invScale - startPos.xy) * slope;\n"
+		       "  vec2 posOut = 1.0 - (floor(tracePos.xy * scale + border) * invScale - startPos.xy) * slope;\n"
+		       "  float depthIn  = min(posIn.x, posIn.y);\n"
+		       "  float depthOut = max(posOut.x, posOut.y);\n"
+		       "  float h1 = texture2D(");
+		FSText(GLSLTexNames[texIndex[normalStage]]);
+		FSText(", startPos.xy + (1.0 - depthIn) * traceVec.xy).w;\n"
+		       "  float h2 = texture2D(");
+		FSText(GLSLTexNames[texIndex[normalStage]]);
+		FSText(", startPos.xy + (1.0 - depthOut) * traceVec.xy).w;\n"
+		       "  float h = (depthIn * h1 + depthOut * h2) / (depthIn - depthOut + h1 + h2);\n"
+		       "  tracePos = startPos + (1.0 - h) * traceVec;\n"
+		       "  return tracePos;\n"
+		       "}\n\n");
+	}
+	if( shader.lightmapIndex == LIGHTMAP_MD3 ) {
+		if( vsFeatures & vsfNormal ) {
+			VSText("vec4 fetchVertex(const float frameNo, const vec2 offset,\n"
+			       "                 out vec4 normal) {\n"
+			       "  vec2 tc = vec2(fract(frameNo), floor(frameNo)/1024.0) + offset;\n"
+			       "  vec4 data = texture2D(texData, tc);\n"
+			       "  vec4 lo = fract(data);\n"
+			       "  vec4 hi = floor(data);\n"
+			       "  normal = vec4((hi.xyz - 128.0) / 127.0, 0.0);\n"
+			       "  return vec4(lo.xyz * 1024.0 - 512.0,\n"
+			       "              1.0);\n"
+			       "}\n\n");
+		} else {
+			VSText("vec4 fetchVertex(const float frameNo, const vec2 offset) {\n"
+			       "  vec2 tc = vec2(fract(frameNo), floor(frameNo)/1024.0) + offset;\n"
+			       "  vec4 data = texture2D(texData, tc);\n"
+			       "  vec4 lo = fract(data);\n"
+			       "  return vec4(lo.xyz * 1024.0 - 512.0,\n"
+			       "              1.0);\n"
+			       "}\n\n");
+		}
+	}
+	
+	// main
+	VSText("\n"
+	       "void main() {\n"
+	       "  vec4 vertex;\n");
+	if( vsFeatures & vsfNormal ) {
+		VSText("  vec4 normal;\n");
+	}
+	if( shader.lightmapIndex == LIGHTMAP_MD3 ) {
+		// interpolate position and normal from two frames
+		if( vsFeatures & vsfNormal ) {
+			VSText("  vec4 normal1, normal2;\n"
+			       "  vertex = mix(fetchVertex(aTimes.z, aVertex.zw, normal1),\n"
+			       "               fetchVertex(aTimes.w, aVertex.zw, normal2),\n"
+			       "               aTimes.y);\n"
+			       "  normal = normalize(mix(normal1, normal2, aTimes.y));\n");
+		} else {
+			VSText("  vertex = mix(fetchVertex(aTimes.z, aVertex.zw),\n"
+			       "               fetchVertex(aTimes.w, aVertex.zw),\n"
+			       "               aTimes.y);\n");
+		}
+		if( vsFeatures & vsfTexCoord ) {
+			VSText("  vTexCoord = aVertex.xyxy;\n");
+		}
+		if( vsFeatures & vsfColor ) {
+			VSText("  vColor = aColor;\n");
+		}
+	} else {
+		VSText("  \n"
+		       "  vertex = vec4(aVertex.xyz, 1.0);\n");
+		if( vsFeatures & vsfNormal ) {
+			VSText("  normal = vec4(aNormal, 0.0);\n");
+		}
+		if( vsFeatures & vsfTexCoord ) {
+			VSText("  vTexCoord = aTexCoord;\n");
+		}
+		if( vsFeatures & vsfColor ) {
+			VSText("  vColor = aColor;\n");
+		}
+	}
+	if( fsFeatures & fsfShaderTime ) {
+		VSText("  \n"
+		       "  vShadertime = aTimes.x;\n");
+	}
+	
+	// apply deforms
+	for( i = 0; i < shader.numDeforms; i++ ) {
+		switch ( shader.deforms[i].deformation ) {
+		case DEFORM_NONE:
+			break;
+		case DEFORM_WAVE:
+			VSText("  \n"
+			       "  vertex += (");
+			VSConst("%f", shader.deforms[i].deformationWave.base);
+			VSText(" + ");
+			VSConst("%f", shader.deforms[i].deformationWave.amplitude);
+			switch( shader.deforms[i].deformationWave.func ) {
+			case GF_NONE:
+				return qfalse;
+			case GF_SIN:
+				VSText(" * genFuncSin(");
+				break;
+			case GF_SQUARE:
+				VSText(" * genFuncSquare(");
+				break;
+			case GF_TRIANGLE:
+				VSText(" * genFuncTriangle(");
+				break;
+			case GF_SAWTOOTH:
+				VSText(" * genFuncSawtooth(");
+				break;
+			case GF_INVERSE_SAWTOOTH:
+				VSText(" * genFuncInverseSawtooth(");
+				break;
+			case GF_NOISE:
+				VSText(" * genFuncNoise(");
+				break;
+			}
+			VSConst("%f", shader.deforms[i].deformationWave.phase);
+			VSText(" + dot(vertex.xyz, vec3(");
+			VSConst("%f", shader.deforms[i].deformationSpread);
+			VSText(")) + ");
+			VSConst("%f", shader.deforms[i].deformationWave.frequency);
+			VSText(" * aTimes.x)) * normal;\n");
+			break;
+		case DEFORM_NORMALS:
+			VSText("  \n"
+			       "  normal.xyz = normalize(normal.xyz + 0.98*noise3(vec4(vertex.xyz, aTimes.x * ");
+			VSConst("%f", shader.deforms[i].deformationWave.frequency);
+			VSText("));\n");
+			break;
+		case DEFORM_BULGE:
+			VSText("  \n"
+			       "  vertex += (");
+			VSConst("%f", shader.deforms[i].bulgeHeight);
+			VSText(" * sin(aTexCoord.x * ");
+			VSConst("%f", shader.deforms[i].bulgeWidth);
+			VSText(" + aTimes.x * ");
+			VSConst("%f", shader.deforms[i].bulgeSpeed * 0.001f);
+			VSText(")) * normal;\n");
+			break;
+		case DEFORM_MOVE:
+			VSText("  \n"
+			       "  vertex.xyz += (");
+			VSConst("%f", shader.deforms[i].deformationWave.base);
+			VSText(" + ");
+			VSConst("%f", shader.deforms[i].deformationWave.amplitude);
+			switch( shader.deforms[i].deformationWave.func ) {
+			case GF_NONE:
+				return qfalse;
+			case GF_SIN:
+				VSText(" * genFuncSin(");
+				break;
+			case GF_SQUARE:
+				VSText(" * genFuncSquare(");
+				break;
+			case GF_TRIANGLE:
+				VSText(" * genFuncTriangle(");
+				break;
+			case GF_SAWTOOTH:
+				VSText(" * genFuncSawtooth(");
+				break;
+			case GF_INVERSE_SAWTOOTH:
+				VSText(" * genFuncInverseSawtooth(");
+				break;
+			case GF_NOISE:
+				VSText(" * genFuncNoise(");
+				break;
+			}
+			VSConst("%f", shader.deforms[i].deformationWave.phase);
+			VSText(" + ");
+			VSConst("%f", shader.deforms[i].deformationWave.frequency);
+			VSText(" * aTimes.x)) * vec3(");
+			VSConst("%f", shader.deforms[i].moveVector[0]);
+			VSText(", ");
+			VSConst("%f", shader.deforms[i].moveVector[1]);
+			VSText(", ");
+			VSConst("%f", shader.deforms[i].moveVector[2]);
+			VSText(");\n");
+			break;
+		default:
+			return qfalse;
+		}
+	}
+	VSText("  vertex = vec4(transform4(vertex), 1.0);\n");
+	if( vsFeatures & vsfNormal ) {
+		VSText("  normal = vec4( transform3( normal.xyz ), 0.0 );\n");
+	}
+	if( fsFeatures & fsfVertex ) {
+		VSText("  vVertex = vertex.xyz;\n");
+	}
+	if( fsFeatures & fsfNormal ) {
+		VSText("  \n"
+		       "  vNormal = normal.xyz;\n");
+	}
+	if( fsFeatures & fsfCameraPos ) {
+		VSText("  vCameraPos = vertex.xyz - aCameraPos.xyz;\n");
+	}
+	if( fsFeatures & fsfLightDir ) {
+		VSText("  vec3 lightDir = normalize(transform3(aLightDir.xyz));\n");
+		if( r_perPixelLighting->integer ) {
+			VSText("  vLightDir = vec4(lightDir, aLightDir.w);\n" );
+		}
+	}
+	
+	if( fsFeatures & fsfDiffuse ) {
+		if( r_perPixelLighting->integer ) {
+			VSText("  \n"
+			       "  vAmbientLight  = aAmbientLight;\n"
+			       "  vDirectedLight = aDirectedLight;\n");
+		} else {
+			VSText("  \n"
+			       "  float diffuse = max(0.0, dot(normal.xyz, lightDir.xyz));\n"
+			       "  vDiffuse = clamp(aAmbientLight + diffuse * aDirectedLight, 0.0, 1.0);\n");
+		}
+	}
+	if( fsFeatures & fsfReflView ) {
+		if( r_perPixelLighting->integer ) {
+		} else {
+			VSText("  \n"
+			       "  vReflView = reflect(vertex.xyz - aCameraPos, normalize(normal.xyz));\n");
+		}
+	}
+	if( fsFeatures & fsfSpecular ) {
+		if( r_perPixelLighting->integer ) {
+		} else {
+			VSText("  vSpecular = max(0.0, 4.0 * dot(lightDir.xyz, normalize(vReflView)) - 3.0);\n"
+			       "  vSpecular *= vSpecular; vSpecular *= vSpecular; vSpecular *= vSpecular;\n");
+		}
+	}
+	VSText("  gl_Position = gl_ModelViewProjectionMatrix * vertex;\n"
+	       "}\n");
+	
+	FSText("void main() {\n"
+	       "  vec4  srcColor = constants.xxxx, dstColor;\n"
+	       "  vec2  tc;\n"
+	       "  vec4  genColor;\n");
+	if( vsFeatures & vsfTexCoord ) {
+		FSText("  vec2  baseTC = vTexCoord.st;\n");
+	}
+
+	if( fsFeatures & fsfNormal ) {
+		FSText("  vec3 normal = normalize(vNormal);\n");
+	}
+	if( fsFeatures & fsfTangents ) {
+		FSText("  vec3 dpx = dFdx(vVertex);\n"
+		       "  vec3 dpy = dFdy(vVertex);\n"
+		       "  vec2 dtx = dFdx(vTexCoord.xy);\n"
+		       "  vec2 dty = dFdy(vTexCoord.xy);\n"
+		       "  float scale = sign(dty.y*dtx.x - dtx.y*dty.x);\n"
+		       "  vec3 uTangent =  dpx * dty.y - dpy * dtx.y;\n"
+		       "  vec3 vTangent = -dpx * dty.x + dpy * dtx.x;\n"
+		//       "  uTangent -= vNormal * dot( uTangent, vNormal );\n"
+		//       "  vTangent -= vNormal * dot( vTangent, vNormal );\n"
+		       "  uTangent = normalize( scale*uTangent );\n"
+		       "  vTangent = normalize( scale*vTangent );\n" );
+	}
+	if( normalStage >= 0 ) {
+		// parallax calculation
+		switch( r_parallax->integer) {
+		case 1:	// simple parallax offset, fast but looks bad
+		case 2: // quadtree displacement mapping, best quality but
+			// requires dynamic branching
+
+			// implementation is in intersectHeightMap function
+
+			// z coord is scaled by 8.0
+			FSText("  vec3 traceVec = vec3(dot(vCameraPos, uTangent),\n"
+			       "                       dot(vCameraPos, vTangent),\n"
+			       "                       dot(vCameraPos, normal) * 8.0);\n"
+			       "  traceVec /= -traceVec.z;\n"
+			       // supersample to smooth out numeric instability...
+			       "  vec3 tracePos = constants.xxx;\n"
+			       // sample 1
+			       "  tracePos += intersectHeightMap(vec3(baseTC + 0.5 * dtx, 1.0), traceVec);\n"
+			       // sample 2
+			       "  tracePos += intersectHeightMap(vec3(baseTC - 0.25 * dtx - 0.433 * dty, 1.0), traceVec);\n"
+			       // sample 3
+			       "  tracePos += intersectHeightMap(vec3(baseTC - 0.25 * dtx + 0.433 * dty, 1.0), traceVec);\n"
+			       // average
+			       "  tracePos *= 1.0/3.0;\n"
+			       "  baseTC = tracePos.xy;\n");
+			break;
+		default:
+			// no parallax
+			FSText("  vec3 tracePos = vec3(fract(baseTC), 1.0);\n");
+			break;
+		}
+	}
+	
+	// normal mapping
+	if( fsFeatures & fsfNormal ) {
+		if( normalStage >= 0 ) {
+			FSText("  vec3 n = texture2D(");
+			FSText(GLSLTexNames[texIndex[normalStage]]);
+			FSText(", baseTC).xyz * 2.0 - 1.0;\n"
+			       "  n.z = sqrt(1.0 - dot(n.xy, n.xy));\n"
+			       "  normal = normalize(n.x * uTangent + n.y * vTangent + n.z * normal);\n");
+		}
+	}
+	if( fsFeatures & fsfLightDir ) {
+		if( r_perPixelLighting->integer ) {
+			if( tr.hasDeluxemaps && lightmapStage >= 0 ) {
+				FSText("  vec3 lightDir = normalize(texture2D(");
+				FSText(GLSLTexNames[texIndex[lightmapStage]]);
+				FSText(", vec2(vTexCoord.p + vLightDir.w, vTexCoord.q)).xyz * 2.0 - 1.0);\n");
+			} else {
+				FSText("  vec3 lightDir = normalize(vLightDir.xyz);\n");
+			}
+		}
+	}
+	if( fsFeatures & fsfDiffuse ) {
+		if( r_perPixelLighting->integer ) {
+			FSText("  float diffuse = max(0.0, dot(normal, lightDir));\n");
+		}
+	}
+	if( fsFeatures & fsfReflView ) {
+		if( r_perPixelLighting->integer ) {
+			FSText("  vec3 reflView = normalize(reflect(vCameraPos, normal));\n");
+		} else {
+			FSText("  vec3 reflView = normalize(vReflView);\n");
+		}
+	}
+	if( fsFeatures & fsfSpecular ) {
+		if( r_perPixelLighting->integer ) {
+			FSText("  float specular = max(0.0, 4.0 * dot(lightDir, reflView) - 3.0);\n"
+			       "  specular *= specular; specular *= specular; specular *= specular;\n");
+		} else {
+			FSText("  float specular = vSpecular;\n");
+		}
+	}
+
+	if( materialStage >= 0 && r_perPixelLighting->integer ) {
+		FSText("  vec4 material = texture2D(");
+		FSText(GLSLTexNames[texIndex[materialStage]]);
+		FSText(", baseTC);\n"
+		       "  vec3 viewVec = normalize(-vCameraPos);\n"
+		       "  vec3 halfVec = normalize(lightDir + viewVec);\n"
+		       "  float HdotN = max(0.0, dot(halfVec, normal));\n"
+		       "  float HdotV = max(0.0, dot(halfVec, viewVec));\n"
+		       "  float VdotN = max(0.0, dot(viewVec, normal));\n"
+		       "  vec2 specs = 1.0 / (0.0001 + material.xy * material.xy);\n"
+		       "  specs = (1.0 + specs) * pow(vec2(HdotN), specs);\n"
+		       "  float fresnel = pow(1.0 - VdotN, 5.0) * material.w;\n");
+	}
+
+	if( blendMode == FILTER ) {
+		FSText("  dstColor = constants.yyyy;\n");
+	} else {
+		FSText("  dstColor = constants.xxxy;\n");
+	}
+
+	for( i = 0; i < MAX_SHADER_STAGES; i++ ) {
+		shaderStage_t *pStage = &stages[i];
+
+		if( !pStage->active || i == normalStage || i == materialStage )
+			break;
+
+		if( pStage->bundle[0].image[0] != tr.whiteImage &&
+		    pStage->bundle[0].image[0] != tr.identityLightImage ) {
+			switch( pStage->bundle[0].tcGen ) {
+			case TCGEN_IDENTITY:
+				FSText("  tc = constants.xx;\n");
+				break;
+			case TCGEN_LIGHTMAP:
+				FSText("  tc = vTexCoord.pq;\n");
+				break;
+			case TCGEN_TEXTURE:
+				FSText("  tc = baseTC;\n");
+				break;
+			case TCGEN_ENVIRONMENT_MAPPED:
+				FSText("  tc = vec2(0.5) + 0.5 * normalize(reflView).yz;\n");
+				break;
+			case TCGEN_FOG:
+				return qfalse;
+			case TCGEN_VECTOR:
+				FSText("  tc = vec2(dot(vVertex, vec3(");
+				FSConst("%f", pStage->bundle[0].tcGenVectors[0][0]);
+				FSText(", ");
+				FSConst("%f", pStage->bundle[0].tcGenVectors[0][1]);
+				FSText(", ");
+				FSConst("%f", pStage->bundle[0].tcGenVectors[0][2]);
+				FSText(")),\n");
+				FSText("            dot(vVertex, vec3(");
+				FSConst("%f", pStage->bundle[0].tcGenVectors[1][0]);
+				FSText(", ");
+				FSConst("%f", pStage->bundle[0].tcGenVectors[1][1]);
+				FSText(", ");
+				FSConst("%f", pStage->bundle[0].tcGenVectors[1][2]);
+				FSText(")));\n");
+				break;
+			default:
+				return qfalse;
+			}
+			for( j = 0; j < pStage->bundle[0].numTexMods; j++ ) {
+				texModInfo_t *pTexMod = &(pStage->bundle[0].texMods[j]);
+				
+				switch( pTexMod->type ) {
+				case TMOD_NONE:
+					break;
+				case TMOD_TRANSFORM:
+					FSText("  tc = tc.s * vec2(");
+					FSConst("%f", pTexMod->matrix[0][0]);
+					FSText(", ");
+					FSConst("%f", pTexMod->matrix[0][1]);
+					FSText(") + tc.t * vec2(");
+					FSConst("%f", pTexMod->matrix[1][0]);
+					FSText(", ");
+					FSConst("%f", pTexMod->matrix[1][1]);
+					FSText(") + vec2(");
+					FSConst("%f", pTexMod->translate[0]);
+					FSText(", ");
+					FSConst("%f", pTexMod->translate[1]);
+					FSText(");\n");
+					break;
+				case TMOD_TURBULENT:
+					FSText("  tc += ");
+					FSConst("%f", pTexMod->wave.amplitude);
+					FSText(" * sin(6.283185308 * (0.000976563 * vVertex.xy + vec2(");
+					FSConst("%f", pTexMod->wave.phase);
+					FSText(" + ");
+					FSConst("%f", pTexMod->wave.frequency);
+					FSText("* vShadertime)));\n");
+					break;
+				case TMOD_SCROLL:
+					FSText("  tc += vShadertime * vec2(");
+					FSConst("%f", pTexMod->scroll[0]);
+					FSText(", ");
+					FSConst("%f", pTexMod->scroll[1]);
+					FSText(");\n");
+					break;
+				case TMOD_SCALE:
+					FSText("  tc *= vec2(");
+					FSConst("%f", pTexMod->scale[0]);
+					FSText(", ");
+					FSConst("%f", pTexMod->scale[1]);
+					FSText(");\n");
+					break;
+				case TMOD_STRETCH:
+					FSText(" tc = vec2(0.5) - 0.5 / ");
+					FSGenFunc(pTexMod->wave);
+					FSText(" * tc;\n");
+					break;
+				case TMOD_ROTATE:
+					FSText("  tc = vec2(0.5) + genFuncRotate(");
+					FSConst("%f", pTexMod->rotateSpeed);
+					FSText(" * vShadertime) * (tc - vec2(0.5));\n");
+					break;
+				case TMOD_ENTITY_TRANSLATE:
+					return qfalse;
+				default:
+					return qfalse;
+				}
+			}
+			// adjust for combined image
+			if ( pStage->bundle[0].combinedImage ) {
+				float xScale = (float)pStage->bundle[0].image[0]->uploadWidth /
+					(float)pStage->bundle[0].combinedImage->uploadWidth;
+				FSText("  tc.x = (tc.x + mod(floor(vShadertime * ");
+				FSConst("%f", pStage->bundle[0].imageAnimationSpeed);
+				FSText("), ");
+				FSConst("%f", (float)pStage->bundle[0].numImageAnimations);
+				FSText(")) * ");
+				FSConst("%f", xScale);
+				FSText(";\n");
+			}
+		}
+
+		if ( materialStage >= 0 &&
+		     ((i == 0 && lightmapStage > 0) ||
+		      (i == 1 && lightmapStage == 0) ) ) {
+			FSText("  srcColor = texture2D(");
+			FSText(GLSLTexNames[texIndex[i]]);
+			FSText(", tc);\n"
+			       "  srcColor.a = mix(srcColor.a, 1.0, fresnel);\n");
+			if( fsFeatures & fsfDiffuse ) {
+				FSText("  srcColor.rgb = vAmbientLight * srcColor.rgb + (diffuse * vDirectedLight) * (0.04 * specs.x\n"   // outer reflection
+				       "                 + srcColor.rgb * (1.0 - 0.04) * specs.y);\n");  // inner reflection
+			} else if( lightmapStage >= 0 ) {
+				// arbitrary split lightmap into 70% ambient, 30% diffuse
+				FSText("  srcColor.rgb = texture2D(");
+				FSText(GLSLTexNames[texIndex[lightmapStage]]);
+				FSText(", vTexCoord.pq).rgb * (0.7 * srcColor.rgb + 0.3* (0.04 * specs.x\n");
+				FSText("                 + srcColor.rgb * (1.0 - 0.04) * specs.y));\n");
+			} else {
+				// no lightmap, no diffuse light ???
+			}
+		} else {
+			switch( pStage->rgbGen ) {
+			case CGEN_IDENTITY_LIGHTING:
+			case CGEN_IDENTITY:
+			case CGEN_CONST:
+				FSText("  genColor = vec4(");
+				FSConst( "%f", constantColor[i][0] / 255.0 );
+				FSText(", ");
+				FSConst( "%f", constantColor[i][1] / 255.0 );
+				FSText(", ");
+				FSConst( "%f", constantColor[i][2] / 255.0 );
+				FSText(", ");
+				switch( pStage->alphaGen ) {
+				case AGEN_IDENTITY:
+				case AGEN_CONST:
+					FSConst("%f", constantColor[i][3] / 255.0);
+					break;
+				case AGEN_ENTITY:
+					FSText("vColor.a");
+					break;
+				case AGEN_ONE_MINUS_ENTITY:
+					FSText("constants.y - vColor.a");
+					break;
+				default:
+					FSText("constants.x"); // will be overwritten later
+					break;
+				}
+				FSText(");\n");
+				break;
+			case CGEN_ENTITY:
+				FSText("  genColor = vColor;\n");
+				break;
+			case CGEN_ONE_MINUS_ENTITY:
+				FSText("  genColor = constants.yyyy - vColor;\n");
+				break;
+			case CGEN_EXACT_VERTEX:
+				FSText("  genColor = vColor;\n");
+				break;
+			case CGEN_VERTEX:
+				FSText("  genColor = vColor * constants.zzzy;\n");
+				break;
+			case CGEN_ONE_MINUS_VERTEX:
+				FSText("  genColor = constants.zzzy - vColor * constants.zzzy;\n");
+				break;
+			case CGEN_WAVEFORM:
+				FSText("  genColor = vec4(clamp(");
+				FSGenFunc(pStage->rgbWave);
+				FSText(", 0.0, 1.0));\n");
+				break;
+			case CGEN_LIGHTING_DIFFUSE:
+				if( r_perPixelLighting->integer ) {
+					FSText("  genColor.rgb = clamp(vAmbientLight + diffuse * vDirectedLight, 0.0, 1.0);\n");
+				} else {
+					FSText("  genColor.rgb = vDiffuse;\n");
+				}
+				break;
+			case CGEN_FOG:
+				return qfalse;
+			default:
+				return qfalse;
+			}
+			
+			switch( pStage->alphaGen ) {
+			case AGEN_IDENTITY:
+			case AGEN_CONST:
+				if( pStage->rgbGen != CGEN_IDENTITY &&
+				    pStage->rgbGen != CGEN_IDENTITY_LIGHTING &&
+				    pStage->rgbGen != CGEN_CONST ) {
+					FSText("  genColor.a = ");
+					FSConst("%f", constantColor[i][3] / 255.0 );
+					FSText(";\n");
+				}
+				break;
+			case AGEN_ENTITY:
+				if( pStage->rgbGen != CGEN_ENTITY &&
+				    pStage->rgbGen != CGEN_CONST )
+					FSText("  genColor.a = vColor.a;\n");
+				break;
+			case AGEN_ONE_MINUS_ENTITY:
+				if( pStage->rgbGen != CGEN_ONE_MINUS_ENTITY &&
+				    pStage->rgbGen != CGEN_CONST )
+					FSText("  genColor.a = constants.y - vColor.a;\n");
+				break;
+			case AGEN_VERTEX:
+				if( pStage->rgbGen != CGEN_VERTEX &&
+				    pStage->rgbGen != CGEN_EXACT_VERTEX )
+					FSText("  genColor.a = vColor.a;\n");
+				break;
+			case AGEN_ONE_MINUS_VERTEX:
+				if( pStage->rgbGen != CGEN_ONE_MINUS_VERTEX )
+					FSText("  genColor.a = constants.y - vColor.a;\n");
+				break;
+			case AGEN_LIGHTING_SPECULAR:
+				FSText("  genColor.a = specular;\n");
+				break;
+			case AGEN_WAVEFORM:
+				FSText("  genColor.a = clamp(");
+				FSGenFunc(pStage->alphaWave);
+				FSText(", 0.0, 1.0);\n");
+				break;
+			case AGEN_PORTAL:
+				FSText("  genColor.a = clamp(");
+				FSConst("%f", 1.0/shader.portalRange);
+				FSText(" * length(vCameraPos), 0.0, 1.0);\n");
+				break;
+			default:
+				return qfalse;
+			}
+
+			if( pStage->bundle[0].image[0] == tr.whiteImage ) {
+				FSText("  srcColor = genColor;\n");
+			} else if( pStage->bundle[0].image[0] == tr.identityLightImage ) {
+				FSText("  srcColor = constants.zzzy * genColor;\n");
+			} else if( i == lightmapStage && materialStage >= 0 ) {
+				FSText("  srcColor = (texture2D(");
+				FSText(GLSLTexNames[texIndex[i]]);
+				FSText(", tc) + texture2D(");
+				FSText(GLSLTexNames[texIndex[materialStage]]);
+				FSText(", baseTC).x * specular * 5.0) * genColor;\n");
+			} else {
+				FSText("  srcColor = texture2D(");
+				FSText(GLSLTexNames[texIndex[i]]);
+				FSText(", tc) * genColor;\n");
+			}
+		}
+
+		// alpha test
+		switch( pStage->stateBits & GLS_ATEST_BITS ) {
+		case 0:
+			break;
+		case GLS_ATEST_GT_0:
+			FSText("  if( srcColor.a > 0.0 ) {\n");
+			break;
+		case GLS_ATEST_LT_80:
+			FSText("  if( srcColor.a < 0.5 ) {\n");
+			break;
+		case GLS_ATEST_GE_80:
+			FSText("  if( srcColor.a >= 0.5 ) {\n");
+			break;
+		}
+
+		if( blendMode == FILTER ) {
+			FSText("  dstColor *= srcColor;\n");
+		} else {
+			// blend colors
+			switch( pStage->stateBits & GLS_DSTBLEND_BITS ) {
+			case 0:
+			case GLS_DSTBLEND_ZERO:
+				FSText("  dstColor.rgb = ");
+				break;
+			case GLS_DSTBLEND_ONE:
+				FSText("  dstColor.rgb += ");
+				break;
+			case GLS_DSTBLEND_SRC_COLOR:
+				FSText("  dstColor.rgb = dstColor.rgb * srcColor.rgb + ");
+				break;
+			case GLS_DSTBLEND_ONE_MINUS_SRC_COLOR:
+				FSText("  dstColor.rgb = dstColor.rgb * (constants.yyy - srcColor.rgb) + ");
+				break;
+			case GLS_DSTBLEND_SRC_ALPHA:
+				FSText("  dstColor.rgb = dstColor.rgb * srcColor.aaa + ");
+				break;
+			case GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA:
+				FSText("  dstColor.rgb = dstColor.rgb * (constants.yyy - srcColor.aaa) + ");
+				break;
+			}
+			switch( pStage->stateBits & GLS_SRCBLEND_BITS ) {
+			case GLS_SRCBLEND_ZERO:
+				FSText("constants.xxx;\n");
+				break;
+			case 0:
+			case GLS_SRCBLEND_ONE:
+				FSText("srcColor.rgb;\n");
+				break;
+			case GLS_SRCBLEND_DST_COLOR:
+				FSText("srcColor.rgb * dstColor.rgb;\n");
+				break;
+			case GLS_SRCBLEND_ONE_MINUS_DST_COLOR:
+				FSText("srcColor.rgb * (constants.yyy - dstColor.rgb);\n");
+				break;
+			case GLS_SRCBLEND_SRC_ALPHA:
+				FSText("srcColor.rgb * srcColor.aaa;\n");
+				break;
+			case GLS_SRCBLEND_ONE_MINUS_SRC_ALPHA:
+				FSText("srcColor.rgb * (constants.yyy - srcColor.aaa);\n");
+				break;
+			}
+			
+			// blend alpha
+			switch( pStage->stateBits & GLS_DSTBLEND_BITS ) {
+			case 0:
+			case GLS_DSTBLEND_ZERO:
+				if( (pStage->stateBits & GLS_SRCBLEND_BITS) == GLS_SRCBLEND_DST_COLOR )
+					;
+				else if( (pStage->stateBits & GLS_SRCBLEND_BITS) == GLS_SRCBLEND_ONE_MINUS_DST_COLOR )
+					FSText("  dstColor.a = constants.y - dstColor.a;\n");
+				else
+					FSText("  dstColor.a = constants.x;\n");
+				break;
+			case GLS_DSTBLEND_ONE:
+				break;
+			case GLS_DSTBLEND_SRC_COLOR:
+				FSText("  dstColor.a *= srcColor.a;\n");
+				break;
+			case GLS_DSTBLEND_ONE_MINUS_SRC_COLOR:
+				FSText("  dstColor.a *= constants.y - srcColor.a;\n");
+			case GLS_DSTBLEND_SRC_ALPHA:
+				FSText("  dstColor.a *= srcColor.a;\n");
+				break;
+			case GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA:
+				FSText("  dstColor.a *= constants.y - srcColor.a;\n");
+				break;
+			}
+		}
+		if ( pStage->stateBits & GLS_ATEST_BITS ) {
+			FSText("  }\n");
+			if ( i == 0 )
+				FSText("  else\n"
+				       "    discard;\n");
+		}
+
+	}
+	shader.numUnfoggedPasses = i;
+	if( normalStage >= 0 )
+		shader.numUnfoggedPasses++;
+	if( materialStage >= 0 )
+		shader.numUnfoggedPasses++;
+
+	FSText("  gl_FragColor = dstColor;\n"
+	       "}\n");
+	
+	// collect attributes
+	if( shader.lightmapIndex != LIGHTMAP_MD3 &&
+	    (vsFeatures & vsfNormal) )
+		attributes |= (1 << AL_NORMAL);
+	if( vsFeatures & vsfColor )
+		attributes |= (1 << AL_COLOR);
+	if( vsFeatures & vsfTexCoord )
+		attributes |= (1 << AL_TEXCOORD);
+	if( shader.lightmapIndex == LIGHTMAP_MD3 ||
+	    (vsFeatures & vsfShaderTime) )
+		attributes |= (1 << AL_TIMES);
+	if( vsFeatures & vsfCameraPos ) {
+		attributes |= (1 << AL_CAMERAPOS);
+	}
+	if( vsFeatures & vsfLightDir )
+		attributes |= (1 << AL_LIGHTDIR);
+	if( vsFeatures & vsfEntLight )
+		attributes |= (1 << AL_AMBIENTLIGHT) | (1 << AL_DIRECTEDLIGHT);
+
+	// *** compile and link ***
+	shader.GLSLprogram = RB_CompileProgram( shader.name, VS, VSidx,
+						FS, FSidx, attributes );
+	if ( !shader.GLSLprogram )
+		return qfalse;
+	
+	// sampler uniforms are set to the TMU once at the start
+	GL_Program( shader.GLSLprogram );
+	// try to move lightmap to TMU 1 to avoid rebinds
+	// always leave TMU 0 as it may be used for alpha test
+	if( lightmapStage > 1 ) {
+		textureBundle_t temp;
+		
+		j = qglGetUniformLocation( shader.GLSLprogram->handle, GLSLTexNames[0] );
+		if( j != -1 ) {
+			qglUniform1i( j, 0 );
+		}
+
+		Com_Memcpy( &temp, &stages[1].bundle[0], sizeof(textureBundle_t) );
+		Com_Memcpy( &stages[1].bundle[0], &stages[lightmapStage].bundle[0], sizeof(textureBundle_t) );
+		Com_Memcpy( &stages[lightmapStage].bundle[0], &temp, sizeof(textureBundle_t) );
+		j = qglGetUniformLocation( shader.GLSLprogram->handle, GLSLTexNames[lightmapStage] );
+		if( j != -1 ) {
+			qglUniform1i( j, 1 );
+		}
+		
+		for( i = 2; i < lightmapStage; i++ ) {
+			j = qglGetUniformLocation( shader.GLSLprogram->handle, GLSLTexNames[i] );
+			if( j != -1 ) {
+				qglUniform1i( j, i );
+			}
+		}
+		j = qglGetUniformLocation( shader.GLSLprogram->handle, GLSLTexNames[1] );
+		if( j != -1 ) {
+			qglUniform1i( j, lightmapStage );
+		}
+		for( i = lightmapStage + 1; i < shader.numUnfoggedPasses; i++ ) {
+			j = qglGetUniformLocation( shader.GLSLprogram->handle, GLSLTexNames[i] );
+			if( j != -1 ) {
+				qglUniform1i( j, i );
+			}
+		}
+	} else {
+		for( i = 0; i < shader.numUnfoggedPasses; i++ ) {
+			j = qglGetUniformLocation( shader.GLSLprogram->handle, GLSLTexNames[i] );
+			if( j != -1 ) {
+				qglUniform1i( j, i );
+			}
+		}
+		if( shader.lightmapIndex == LIGHTMAP_MD3 ) {
+			j = qglGetUniformLocation( shader.GLSLprogram->handle, "texData" );
+			if( j != -1 ) {
+				qglUniform1i( j, shader.numUnfoggedPasses );
+			}
+		}
+	}
+
+	stages[0].stateBits &= ~(GLS_SRCBLEND_BITS | GLS_DSTBLEND_BITS);
+	switch( blendMode ) {
+	case REPLACE:
+		break;
+	case BLEND:
+		stages[0].stateBits |= GLS_SRCBLEND_ONE | GLS_DSTBLEND_SRC_ALPHA;
+		break;
+	case FILTER:
+		stages[0].stateBits |= GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
+		break;
+	}
+	shader.optimalStageIteratorFunc = RB_StageIteratorGLSL;
+	if ( qglGenBuffersARB && shader.lightmapIndex != LIGHTMAP_2D ) {
+		shader.useVBO = qtrue;
+	}
+	
+	return qtrue;
+}
+
+/*
+=================
 VertexLightingCollapse
 
 If vertex lighting is enabled, only render a single
@@ -2128,6 +3935,7 @@
 	int stage;
 	qboolean		hasLightmapStage;
 	qboolean		vertexLightmap;
+	shader_t		*sh;
 
 	hasLightmapStage = qfalse;
 	vertexLightmap = qfalse;
@@ -2142,7 +3950,7 @@
 	//
 	// set polygon offset
 	//
-	if ( shader.polygonOffset && !shader.sort ) {
+	if ( (stages[0].stateBits & GLS_POLYGON_OFFSET) && !shader.sort ) {
 		shader.sort = SS_DECAL;
 	}
 
@@ -2156,7 +3964,7 @@
 			break;
 		}
 
-    // check for a missing texture
+		// check for a missing texture
 		if ( !pStage->bundle[0].image[0] ) {
 			ri.Printf( PRINT_WARNING, "Shader %s has a stage with no image\n", shader.name );
 			pStage->active = qfalse;
@@ -2255,6 +4063,10 @@
 				}
 			}
 		}
+
+		if( shader.isSky ) {
+			pStage->stateBits |= GLS_DEPTHRANGE_1_TO_1;
+		}
 		
 		stage++;
 	}
@@ -2266,44 +4078,111 @@
 	}
 
 	//
-	// if we are in r_vertexLight mode, never use a lightmap texture
+	// try to generate a GLSL shader if possible
 	//
-	if ( stage > 1 && ( (r_vertexLight->integer && !r_uiFullScreen->integer) || glConfig.hardwareType == GLHW_PERMEDIA2 ) ) {
-		VertexLightingCollapse();
-		stage = 1;
-		hasLightmapStage = qfalse;
+	if ( !CollapseGLSL() ) {
+		//
+		// if we are in r_vertexLight mode, never use a lightmap texture
+		//
+		if ( stage > 1 && ( (r_vertexLight->integer && !r_uiFullScreen->integer) || glConfig.hardwareType == GLHW_PERMEDIA2 ) ) {
+			VertexLightingCollapse();
+			stage = 1;
+			hasLightmapStage = qfalse;
+		}
+		
+		//
+		// look for multitexture potential
+		//
+		if ( stage > 1 ) {
+			stage = CollapseMultitexture();
+		}
+		
+		if ( shader.lightmapIndex >= 0 && !hasLightmapStage ) {
+			if (vertexLightmap) {
+				ri.Printf( PRINT_DEVELOPER, "WARNING: shader '%s' has VERTEX forced lightmap!\n", shader.name );
+			} else {
+				ri.Printf( PRINT_DEVELOPER, "WARNING: shader '%s' has lightmap but no lightmap stage!\n", shader.name );
+				shader.lightmapIndex = LIGHTMAP_NONE;
+			}
+		}
+		
+		
+		//
+		// compute number of passes
+		//
+		shader.numUnfoggedPasses = stage;
+		
+		// fogonly shaders don't have any normal passes
+		if (stage == 0 && !shader.isSky)
+			shader.sort = SS_FOG;
+		
+		// determine which stage iterator function is appropriate
+		ComputeStageIteratorFunc();
 	}
 
-	//
-	// look for multitexture potential
-	//
-	if ( stage > 1 && CollapseMultitexture() ) {
-		stage--;
-	}
+	shader.isDepth = qfalse;
+	sh = GeneratePermanentShader();
 
-	if ( shader.lightmapIndex >= 0 && !hasLightmapStage ) {
-		if (vertexLightmap) {
-			ri.Printf( PRINT_DEVELOPER, "WARNING: shader '%s' has VERTEX forced lightmap!\n", shader.name );
+	// generate depth-only shader if necessary
+	if( r_depthPass->integer && !shader.isSky ) {
+		if( (stages[0].stateBits & GLS_DEPTHMASK_TRUE) &&
+		    !(stages[0].stateBits & GLS_DEPTHFUNC_EQUAL) &&
+		    !(shader.lightmapIndex == LIGHTMAP_2D) ) {
+			// this shader may update depth
+			stages[1].active = qfalse;
+			strcat(shader.name, "*");
+			
+			if( stages[0].stateBits & GLS_ATEST_BITS ) {
+				// alpha test requires a custom depth shader
+				shader.sort = SS_DEPTH;
+				stages[0].stateBits &= ~GLS_SRCBLEND_BITS & ~GLS_DSTBLEND_BITS;
+				stages[0].stateBits |= GLS_COLORMASK_FALSE;
+				
+				if( !CollapseGLSL() ) {
+					shader.numUnfoggedPasses = 1;
+					ComputeStageIteratorFunc();
+				}
+				sh->depthShader = GeneratePermanentShader();
+			} else if ( shader.lightmapIndex == LIGHTMAP_MD3 &&
+				    shader.cullType == 0 &&
+				    shader.numDeforms == 0 &&
+				    tr.defaultMD3Shader ) {
+				// can use the default MD3 depth shader
+				sh->depthShader = tr.defaultMD3Shader->depthShader;
+			} else if ( shader.lightmapIndex != LIGHTMAP_MD3 &&
+				    shader.cullType == 0 &&
+				    shader.numDeforms == 0 &&
+				    tr.defaultShader ) {
+				// can use the default depth shader
+				sh->depthShader = tr.defaultShader->depthShader;
+			} else {
+				// requires a custom depth shader, but can skip
+				// the texturing
+				shader.sort = SS_DEPTH;
+				stages[0].stateBits &= ~GLS_SRCBLEND_BITS & ~GLS_DSTBLEND_BITS;
+				stages[0].stateBits |= GLS_COLORMASK_FALSE;
+				stages[0].bundle[0].image[0] = tr.whiteImage;
+				stages[0].bundle[0].tcGen = TCGEN_IDENTITY;
+				stages[0].bundle[0].numTexMods = 0;
+				stages[0].rgbGen = CGEN_IDENTITY;
+				stages[0].alphaGen = AGEN_IDENTITY;
+
+				if( !CollapseGLSL() ) {
+					shader.numUnfoggedPasses = 1;
+					ComputeStageIteratorFunc();
+				}
+				shader.isDepth = qtrue;
+				sh->depthShader = GeneratePermanentShader();
+			}
+			// disable depth writes in the main pass
+			sh->stages[0]->stateBits &= ~GLS_DEPTHMASK_TRUE;
 		} else {
-			ri.Printf( PRINT_DEVELOPER, "WARNING: shader '%s' has lightmap but no lightmap stage!\n", shader.name );
-  			shader.lightmapIndex = LIGHTMAP_NONE;
+			sh->depthShader = NULL;
 		}
+	} else {
+		sh->depthShader = NULL;
 	}
-
-
-	//
-	// compute number of passes
-	//
-	shader.numUnfoggedPasses = stage;
-
-	// fogonly shaders don't have any normal passes
-	if (stage == 0 && !shader.isSky)
-		shader.sort = SS_FOG;
-
-	// determine which stage iterator function is appropriate
-	ComputeStageIteratorFunc();
-
-	return GeneratePermanentShader();
+	return sh;
 }
 
 //========================================================================================
@@ -2335,7 +4214,7 @@
 			return p;
 		}
 	}
-
+#if 0
 	p = s_shaderText;
 
 	if ( !p ) {
@@ -2357,7 +4236,7 @@
 			SkipBracedSection( &p );
 		}
 	}
-
+#endif
 	return NULL;
 }
 
@@ -2437,7 +4316,7 @@
 	shader_t	*sh;
 
 	if ( name[0] == 0 ) {
-		return tr.defaultShader;
+		return lightmapIndex == LIGHTMAP_MD3 ? tr.defaultMD3Shader : tr.defaultShader;
 	}
 
 	// use (fullbright) vertex lighting if the bsp file doesn't have
@@ -2484,11 +4363,7 @@
 		stages[i].bundle[0].texMods = texMods[i];
 	}
 
-	// FIXME: set these "need" values apropriately
-	shader.needsNormal = qtrue;
-	shader.needsST1 = qtrue;
-	shader.needsST2 = qtrue;
-	shader.needsColor = qtrue;
+	shader.useVBO = qfalse;
 
 	//
 	// attempt to define shader from an explicit parameter file
@@ -2504,8 +4379,10 @@
 		if ( !ParseShader( &shaderText ) ) {
 			// had errors, so use default shader
 			shader.defaultShader = qtrue;
+			sh = FinishShader();
+		} else {
+			sh = FinishShader();
 		}
-		sh = FinishShader();
 		return sh;
 	}
 
@@ -2518,13 +4395,15 @@
 	if ( !image ) {
 		ri.Printf( PRINT_DEVELOPER, "Couldn't find image file for shader %s\n", name );
 		shader.defaultShader = qtrue;
-		return FinishShader();
+		sh = FinishShader();
+		return sh;
 	}
 
 	//
 	// create the default shading commands
 	//
-	if ( shader.lightmapIndex == LIGHTMAP_NONE ) {
+	if ( shader.lightmapIndex == LIGHTMAP_NONE ||
+	     shader.lightmapIndex == LIGHTMAP_MD3 ) {
 		// dynamic colors at vertexes
 		stages[0].bundle[0].image[0] = image;
 		stages[0].active = qtrue;
@@ -2572,7 +4451,8 @@
 		stages[1].stateBits |= GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
 	}
 
-	return FinishShader();
+	sh = FinishShader();
+	return sh;
 }
 
 
@@ -2620,11 +4500,7 @@
 		stages[i].bundle[0].texMods = texMods[i];
 	}
 
-	// FIXME: set these "need" values apropriately
-	shader.needsNormal = qtrue;
-	shader.needsST1 = qtrue;
-	shader.needsST2 = qtrue;
-	shader.needsColor = qtrue;
+	shader.useVBO = qfalse;
 
 	//
 	// create the default shading commands
@@ -2678,7 +4554,7 @@
 	}
 
 	sh = FinishShader();
-  return sh->index; 
+	return sh->index; 
 }
 
 
@@ -2697,7 +4573,7 @@
 	shader_t	*sh;
 
 	if ( strlen( name ) >= MAX_QPATH ) {
-		Com_Printf( "Shader name exceeds MAX_QPATH\n" );
+		ri.Printf( PRINT_WARNING, "Shader name exceeds MAX_QPATH\n" );
 		return 0;
 	}
 
@@ -2731,7 +4607,7 @@
 	shader_t	*sh;
 
 	if ( strlen( name ) >= MAX_QPATH ) {
-		Com_Printf( "Shader name exceeds MAX_QPATH\n" );
+		ri.Printf( PRINT_WARNING, "Shader name exceeds MAX_QPATH\n" );
 		return 0;
 	}
 
@@ -2761,7 +4637,7 @@
 	shader_t	*sh;
 
 	if ( strlen( name ) >= MAX_QPATH ) {
-		Com_Printf( "Shader name exceeds MAX_QPATH\n" );
+		ri.Printf( PRINT_ALL, "Shader name exceeds MAX_QPATH\n" );
 		return 0;
 	}
 
@@ -2789,7 +4665,7 @@
 */
 shader_t *R_GetShaderByHandle( qhandle_t hShader ) {
 	if ( hShader < 0 ) {
-	  ri.Printf( PRINT_WARNING, "R_GetShaderByHandle: out of range hShader '%d'\n", hShader );
+		ri.Printf( PRINT_WARNING, "R_GetShaderByHandle: out of range hShader '%d'\n", hShader );
 		return tr.defaultShader;
 	}
 	if ( hShader >= tr.numShaders ) {
@@ -2808,7 +4684,7 @@
 ===============
 */
 void	R_ShaderList_f (void) {
-	int			i;
+	int			i, j, k;
 	int			count;
 	shader_t	*shader;
 
@@ -2829,15 +4705,6 @@
 		} else {
 			ri.Printf (PRINT_ALL, "  ");
 		}
-		if ( shader->multitextureEnv == GL_ADD ) {
-			ri.Printf( PRINT_ALL, "MT(a) " );
-		} else if ( shader->multitextureEnv == GL_MODULATE ) {
-			ri.Printf( PRINT_ALL, "MT(m) " );
-		} else if ( shader->multitextureEnv == GL_DECAL ) {
-			ri.Printf( PRINT_ALL, "MT(d) " );
-		} else {
-			ri.Printf( PRINT_ALL, "      " );
-		}
 		if ( shader->explicitlyDefined ) {
 			ri.Printf( PRINT_ALL, "E " );
 		} else {
@@ -2852,6 +4719,8 @@
 			ri.Printf( PRINT_ALL, "lmmt" );
 		} else if ( shader->optimalStageIteratorFunc == RB_StageIteratorVertexLitTexture ) {
 			ri.Printf( PRINT_ALL, "vlt " );
+		} else if ( shader->optimalStageIteratorFunc == RB_StageIteratorGLSL ) {
+			ri.Printf( PRINT_ALL, "glsl" );
 		} else {
 			ri.Printf( PRINT_ALL, "    " );
 		}
@@ -2861,6 +4730,21 @@
 		} else {
 			ri.Printf (PRINT_ALL,  ": %s\n", shader->name);
 		}
+		for ( j = 0; j < shader->numUnfoggedPasses; j++ ) {
+			shaderStage_t *stage = shader->stages[j];
+			
+			if ( !stage->active )
+				break;
+
+			ri.Printf (PRINT_DEVELOPER, " %d\n" );
+			
+			for ( k = 0; i < NUM_TEXTURE_BUNDLES; k++ ) {
+				if ( !stage->bundle[k].image[0] )
+					break;
+
+				ri.Printf (PRINT_DEVELOPER, "  %s\n", stage->bundle[k].image[0]->imgName );
+			}
+		}
 		count++;
 	}
 	ri.Printf (PRINT_ALL, "%i total shaders\n", count);
@@ -3010,6 +4894,94 @@
 }
 
 
+static const char *normalVS = 
+	"#version 110\n"
+	"#extension GL_EXT_geometry_shader4 : enable\n"
+	"\n"
+	"// attribute vec4 aVertex;\n"
+	"#define aVertex gl_Vertex\n"
+	"attribute vec4 aTransX, aTransY, aTransZ;\n"
+	"attribute vec3 aNormal;\n"
+	"\n"
+	"varying vec4 vVertex, vNormal;\n"
+	"\n"
+	"vec4 transform4(vec4 point) {\n"
+	"  return vec4( dot( aTransX, point ),\n"
+	"               dot( aTransY, point ),\n"
+	"               dot( aTransZ, point ),\n"
+	"               1.0 );\n"
+	"}\n"
+	"\n"
+	"void main() {\n"
+	"  vec4 vertex = vec4(aVertex.xyz, 1.0);\n"
+	"  vVertex = gl_ModelViewProjectionMatrix * transform4(vertex);\n"
+	"  vNormal = gl_ModelViewProjectionMatrix * transform4(vertex + 2.0 * vec4(aNormal, 0.0));\n"
+	"}\n";
+static const char *normalMD3VS = 
+	"#version 110\n"
+	"#extension GL_EXT_geometry_shader4 : enable\n"
+	"\n"
+	"// attribute vec4 aVertex;\n"
+	"#define aVertex gl_Vertex\n"
+	"attribute vec4 aTransX, aTransY, aTransZ;\n"
+	"attribute vec4 aTimes;\n"
+	"\n"
+	"uniform sampler2D texData;\n"
+	"\n"
+	"varying vec4 vVertex, vNormal;\n"
+	"\n"
+	"vec4 transform4(vec4 point) {\n"
+	"  return vec4( dot( aTransX, point ),\n"
+	"               dot( aTransY, point ),\n"
+	"               dot( aTransZ, point ),\n"
+	"               1.0 );\n"
+	"}\n"
+	"\n"
+	"vec4 fetchVertex(const float frameNo, const vec2 offset,\n"
+	"                 out vec4 normal) {\n"
+	"  vec2 tc = vec2(fract(frameNo), floor(frameNo)/1024.0) + offset;\n"
+	"  vec4 data = texture2D(texData, tc);\n"
+	"  vec4 hi = floor(data);\n"
+	"  vec4 lo = fract(data);\n"
+	"  normal = vec4((hi.xyz - 128.0) / 127.0, 0.0);\n"
+	"  return vec4(lo.xyz * 1024.0 - 512.0,\n"
+	"              1.0);\n"
+	"}\n"
+	"\n"
+	"void main() {\n"
+	"  vec4 normal1, normal2;\n"
+	"  vec4 vertex = mix(fetchVertex(aTimes.z, aVertex.zw, normal1),\n"
+	"                    fetchVertex(aTimes.w, aVertex.zw, normal2),\n"
+	"                    aTimes.y);\n"
+	"  vec3 normal = normalize(mix(normal1.xyz, normal2.xyz, aTimes.y));\n"
+	"  vVertex = gl_ModelViewProjectionMatrix * transform4(vertex);\n"
+	"  vNormal = gl_ModelViewProjectionMatrix * transform4(vertex + 2.0*vec4(normal, 0.0));\n"
+	"}\n";
+static const char *normalGS =
+	"#version 110\n"
+	"#extension GL_EXT_geometry_shader4 : enable\n"
+	"\n"
+	"varying in  vec4 vVertex[], vNormal[];\n"
+	"varying out vec4 vColor;\n"
+	"\n"
+	"void main() {\n"
+	"  vColor = vec4(1.0, 0.0, 0.0, 1.0);\n"
+	"  gl_Position = vVertex[0];\n"
+	"  EmitVertex();\n"
+	"  vColor = vec4(1.0, 0.0, 0.0, 1.0);\n"
+	"  gl_Position = vNormal[0];\n"
+	"  EmitVertex();\n"
+	"  EndPrimitive();\n"
+	"}\n";
+static const char *normalFS =
+	"#version 110\n"
+	"#extension GL_EXT_geometry_shader4 : enable\n"
+	"\n"
+	"varying vec4 vColor;\n"
+	"void main() {\n"
+	"  gl_FragColor = vColor;\n"
+	"}\n";
+
 /*
 ====================
 CreateInternalShaders
@@ -3025,15 +4997,89 @@
 	Q_strncpyz( shader.name, "<default>", sizeof( shader.name ) );
 
 	shader.lightmapIndex = LIGHTMAP_NONE;
+	shader.sort = SS_OPAQUE;
 	stages[0].bundle[0].image[0] = tr.defaultImage;
 	stages[0].active = qtrue;
 	stages[0].stateBits = GLS_DEFAULT;
+	stages[0].rgbGen = CGEN_VERTEX;
+	stages[0].alphaGen = AGEN_VERTEX;
 	tr.defaultShader = FinishShader();
 
+	if( qglCreateShader && qglGenBuffersARB && glGlobals.floatTextures ) {
+		Q_strncpyz( shader.name, "<default md3>", sizeof( shader.name ) );
+		shader.lightmapIndex = LIGHTMAP_MD3;
+		shader.sort = SS_OPAQUE;
+		stages[0].bundle[0].image[0] = tr.defaultImage;
+		stages[0].active = qtrue;
+		stages[0].stateBits = GLS_DEFAULT;
+		stages[0].rgbGen = CGEN_VERTEX;
+		stages[0].alphaGen = AGEN_VERTEX;
+		tr.defaultMD3Shader = FinishShader();
+	} else {
+		tr.defaultMD3Shader = tr.defaultShader;
+	}
+
+	// fogShader exists only to generate a GLSL program for fog blending
+	Q_strncpyz( shader.name, "<fog>", sizeof( shader.name ) );
+	shader.lightmapIndex = LIGHTMAP_NONE;
+	stages[0].bundle[0].image[0] = tr.defaultImage;
+	stages[0].rgbGen = CGEN_VERTEX;
+	stages[0].stateBits = GLS_DEFAULT | GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA;
+	tr.fogShader = FinishShader();
+
 	// shadow shader is just a marker
 	Q_strncpyz( shader.name, "<stencil shadow>", sizeof( shader.name ) );
 	shader.sort = SS_STENCIL_SHADOW;
 	tr.shadowShader = FinishShader();
+
+	// prepare portal shader is just a marker
+	Q_strncpyz( shader.name, "<prepare portal>", sizeof( shader.name ) );
+	shader.sort = SS_PORTAL;
+	tr.preparePortalShader = FinishShader();
+	tr.preparePortalShader->optimalStageIteratorFunc = RB_StageIteratorPreparePortal;
+	tr.preparePortalShader->useVBO = qfalse;
+
+	// finalise portal shader is just a marker
+	Q_strncpyz( shader.name, "<finalise portal>", sizeof( shader.name ) );
+	shader.sort = SS_PORTAL;
+	tr.finalisePortalShader = FinishShader();
+	tr.finalisePortalShader->optimalStageIteratorFunc = RB_StageIteratorFinalisePortal;
+	tr.finalisePortalShader->useVBO = qfalse;
+
+	// internal GLSL programs for r_showNormals mode
+	if( qglCreateShader && qglProgramParameteriEXT ) {
+		int i;
+		backEnd.normalProgram = RB_CompileGSProgram( "<normal>",
+							     &normalVS, 1,
+							     &normalGS, 1,
+							     6, GL_POINTS, GL_LINES,
+							     &normalFS, 1,
+							     (1 << AL_VERTEX) |
+							     (1 << AL_NORMAL) |
+							     (1 << AL_TRANSX) |
+							     (1 << AL_TRANSY) |
+							     (1 << AL_TRANSZ) );
+		backEnd.normalProgramMD3 = RB_CompileGSProgram( "<normal md3>",
+								&normalMD3VS, 1,
+								&normalGS, 1,
+								6, GL_POINTS, GL_LINE_STRIP,
+								&normalFS, 1,
+								(1 << AL_VERTEX) |
+								(1 << AL_NORMAL) |
+								(1 << AL_TRANSX) |
+								(1 << AL_TRANSY) |
+								(1 << AL_TRANSZ) |
+								(1 << AL_TIMES) );
+		if( backEnd.normalProgramMD3 ) {
+			i = qglGetUniformLocation( backEnd.normalProgramMD3->handle, "texData" );
+			if( i != -1 ) {
+				qglUniform1i( i, 0 );
+			}
+		}
+	} else {
+		backEnd.normalProgram = NULL;
+		backEnd.normalProgramMD3 = NULL;
+	}
 }
 
 static void CreateExternalShaders( void ) {
@@ -3054,6 +5100,15 @@
 	}
 
 	tr.sunShader = R_FindShader( "sun", LIGHTMAP_NONE, qtrue );
+	if(!tr.sunShader->defaultShader)
+	{
+		int index;
+
+		for(index = 0; index < tr.sunShader->numUnfoggedPasses; index++)
+		{
+			tr.sunShader->stages[index]->stateBits |= GLS_DEPTHRANGE_1_TO_1;
+		}
+	}
 }
 
 /*
@@ -3062,7 +5117,7 @@
 ==================
 */
 void R_InitShaders( void ) {
-	ri.Printf( PRINT_ALL, "Initializing Shaders\n" );
+	ri.Printf( PRINT_DEVELOPER, "Initializing Shaders\n" );
 
 	Com_Memset(hashTable, 0, sizeof(hashTable));
 
Index: src/renderer/tr_sky.c
===================================================================
--- src/renderer/tr_sky.c	(Revision 2062)
+++ src/renderer/tr_sky.c	(Arbeitskopie)
@@ -26,6 +26,10 @@
 #define SKY_SUBDIVISIONS		8
 #define HALF_SKY_SUBDIVISIONS	(SKY_SUBDIVISIONS/2)
 
+#define SKY_MAX_QUADS		(5 * SKY_SUBDIVISIONS * SKY_SUBDIVISIONS)
+#define SKY_MAX_VERTEXES	(4 * SKY_MAX_QUADS)
+#define SKY_MAX_INDEXES		(6 * SKY_MAX_QUADS)
+
 static float s_cloudTexCoords[6][SKY_SUBDIVISIONS+1][SKY_SUBDIVISIONS+1][2];
 static float s_cloudTexP[6][SKY_SUBDIVISIONS+1][SKY_SUBDIVISIONS+1];
 
@@ -269,9 +273,9 @@
 	{
 		for (j = 0 ; j < 3 ; j++) 
 		{
-			VectorSubtract( input->xyz[input->indexes[i+j]],
-							backEnd.viewParms.or.origin, 
-							p[j] );
+			VectorSubtract( tess.vertexPtr2[tess.indexPtr.p16[i+j]].xyz,
+					backEnd.viewParms.or.origin, 
+					p[j] );
 		}
 		ClipSkyPolygon( 3, p[0], 0 );
 	}
@@ -364,25 +368,40 @@
 
 static void DrawSkySide( struct image_s *image, const int mins[2], const int maxs[2] )
 {
-	int s, t;
+	int s, t, i;
+	GLushort indexes[6*(SKY_SUBDIVISIONS+1)*(SKY_SUBDIVISIONS+1)];
+	glRenderState_t state;
 
-	GL_Bind( image );
+	InitState( &state );
 
+	state.program = NULL;
+	state.numImages = 1;
+	state.image[0] = image;
+	SetAttrPointer( &state, AL_VERTEX, 0,
+			3, GL_FLOAT, sizeof(vec3_t),
+			s_skyPoints );
+	SetAttrPointer( &state, AL_TEXCOORD, 0,
+			2, GL_FLOAT, 0,
+			s_skyTexCoords[0][0] );
+	SetAttrVec4f( &state, AL_COLOR, 1.0f, 1.0f, 1.0f, 1.0f );
+	i = 0;
+
 	for ( t = mins[1]+HALF_SKY_SUBDIVISIONS; t < maxs[1]+HALF_SKY_SUBDIVISIONS; t++ )
 	{
-		qglBegin( GL_TRIANGLE_STRIP );
-
-		for ( s = mins[0]+HALF_SKY_SUBDIVISIONS; s <= maxs[0]+HALF_SKY_SUBDIVISIONS; s++ )
+		for ( s = mins[0]+HALF_SKY_SUBDIVISIONS; s < maxs[0]+HALF_SKY_SUBDIVISIONS; s++ )
 		{
-			qglTexCoord2fv( s_skyTexCoords[t][s] );
-			qglVertex3fv( s_skyPoints[t][s] );
-
-			qglTexCoord2fv( s_skyTexCoords[t+1][s] );
-			qglVertex3fv( s_skyPoints[t+1][s] );
+			indexes[i++] = t * (SKY_SUBDIVISIONS+1) + s;
+			indexes[i++] = (t+1) * (SKY_SUBDIVISIONS+1) + s;
+			indexes[i++] = t * (SKY_SUBDIVISIONS+1) + (s+1);
+			indexes[i++] = t * (SKY_SUBDIVISIONS+1) + (s+1);
+			indexes[i++] = (t+1) * (SKY_SUBDIVISIONS+1) + s;
+			indexes[i++] = (t+1) * (SKY_SUBDIVISIONS+1) + (s+1);
 		}
-
-		qglEnd();
 	}
+	if( i > 0 )
+		// the largest index is always the last one
+		GL_DrawElements( &state, i, 0, indexes,
+				 0, indexes[i - 1], 0 );
 }
 
 static void DrawSkyBox( shader_t *shader )
@@ -449,8 +468,7 @@
 		}
 
 		DrawSkySide( shader->sky.outerbox[sky_texorder[i]],
-			         sky_mins_subd,
-					 sky_maxs_subd );
+			     sky_mins_subd, sky_maxs_subd );
 	}
 
 }
@@ -460,6 +478,8 @@
 	int s, t;
 	int vertexStart = tess.numVertexes;
 	int tHeight, sWidth;
+	vaWord1_t	*vertexPtr1 = tess.vertexPtr1 + tess.numVertexes;
+	vaWord2_t	*vertexPtr2 = tess.vertexPtr2 + tess.numVertexes;
 
 	tHeight = maxs[1] - mins[1] + 1;
 	sWidth = maxs[0] - mins[0] + 1;
@@ -468,37 +488,44 @@
 	{
 		for ( s = mins[0]+HALF_SKY_SUBDIVISIONS; s <= maxs[0]+HALF_SKY_SUBDIVISIONS; s++ )
 		{
-			VectorAdd( s_skyPoints[t][s], backEnd.viewParms.or.origin, tess.xyz[tess.numVertexes] );
-			tess.texCoords[tess.numVertexes][0][0] = s_skyTexCoords[t][s][0];
-			tess.texCoords[tess.numVertexes][0][1] = s_skyTexCoords[t][s][1];
+			VectorAdd( s_skyPoints[t][s], backEnd.viewParms.or.origin, vertexPtr2->xyz );
+			vertexPtr1->tc1[0] = s_skyTexCoords[t][s][0];
+			vertexPtr1->tc1[1] = s_skyTexCoords[t][s][1];
+			vertexPtr2->fogNum = tess.fogNum;
 
 			tess.numVertexes++;
+			vertexPtr1++;
+			vertexPtr2++;
 
-			if ( tess.numVertexes >= SHADER_MAX_VERTEXES )
+			if ( tess.numVertexes >= SKY_MAX_VERTEXES )
 			{
-				ri.Error( ERR_DROP, "SHADER_MAX_VERTEXES hit in FillCloudySkySide()\n" );
+				ri.Error( ERR_DROP, "SKY_MAX_VERTEXES hit in FillCloudySkySide()\n" );
 			}
 		}
 	}
 
 	// only add indexes for one pass, otherwise it would draw multiple times for each pass
 	if ( addIndexes ) {
+		if ( tess.minIndex > vertexStart )
+			tess.minIndex = vertexStart;
+		if ( tess.maxIndex < tess.numVertexes - 1 )
+			tess.maxIndex = tess.numVertexes - 1;
 		for ( t = 0; t < tHeight-1; t++ )
 		{	
 			for ( s = 0; s < sWidth-1; s++ )
 			{
-				tess.indexes[tess.numIndexes] = vertexStart + s + t * ( sWidth );
+				tess.indexPtr.p16[tess.numIndexes] = vertexStart + s + t * ( sWidth );
 				tess.numIndexes++;
-				tess.indexes[tess.numIndexes] = vertexStart + s + ( t + 1 ) * ( sWidth );
+				tess.indexPtr.p16[tess.numIndexes] = vertexStart + s + ( t + 1 ) * ( sWidth );
 				tess.numIndexes++;
-				tess.indexes[tess.numIndexes] = vertexStart + s + 1 + t * ( sWidth );
+				tess.indexPtr.p16[tess.numIndexes] = vertexStart + s + 1 + t * ( sWidth );
 				tess.numIndexes++;
 
-				tess.indexes[tess.numIndexes] = vertexStart + s + ( t + 1 ) * ( sWidth );
+				tess.indexPtr.p16[tess.numIndexes] = vertexStart + s + ( t + 1 ) * ( sWidth );
 				tess.numIndexes++;
-				tess.indexes[tess.numIndexes] = vertexStart + s + 1 + ( t + 1 ) * ( sWidth );
+				tess.indexPtr.p16[tess.numIndexes] = vertexStart + s + 1 + ( t + 1 ) * ( sWidth );
 				tess.numIndexes++;
-				tess.indexes[tess.numIndexes] = vertexStart + s + 1 + t * ( sWidth );
+				tess.indexPtr.p16[tess.numIndexes] = vertexStart + s + 1 + t * ( sWidth );
 				tess.numIndexes++;
 			}
 		}
@@ -615,6 +642,10 @@
 	sky_min = 1.0 / 256.0f;		// FIXME: not correct?
 	sky_max = 255.0 / 256.0f;
 
+	tess.numIndexes = SKY_MAX_INDEXES;
+	tess.numVertexes = SKY_MAX_VERTEXES;
+	RB_SetupVertexBuffer( shader, NULL );
+
 	// set up for drawing
 	tess.numIndexes = 0;
 	tess.numVertexes = 0;
@@ -702,6 +733,10 @@
 	float		dist;
 	vec3_t		origin, vec1, vec2;
 	vec3_t		temp;
+	vaWord1_t	*vertexPtr1;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
+	vaWord4_t	*vertexPtr4;
 
 	if ( !backEnd.skyRenderedThisView ) {
 		return;
@@ -722,66 +757,87 @@
 	VectorScale( vec1, size, vec1 );
 	VectorScale( vec2, size, vec2 );
 
-	// farthest depth range
-	qglDepthRange( 1.0, 1.0 );
-
 	// FIXME: use quad stamp
 	RB_BeginSurface( tr.sunShader, tess.fogNum );
-		VectorCopy( origin, temp );
-		VectorSubtract( temp, vec1, temp );
-		VectorSubtract( temp, vec2, temp );
-		VectorCopy( temp, tess.xyz[tess.numVertexes] );
-		tess.texCoords[tess.numVertexes][0][0] = 0;
-		tess.texCoords[tess.numVertexes][0][1] = 0;
-		tess.vertexColors[tess.numVertexes][0] = 255;
-		tess.vertexColors[tess.numVertexes][1] = 255;
-		tess.vertexColors[tess.numVertexes][2] = 255;
-		tess.numVertexes++;
 
-		VectorCopy( origin, temp );
-		VectorAdd( temp, vec1, temp );
-		VectorSubtract( temp, vec2, temp );
-		VectorCopy( temp, tess.xyz[tess.numVertexes] );
-		tess.texCoords[tess.numVertexes][0][0] = 0;
-		tess.texCoords[tess.numVertexes][0][1] = 1;
-		tess.vertexColors[tess.numVertexes][0] = 255;
-		tess.vertexColors[tess.numVertexes][1] = 255;
-		tess.vertexColors[tess.numVertexes][2] = 255;
-		tess.numVertexes++;
+	tess.numVertexes = 4;
+	tess.numIndexes  = 6;
+	RB_SetupVertexBuffer( tr.sunShader, NULL );
 
-		VectorCopy( origin, temp );
-		VectorAdd( temp, vec1, temp );
-		VectorAdd( temp, vec2, temp );
-		VectorCopy( temp, tess.xyz[tess.numVertexes] );
-		tess.texCoords[tess.numVertexes][0][0] = 1;
-		tess.texCoords[tess.numVertexes][0][1] = 1;
-		tess.vertexColors[tess.numVertexes][0] = 255;
-		tess.vertexColors[tess.numVertexes][1] = 255;
-		tess.vertexColors[tess.numVertexes][2] = 255;
-		tess.numVertexes++;
+	vertexPtr1 = tess.vertexPtr1;
+	vertexPtr2 = tess.vertexPtr2;
+	vertexPtr3 = tess.vertexPtr3;
+	vertexPtr4 = tess.vertexPtr4;
 
-		VectorCopy( origin, temp );
-		VectorSubtract( temp, vec1, temp );
-		VectorAdd( temp, vec2, temp );
-		VectorCopy( temp, tess.xyz[tess.numVertexes] );
-		tess.texCoords[tess.numVertexes][0][0] = 1;
-		tess.texCoords[tess.numVertexes][0][1] = 0;
-		tess.vertexColors[tess.numVertexes][0] = 255;
-		tess.vertexColors[tess.numVertexes][1] = 255;
-		tess.vertexColors[tess.numVertexes][2] = 255;
-		tess.numVertexes++;
+	VectorCopy( origin, temp );
+	VectorSubtract( temp, vec1, temp );
+	VectorSubtract( temp, vec2, temp );
+	VectorCopy( temp, vertexPtr2->xyz );
+	vertexPtr1->tc1[0] = 0;
+	vertexPtr1->tc1[1] = 0;
+	vertexPtr4->color[0] = 255;
+	vertexPtr4->color[1] = 255;
+	vertexPtr4->color[2] = 255;
+	vertexPtr2->fogNum = tess.fogNum;
+	vertexPtr1++;
+	vertexPtr2++;
+	vertexPtr3++;
+	vertexPtr4++;
+	
+	VectorCopy( origin, temp );
+	VectorAdd( temp, vec1, temp );
+	VectorSubtract( temp, vec2, temp );
+	VectorCopy( temp, vertexPtr2->xyz );
+	vertexPtr1->tc1[0] = 0;
+	vertexPtr1->tc1[1] = 1;
+	vertexPtr4->color[0] = 255;
+	vertexPtr4->color[1] = 255;
+	vertexPtr4->color[2] = 255;
+	vertexPtr2->fogNum = tess.fogNum;
+	vertexPtr1++;
+	vertexPtr2++;
+	vertexPtr3++;
+	vertexPtr4++;
+	
+	VectorCopy( origin, temp );
+	VectorAdd( temp, vec1, temp );
+	VectorAdd( temp, vec2, temp );
+	VectorCopy( temp, vertexPtr2->xyz );
+	vertexPtr1->tc1[0] = 1;
+	vertexPtr1->tc1[1] = 1;
+	vertexPtr4->color[0] = 255;
+	vertexPtr4->color[1] = 255;
+	vertexPtr4->color[2] = 255;
+	vertexPtr2->fogNum = tess.fogNum;
+	vertexPtr1++;
+	vertexPtr2++;
+	vertexPtr3++;
+	vertexPtr4++;
+	
+	VectorCopy( origin, temp );
+	VectorSubtract( temp, vec1, temp );
+	VectorAdd( temp, vec2, temp );
+	VectorCopy( temp, vertexPtr2->xyz );
+	vertexPtr1->tc1[0] = 1;
+	vertexPtr1->tc1[1] = 0;
+	vertexPtr4->color[0] = 255;
+	vertexPtr4->color[1] = 255;
+	vertexPtr4->color[2] = 255;
+	vertexPtr2->fogNum = tess.fogNum;
+	vertexPtr1++;
+	vertexPtr2++;
+	vertexPtr3++;
+	vertexPtr4++;
+	
+	tess.indexPtr.p16[0] = 0;
+	tess.indexPtr.p16[1] = 1;
+	tess.indexPtr.p16[2] = 2;
+	tess.indexPtr.p16[3] = 0;
+	tess.indexPtr.p16[4] = 2;
+	tess.indexPtr.p16[5] = 3;
 
-		tess.indexes[tess.numIndexes++] = 0;
-		tess.indexes[tess.numIndexes++] = 1;
-		tess.indexes[tess.numIndexes++] = 2;
-		tess.indexes[tess.numIndexes++] = 0;
-		tess.indexes[tess.numIndexes++] = 2;
-		tess.indexes[tess.numIndexes++] = 3;
-
 	RB_EndSurface();
-
-	// back to normal depth range
-	qglDepthRange( 0.0, 1.0 );
+	RB_ClearVertexBuffer();
 }
 
 
@@ -809,18 +865,15 @@
 	// r_showsky will let all the sky blocks be drawn in
 	// front of everything to allow developers to see how
 	// much sky is getting sucked in
-	if ( r_showsky->integer ) {
-		qglDepthRange( 0.0, 0.0 );
-	} else {
-		qglDepthRange( 1.0, 1.0 );
-	}
+	//if ( r_showsky->integer ) {
+	//	qglDepthRange( 0.0, 0.0 );
+	//} else {
+	//	qglDepthRange( 1.0, 1.0 );
+	//}
 
 	// draw the outer skybox
 	if ( tess.shader->sky.outerbox[0] && tess.shader->sky.outerbox[0] != tr.defaultImage ) {
-		qglColor3f( tr.identityLight, tr.identityLight, tr.identityLight );
-		
 		qglPushMatrix ();
-		GL_State( 0 );
 		qglTranslatef (backEnd.viewParms.or.origin[0], backEnd.viewParms.or.origin[1], backEnd.viewParms.or.origin[2]);
 
 		DrawSkyBox( tess.shader );
@@ -834,12 +887,6 @@
 
 	RB_StageIteratorGeneric();
 
-	// draw the inner skybox
-
-
-	// back to normal depth range
-	qglDepthRange( 0.0, 1.0 );
-
 	// note that sky was drawn so we will draw a sun later
 	backEnd.skyRenderedThisView = qtrue;
 }
Index: src/renderer/tr_light.c
===================================================================
--- src/renderer/tr_light.c	(Revision 2062)
+++ src/renderer/tr_light.c	(Arbeitskopie)
@@ -95,11 +95,11 @@
 	for ( i = 0 ; i < bmodel->numSurfaces ; i++ ) {
 		surf = bmodel->firstSurface + i;
 
-		if ( *surf->data == SF_FACE ) {
+		if ( surf->type == SF_FACE ) {
 			((srfSurfaceFace_t *)surf->data)->dlightBits[ tr.smpFrame ] = mask;
-		} else if ( *surf->data == SF_GRID ) {
+		} else if ( surf->type == SF_GRID ) {
 			((srfGridMesh_t *)surf->data)->dlightBits[ tr.smpFrame ] = mask;
-		} else if ( *surf->data == SF_TRIANGLES ) {
+		} else if ( surf->type == SF_TRIANGLES ) {
 			((srfTriangles_t *)surf->data)->dlightBits[ tr.smpFrame ] = mask;
 		}
 	}
Index: src/renderer/tr_types.h
===================================================================
--- src/renderer/tr_types.h	(Revision 2062)
+++ src/renderer/tr_types.h	(Arbeitskopie)
@@ -25,7 +25,8 @@
 #define __TR_TYPES_H
 
 
-#define	MAX_DLIGHTS		32		// can't be increased, because bit flags are used on surfaces
+#define	MAX_DLIGHTS		256
+#define MAX_TEXTURE_DLIGHTS	32		// can't be increased, because because bit flags are used on surfaces
 #define	MAX_ENTITIES		1023		// can't be increased without changing drawsurf bit packing
 
 // renderfx flags
@@ -212,7 +213,6 @@
 
 	qboolean				textureFilterAnisotropic;
 	int							maxAnisotropy;
-                
 } glconfig_t;
 
 #endif	// __TR_TYPES_H
Index: src/renderer/tr_image_dds.c
===================================================================
--- src/renderer/tr_image_dds.c	(Revision 0)
+++ src/renderer/tr_image_dds.c	(Revision 0)
@@ -0,0 +1,363 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+
+This file is part of Tremfusion.
+
+Tremfusion is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremfusion is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremfusion; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+
+#include "tr_local.h"
+#define	LL(x) x=LittleLong(x)
+
+#define DDS_MAGIC   0x20534444
+
+// DDS_PIXELFORMAT.dwFlags
+#define DDPF_ALPHAPIXELS 0x00000001
+#define DDPF_ALPHA       0x00000002
+#define DDPF_FOURCC      0x00000004
+#define DDPF_RGB         0x00000040
+#define DDPF_YUV         0x00000200
+#define DDPF_LUMINANCE   0x00020000
+
+#define FOURCC_DX10 0x30315844
+#define FOURCC_DXT1 0x31545844
+#define FOURCC_DXT2 0x32545844
+#define FOURCC_DXT3 0x33545844
+#define FOURCC_DXT4 0x34545844
+#define FOURCC_DXT5 0x35545844
+#define FOURCC_ATI1 0x31495451
+#define FOURCC_ATI2 0x32495451
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwFlags;
+  unsigned int dwFourCC;
+  unsigned int dwRGBBitCount;
+  unsigned int dwRBitMask;
+  unsigned int dwGBitMask;
+  unsigned int dwBBitMask;
+  unsigned int dwABitMask;
+} DDS_PIXELFORMAT;
+
+// DDS_HEADER.dwHeaderFlags
+#define DDSD_CAPS        0x00000001
+#define DDSD_HEIGHT      0x00000002
+#define DDSD_WIDTH       0x00000004
+#define DDSD_PITCH       0x00000008
+#define DDSD_PIXELFORMAT 0x00001000
+#define DDSD_MIPMAPCOUNT 0x00020000
+#define DDSD_LINEARSIZE  0x00080000
+#define DDSD_DEPTH       0x00800000
+
+// DDS_HEADER.dwSurfaceFlags
+#define DDSCAPS_COMPLEX 0x00000008
+#define DDSCAPS_TEXTURE 0x00001000
+#define DDSCAPS_MIPMAP  0x00400000
+
+// DDS_HEADER.dwCubemapFlags
+#define DDSCAPS2_CUBEMAP           0x00000200
+#define DDSCAPS2_CUBEMAP_POSITIVEX 0x00000400
+#define DDSCAPS2_CUBEMAP_NEGATIVEX 0x00000800
+#define DDSCAPS2_CUBEMAP_POSITIVEY 0x00001000
+#define DDSCAPS2_CUBEMAP_NEGATIVEY 0x00002000
+#define DDSCAPS2_CUBEMAP_POSITIVEZ 0x00004000
+#define DDSCAPS2_CUBEMAP_NEGATIVEZ 0x00008000
+#define DDSCAPS2_VOLUME            0x00200000
+
+typedef struct {
+  unsigned int    dwSize;
+  unsigned int    dwHeaderFlags;
+  unsigned int    dwHeight;
+  unsigned int    dwWidth;
+  unsigned int    dwPitchOrLinearSize;
+  unsigned int    dwDepth;
+  unsigned int    dwMipMapCount;
+  unsigned int    dwReserved1[11];
+  DDS_PIXELFORMAT ddspf;
+  unsigned int    dwSurfaceFlags;
+  unsigned int    dwCubemapFlags;
+  unsigned int    dwReserved2[3];
+} DDS_HEADER;
+
+typedef enum DXGI_FORMAT {
+  DXGI_FORMAT_UNKNOWN                      = 0,
+  DXGI_FORMAT_R32G32B32A32_TYPELESS        = 1,
+  DXGI_FORMAT_R32G32B32A32_FLOAT           = 2,
+  DXGI_FORMAT_R32G32B32A32_UINT            = 3,
+  DXGI_FORMAT_R32G32B32A32_SINT            = 4,
+  DXGI_FORMAT_R32G32B32_TYPELESS           = 5,
+  DXGI_FORMAT_R32G32B32_FLOAT              = 6,
+  DXGI_FORMAT_R32G32B32_UINT               = 7,
+  DXGI_FORMAT_R32G32B32_SINT               = 8,
+  DXGI_FORMAT_R16G16B16A16_TYPELESS        = 9,
+  DXGI_FORMAT_R16G16B16A16_FLOAT           = 10,
+  DXGI_FORMAT_R16G16B16A16_UNORM           = 11,
+  DXGI_FORMAT_R16G16B16A16_UINT            = 12,
+  DXGI_FORMAT_R16G16B16A16_SNORM           = 13,
+  DXGI_FORMAT_R16G16B16A16_SINT            = 14,
+  DXGI_FORMAT_R32G32_TYPELESS              = 15,
+  DXGI_FORMAT_R32G32_FLOAT                 = 16,
+  DXGI_FORMAT_R32G32_UINT                  = 17,
+  DXGI_FORMAT_R32G32_SINT                  = 18,
+  DXGI_FORMAT_R32G8X24_TYPELESS            = 19,
+  DXGI_FORMAT_D32_FLOAT_S8X24_UINT         = 20,
+  DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS     = 21,
+  DXGI_FORMAT_X32_TYPELESS_G8X24_UINT      = 22,
+  DXGI_FORMAT_R10G10B10A2_TYPELESS         = 23,
+  DXGI_FORMAT_R10G10B10A2_UNORM            = 24,
+  DXGI_FORMAT_R10G10B10A2_UINT             = 25,
+  DXGI_FORMAT_R11G11B10_FLOAT              = 26,
+  DXGI_FORMAT_R8G8B8A8_TYPELESS            = 27,
+  DXGI_FORMAT_R8G8B8A8_UNORM               = 28,
+  DXGI_FORMAT_R8G8B8A8_UNORM_SRGB          = 29,
+  DXGI_FORMAT_R8G8B8A8_UINT                = 30,
+  DXGI_FORMAT_R8G8B8A8_SNORM               = 31,
+  DXGI_FORMAT_R8G8B8A8_SINT                = 32,
+  DXGI_FORMAT_R16G16_TYPELESS              = 33,
+  DXGI_FORMAT_R16G16_FLOAT                 = 34,
+  DXGI_FORMAT_R16G16_UNORM                 = 35,
+  DXGI_FORMAT_R16G16_UINT                  = 36,
+  DXGI_FORMAT_R16G16_SNORM                 = 37,
+  DXGI_FORMAT_R16G16_SINT                  = 38,
+  DXGI_FORMAT_R32_TYPELESS                 = 39,
+  DXGI_FORMAT_D32_FLOAT                    = 40,
+  DXGI_FORMAT_R32_FLOAT                    = 41,
+  DXGI_FORMAT_R32_UINT                     = 42,
+  DXGI_FORMAT_R32_SINT                     = 43,
+  DXGI_FORMAT_R24G8_TYPELESS               = 44,
+  DXGI_FORMAT_D24_UNORM_S8_UINT            = 45,
+  DXGI_FORMAT_R24_UNORM_X8_TYPELESS        = 46,
+  DXGI_FORMAT_X24_TYPELESS_G8_UINT         = 47,
+  DXGI_FORMAT_R8G8_TYPELESS                = 48,
+  DXGI_FORMAT_R8G8_UNORM                   = 49,
+  DXGI_FORMAT_R8G8_UINT                    = 50,
+  DXGI_FORMAT_R8G8_SNORM                   = 51,
+  DXGI_FORMAT_R8G8_SINT                    = 52,
+  DXGI_FORMAT_R16_TYPELESS                 = 53,
+  DXGI_FORMAT_R16_FLOAT                    = 54,
+  DXGI_FORMAT_D16_UNORM                    = 55,
+  DXGI_FORMAT_R16_UNORM                    = 56,
+  DXGI_FORMAT_R16_UINT                     = 57,
+  DXGI_FORMAT_R16_SNORM                    = 58,
+  DXGI_FORMAT_R16_SINT                     = 59,
+  DXGI_FORMAT_R8_TYPELESS                  = 60,
+  DXGI_FORMAT_R8_UNORM                     = 61,
+  DXGI_FORMAT_R8_UINT                      = 62,
+  DXGI_FORMAT_R8_SNORM                     = 63,
+  DXGI_FORMAT_R8_SINT                      = 64,
+  DXGI_FORMAT_A8_UNORM                     = 65,
+  DXGI_FORMAT_R1_UNORM                     = 66,
+  DXGI_FORMAT_R9G9B9E5_SHAREDEXP           = 67,
+  DXGI_FORMAT_R8G8_B8G8_UNORM              = 68,
+  DXGI_FORMAT_G8R8_G8B8_UNORM              = 69,
+  DXGI_FORMAT_BC1_TYPELESS                 = 70,
+  DXGI_FORMAT_BC1_UNORM                    = 71,
+  DXGI_FORMAT_BC1_UNORM_SRGB               = 72,
+  DXGI_FORMAT_BC2_TYPELESS                 = 73,
+  DXGI_FORMAT_BC2_UNORM                    = 74,
+  DXGI_FORMAT_BC2_UNORM_SRGB               = 75,
+  DXGI_FORMAT_BC3_TYPELESS                 = 76,
+  DXGI_FORMAT_BC3_UNORM                    = 77,
+  DXGI_FORMAT_BC3_UNORM_SRGB               = 78,
+  DXGI_FORMAT_BC4_TYPELESS                 = 79,
+  DXGI_FORMAT_BC4_UNORM                    = 80,
+  DXGI_FORMAT_BC4_SNORM                    = 81,
+  DXGI_FORMAT_BC5_TYPELESS                 = 82,
+  DXGI_FORMAT_BC5_UNORM                    = 83,
+  DXGI_FORMAT_BC5_SNORM                    = 84,
+  DXGI_FORMAT_B5G6R5_UNORM                 = 85,
+  DXGI_FORMAT_B5G5R5A1_UNORM               = 86,
+  DXGI_FORMAT_B8G8R8A8_UNORM               = 87,
+  DXGI_FORMAT_B8G8R8X8_UNORM               = 88,
+  DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM   = 89,
+  DXGI_FORMAT_B8G8R8A8_TYPELESS            = 90,
+  DXGI_FORMAT_B8G8R8A8_UNORM_SRGB          = 91,
+  DXGI_FORMAT_B8G8R8X8_TYPELESS            = 92,
+  DXGI_FORMAT_B8G8R8X8_UNORM_SRGB          = 93,
+  DXGI_FORMAT_BC6H_TYPELESS                = 94,
+  DXGI_FORMAT_BC6H_UF16                    = 95,
+  DXGI_FORMAT_BC6H_SF16                    = 96,
+  DXGI_FORMAT_BC7_TYPELESS                 = 97,
+  DXGI_FORMAT_BC7_UNORM                    = 98,
+  DXGI_FORMAT_BC7_UNORM_SRGB               = 99,
+  DXGI_FORMAT_FORCE_UINT                   = 0xffffffffUL 
+} DXGI_FORMAT;
+
+typedef enum {
+  D3D10_RESOURCE_DIMENSION_UNKNOWN     = 0,
+  D3D10_RESOURCE_DIMENSION_BUFFER      = 1,
+  D3D10_RESOURCE_DIMENSION_TEXTURE1D   = 2,
+  D3D10_RESOURCE_DIMENSION_TEXTURE2D   = 3,
+  D3D10_RESOURCE_DIMENSION_TEXTURE3D   = 4 
+} D3D10_RESOURCE_DIMENSION;
+
+// DDS_HEADER_DXT10.miscFlag;
+#define DDS_RESOURCE_MISC_TEXTURECUBE 0x00000004
+
+typedef struct {
+  DXGI_FORMAT              dxgiFormat;
+  D3D10_RESOURCE_DIMENSION resourceDimension;
+  unsigned int             miscFlag;
+  unsigned int             arraySize;
+  unsigned int             reserved;
+} DDS_HEADER_DXT10;
+
+static void SetupBlocks( texImage_t *pic, int width, int height, GLuint format,
+			 int blockW, int blockH, int blockSize, int mipmaps,
+			 byte *data ) {
+	int i;
+	int size = 0;
+
+	pic->format = format;
+	pic->numMipmaps = mipmaps;
+
+	for( i = 0; i < mipmaps; i++ ) {
+		int blocksHoriz = (width + blockW - 1) / blockW;
+		int blocksVert  = (height + blockH - 1) / blockH;
+
+		pic->size[i] = blocksHoriz * blocksVert * blockSize;
+
+		if( width > 1 ) width >>= 1;
+		if( height > 1 ) height >>= 1;
+
+		size += pic->size[i];
+	}
+
+	pic->data[0] = ri.Malloc(size);
+	Com_Memcpy( pic->data[0], data, size );
+
+	for( i = 1; i < mipmaps; i++ ) {
+		pic->data[i] = pic->data[i-1] + pic->size[i-1];
+	}
+}
+
+void R_LoadDDS ( const char *name, texImage_t *pic, int *width, int *height)
+{
+	union {
+		byte *b;
+		void *v;
+	} buffer;
+	DDS_HEADER *hdr;
+	int length;
+
+	pic->numMipmaps = 0;
+
+	if(width)
+		*width = 0;
+	if(height)
+		*height = 0;
+
+	//
+	// load the file
+	//
+	length = ri.FS_ReadFile ( ( char * ) name, &buffer.v);
+	if (!buffer.b || length < 0) {
+		return;
+	}
+
+	if( length < 4 || Q_strncmp((char *)buffer.v, "DDS ", 4) ) {
+		ri.Error( ERR_DROP, "LoadDDS: missig DDS signature (%s)\n", name );
+	}
+
+	if( length < 4 + sizeof(DDS_HEADER) ) {
+		ri.Error( ERR_DROP, "LoadDDS: DDS header missing (%s)\n", name );
+	}
+	hdr = (DDS_HEADER *)(buffer.b + 4);
+	LL(hdr->dwSize);
+	LL(hdr->dwHeaderFlags);
+	LL(hdr->dwHeight);
+	LL(hdr->dwWidth);
+	LL(hdr->dwMipMapCount);
+	LL(hdr->ddspf.dwSize);
+	LL(hdr->ddspf.dwFlags);
+	LL(hdr->ddspf.dwFourCC);
+	LL(hdr->ddspf.dwRGBBitCount);
+	LL(hdr->ddspf.dwRBitMask);
+	LL(hdr->ddspf.dwGBitMask);
+	LL(hdr->ddspf.dwBBitMask);
+	LL(hdr->ddspf.dwABitMask);
+	LL(hdr->dwSurfaceFlags);
+	LL(hdr->dwCubemapFlags);
+
+	if( hdr->dwSize != sizeof( DDS_HEADER ) ||
+	    hdr->ddspf.dwSize != sizeof( DDS_PIXELFORMAT ) ) {
+		ri.Error( ERR_DROP, "LoadDDS: DDS header missing (%s)\n", name );
+	}
+
+	GLuint glFormat = 0;
+	int    mipmaps = hdr->dwMipMapCount ? hdr->dwMipMapCount : 1;
+	byte  *base = (byte *)(hdr + 1);
+	
+	if( (hdr->ddspf.dwFlags & DDPF_FOURCC) ) {
+		if( hdr->ddspf.dwFourCC == FOURCC_DX10 ) {
+			// has special DX10 header
+			ri.Error( ERR_DROP, "LoadDDS: unsupported texture format(%s)\n", name );
+		} else {
+			// check if it is one of the DXTn formats
+			switch( hdr->ddspf.dwFourCC ) {
+			case FOURCC_DXT1:
+				glFormat = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
+				break;
+			case FOURCC_DXT2:
+			case FOURCC_DXT3:
+				glFormat = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;
+				break;
+			case FOURCC_DXT4:
+			case FOURCC_DXT5:
+				glFormat = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
+				break;
+			case FOURCC_ATI1:
+				glFormat = GL_COMPRESSED_LUMINANCE_LATC1_EXT;
+				break;
+			case FOURCC_ATI2:
+				glFormat = GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT;
+				break;
+			default:
+				ri.Error( ERR_DROP, "LoadDDS: unsupported texture format(%s)\n", name );
+				break;
+			}
+		}
+
+	} else {
+		// linear data
+		glFormat = GL_RGBA8;
+	}
+
+	switch( glFormat ) {
+	case GL_RGBA8:
+		break;
+	case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+		SetupBlocks( pic, hdr->dwWidth, hdr->dwHeight, glFormat,
+			     4, 4, 8, mipmaps, base );
+		break;
+	case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
+		SetupBlocks( pic, hdr->dwWidth, hdr->dwHeight, glFormat,
+			     4, 4, 16, mipmaps, base );
+		break;
+	case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
+		SetupBlocks( pic, hdr->dwWidth, hdr->dwHeight, glFormat,
+			     4, 4, 16, mipmaps, base );
+		break;
+	}
+
+	if (width)
+		*width = hdr->dwWidth;
+	if (height)
+		*height = hdr->dwHeight;
+
+	ri.FS_FreeFile (buffer.v);
+}
Index: src/renderer/tr_animation.c
===================================================================
--- src/renderer/tr_animation.c	(Revision 2062)
+++ src/renderer/tr_animation.c	(Arbeitskopie)
@@ -46,13 +46,13 @@
 	shader_t		*shader;
 	int				i;
 
-	header = (md4Header_t *) tr.currentModel->md4;
+	header = (md4Header_t *) tr.currentModel->modelData.md4.md4;
 	lod = (md4LOD_t *)( (byte *)header + header->ofsLODs );
 
 	surface = (md4Surface_t *)( (byte *)lod + lod->ofsSurfaces );
 	for ( i = 0 ; i < lod->numSurfaces ; i++ ) {
 		shader = R_GetShaderByHandle( surface->shaderIndex );
-		R_AddDrawSurf( (void *)surface, shader, 0 /*fogNum*/, qfalse );
+		R_AddDrawSurf( (void *)surface, shader, 0 /*fogNum*/, 0, qfalse );
 		surface = (md4Surface_t *)( (byte *)surface + surface->ofsEnd );
 	}
 }
@@ -62,12 +62,13 @@
 RB_SurfaceAnim
 ==============
 */
-void RB_SurfaceAnim( md4Surface_t *surface ) {
+void RB_SurfaceAnim( surfaceType_t *surf ) {
+	md4Surface_t		*surface = (md4Surface_t *)surf;
 	int				i, j, k;
 	float			frontlerp, backlerp;
 	int				*triangles;
 	int				indexes;
-	int				baseIndex, baseVertex;
+	int				baseVertex;
 	int				numVerts;
 	md4Vertex_t		*v;
 	md4Bone_t		bones[MD4_MAX_BONES];
@@ -76,8 +77,10 @@
 	md4Frame_t		*frame;
 	md4Frame_t		*oldFrame;
 	int				frameSize;
+	vaWord1_t		*vertexPtr1;
+	vaWord2_t		*vertexPtr2;
+	vaWord3_t		*vertexPtr3;
 
-
 	if (  backEnd.currentEntity->e.oldframe == backEnd.currentEntity->e.frame ) {
 		backlerp = 0;
 		frontlerp = 1;
@@ -94,77 +97,92 @@
 	oldFrame = (md4Frame_t *)((byte *)header + header->ofsFrames + 
 			backEnd.currentEntity->e.oldframe * frameSize );
 
-	RB_CheckOverflow( surface->numVerts, surface->numTriangles * 3 );
+	if ( tess.vertexPtr1 ) {
+		baseVertex = tess.numVertexes;
+		vertexPtr1 = tess.vertexPtr1 + baseVertex;
+		vertexPtr2 = tess.vertexPtr2 + baseVertex;
+		vertexPtr3 = tess.vertexPtr3 + baseVertex;
 
-	triangles = (int *) ((byte *)surface + surface->ofsTriangles);
-	indexes = surface->numTriangles * 3;
-	baseIndex = tess.numIndexes;
-	baseVertex = tess.numVertexes;
-	for (j = 0 ; j < indexes ; j++) {
-		tess.indexes[baseIndex + j] = baseIndex + triangles[j];
-	}
-	tess.numIndexes += indexes;
-
-	//
-	// lerp all the needed bones
-	//
-	if ( !backlerp ) {
-		// no lerping needed
-		bonePtr = frame->bones;
-	} else {
-		bonePtr = bones;
-		for ( i = 0 ; i < header->numBones*12 ; i++ ) {
-			((float *)bonePtr)[i] = frontlerp * ((float *)frame->bones)[i]
+		//
+		// lerp all the needed bones
+		//
+		if ( !backlerp ) {
+			// no lerping needed
+			bonePtr = frame->bones;
+		} else {
+			bonePtr = bones;
+			for ( i = 0 ; i < header->numBones*12 ; i++ ) {
+				((float *)bonePtr)[i] = frontlerp * ((float *)frame->bones)[i]
 					+ backlerp * ((float *)oldFrame->bones)[i];
+			}
 		}
-	}
-
-	//
-	// deform the vertexes by the lerped bones
-	//
-	numVerts = surface->numVerts;
-	// FIXME
-	// This makes TFC's skeletons work.  Shouldn't be necessary anymore, but left
-	// in for reference.
-	//v = (md4Vertex_t *) ((byte *)surface + surface->ofsVerts + 12);
-	v = (md4Vertex_t *) ((byte *)surface + surface->ofsVerts);
-	for ( j = 0; j < numVerts; j++ ) {
-		vec3_t	tempVert, tempNormal;
-		md4Weight_t	*w;
-
-		VectorClear( tempVert );
-		VectorClear( tempNormal );
-		w = v->weights;
-		for ( k = 0 ; k < v->numWeights ; k++, w++ ) {
-			bone = bonePtr + w->boneIndex;
-
-			tempVert[0] += w->boneWeight * ( DotProduct( bone->matrix[0], w->offset ) + bone->matrix[0][3] );
-			tempVert[1] += w->boneWeight * ( DotProduct( bone->matrix[1], w->offset ) + bone->matrix[1][3] );
-			tempVert[2] += w->boneWeight * ( DotProduct( bone->matrix[2], w->offset ) + bone->matrix[2][3] );
-
-			tempNormal[0] += w->boneWeight * DotProduct( bone->matrix[0], v->normal );
-			tempNormal[1] += w->boneWeight * DotProduct( bone->matrix[1], v->normal );
-			tempNormal[2] += w->boneWeight * DotProduct( bone->matrix[2], v->normal );
-		}
-
-		tess.xyz[baseVertex + j][0] = tempVert[0];
-		tess.xyz[baseVertex + j][1] = tempVert[1];
-		tess.xyz[baseVertex + j][2] = tempVert[2];
-
-		tess.normal[baseVertex + j][0] = tempNormal[0];
-		tess.normal[baseVertex + j][1] = tempNormal[1];
-		tess.normal[baseVertex + j][2] = tempNormal[2];
-
-		tess.texCoords[baseVertex + j][0][0] = v->texCoords[0];
-		tess.texCoords[baseVertex + j][0][1] = v->texCoords[1];
-
+		
+		//
+		// deform the vertexes by the lerped bones
+		//
+		numVerts = surface->numVerts;
 		// FIXME
 		// This makes TFC's skeletons work.  Shouldn't be necessary anymore, but left
 		// in for reference.
-		//v = (md4Vertex_t *)( ( byte * )&v->weights[v->numWeights] + 12 );
-		v = (md4Vertex_t *)&v->weights[v->numWeights];
+		//v = (md4Vertex_t *) ((byte *)surface + surface->ofsVerts + 12);
+		v = (md4Vertex_t *) ((byte *)surface + surface->ofsVerts);
+		for ( j = 0; j < numVerts; j++ ) {
+			vec4_t	tempVert, tempNormal;
+			md4Weight_t	*w;
+			
+			VectorClear( tempVert ); tempVert[3] = 0.0;
+			VectorClear( tempNormal ); tempNormal[3] = 0.0;
+			w = v->weights;
+			for ( k = 0 ; k < v->numWeights ; k++, w++ ) {
+				bone = bonePtr + w->boneIndex;
+				
+				tempVert[0] += w->boneWeight * ( DotProduct( bone->matrix[0], w->offset ) + bone->matrix[0][3] );
+				tempVert[1] += w->boneWeight * ( DotProduct( bone->matrix[1], w->offset ) + bone->matrix[1][3] );
+				tempVert[2] += w->boneWeight * ( DotProduct( bone->matrix[2], w->offset ) + bone->matrix[2][3] );
+				
+				tempNormal[0] += w->boneWeight * DotProduct( bone->matrix[0], v->normal );
+				tempNormal[1] += w->boneWeight * DotProduct( bone->matrix[1], v->normal );
+				tempNormal[2] += w->boneWeight * DotProduct( bone->matrix[2], v->normal );
+			}
+			
+			VectorCopy( tempVert, vertexPtr2->xyz );
+			VectorCopy( tempNormal, vertexPtr3->normal );
+			Vector2Copy( v->texCoords, vertexPtr1->tc1 );
+			Vector2Copy( v->texCoords, vertexPtr1->tc2 );
+			vertexPtr2->fogNum = (float)tess.fogNum;
+
+			vertexPtr1++;
+			vertexPtr2++;
+			vertexPtr3++;
+			
+			// FIXME
+			// This makes TFC's skeletons work.  Shouldn't be necessary anymore, but left
+			// in for reference.
+			//v = (md4Vertex_t *)( ( byte * )&v->weights[v->numWeights] + 12 );
+			v = (md4Vertex_t *)&v->weights[v->numWeights];
+		}
+	} else {
+		baseVertex = 0; // ERROR
 	}
+	
+	if ( tess.indexPtr.p16 ) {
+		triangles = (int *) ((byte *)surface + surface->ofsTriangles);
+		indexes = surface->numTriangles * 3;
 
+		if ( tess.indexInc == sizeof(GLushort) ) {
+			GLushort *indexPtr = tess.indexPtr.p16 + tess.numIndexes;
+			for (j = 0 ; j < indexes ; j++) {
+				*indexPtr++ = (GLushort)(baseVertex + triangles[j]);
+			}
+		} else {
+			GLuint *indexPtr32 = tess.indexPtr.p32 + tess.numIndexes;
+			for (j = 0 ; j < indexes ; j++) {
+				*indexPtr32++ = baseVertex + triangles[j];
+			}
+		}
+	}
+	
+	tess.numIndexes += surface->numTriangles * 3;
 	tess.numVertexes += surface->numVerts;
 }
 
@@ -445,8 +463,9 @@
 RB_MDRSurfaceAnim
 ==============
 */
-void RB_MDRSurfaceAnim( md4Surface_t *surface )
+void RB_MDRSurfaceAnim( surfaceType_t *surf )
 {
+	md4Surface_t *surface = (md4Surface_t *) surf;
 	int				i, j, k;
 	float			frontlerp, backlerp;
 	int				*triangles;
@@ -483,8 +502,6 @@
 	oldFrame = (mdrFrame_t *)((byte *)header + header->ofsFrames +
 		backEnd.currentEntity->e.oldframe * frameSize );
 
-	RB_CheckOverflow( surface->numVerts, surface->numTriangles );
-
 	triangles	= (int *) ((byte *)surface + surface->ofsTriangles);
 	indexes		= surface->numTriangles * 3;
 	baseIndex	= tess.numIndexes;
Index: src/renderer/tr_image_jpg.c
===================================================================
--- src/renderer/tr_image_jpg.c	(Revision 2062)
+++ src/renderer/tr_image_jpg.c	(Arbeitskopie)
@@ -34,7 +34,7 @@
 #define JPEG_INTERNALS
 #include "../jpeg-6b/jpeglib.h"
 
-void R_LoadJPG( const char *filename, unsigned char **pic, int *width, int *height ) {
+void R_LoadJPG( const char *filename, texImage_t *pic, int *width, int *height ) {
   /* This struct contains the JPEG decompression parameters and pointers to
    * working space (which is allocated as needed by the JPEG library).
    */
@@ -64,6 +64,8 @@
 	} fbuffer;
   byte  *buf;
 
+  pic->numMipmaps = 0;
+
   /* In this example we want to open the input file before doing anything else,
    * so that the setjmp() error recovery below can assume the file is open.
    * VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
@@ -188,7 +190,9 @@
 	}
   }
 
-  *pic = out;
+  pic->format = GL_RGBA8;
+  pic->numMipmaps = 1;
+  pic->data[0] = out;
 
   /* Step 7: Finish decompression */
 
Index: src/renderer/tr_image.c
===================================================================
--- src/renderer/tr_image.c	(Revision 2062)
+++ src/renderer/tr_image.c	(Arbeitskopie)
@@ -115,7 +115,7 @@
 	for ( i = 0 ; i < tr.numImages ; i++ ) {
 		glt = tr.images[ i ];
 		if ( glt->mipmap ) {
-			GL_Bind (glt);
+			GL_BindTexture ( glt->texnum );
 			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
 			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
 		}
@@ -230,10 +230,10 @@
 before or after.
 ================
 */
-static void ResampleTexture( unsigned *in, int inwidth, int inheight, unsigned *out,  
-							int outwidth, int outheight ) {
+static void ResampleTexture( byte *in, int inwidth, int inheight,
+			     byte *out, int outwidth, int outheight ) {
 	int		i, j;
-	unsigned	*inrow, *inrow2;
+	byte		*inrow, *inrow2;
 	unsigned	frac, fracstep;
 	unsigned	p1[2048], p2[2048];
 	byte		*pix1, *pix2, *pix3, *pix4;
@@ -254,19 +254,19 @@
 		frac += fracstep;
 	}
 
-	for (i=0 ; i<outheight ; i++, out += outwidth) {
-		inrow = in + inwidth*(int)((i+0.25)*inheight/outheight);
-		inrow2 = in + inwidth*(int)((i+0.75)*inheight/outheight);
+	for (i=0 ; i<outheight ; i++, out += 4*outwidth) {
+		inrow = in + 4*inwidth*(int)((i+0.25)*inheight/outheight);
+		inrow2 = in + 4*inwidth*(int)((i+0.75)*inheight/outheight);
 		frac = fracstep >> 1;
 		for (j=0 ; j<outwidth ; j++) {
-			pix1 = (byte *)inrow + p1[j];
-			pix2 = (byte *)inrow + p2[j];
-			pix3 = (byte *)inrow2 + p1[j];
-			pix4 = (byte *)inrow2 + p2[j];
-			((byte *)(out+j))[0] = (pix1[0] + pix2[0] + pix3[0] + pix4[0])>>2;
-			((byte *)(out+j))[1] = (pix1[1] + pix2[1] + pix3[1] + pix4[1])>>2;
-			((byte *)(out+j))[2] = (pix1[2] + pix2[2] + pix3[2] + pix4[2])>>2;
-			((byte *)(out+j))[3] = (pix1[3] + pix2[3] + pix3[3] + pix4[3])>>2;
+			pix1 = inrow + p1[j];
+			pix2 = inrow + p2[j];
+			pix3 = inrow2 + p1[j];
+			pix4 = inrow2 + p2[j];
+			out[4*j+0] = (pix1[0] + pix2[0] + pix3[0] + pix4[0])>>2;
+			out[4*j+1] = (pix1[1] + pix2[1] + pix3[1] + pix4[1])>>2;
+			out[4*j+2] = (pix1[2] + pix2[2] + pix3[2] + pix4[2])>>2;
+			out[4*j+3] = (pix1[3] + pix2[3] + pix3[3] + pix4[3])>>2;
 		}
 	}
 }
@@ -279,16 +279,16 @@
 lighting range
 ================
 */
-void R_LightScaleTexture (unsigned *in, int inwidth, int inheight, qboolean only_gamma )
+void R_LightScaleTexture (byte *in, int inwidth, int inheight, qboolean only_gamma )
 {
 	if ( only_gamma )
 	{
 		if ( !glConfig.deviceSupportsGamma )
 		{
-			int		i, c;
+			int	i, c;
 			byte	*p;
 
-			p = (byte *)in;
+			p = in;
 
 			c = inwidth*inheight;
 			for (i=0 ; i<c ; i++, p+=4)
@@ -301,10 +301,10 @@
 	}
 	else
 	{
-		int		i, c;
+		int	i, c;
 		byte	*p;
 
-		p = (byte *)in;
+		p = in;
 
 		c = inwidth*inheight;
 
@@ -397,6 +397,7 @@
 	int		i, j;
 	byte	*out;
 	int		row;
+	int	w0, w1, w2, w3, w4, w5;
 
 	if ( !r_simpleMipMaps->integer ) {
 		R_MipMap2( (unsigned *)in, width, height );
@@ -409,31 +410,210 @@
 
 	row = width * 4;
 	out = in;
+
+	if( width == 1 ) {
+		if( height == 1 ) {
+			return;
+		} else if( height & 1 ) {
+			height >>= 1;
+			for( i = 0; i < height; i++, out+=4, in+=8 ) {
+				w0 = (height - i) * 0x10000 / (2*height+1);
+				w1 = height       * 0x10000 / (2*height+1);
+				w2 = 0x10000 - w0 - w1;
+				out[0] = (w0 * in[0] + w1 * in[4] + w2 * in[ 8]) >> 16;
+				out[1] = (w0 * in[1] + w1 * in[5] + w2 * in[ 9]) >> 16;
+				out[2] = (w0 * in[2] + w1 * in[6] + w2 * in[10]) >> 16;
+				out[3] = (w0 * in[3] + w1 * in[7] + w2 * in[11]) >> 16;
+			}
+		} else {
+			height >>= 1;
+			for( i = 0; i < height; i++, out+=4, in+=8 ) {
+				out[0] = (in[0] + in[4]) >> 1;
+				out[1] = (in[1] + in[5]) >> 1;
+				out[2] = (in[2] + in[6]) >> 1;
+				out[3] = (in[3] + in[7]) >> 1;
+			}
+		}
+	} else if( width & 1 ) {
+		width >>= 1;
+		if( height == 1 ) {
+			for( j = 0; j < width; j++, out+=4, in+=8 ) {
+				w0 = (width - j) * 0x10000 / (2*width+1);
+				w1 = width       * 0x10000 / (2*width+1);
+				w2 = 0x10000 - w0 - w1;
+				out[0] = (w0 * in[0] + w1 * in[4] + w2 * in[ 8]) >> 16;
+				out[1] = (w0 * in[1] + w1 * in[5] + w2 * in[ 9]) >> 16;
+				out[2] = (w0 * in[2] + w1 * in[6] + w2 * in[10]) >> 16;
+				out[3] = (w0 * in[3] + w1 * in[7] + w2 * in[11]) >> 16;
+			}
+		} else if( height & 1 ) {
+			height >>= 1;
+			for (i=0 ; i<height ; i++, in+=row+4) {
+				w0 = (height - i) * 0x100 / (2*height+1);
+				w1 = height       * 0x100 / (2*height+1);
+				w2 = 0x100 - w0 - w1;
+				for (j=0 ; j<width ; j++, out+=4, in+=8) {
+					w3 = (width - j) * 0x100 / (2*width+1);
+					w4 = width       * 0x100 / (2*width+1);
+					w5 = 0x100 - w3 - w4;
+					out[0] = (w0 * w3 * in[      0] + w0 * w4 * in[      4] + w0 * w5 * in[       8] +
+						  w1 * w3 * in[  row+0] + w1 * w4 * in[  row+4] + w1 * w5 * in[  row+ 8] +
+						  w2 * w3 * in[2*row+0] + w2 * w4 * in[2*row+4] + w2 * w5 * in[2*row+ 8]) >> 16;
+					out[1] = (w0 * w3 * in[      1] + w0 * w4 * in[      5] + w0 * w5 * in[       9] +
+						  w1 * w3 * in[  row+1] + w1 * w4 * in[  row+5] + w1 * w5 * in[  row+ 9] +
+						  w2 * w3 * in[2*row+1] + w2 * w4 * in[2*row+5] + w2 * w5 * in[2*row+ 9]) >> 16;
+					out[2] = (w0 * w3 * in[      2] + w0 * w4 * in[      6] + w0 * w5 * in[      10] +
+						  w1 * w3 * in[  row+2] + w1 * w4 * in[  row+6] + w1 * w5 * in[  row+10] +
+						  w2 * w3 * in[2*row+2] + w2 * w4 * in[2*row+6] + w2 * w5 * in[2*row+10]) >> 16;
+					out[3] = (w0 * w3 * in[      3] + w0 * w4 * in[      7] + w0 * w5 * in[      11] +
+						  w1 * w3 * in[  row+3] + w1 * w4 * in[  row+7] + w1 * w5 * in[  row+11] +
+						  w2 * w3 * in[2*row+3] + w2 * w4 * in[2*row+7] + w2 * w5 * in[2*row+11]) >> 16;
+				}
+			}
+		} else {
+			height >>= 1;
+			for (i=0 ; i<height ; i++, in+=row) {
+				for (j=0 ; j<width ; j++, out+=4, in+=8) {
+					w0 = (width - j) * 0x10000 / (2*width+1);
+					w1 = width       * 0x10000 / (2*width+1);
+					w2 = 0x10000 - w0 - w1;
+					out[0] = (w0 * (in[0] + in[row+0]) + w1 * (in[4] + in[row+4]) + w2 * (in[ 8] + in[row+ 8]))>>17;
+					out[1] = (w0 * (in[1] + in[row+1]) + w1 * (in[5] + in[row+5]) + w2 * (in[ 9] + in[row+ 9]))>>17;
+					out[2] = (w0 * (in[2] + in[row+2]) + w1 * (in[6] + in[row+6]) + w2 * (in[10] + in[row+10]))>>17;
+					out[3] = (w0 * (in[3] + in[row+3]) + w1 * (in[7] + in[row+7]) + w2 * (in[11] + in[row+11]))>>17;
+				}
+			}
+		}
+	} else {
+		width >>= 1;
+		if( height == 1 ) {
+			for( j = 0; j < width; j++, out+=4, in+=8 ) {
+				out[0] = (in[0] + in[4]) >> 1;
+				out[1] = (in[1] + in[5]) >> 1;
+				out[2] = (in[2] + in[6]) >> 1;
+				out[3] = (in[3] + in[7]) >> 1;
+			}
+		} else if( height & 1 ) {
+			height >>= 1;
+			for (i=0 ; i<height ; i++, in+=row) {
+				w0 = (height - i) * 0x10000 / (2*height+1);
+				w1 = height       * 0x10000 / (2*height+1);
+				w2 = 0x10000 - w0 - w1;
+				for (j=0 ; j<width ; j++, out+=4, in+=8) {
+					out[0] = (w0 * (in[0] + in[4]) + w1 * (in[row+0] + in[row+4]) + w2 * (in[2*row+0] + in[2*row+4]))>>17;
+					out[1] = (w0 * (in[1] + in[5]) + w1 * (in[row+1] + in[row+5]) + w2 * (in[2*row+1] + in[2*row+5]))>>17;
+					out[2] = (w0 * (in[2] + in[6]) + w1 * (in[row+2] + in[row+6]) + w2 * (in[2*row+2] + in[2*row+6]))>>17;
+					out[3] = (w0 * (in[3] + in[7]) + w1 * (in[row+3] + in[row+7]) + w2 * (in[2*row+3] + in[2*row+7]))>>17;
+				}
+			}
+		} else {
+			height >>= 1;
+			for (i=0 ; i<height ; i++, in+=row) {
+				for (j=0 ; j<width ; j++, out+=4, in+=8) {
+					out[0] = (in[0] + in[4] + in[row+0] + in[row+4])>>2;
+					out[1] = (in[1] + in[5] + in[row+1] + in[row+5])>>2;
+					out[2] = (in[2] + in[6] + in[row+2] + in[row+6])>>2;
+					out[3] = (in[3] + in[7] + in[row+3] + in[row+7])>>2;
+				}
+			}
+		}
+	}
+}
+
+
+/*
+================
+R_MipMapHeightMap
+
+Operates in place, quartering the size of the texture
+The red & green and blue channels are set the the x, y and z of the
+average normal and the alpha channel is the max or average height.
+================
+*/
+static byte avg(byte a, byte b) { return (a+b) >> 1; }
+static byte avg4(byte a, byte b, byte c, byte d) { return (a+b+c+d) >> 2; }
+static void R_MipMapHeightMap (byte *in, int width, int height) {
+	int	i, j;
+	byte	*out;
+	int	row;
+	vec3_t  normal, normalSum;
+
+	if ( width == 1 && height == 1 ) {
+		return;
+	}
+
+	row = width * 4;
+	out = in;
 	width >>= 1;
 	height >>= 1;
 
 	if ( width == 0 || height == 0 ) {
 		width += height;	// get largest
 		for (i=0 ; i<width ; i++, out+=4, in+=8 ) {
-			out[0] = ( in[0] + in[4] )>>1;
-			out[1] = ( in[1] + in[5] )>>1;
-			out[2] = ( in[2] + in[6] )>>1;
-			out[3] = ( in[3] + in[7] )>>1;
+			VectorClear( normalSum );
+
+			normal[0] = in[0] * 1.0f/127.5f - 1.0f;
+			normal[1] = in[1] * 1.0f/127.5f - 1.0f;
+			normal[2] = 1.0f - normal[0]*normal[0] - normal[1]*normal[1];
+			normal[2] *= Q_rsqrt(normal[2]);
+			VectorAdd( normal, normalSum, normalSum );
+
+			normal[0] = in[4] * 1.0f/127.5f - 1.0f;
+			normal[1] = in[5] * 1.0f/127.5f - 1.0f;
+			normal[2] = 1.0f - normal[0]*normal[0] - normal[1]*normal[1];
+			normal[2] *= Q_rsqrt(normal[2]);
+			VectorAdd( normal, normalSum, normalSum );
+
+			VectorNormalizeFast( normalSum );
+			out[0] = (normalSum[0] + 1.0f) * 127.5f;
+			out[1] = (normalSum[1] + 1.0f) * 127.5f;
+			out[2] = (normalSum[2] + 1.0f) * 127.5f;
+			
+			out[3] = avg( in[3], in[7] );
 		}
 		return;
 	}
 
 	for (i=0 ; i<height ; i++, in+=row) {
 		for (j=0 ; j<width ; j++, out+=4, in+=8) {
-			out[0] = (in[0] + in[4] + in[row+0] + in[row+4])>>2;
-			out[1] = (in[1] + in[5] + in[row+1] + in[row+5])>>2;
-			out[2] = (in[2] + in[6] + in[row+2] + in[row+6])>>2;
-			out[3] = (in[3] + in[7] + in[row+3] + in[row+7])>>2;
+			VectorClear( normalSum );
+
+			normal[0] = in[0] * 1.0f/127.5f - 1.0f;
+			normal[1] = in[1] * 1.0f/127.5f - 1.0f;
+			normal[2] = 1.0f - normal[0]*normal[0] - normal[1]*normal[1];
+			normal[2] *= Q_rsqrt(normal[2]);
+			VectorAdd( normal, normalSum, normalSum );
+
+			normal[0] = in[4] * 1.0f/127.5f - 1.0f;
+			normal[1] = in[5] * 1.0f/127.5f - 1.0f;
+			normal[2] = 1.0f - normal[0]*normal[0] - normal[1]*normal[1];
+			normal[2] *= Q_rsqrt(normal[2]);
+			VectorAdd( normal, normalSum, normalSum );
+
+			normal[0] = in[row+0] * 1.0f/127.5f - 1.0f;
+			normal[1] = in[row+1] * 1.0f/127.5f - 1.0f;
+			normal[2] = 1.0f - normal[0]*normal[0] - normal[1]*normal[1];
+			normal[2] *= Q_rsqrt(normal[2]);
+			VectorAdd( normal, normalSum, normalSum );
+
+			normal[0] = in[row+4] * 1.0f/127.5f - 1.0f;
+			normal[1] = in[row+5] * 1.0f/127.5f - 1.0f;
+			normal[2] = 1.0f - normal[0]*normal[0] - normal[1]*normal[1];
+			normal[2] *= Q_rsqrt(normal[2]);
+			VectorAdd( normal, normalSum, normalSum );
+
+			VectorNormalizeFast( normalSum );
+			out[0] = (normalSum[0] + 1.0f) * 127.5f;
+			out[1] = (normalSum[1] + 1.0f) * 127.5f;
+			out[2] = (normalSum[2] + 1.0f) * 127.5f;
+
+			out[3] = avg4( in[3], in[7],
+				       in[row+3], in[row+7] );
 		}
 	}
+	return;
 }
 
-
 /*
 ==================
 R_BlendOverTexture
@@ -477,128 +657,362 @@
 	{0,0,255,128},
 };
 
+static qboolean TexFormatSupported( GLenum internalFormat, int width, int height ) {
+	qglTexImage2D (GL_PROXY_TEXTURE_2D, 0, internalFormat,
+		       width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+	qglGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, 0,
+				  GL_TEXTURE_WIDTH, &width);
+	return (width != 0);
+}
 
+static qboolean IsCompressedFormat( GLenum format ) {
+	switch( format ) {
+	case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+	case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
+	case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
+	case GL_COMPRESSED_LUMINANCE_LATC1_EXT:
+	case GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:
+		return qtrue;
+	case GL_RGBA8:
+		return qfalse;
+	default:
+		ri.Printf( PRINT_WARNING, "unknown texture format %x\n", format );
+		return qfalse;
+	}
+}
+
+static void UncompressImage( GLenum format, int width, int height,
+			     byte *in, byte *out ) {
+	int             x, y, alphasize, row = 4*width;
+	unsigned short  col0, col1;
+	color4ub_t      palette[16];
+	unsigned int    colorbits0, colorbits1, alphabits0, alphabits1, alphamask;
+
+	for( x = 0; x < width; x += 4 ) {
+		for( y = 0; x < height; y += 4 ) {
+			switch( format ) {
+			case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+			case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
+			case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
+				// setup color palette
+				col0 = in[0] | (in[1] << 8); // R5G6B5
+				col1 = in[2] | (in[3] << 8);
+
+				palette[0][0] = ((col0 >> 8) & 0xf8) | ((col0 >> 13) & 0x07);
+				palette[0][1] = ((col0 >> 3) & 0xfc) | ((col0 >> 9) & 0x03);
+				palette[0][2] = ((col0 << 3) & 0xf8) | (col0 & 0x07);
+				palette[0][3] = 255;
+
+				palette[1][0] = ((col1 >> 8) & 0xf8) | ((col1 >> 13) & 0x07);
+				palette[1][1] = ((col1 >> 3) & 0xfc) | ((col1 >> 9) & 0x03);
+				palette[1][2] = ((col1 << 3) & 0xf8) | (col1 & 0x07);
+				palette[1][3] = 255;
+
+				if( col0 <= col1 ) {
+					palette[2][0] = (palette[0][0] + palette[1][0]) >> 1;
+					palette[2][1] = (palette[0][1] + palette[1][1]) >> 1;
+					palette[2][2] = (palette[0][2] + palette[1][2]) >> 1;
+					palette[2][3] = 255;
+					palette[3][0] = 0;
+					palette[3][1] = 0;
+					palette[3][2] = 0;
+					palette[3][3] = 0; // will be overwritten for non-DXT1 formats
+				} else {
+					palette[2][0] = (2*palette[0][0] + palette[1][0]) / 3;
+					palette[2][1] = (2*palette[0][1] + palette[1][1]) / 3;
+					palette[2][2] = (2*palette[0][2] + palette[1][2]) / 3;
+					palette[2][3] = 255;
+					palette[3][0] = (palette[0][0] + 2*palette[1][0]) / 3;
+					palette[3][1] = (palette[0][1] + 2*palette[1][1]) / 3;
+					palette[3][2] = (palette[0][2] + 2*palette[1][2]) / 3;
+					palette[3][3] = 255;
+				}
+				colorbits0 = in[2] + (in[3] << 8) + (in[4] << 16);
+				colorbits1 = in[5] + (in[6] << 8) + (in[7] << 16);
+				break;
+			case GL_COMPRESSED_LUMINANCE_LATC1_EXT:
+			case GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:
+				palette[0][0] = palette[0][1] = palette[0][2] = in[8];
+				palette[1][0] = palette[1][1] = palette[1][2] = in[9];
+				if( in[8] > in[9] ) {
+					palette[2][0] = palette[2][1] = palette[2][2] =
+						(6*in[8] + 1*in[9]) / 7;
+					palette[3][0] = palette[3][1] = palette[3][2] =
+						(5*in[8] + 2*in[9]) / 7;
+					palette[4][0] = palette[4][1] = palette[4][2] =
+						(4*in[8] + 3*in[9]) / 7;
+					palette[5][0] = palette[5][1] = palette[5][2] =
+						(3*in[8] + 4*in[9]) / 7;
+					palette[6][0] = palette[6][1] = palette[6][2] =
+						(2*in[8] + 5*in[9]) / 7;
+					palette[7][0] = palette[7][1] = palette[7][2] =
+						(1*in[8] + 6*in[9]) / 7;
+				} else {
+					palette[2][0] = palette[2][1] = palette[2][2] =
+						(4*in[8] + 1*in[9]) / 5;
+					palette[3][0] = palette[3][1] = palette[3][2] =
+						(3*in[8] + 2*in[9]) / 5;
+					palette[4][0] = palette[4][1] = palette[4][2] =
+						(2*in[8] + 3*in[9]) / 5;
+					palette[5][0] = palette[5][1] = palette[5][2] =
+						(1*in[8] + 4*in[9]) / 5;
+					palette[6][0] = palette[6][1] = palette[6][2] =
+						0;
+					palette[7][0] = palette[7][1] = palette[7][2] =
+						255;
+				}
+				break;
+			default:
+				ri.Error( ERR_DROP, "Uncompress of format %x not implemented\n", format );
+				break;
+			}
+
+			// setup alpha palette
+			switch( format ) {
+			case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+			case GL_COMPRESSED_LUMINANCE_LATC1_EXT:
+				alphasize = 0;
+				break;
+			case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
+				palette[0][3] = 0x00;
+				palette[1][3] = 0x11;
+				palette[2][3] = 0x22;
+				palette[3][3] = 0x33;
+				palette[4][3] = 0x44;
+				palette[5][3] = 0x55;
+				palette[6][3] = 0x66;
+				palette[7][3] = 0x77;
+				palette[8][3] = 0x88;
+				palette[9][3] = 0x99;
+				palette[10][3] = 0xaa;
+				palette[11][3] = 0xbb;
+				palette[12][3] = 0xcc;
+				palette[13][3] = 0xdd;
+				palette[14][3] = 0xee;
+				palette[15][3] = 0xff;
+				
+				alphasize = 4; alphamask = 0x0f;
+				alphabits0 = in[8] + (in[9] << 8) + (in[10] << 16) + (in[11] << 24);
+				alphabits1 = in[12] + (in[13] << 8) + (in[14] << 16) + (in[15] << 24);
+				break;
+			case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
+			case GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:
+				palette[0][3] = in[8];
+				palette[1][3] = in[9];
+				if( in[8] > in[9] ) {
+					palette[2][3] = (6*in[8] + 1*in[9]) / 7;
+					palette[3][3] = (5*in[8] + 2*in[9]) / 7;
+					palette[4][3] = (4*in[8] + 3*in[9]) / 7;
+					palette[5][3] = (3*in[8] + 4*in[9]) / 7;
+					palette[6][3] = (2*in[8] + 5*in[9]) / 7;
+					palette[7][3] = (1*in[8] + 6*in[9]) / 7;
+				} else {
+					palette[2][3] = (4*in[8] + 1*in[9]) / 5;
+					palette[3][3] = (3*in[8] + 2*in[9]) / 5;
+					palette[4][3] = (2*in[8] + 3*in[9]) / 5;
+					palette[5][3] = (1*in[8] + 4*in[9]) / 5;
+					palette[6][3] = 0;
+					palette[7][3] = 255;
+				}
+				
+				alphasize = 3; alphamask = 0x07;
+				alphabits0 = in[10] + (in[11] << 8) + (in[12] << 16);
+				alphabits1 = in[13] + (in[14] << 8) + (in[15] << 16);
+				break;
+			}
+
+			// decode 16 pixels
+#define decodePixel(xoff, yoff, wordidx)				\
+			if( (xoff == 0 || x + xoff < width) && (yoff == 0 || y + yoff < height) ) { \
+				int off = 4*(xoff + row * yoff);	\
+				out[off+0] = palette[colorbits##wordidx & 0x07][0]; \
+				out[off+1] = palette[colorbits##wordidx & 0x07][1]; \
+				out[off+2] = palette[colorbits##wordidx & 0x07][2]; \
+				if( alphasize ) {			\
+					out[off+3] = palette[alphabits##wordidx & alphamask][3]; \
+				} else {				\
+					out[off+3] = palette[colorbits##wordidx & 0x07][3]; \
+				}					\
+			}						\
+			alphabits##wordidx >>= alphasize;		\
+			colorbits##wordidx >>= 3;
+			
+			decodePixel( 0, 0, 0 );
+			decodePixel( 0, 1, 0 );
+			decodePixel( 0, 2, 0 );
+			decodePixel( 0, 3, 0 );
+			decodePixel( 1, 0, 0 );
+			decodePixel( 1, 1, 0 );
+			decodePixel( 1, 2, 0 );
+			decodePixel( 1, 3, 0 );
+			decodePixel( 2, 0, 1 );
+			decodePixel( 2, 1, 1 );
+			decodePixel( 2, 2, 1 );
+			decodePixel( 2, 3, 1 );
+			decodePixel( 3, 0, 1 );
+			decodePixel( 3, 1, 1 );
+			decodePixel( 3, 2, 1 );
+			decodePixel( 3, 3, 1 );
+#undef decodePixel			
+			out += 4*(width - x > 4 ? 4 : width - x);
+		}
+		out += 3*row;
+	}
+}
+
 /*
 ===============
 Upload32
 
+Upload a color texture with all required mipmaps
 ===============
 */
-extern qboolean charSet;
-static void Upload32( unsigned *data, 
-						  int width, int height, 
-						  qboolean mipmap, 
-						  qboolean picmip, 
-							qboolean lightMap,
-						  int *format, 
-						  int *pUploadWidth, int *pUploadHeight )
+static void Upload32( texImage_t *pic,
+		      int width, int height, 
+		      qboolean mipmap, 
+		      qboolean picmip, 
+		      qboolean lightMap,
+		      int *format, 
+		      int *pUploadWidth, int *pUploadHeight,
+		      qboolean *hasAlpha, int *maxMipLevel )
 {
-	int			samples;
-	unsigned	*scaledBuffer = NULL;
-	unsigned	*resampledBuffer = NULL;
-	int			scaled_width, scaled_height;
-	int			i, c;
+	int		base_level, max_level;
+	int		pot_width, pot_height, w, h, w2, h2;
+	qboolean	compressed = qfalse;
+	qboolean	uncompress = qfalse;
+	qboolean	rescale = qfalse;
+	qboolean	hasColor = qfalse;
+	int		samples;
+	byte		*data = pic->data[0];
+	byte		*uncompressedBuffer = NULL;
+	byte		*resampledBuffer = NULL;
+	int		i, c;
 	byte		*scan;
 	GLenum		internalFormat = GL_RGB;
-	float		rMax = 0, gMax = 0, bMax = 0;
 
 	//
 	// convert to exact power of 2 sizes
 	//
-	for (scaled_width = 1 ; scaled_width < width ; scaled_width<<=1)
+	for( pot_width = 1 ; pot_width < width ; pot_width<<=1)
 		;
-	for (scaled_height = 1 ; scaled_height < height ; scaled_height<<=1)
+	for( pot_height = 1 ; pot_height < height ; pot_height<<=1)
 		;
-	if ( r_roundImagesDown->integer && scaled_width > width )
-		scaled_width >>= 1;
-	if ( r_roundImagesDown->integer && scaled_height > height )
-		scaled_height >>= 1;
 
-	if ( scaled_width != width || scaled_height != height ) {
-		resampledBuffer = ri.Hunk_AllocateTempMemory( scaled_width * scaled_height * 4 );
-		ResampleTexture (data, width, height, resampledBuffer, scaled_width, scaled_height);
-		data = resampledBuffer;
-		width = scaled_width;
-		height = scaled_height;
-	}
+	if ( r_roundImagesDown->integer && pot_width > width )
+		pot_width >>= 1;
+	if ( r_roundImagesDown->integer && pot_height > height )
+		pot_height >>= 1;
 
 	//
-	// perform optional picmip operation
+	// compute mip levels
 	//
-	if ( picmip ) {
-		scaled_width >>= r_picmip->integer;
-		scaled_height >>= r_picmip->integer;
+	base_level = 0;
+	if( picmip && r_picmip->integer >= 0 )
+		base_level = r_picmip->integer;
+
+	w = width;
+	h = height;
+	max_level = 0;
+	while( w > 1 || h > 1 ) {
+		// OpenGL rounds down non-pot sizes
+		w >>= 1;
+		h >>= 1;
+		max_level++;
 	}
 
-	//
-	// clamp to minimum size
-	//
-	if (scaled_width < 1) {
-		scaled_width = 1;
+	// compressed textures require all mip levels
+	if( (compressed = IsCompressedFormat( pic->format )) ) {
+		if( !qglCompressedTexImage2DARB ) {
+			uncompress = qtrue;
+		} else if( pic->numMipmaps < max_level + 1 ) {
+			uncompress = qtrue;
+		}
 	}
-	if (scaled_height < 1) {
-		scaled_height = 1;
+
+	// find best texture format supported
+	w = width; h = height; w2 = pot_width; h2 = pot_height;
+	for( i = 0; i <= max_level; i++ ) {
+		if( i < base_level )
+			continue;
+		if( compressed && !uncompress &&
+		    TexFormatSupported( pic->format, w, h ) ) {
+			break;
+		}
+		if( TexFormatSupported( GL_RGBA8, w, h ) ) {
+			uncompress = compressed;
+			break;
+		}
+		if( TexFormatSupported( GL_RGBA8, w2, h2 ) ) {
+			uncompress = compressed;
+			rescale = qtrue;
+			break;
+		}
 	}
+	base_level = i;
+	if( !mipmap ) {
+		max_level = base_level;
+	}
 
-	//
-	// clamp to the current upper OpenGL limit
-	// scale both axis down equally so we don't have to
-	// deal with a half mip resampling
-	//
-	while ( scaled_width > glConfig.maxTextureSize
-		|| scaled_height > glConfig.maxTextureSize ) {
-		scaled_width >>= 1;
-		scaled_height >>= 1;
+	if( uncompress ) {
+		uncompressedBuffer = ri.Hunk_AllocateTempMemory( width * height * sizeof(color4ub_t) );
+		UncompressImage( pic->format, width, height,
+				 data, uncompressedBuffer );
+		data = uncompressedBuffer;
+		compressed = qfalse;
+		pic->numMipmaps = 1;
 	}
 
-	scaledBuffer = ri.Hunk_AllocateTempMemory( sizeof( unsigned ) * scaled_width * scaled_height );
+	if ( rescale ) {
+		resampledBuffer = ri.Hunk_AllocateTempMemory( pot_width * pot_height * 4 );
+		ResampleTexture (data, width, height, resampledBuffer, pot_width, pot_height);
+		data = resampledBuffer;
 
+		width = pot_width;
+		height = pot_height;
+		pic->numMipmaps = 1;
+	}
+
 	//
 	// scan the texture for each channel's max values
 	// and verify if the alpha channel is being used or not
 	//
 	c = width*height;
-	scan = ((byte *)data);
+	scan = data;
 	samples = 3;
 
-	if(lightMap)
-	{
+	if(lightMap) {
 		if(r_greyscale->integer)
 			internalFormat = GL_LUMINANCE;
 		else
 			internalFormat = GL_RGB;
-	}
-	else
-	{
+	} else if( compressed ) {
+		internalFormat = pic->format;
+		*hasAlpha = qtrue;
+	} else {
 		for ( i = 0; i < c; i++ )
 		{
-			if ( scan[i*4+0] > rMax )
-			{
-				rMax = scan[i*4+0];
+			if( scan[i*4 + 0] != scan[i*4 + 1] || scan[i*4 + 0] != scan[i*4 + 2] ) {
+				hasColor = qtrue;
+				if( samples == 4 )
+					break;
 			}
-			if ( scan[i*4+1] > gMax )
+			if( scan[i*4 + 3] != 255 ) 
 			{
-				gMax = scan[i*4+1];
-			}
-			if ( scan[i*4+2] > bMax )
-			{
-				bMax = scan[i*4+2];
-			}
-			if ( scan[i*4 + 3] != 255 ) 
-			{
 				samples = 4;
-				break;
+				if( hasColor )
+					break;
 			}
 		}
 		// select proper internal format
 		if ( samples == 3 )
 		{
-			if(r_greyscale->integer)
+			*hasAlpha = qfalse;
+			if( r_greyscale->integer || !hasColor )
 			{
 				if(r_texturebits->integer == 16)
 					internalFormat = GL_LUMINANCE8;
 				else if(r_texturebits->integer == 32)
-					internalFormat = GL_LUMINANCE16;
+					internalFormat = GL_LUMINANCE8;
 				else
 					internalFormat = GL_LUMINANCE;
 			}
@@ -628,12 +1042,13 @@
 		}
 		else if ( samples == 4 )
 		{
-			if(r_greyscale->integer)
+			*hasAlpha = qtrue;
+			if( r_greyscale->integer || !hasColor )
 			{
 				if(r_texturebits->integer == 16)
 					internalFormat = GL_LUMINANCE8_ALPHA8;
 				else if(r_texturebits->integer == 32)
-					internalFormat = GL_LUMINANCE16_ALPHA16;
+					internalFormat = GL_LUMINANCE8_ALPHA8;
 				else
 					internalFormat = GL_LUMINANCE_ALPHA;
 			}
@@ -655,69 +1070,59 @@
 		}
 	}
 
-	// copy or resample data as appropriate for first MIP level
-	if ( ( scaled_width == width ) && 
-		( scaled_height == height ) ) {
-		if (!mipmap)
-		{
-			qglTexImage2D (GL_TEXTURE_2D, 0, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
-			*pUploadWidth = scaled_width;
-			*pUploadHeight = scaled_height;
-			*format = internalFormat;
+	w = width; h = height;
 
-			goto done;
+	// there may be base_level unused levels, but we need the
+	// data for mipmapping
+	for( i = 0; i <= max_level; i++ ) {
+		if( i == 0 ) {
+			// data pointer is already set up
+		} else if( i < pic->numMipmaps ) {
+			// mipmap provided by image loader
+			data = pic->data[i];
+
+			if( w > 1 ) w >>= 1;
+			if( h > 1 ) h >>= 1;
+		} else {
+			// compute mipmaps inplace
+			R_MipMap( data, w, h );
+
+			if( w > 1 ) w >>= 1;
+			if( h > 1 ) h >>= 1;
 		}
-		Com_Memcpy (scaledBuffer, data, width*height*4);
-	}
-	else
-	{
-		// use the normal mip-mapping function to go down from here
-		while ( width > scaled_width || height > scaled_height ) {
-			R_MipMap( (byte *)data, width, height );
-			width >>= 1;
-			height >>= 1;
-			if ( width < 1 ) {
-				width = 1;
+
+		if( i >= base_level ) {
+			if( !compressed ) {
+				R_LightScaleTexture (data, w, h, !mipmap );
+				if ( r_colorMipLevels->integer ) {
+					R_BlendOverTexture( data, w * h,
+							    mipBlendColors[i - base_level] );
+				}
+				qglTexImage2D (GL_TEXTURE_2D, i - base_level,
+					       internalFormat, w, h, 0,
+					       GL_RGBA, GL_UNSIGNED_BYTE, data);
+			} else {
+				qglCompressedTexImage2DARB( GL_TEXTURE_2D, i - base_level,
+							    internalFormat, w, h, 0,
+							    pic->size[i], data );
 			}
-			if ( height < 1 ) {
-				height = 1;
-			}
 		}
-		Com_Memcpy( scaledBuffer, data, width * height * 4 );
-	}
 
-	R_LightScaleTexture (scaledBuffer, scaled_width, scaled_height, !mipmap );
+		if( i == base_level ) {
+			*pUploadWidth = w;
+			*pUploadHeight = h;
+			*format = internalFormat;
+			*maxMipLevel = max_level - base_level;
 
-	*pUploadWidth = scaled_width;
-	*pUploadHeight = scaled_height;
-	*format = internalFormat;
-
-	qglTexImage2D (GL_TEXTURE_2D, 0, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
-
-	if (mipmap)
-	{
-		int		miplevel;
-
-		miplevel = 0;
-		while (scaled_width > 1 || scaled_height > 1)
-		{
-			R_MipMap( (byte *)scaledBuffer, scaled_width, scaled_height );
-			scaled_width >>= 1;
-			scaled_height >>= 1;
-			if (scaled_width < 1)
-				scaled_width = 1;
-			if (scaled_height < 1)
-				scaled_height = 1;
-			miplevel++;
-
-			if ( r_colorMipLevels->integer ) {
-				R_BlendOverTexture( (byte *)scaledBuffer, scaled_width * scaled_height, mipBlendColors[miplevel] );
+			if( qglGenerateMipmap &&
+			    pic->numMipmaps <= base_level + 1 &&
+			    !r_colorMipLevels->integer ) {
+				// use automatic mipmap generation
+				qglGenerateMipmap( GL_TEXTURE_2D );
+				break;
 			}
-
-			qglTexImage2D (GL_TEXTURE_2D, miplevel, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
 		}
 	}
-done:
 
 	if (mipmap)
 	{
@@ -739,6 +1144,232 @@
 
 	GL_CheckErrors();
 
+	if ( resampledBuffer )
+		ri.Hunk_FreeTempMemory( resampledBuffer );
+	if( uncompressedBuffer )
+		ri.Hunk_FreeTempMemory( uncompressedBuffer );
+}
+
+
+/*
+================
+R_BuildMaxPyramid
+
+Operates in place, computes a max pyramid in the blue channel.
+================
+*/
+static ID_INLINE byte max(byte a, byte b) { return (a >= b) ? a : b; }
+static void R_BuildMaxPyramid (byte *in, int width, int height) {
+	int	i, j;
+	int	row, stepIn, stepOut;
+
+	if ( width == 1 && height == 1 ) {
+		in[2] = in[3]; // single texel is automatically max
+		return;
+	}
+
+	row = width * 4;
+
+	if ( width == 0 || height == 0 ) {
+		return;
+	}
+
+	for( i = 0; i < height; i++ )
+		for( j = 0; j < width; j++ )
+			in[i * row + j * 4 + 2] = 0;
+
+	// build first level from alpha
+	stepIn = 1;
+	stepOut = 2;
+	
+	for( i = stepIn - 1; i < height; i += stepOut ) {
+		for( j=stepIn - 1; j < width; j += stepOut ) {
+			byte maximum = in[i * row + j * 4 + 3];
+			maximum = max(maximum, in[i * row + (j+stepIn) * 4 + 3]);
+			maximum = max(maximum, in[(i+stepIn) * row + j * 4 + 3]);
+			maximum = max(maximum, in[(i+stepIn) * row + (j+stepIn) * 4 + 3]);
+			in[i * row + j * 4 + 2] = maximum;
+		}
+	}
+	// build higher levels from computed max's in blue
+	stepIn = 1;
+	stepOut = 4;
+	while(stepOut <= width || stepOut <= height) {
+		for( i = 2*stepIn - 1; i < height; i += stepOut ) {
+			for( j = 2*stepIn - 1; j < width; j += stepOut ) {
+				byte maximum = in[(i-stepIn) * row + (j-stepIn) * 4 + 2];
+				maximum = max(maximum, in[(i-stepIn) * row + (j+stepIn) * 4 + 2]);
+				maximum = max(maximum, in[(i+stepIn) * row + (j-stepIn) * 4 + 2]);
+				maximum = max(maximum, in[(i+stepIn) * row + (j+stepIn) * 4 + 2]);
+				in[i * row + j * 4 + 2] = maximum;
+
+			}
+		}
+		stepIn *= 2;
+		stepOut *= 2;
+	}
+	return;
+}
+
+
+/*
+===============
+UploadHeightMap
+
+Upload a normal/height texture with all required mipmaps
+===============
+*/
+static void UploadHeightMap( texImage_t *pic,
+			     int width, int height, 
+			     qboolean picmip, 
+			     int *format, 
+			     int *pUploadWidth, int *pUploadHeight,
+			     int *maxMipLevel )
+{
+	byte		*data = pic->data[0];
+	byte		*scaledBuffer = NULL;
+	byte		*resampledBuffer = NULL;
+	int		scaled_width, scaled_height;
+	int		i, c;
+	byte		*scan;
+	GLenum		internalFormat = GL_RGB;
+	int		miplevel;
+	float		hMax = 0;
+	qboolean	skip;
+
+	//
+	// convert to exact power of 2 sizes
+	//
+	for (scaled_width = 1 ; scaled_width < width ; scaled_width<<=1)
+		;
+	for (scaled_height = 1 ; scaled_height < height ; scaled_height<<=1)
+		;
+	if ( r_roundImagesDown->integer && scaled_width > width )
+		scaled_width >>= 1;
+	if ( r_roundImagesDown->integer && scaled_height > height )
+		scaled_height >>= 1;
+
+	if ( scaled_width != width || scaled_height != height ) {
+		resampledBuffer = ri.Hunk_AllocateTempMemory( scaled_width * scaled_height * 4 );
+		ResampleTexture (data, width, height, resampledBuffer, scaled_width, scaled_height);
+		data = resampledBuffer;
+
+		width = scaled_width;
+		height = scaled_height;
+	}
+
+	//
+	// perform optional picmip operation
+	//
+	if ( picmip ) {
+		scaled_width >>= r_picmip->integer;
+		scaled_height >>= r_picmip->integer;
+	}
+
+	//
+	// clamp to minimum size
+	//
+	if (scaled_width < 1) {
+		scaled_width = 1;
+	}
+	if (scaled_height < 1) {
+		scaled_height = 1;
+	}
+
+	//
+	// clamp to the current upper OpenGL limit
+	// scale both axis down equally so we don't have to
+	// deal with a half mip resampling
+	//
+	while ( scaled_width > glConfig.maxTextureSize
+		|| scaled_height > glConfig.maxTextureSize ) {
+		scaled_width >>= 1;
+		scaled_height >>= 1;
+	}
+	// calculate maxMipLevel for this texture
+	for( i = 1, *maxMipLevel = 0; i < scaled_width || i < scaled_height;
+	     i <<= 1, (*maxMipLevel)++);
+
+	scaledBuffer = ri.Hunk_AllocateTempMemory( sizeof( unsigned ) * scaled_width * scaled_height );
+
+	// select proper internal format
+	internalFormat = GL_RGBA8;
+	skip = qfalse;
+
+	// copy or resample data as appropriate for first MIP level
+	// use the normal mip-mapping function to go down from here
+	while ( width > scaled_width || height > scaled_height ) {
+		R_MipMapHeightMap( (byte *)data, width, height );
+		width >>= 1;
+		height >>= 1;
+		if ( width < 1 ) {
+			width = 1;
+		}
+		if ( height < 1 ) {
+			height = 1;
+		}
+	}
+	Com_Memcpy( scaledBuffer, data, width * height * 4 );
+
+	//
+	// scan the texture for maximum height values and increase
+	// height values so that the maximum is 255.
+	//
+	c = scaled_width * scaled_height;
+	scan = ((byte *)scaledBuffer);
+
+	for ( i = 0; i < c; i++ )
+	{
+		if ( scan[i*4+3] > hMax ) 
+		{
+			hMax = scan[i*4+3];
+		}
+	}
+	if( hMax < 255 ) {
+		for ( i = 0; i < c; i++ )
+		{
+			scan[i*4+3] += 255 - hMax;
+		}
+	}
+
+	*pUploadWidth = scaled_width;
+	*pUploadHeight = scaled_height;
+	*format = internalFormat;
+
+	for( miplevel = 0; miplevel <= *maxMipLevel; miplevel++ ) {
+		// prepare blue channel of height map
+		switch( r_parallax->integer ) {
+		case 0:
+			break;
+		case 1:
+			break;
+		case 2:
+			// blue channel holds the max pyramid of the alpha channel
+			R_BuildMaxPyramid( (byte *)scaledBuffer, scaled_width, scaled_height );
+			break;
+		}
+		
+		qglTexImage2D (GL_TEXTURE_2D, miplevel, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
+		
+		R_MipMapHeightMap( (byte *)scaledBuffer, scaled_width, scaled_height );
+		scaled_width >>= 1;
+		scaled_height >>= 1;
+		if (scaled_width < 1)
+			scaled_width = 1;
+		if (scaled_height < 1)
+			scaled_height = 1;
+	}
+	
+	if( r_parallax->integer == 2 ) {
+		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	} else {
+		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	}
+	
+	GL_CheckErrors();
+	
 	if ( scaledBuffer != 0 )
 		ri.Hunk_FreeTempMemory( scaledBuffer );
 	if ( resampledBuffer != 0 )
@@ -753,8 +1384,8 @@
 This is the only way any image_t are created
 ================
 */
-image_t *R_CreateImage( const char *name, const byte *pic, int width, int height, 
-					   qboolean mipmap, qboolean allowPicmip, int glWrapClampMode ) {
+image_t *R_CreateImage( const char *name, texImage_t *pic, int width, int height, 
+			qboolean mipmap, qboolean allowPicmip, int glWrapClampMode ) {
 	image_t		*image;
 	qboolean	isLightmap = qfalse;
 	long		hash;
@@ -771,7 +1402,8 @@
 	}
 
 	image = tr.images[tr.numImages] = ri.Hunk_Alloc( sizeof( image_t ), h_low );
-	image->texnum = 1024 + tr.numImages;
+	qglGenTextures(1, &image->texnum);
+	//image->texnum = 1024 + tr.numImages;
 	tr.numImages++;
 
 	image->mipmap = mipmap;
@@ -790,29 +1422,38 @@
 		image->TMU = 0;
 	}
 
-	if ( qglActiveTextureARB ) {
-		GL_SelectTexture( image->TMU );
+	GL_BindTexture( image->texnum );
+
+	if( pic && pic->numMipmaps > 0 ) {
+		if( *name == '^' ) {
+			// height map
+			UploadHeightMap( pic,
+					 image->width, image->height, 
+					 allowPicmip,
+					 &image->internalFormat,
+					 &image->uploadWidth,
+					 &image->uploadHeight,
+					 &image->maxMipLevel
+				);
+			image->hasAlpha = qtrue;
+		} else {
+			Upload32( pic,
+				  image->width, image->height, 
+				  image->mipmap,
+				  allowPicmip,
+				  isLightmap,
+				  &image->internalFormat,
+				  &image->uploadWidth,
+				  &image->uploadHeight,
+				  &image->hasAlpha,
+				  &image->maxMipLevel
+				);
+		}
 	}
 
-	GL_Bind(image);
-
-	Upload32( (unsigned *)pic, image->width, image->height, 
-								image->mipmap,
-								allowPicmip,
-								isLightmap,
-								&image->internalFormat,
-								&image->uploadWidth,
-								&image->uploadHeight );
-
 	qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, glWrapClampMode );
 	qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, glWrapClampMode );
 
-	qglBindTexture( GL_TEXTURE_2D, 0 );
-
-	if ( image->TMU == 1 ) {
-		GL_SelectTexture( 0 );
-	}
-
 	hash = generateHashValue(name);
 	image->next = hashTable[hash];
 	hashTable[hash] = image;
@@ -825,13 +1466,14 @@
 typedef struct
 {
 	char *ext;
-	void (*ImageLoader)( const char *, unsigned char **, int *, int * );
+	void (*ImageLoader)( const char *, texImage_t *, int *, int * );
 } imageExtToLoaderMap_t;
 
 // Note that the ordering indicates the order of preference used
 // when there are multiple images of different formats available
 static imageExtToLoaderMap_t imageLoaders[ ] =
 {
+	{ "dds",  R_LoadDDS },
 	{ "tga",  R_LoadTGA },
 	{ "jpg",  R_LoadJPG },
 	{ "jpeg", R_LoadJPG },
@@ -851,14 +1493,14 @@
 32 bit format.
 =================
 */
-void R_LoadImage( const char *name, byte **pic, int *width, int *height )
+void R_LoadImage( const char *name, texImage_t *pic, int *width, int *height )
 {
 	qboolean orgNameFailed = qfalse;
 	int i;
 	char localName[ MAX_QPATH ];
 	const char *ext;
 
-	*pic = NULL;
+	pic->numMipmaps = 0;
 	*width = 0;
 	*height = 0;
 
@@ -882,7 +1524,7 @@
 		// A loader was found
 		if( i < numImageLoaders )
 		{
-			if( *pic == NULL )
+			if( pic->numMipmaps == 0 )
 			{
 				// Loader failed, most likely because the file isn't there;
 				// try again without the extension
@@ -906,7 +1548,7 @@
 		// Load
 		imageLoaders[ i ].ImageLoader( altName, pic, width, height );
 
-		if( *pic )
+		if( pic->numMipmaps > 0 )
 		{
 			if( orgNameFailed )
 			{
@@ -931,7 +1573,7 @@
 image_t	*R_FindImageFile( const char *name, qboolean mipmap, qboolean allowPicmip, int glWrapClampMode ) {
 	image_t	*image;
 	int		width, height;
-	byte	*pic;
+	texImage_t	pic;
 	long	hash;
 
 	if (!name) {
@@ -965,16 +1607,142 @@
 	// load the pic from disk
 	//
 	R_LoadImage( name, &pic, &width, &height );
-	if ( pic == NULL ) {
+	if ( pic.numMipmaps == 0 ) {
 		return NULL;
 	}
 
-	image = R_CreateImage( ( char * ) name, pic, width, height, mipmap, allowPicmip, glWrapClampMode );
-	ri.Free( pic );
+	image = R_CreateImage( ( char * ) name, &pic, width, height, mipmap, allowPicmip, glWrapClampMode );
+	ri.Free( pic.data[0] );
 	return image;
 }
 
+/*
+===============
+R_FindHeightMapFile
 
+Finds or loads the given height map file.
+Returns NULL if it fails, not a default image.
+==============
+*/
+image_t	*R_FindHeightMapFile( const char *name, qboolean mipmap, int glWrapClampMode ) {
+	image_t	*image;
+	int		width, height;
+	texImage_t	pic;
+	long	hash;
+	char localName[ MAX_QPATH ];
+
+	if (!name) {
+		return NULL;
+	}
+
+	localName[0] = '^';
+	strcpy( localName+1, name );
+
+	hash = generateHashValue( localName );
+
+	//
+	// see if the image is already loaded
+	//
+	for (image=hashTable[hash]; image; image=image->next) {
+		if ( !strcmp( name, image->imgName ) ) {
+			// the white image can be used with any set of parms, but other mismatches are errors
+			if ( strcmp( name, "*white" ) ) {
+				if ( image->mipmap != mipmap ) {
+					ri.Printf( PRINT_DEVELOPER, "WARNING: reused image %s with mixed mipmap parm\n", name );
+				}
+				if ( image->allowPicmip ) {
+					ri.Printf( PRINT_DEVELOPER, "WARNING: reused image %s with mixed allowPicmip parm\n", name );
+				}
+				if ( image->wrapClampMode != glWrapClampMode ) {
+					ri.Printf( PRINT_ALL, "WARNING: reused image %s with mixed glWrapClampMode parm\n", name );
+				}
+			}
+			return image;
+		}
+	}
+
+	//
+	// load the pic from disk
+	//
+	R_LoadImage( localName+1, &pic, &width, &height );
+	if ( pic.numMipmaps == 0 ) {
+		return NULL;
+	}
+
+	image = R_CreateImage( localName, &pic, width, height, mipmap, qfalse, glWrapClampMode );
+	ri.Free( pic.data[0] );
+	return image;
+}
+
+
+image_t *R_CombineImages( int num, image_t **images ) {
+	int	i, cols, width, height, lod, maxLod, xoffs;
+	byte	*data;
+	image_t	*result;
+	
+	if( num <= 1 )
+		return NULL;
+	
+	/* check that all images are compatible */
+	for( i = 1; i < num; i++ ) {
+		if( images[i]->uploadWidth    != images[0]->uploadWidth ||
+		    images[i]->uploadHeight   != images[0]->uploadHeight ||
+		    images[i]->internalFormat != images[0]->internalFormat )
+			return NULL;
+	}
+	
+	width = images[0]->uploadWidth;
+	height = images[0]->uploadHeight;
+	
+	/* Check that they fit into one texture */
+	for( cols = 1; cols < num; cols *= 2 ) {
+		if( cols * width >= glConfig.maxTextureSize )
+			break;
+	}
+	
+	/* TODO: avoid the GPU->CPU->GPU roundtrip with some render-to-texture
+	 *       magic */
+	data = ri.Hunk_AllocateTempMemory( width * height * sizeof(color4ub_t) );
+	
+	result = R_CreateImage( "*combined", NULL, cols * width,
+				height, images[0]->mipmap,
+				images[0]->allowPicmip, GL_REPEAT );
+	result->uploadWidth = cols * width;
+	result->uploadHeight = height;
+	result->internalFormat = images[0]->internalFormat;
+
+	if( !images[0]->mipmap ) {
+		maxLod = 0;
+	} else {
+		for( maxLod = 0; (1<<maxLod) < width &&
+			     (1<<maxLod) < height; maxLod++ );
+	}
+	for( lod = 0; lod <= maxLod; lod++ ) {
+		qglTexImage2D( GL_TEXTURE_2D, lod, result->internalFormat,
+			       cols * width, height,
+			       0, GL_RGBA, GL_UNSIGNED_BYTE, NULL );
+		xoffs = 0;
+		for( i = 0; i < num; i++ ) {
+			GL_BindTexture( images[i]->texnum );
+			qglGetTexImage( GL_TEXTURE_2D, lod, GL_RGBA, GL_UNSIGNED_BYTE, data );
+			GL_BindTexture( result->texnum );
+			qglTexSubImage2D( GL_TEXTURE_2D, lod, 
+					  xoffs, 0,
+					  width, height,
+					  GL_RGBA, GL_UNSIGNED_BYTE, data );
+			GL_CheckErrors();
+			
+			xoffs += width;
+		}
+		width >>= 1; height >>= 1;
+	}
+	qglTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, maxLod );
+	
+	ri.Hunk_FreeTempMemory( data );
+	
+	return result;
+}
+
 /*
 ================
 R_CreateDlightImage
@@ -984,6 +1752,7 @@
 static void R_CreateDlightImage( void ) {
 	int		x,y;
 	byte	data[DLIGHT_SIZE][DLIGHT_SIZE][4];
+	texImage_t	pic;
 	int		b;
 
 	// make a centered inverse-square falloff blob for dynamic lighting
@@ -1005,7 +1774,11 @@
 			data[y][x][3] = 255;			
 		}
 	}
-	tr.dlightImage = R_CreateImage("*dlight", (byte *)data, DLIGHT_SIZE, DLIGHT_SIZE, qfalse, qfalse, GL_CLAMP_TO_EDGE );
+	pic.format = GL_RGBA8;
+	pic.numMipmaps = 1;
+	pic.data[0] = &data[0][0][0];
+
+	tr.dlightImage = R_CreateImage("*dlight", &pic, DLIGHT_SIZE, DLIGHT_SIZE, qfalse, qfalse, GL_CLAMP_TO_EDGE );
 }
 
 
@@ -1072,6 +1845,7 @@
 #define	FOG_T	32
 static void R_CreateFogImage( void ) {
 	int		x,y;
+	texImage_t	pic;
 	byte	*data;
 	float	g;
 	float	d;
@@ -1095,7 +1869,11 @@
 	// standard openGL clamping doesn't really do what we want -- it includes
 	// the border color at the edges.  OpenGL 1.2 has clamp-to-edge, which does
 	// what we want.
-	tr.fogImage = R_CreateImage("*fog", (byte *)data, FOG_S, FOG_T, qfalse, qfalse, GL_CLAMP_TO_EDGE );
+	pic.format = GL_RGBA8;
+	pic.numMipmaps = 1;
+	pic.data[0] = data;
+
+	tr.fogImage = R_CreateImage("*fog", &pic, FOG_S, FOG_T, qfalse, qfalse, GL_CLAMP_TO_EDGE );
 	ri.Hunk_FreeTempMemory( data );
 
 	borderColor[0] = 1.0;
@@ -1115,6 +1893,7 @@
 static void R_CreateDefaultImage( void ) {
 	int		x;
 	byte	data[DEFAULT_SIZE][DEFAULT_SIZE][4];
+	texImage_t	pic;
 
 	// the default image will be a box, to allow you to see the mapping coordinates
 	Com_Memset( data, 32, sizeof( data ) );
@@ -1139,7 +1918,11 @@
 		data[x][DEFAULT_SIZE-1][2] =
 		data[x][DEFAULT_SIZE-1][3] = 255;
 	}
-	tr.defaultImage = R_CreateImage("*default", (byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, qtrue, qfalse, GL_REPEAT );
+	pic.format = GL_RGBA8;
+	pic.numMipmaps = 1;
+	pic.data[0] = &data[0][0][0];
+
+	tr.defaultImage = R_CreateImage("*default", &pic, DEFAULT_SIZE, DEFAULT_SIZE, qtrue, qfalse, GL_REPEAT );
 }
 
 /*
@@ -1150,12 +1933,17 @@
 void R_CreateBuiltinImages( void ) {
 	int		x,y;
 	byte	data[DEFAULT_SIZE][DEFAULT_SIZE][4];
+	texImage_t	pic;
 
 	R_CreateDefaultImage();
 
+	pic.format = GL_RGBA8;
+	pic.numMipmaps = 1;
+	pic.data[0] = &data[0][0][0];
+
 	// we use a solid white image instead of disabling texturing
 	Com_Memset( data, 255, sizeof( data ) );
-	tr.whiteImage = R_CreateImage("*white", (byte *)data, 8, 8, qfalse, qfalse, GL_REPEAT );
+	tr.whiteImage = R_CreateImage("*white", &pic, 8, 8, qfalse, qfalse, GL_REPEAT );
 
 	// with overbright bits active, we need an image which is some fraction of full color,
 	// for default lightmaps, etc
@@ -1168,12 +1956,12 @@
 		}
 	}
 
-	tr.identityLightImage = R_CreateImage("*identityLight", (byte *)data, 8, 8, qfalse, qfalse, GL_REPEAT );
+	tr.identityLightImage = R_CreateImage("*identityLight", &pic, 8, 8, qfalse, qfalse, GL_REPEAT );
 
 
 	for(x=0;x<32;x++) {
 		// scratchimage is usually used for cinematic drawing
-		tr.scratchImage[x] = R_CreateImage("*scratch", (byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, qfalse, qtrue, GL_CLAMP_TO_EDGE );
+		tr.scratchImage[x] = R_CreateImage("*scratch", &pic, DEFAULT_SIZE, DEFAULT_SIZE, qfalse, qtrue, GL_CLAMP_TO_EDGE );
 	}
 
 	R_CreateDlightImage();
@@ -1296,14 +2084,7 @@
 	tr.numImages = 0;
 
 	Com_Memset( glState.currenttextures, 0, sizeof( glState.currenttextures ) );
-	if ( qglActiveTextureARB ) {
-		GL_SelectTexture( 1 );
-		qglBindTexture( GL_TEXTURE_2D, 0 );
-		GL_SelectTexture( 0 );
-		qglBindTexture( GL_TEXTURE_2D, 0 );
-	} else {
-		qglBindTexture( GL_TEXTURE_2D, 0 );
-	}
+	GL_UnbindAllTextures( );
 }
 
 /*
@@ -1412,7 +2193,7 @@
 
 	if (len == MAX_TOKEN_CHARS)
 	{
-//		Com_Printf ("Token exceeded %i chars, discarded.\n", MAX_TOKEN_CHARS);
+//		ri.Printf (PRINT_WARNING, "Token exceeded %i chars, discarded.\n", MAX_TOKEN_CHARS);
 		len = 0;
 	}
 	com_token[len] = 0;
@@ -1441,12 +2222,12 @@
 	char		surfName[MAX_QPATH];
 
 	if ( !name || !name[0] ) {
-		Com_Printf( "Empty name passed to RE_RegisterSkin\n" );
+		ri.Printf( PRINT_WARNING, "Empty name passed to RE_RegisterSkin\n" );
 		return 0;
 	}
 
 	if ( strlen( name ) >= MAX_QPATH ) {
-		Com_Printf( "Skin name exceeds MAX_QPATH\n" );
+		ri.Printf( PRINT_WARNING, "Skin name exceeds MAX_QPATH\n" );
 		return 0;
 	}
 
@@ -1480,12 +2261,12 @@
 	if ( strcmp( name + strlen( name ) - 5, ".skin" ) ) {
 		skin->numSurfaces = 1;
 		skin->surfaces[0] = ri.Hunk_Alloc( sizeof(skin->surfaces[0]), h_low );
-		skin->surfaces[0]->shader = R_FindShader( name, LIGHTMAP_NONE, qtrue );
+		skin->surfaces[0]->shader = R_FindShader( name, tr.defaultMD3Shader->lightmapIndex, qtrue );
 		return hSkin;
 	}
 
 	// load and parse the skin file
-    ri.FS_ReadFile( name, &text.v );
+	ri.FS_ReadFile( name, &text.v );
 	if ( !text.c ) {
 		return 0;
 	}
@@ -1515,7 +2296,7 @@
 
 		surf = skin->surfaces[ skin->numSurfaces ] = ri.Hunk_Alloc( sizeof( *skin->surfaces[0] ), h_low );
 		Q_strncpyz( surf->name, surfName, sizeof( surf->name ) );
-		surf->shader = R_FindShader( token, LIGHTMAP_NONE, qtrue );
+		surf->shader = R_FindShader( token, tr.defaultMD3Shader->lightmapIndex, qtrue );
 		skin->numSurfaces++;
 	}
 
Index: src/renderer/qgl.h
===================================================================
--- src/renderer/qgl.h	(Revision 2062)
+++ src/renderer/qgl.h	(Arbeitskopie)
@@ -27,20 +27,330 @@
 #ifndef __QGL_H__
 #define __QGL_H__
 
+#ifndef _WIN32
+#define NO_SDL_GLEXT
+#include <SDL_opengl.h>
+#else
+#include <SDL_opengl.h>
+
+// hack alarm !
+#ifndef GL_EXT_timer_query
+#define GL_TIME_ELAPSED_EXT 0x88BF
+typedef int64_t GLint64EXT;
+typedef uint64_t GLuint64EXT;
+#endif
+
+#ifndef GL_EXT_geometry_shader4
+#define GL_GEOMETRY_SHADER_EXT 0x8DD9
+#define GL_GEOMETRY_VERTICES_OUT_EXT 0x8DDA
+#define GL_GEOMETRY_INPUT_TYPE_EXT 0x8DDB
+#define GL_GEOMETRY_OUTPUT_TYPE_EXT 0x8DDC
+#endif
+
+#ifndef GL_EXT_texture_compression_latc
+#define GL_COMPRESSED_LUMINANCE_LATC1_EXT 0x8C70
+#define GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT 0x8C72
+#endif
+
+#ifndef GL_ARB_debug_output
+typedef void (APIENTRYP *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,GLvoid *userParam);
+#define GL_DEBUG_LOGGED_MESSAGES_ARB 0x9145
+#define GL_DEBUG_SEVERITY_HIGH_ARB 0x9146
+#define GL_DEBUG_SEVERITY_MEDIUM_ARB 0x9147
+#define GL_DEBUG_SEVERITY_LOW_ARB 0x9148
+#define GL_DEBUG_SOURCE_APPLICATION_ARB 0x824A
+#define GL_DEBUG_TYPE_OTHER_ARB 0x8251
+#endif
+
+#ifndef GL_AMD_debug_output
+typedef void (APIENTRYP *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,GLvoid *userParam);
+#define GL_DEBUG_LOGGED_MESSAGES_AMD 0x9145
+#define GL_DEBUG_SEVERITY_HIGH_AMD 0x9146
+#define GL_DEBUG_SEVERITY_MEDIUM_AMD 0x9147
+#define GL_DEBUG_SEVERITY_LOW_AMD 0x9148
+#define GL_DEBUG_CATEGORY_APPLICATION_AMD 0x914f
+#endif
+
+#ifndef WGL_ARB_create_context_profile
+#define WGL_CONTEXT_FLAGS_ARB 0x2094
+#define WGL_CONTEXT_DEBUG_BIT_ARB 0x0001
+#endif
+#endif
+
 #ifdef USE_LOCAL_HEADERS
 #	include "SDL_opengl.h"
 #else
 #	include <SDL_opengl.h>
 #endif
 
+// GL_EXT_draw_range_elements
+extern void (APIENTRYP qglDrawRangeElementsEXT) (GLenum mode, GLsizei count, GLuint start, GLuint end, GLenum type, const GLvoid *indices);
+
 extern void (APIENTRYP qglActiveTextureARB) (GLenum texture);
 extern void (APIENTRYP qglClientActiveTextureARB) (GLenum texture);
 extern void (APIENTRYP qglMultiTexCoord2fARB) (GLenum target, GLfloat s, GLfloat t);
+extern void (APIENTRYP qglMultiTexCoord4fvARB) (GLenum target, GLfloat *v);
 
 extern void (APIENTRYP qglLockArraysEXT) (GLint first, GLsizei count);
 extern void (APIENTRYP qglUnlockArraysEXT) (void);
 
+// GL_ARB_texture_compression
+extern void (APIENTRYP qglCompressedTexImage3DARB) (GLenum target, GLint level,
+						    GLenum internalformat, GLsizei width,
+						    GLsizei height, GLsizei depth,
+						    GLint border, GLsizei imageSize,
+						    const GLvoid *data);
+extern void (APIENTRYP qglCompressedTexImage2DARB) (GLenum target, GLint level,
+						    GLenum internalformat, GLsizei width,
+						    GLsizei height, GLint border, 
+						    GLsizei imageSize, const GLvoid *data);
+extern void (APIENTRYP qglCompressedTexImage1DARB) (GLenum target, GLint level,
+						    GLenum internalformat, GLsizei width,
+						    GLint border, GLsizei imageSize,
+						    const GLvoid *data);
+extern void (APIENTRYP qglCompressedTexSubImage3DARB) (GLenum target, GLint level, 
+						       GLint xoffset, GLint yoffset,
+						       GLint zoffset, GLsizei width,
+						       GLsizei height, GLsizei depth,
+						       GLenum format, GLsizei imageSize,
+						       const GLvoid *data);
+extern void (APIENTRYP qglCompressedTexSubImage2DARB) (GLenum target, GLint level, 
+						       GLint xoffset, GLint yoffset,
+						       GLsizei width, GLsizei height,
+						       GLenum format, GLsizei imageSize,
+						       const GLvoid *data);
+extern void (APIENTRYP qglCompressedTexSubImage1DARB) (GLenum target, GLint level, 
+						       GLint xoffset, GLsizei width,
+						       GLenum format, GLsizei imageSize,
+						       const GLvoid *data);
+extern void (APIENTRYP qglGetCompressedTexImageARB) (GLenum target, GLint lod,
+						     GLvoid *img);
 
+// GL_ARB_vertex_buffer_object
+extern void (APIENTRYP qglBindBufferARB) (GLenum target, GLuint buffer);
+extern void (APIENTRYP qglDeleteBuffersARB) (GLsizei n, const GLuint *buffers);
+extern void (APIENTRYP qglGenBuffersARB) (GLsizei n, GLuint *buffers);
+extern GLboolean (APIENTRYP qglIsBufferARB) (GLuint buffer);
+extern void (APIENTRYP qglBufferDataARB) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
+extern void (APIENTRYP qglBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
+extern void (APIENTRYP qglGetBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
+extern GLvoid *(APIENTRYP qglMapBufferARB) (GLenum target, GLenum access);
+extern GLboolean (APIENTRYP qglUnmapBufferARB) (GLenum target);
+extern void (APIENTRYP qglGetBufferParameterivARB) (GLenum target, GLenum pname, GLint *params);
+extern void (APIENTRYP qglGetBufferPointervARB) (GLenum target, GLenum pname, GLvoid **params);
+
+// GL_ARB_shader_objects
+extern GLvoid (APIENTRYP qglDeleteShader) (GLuint shader);
+extern GLvoid (APIENTRYP qglDeleteProgram) (GLuint program);
+extern GLvoid (APIENTRYP qglDetachShader) (GLuint program, GLuint shader);
+extern GLuint (APIENTRYP qglCreateShader) (GLenum type);
+extern GLvoid (APIENTRYP qglShaderSource) (GLuint shader, GLsizei count, const char **string,
+					   const GLint *length);
+extern GLvoid (APIENTRYP qglCompileShader) (GLuint shader);
+extern GLuint (APIENTRYP qglCreateProgram) (void);
+extern GLvoid (APIENTRYP qglAttachShader) (GLuint program, GLuint shader);
+extern GLvoid (APIENTRYP qglLinkProgram) (GLuint program);
+extern GLvoid (APIENTRYP qglUseProgram) (GLuint program);
+extern GLvoid (APIENTRYP qglValidateProgram) (GLuint program);
+extern GLvoid (APIENTRYP qglUniform1f) (GLint location, GLfloat v0);
+extern GLvoid (APIENTRYP qglUniform2f) (GLint location, GLfloat v0, GLfloat v1);
+extern GLvoid (APIENTRYP qglUniform3f) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+extern GLvoid (APIENTRYP qglUniform4f) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+extern GLvoid (APIENTRYP qglUniform1i) (GLint location, GLint v0);
+extern GLvoid (APIENTRYP qglUniform2i) (GLint location, GLint v0, GLint v1);
+extern GLvoid (APIENTRYP qglUniform3i) (GLint location, GLint v0, GLint v1, GLint v2);
+extern GLvoid (APIENTRYP qglUniform4i) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+extern GLvoid (APIENTRYP qglUniform1fv) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniform2fv) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniform3fv) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniform4fv) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniform1iv) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRYP qglUniform2iv) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRYP qglUniform3iv) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRYP qglUniform4iv) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRYP qglUniformMatrix2fv) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniformMatrix3fv) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniformMatrix4fv) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+extern GLvoid (APIENTRYP qglGetShaderiv) (GLuint shader, GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglGetProgramiv) (GLuint program, GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglGetShaderInfoLog) (GLuint shader, GLsizei maxLength, GLsizei *length, char *infoLog);
+extern GLvoid (APIENTRYP qglGetProgramInfoLog) (GLuint program, GLsizei maxLength, GLsizei *length, char *infoLog);
+extern GLvoid (APIENTRYP qglGetAttachedShaders) (GLuint program, GLsizei maxCount, GLsizei *count,
+						 GLuint *shaders);
+extern GLint (APIENTRYP qglGetUniformLocation) (GLuint program, const char *name);
+extern GLvoid (APIENTRYP qglGetActiveUniform) (GLuint program, GLuint index, GLsizei maxLength,
+					       GLsizei *length, GLint *size, GLenum *type, char *name);
+extern GLvoid (APIENTRYP qglGetUniformfv) (GLuint program, GLint location, GLfloat *params);
+extern GLvoid (APIENTRYP qglGetUniformiv) (GLuint program, GLint location, GLint *params);
+extern GLvoid (APIENTRYP qglGetShaderSource) (GLuint shader, GLsizei maxLength, GLsizei *length,
+					      char *source);
+
+// GL_ARB_vertex_shader
+extern GLvoid (APIENTRYP qglVertexAttrib1fARB) (GLuint index, GLfloat v0);
+extern GLvoid (APIENTRYP qglVertexAttrib1sARB) (GLuint index, GLshort v0);
+extern GLvoid (APIENTRYP qglVertexAttrib1dARB) (GLuint index, GLdouble v0);
+extern GLvoid (APIENTRYP qglVertexAttrib2fARB) (GLuint index, GLfloat v0, GLfloat v1);
+extern GLvoid (APIENTRYP qglVertexAttrib2sARB) (GLuint index, GLshort v0, GLshort v1);
+extern GLvoid (APIENTRYP qglVertexAttrib2dARB) (GLuint index, GLdouble v0, GLdouble v1);
+extern GLvoid (APIENTRYP qglVertexAttrib3fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);
+extern GLvoid (APIENTRYP qglVertexAttrib3sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2);
+extern GLvoid (APIENTRYP qglVertexAttrib3dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
+extern GLvoid (APIENTRYP qglVertexAttrib4fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+extern GLvoid (APIENTRYP qglVertexAttrib4sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);
+extern GLvoid (APIENTRYP qglVertexAttrib4dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
+extern GLvoid (APIENTRYP qglVertexAttrib4NubARB) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+extern GLvoid (APIENTRYP qglVertexAttrib1fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRYP qglVertexAttrib1svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib1dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRYP qglVertexAttrib2fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRYP qglVertexAttrib2svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib2dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRYP qglVertexAttrib3fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRYP qglVertexAttrib3svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib3dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4ivARB) (GLuint index, GLint *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4bvARB) (GLuint index, GLbyte *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4ubvARB) (GLuint index, GLubyte *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4usvARB) (GLuint index, GLushort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4uivARB) (GLuint index, GLuint *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NbvARB) (GLuint index, const GLbyte *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NsvARB) (GLuint index, const GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NivARB) (GLuint index, const GLint *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NubvARB) (GLuint index, const GLubyte *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NusvARB) (GLuint index, const GLushort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NuivARB) (GLuint index, const GLuint *v);
+extern GLvoid (APIENTRYP qglVertexAttribPointerARB) (GLuint index, GLint size, GLenum type, GLboolean normalized,
+						     GLsizei stride, const GLvoid *pointer);
+extern GLvoid (APIENTRYP qglEnableVertexAttribArrayARB) (GLuint index);
+extern GLvoid (APIENTRYP qglDisableVertexAttribArrayARB) (GLuint index);
+extern GLvoid (APIENTRYP qglBindAttribLocationARB) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
+extern GLvoid (APIENTRYP qglGetActiveAttribARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
+						 GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+extern GLint (APIENTRYP qglGetAttribLocationARB) (GLhandleARB programObj, const GLcharARB *name);
+extern GLvoid (APIENTRYP qglGetVertexAttribdvARB) (GLuint index, GLenum pname, GLdouble *params);
+extern GLvoid (APIENTRYP qglGetVertexAttribfvARB) (GLuint index, GLenum pname, GLfloat *params);
+extern GLvoid (APIENTRYP qglGetVertexAttribivARB) (GLuint index, GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglGetVertexAttribPointervARB) (GLuint index, GLenum pname, GLvoid **pointer);
+
+// GL_EXT_geometry_shader4
+extern GLvoid (APIENTRYP qglProgramParameteriEXT) (GLuint program, GLenum pname, GLint value);
+extern GLvoid (APIENTRYP qglFramebufferTextureEXT) (GLenum target, GLenum attachment,
+						    GLuint texture, GLint level);
+extern GLvoid (APIENTRYP qglFramebufferTextureLayerEXT) (GLenum target, GLenum attachment,
+							 GLuint texture, GLint level, GLint layer);
+extern GLvoid (APIENTRYP qglFramebufferTextureFaceEXT) (GLenum target, GLenum attachment,
+							GLuint texture, GLint level, GLenum face);
+
+// GL_EXT_texture3D
+extern GLvoid (APIENTRYP qglTexImage3DEXT) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+
+// GL_ARB_framebuffer_object
+extern GLboolean (APIENTRYP qglIsRenderbuffer) (GLuint renderbuffer);
+extern GLvoid (APIENTRYP qglBindRenderbuffer) (GLenum target, GLuint renderbuffer);
+extern GLvoid (APIENTRYP qglDeleteRenderbuffers) (GLsizei n, const GLuint *renderbuffers);
+extern GLvoid (APIENTRYP qglGenRenderbuffers) (GLsizei n, GLuint *renderbuffers);
+extern GLvoid (APIENTRYP qglRenderbufferStorage) (GLenum target, GLenum internalformat,
+						  GLsizei width, GLsizei height);
+extern GLvoid (APIENTRYP qglRenderbufferStorageMultisample) (GLenum target, GLsizei samples,
+							     GLenum internalformat,
+							     GLsizei width, GLsizei height);
+extern GLvoid (APIENTRYP qglGetRenderbufferParameteriv) (GLenum target, GLenum pname, GLint *params);
+extern GLboolean (APIENTRYP qglIsFramebuffer) (GLuint framebuffer);
+extern GLvoid (APIENTRYP qglBindFramebuffer) (GLenum target, GLuint framebuffer);
+extern GLvoid (APIENTRYP qglDeleteFramebuffers) (GLsizei n, const GLuint *framebuffers);
+extern GLvoid (APIENTRYP qglGenFramebuffers) (GLsizei n, GLuint *framebuffers);
+extern GLenum (APIENTRYP qglCheckFramebufferStatus) (GLenum target);
+extern GLvoid (APIENTRYP qglFramebufferTexture1D) (GLenum target, GLenum attachment,
+						   GLenum textarget, GLuint texture, GLint level);
+extern GLvoid (APIENTRYP qglFramebufferTexture2D) (GLenum target, GLenum attachment,
+						   GLenum textarget, GLuint texture, GLint level);
+extern GLvoid (APIENTRYP qglFramebufferTexture3D) (GLenum target, GLenum attachment,
+						   GLenum textarget, GLuint texture,
+						   GLint level, GLint layer);
+extern GLvoid (APIENTRYP qglFramebufferTextureLayer) (GLenum target, GLenum attachment,
+						      GLuint texture, GLint level, GLint layer);
+extern GLvoid (APIENTRYP qglFramebufferRenderbuffer) (GLenum target, GLenum attachment,
+						      GLenum renderbuffertarget, GLuint renderbuffer);
+extern GLvoid (APIENTRYP qglGetFramebufferAttachmentParameteriv) (GLenum target, GLenum attachment,
+								  GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglBlitFramebuffer) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
+					      GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
+					      GLbitfield mask, GLenum filter);
+extern GLvoid (APIENTRYP qglGenerateMipmap) (GLenum target);
+
+// GL_EXT_timer_query
+extern GLvoid (APIENTRYP qglGenQueriesARB) (GLsizei n, GLuint *ids);
+extern GLvoid (APIENTRYP qglDeleteQueriesARB) (GLsizei n, const GLuint *ids);
+extern GLboolean (APIENTRYP qglIsQueryARB) (GLuint id);
+extern GLvoid (APIENTRYP qglBeginQueryARB) (GLenum target, GLuint id);
+extern GLvoid (APIENTRYP qglEndQueryARB) (GLenum target);
+extern GLvoid (APIENTRYP qglGetQueryivARB) (GLenum target, GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglGetQueryObjectivARB) (GLuint id, GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglGetQueryObjectuivARB) (GLuint id, GLenum pname, GLuint *params);
+extern GLvoid (APIENTRYP qglGetQueryObjecti64vEXT) (GLuint id, GLenum pname, GLint64EXT *params);
+extern GLvoid (APIENTRYP qglGetQueryObjectui64vEXT) (GLuint id, GLenum pname, GLuint64EXT *params);
+
+// GL_ARB_instanced_arrays
+extern GLvoid (APIENTRYP qglVertexAttribDivisorARB) (GLuint index, GLuint divisor);
+extern GLvoid (APIENTRYP qglDrawArraysInstancedARB) (GLenum mode, GLint first, GLsizei count,
+						     GLsizei primcount);
+extern GLvoid (APIENTRYP qglDrawElementsInstancedARB) (GLenum mode, GLsizei count, GLenum type,
+						       const GLvoid *indices, GLsizei primcount);
+
+// GL_ARB_separate_stencil, does not really exists, part of 2.0
+extern GLvoid (APIENTRYP qglStencilOpSeparate) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
+extern GLvoid (APIENTRYP qglStencilFuncSeparate) (GLenum face, GLenum func, GLint ref, GLuint mask);
+extern GLvoid (APIENTRYP qglStencilMaskSeparate) (GLenum face, GLuint mask);
+
+// GL_ARB_debug_output, not part of core
+extern GLvoid (APIENTRYP qglDebugMessageControlARB) (GLenum source,
+						     GLenum type,
+						     GLenum severity,
+						     GLsizei count,
+						     const GLuint* ids,
+						     GLboolean enabled);
+extern GLvoid (APIENTRYP qglDebugMessageInsertARB) (GLenum source,
+						    GLenum type,
+						    GLuint id,
+						    GLenum severity,
+						    GLsizei length, 
+						    const GLchar* buf);
+extern GLvoid (APIENTRYP qglDebugMessageCallbackARB) (GLDEBUGPROCARB callback,
+						      GLvoid *userParam);
+extern GLuint (APIENTRYP qglGetDebugMessageLogARB) (GLuint count,
+						    GLsizei bufsize,
+						    GLenum *sources,
+						    GLenum *types,
+						    GLuint *ids,
+						    GLenum *severities,
+						    GLsizei *lengths, 
+						    GLchar *messageLog);
+// GL_AMD_debug_output, predecessor to GL_ARB_debug_output, but has only
+// a category parameter instead of source and type
+extern GLvoid (APIENTRYP qglDebugMessageEnableAMD) (GLenum category,
+						    GLenum severity,
+						    GLsizei count,
+						    const GLuint* ids,
+						    GLboolean enabled);
+extern GLvoid (APIENTRYP qglDebugMessageInsertAMD) (GLenum category,
+						    GLuint id,
+						    GLenum severity,
+						    GLsizei length, 
+						    const GLchar* buf);
+extern GLvoid (APIENTRYP qglDebugMessageCallbackAMD) (GLDEBUGPROCAMD callback,
+						      GLvoid *userParam);
+extern GLuint (APIENTRYP qglGetDebugMessageLogAMD) (GLuint count,
+						    GLsizei bufsize,
+						    GLenum *categories,
+						    GLuint *ids,
+						    GLenum *severities,
+						    GLsizei *lengths, 
+						    GLchar *messageLog);
+
+
 //===========================================================================
 
 #define qglAccum glAccum
Index: src/renderer/tr_public.h
===================================================================
--- src/renderer/tr_public.h	(Revision 2062)
+++ src/renderer/tr_public.h	(Arbeitskopie)
@@ -82,7 +82,7 @@
 	void	(*BeginFrame)( stereoFrame_t stereoFrame );
 
 	// if the pointers are not NULL, timing info will be returned
-	void	(*EndFrame)( int *frontEndMsec, int *backEndMsec );
+	void	(*EndFrame)( int *frontEndMsec, int *backEndMsec, int *GLMsec );
 
 
 	int		(*MarkFragments)( int numPoints, const vec3_t *points, const vec3_t projection,
Index: src/renderer/tr_curve.c
===================================================================
--- src/renderer/tr_curve.c	(Revision 2062)
+++ src/renderer/tr_curve.c	(Arbeitskopie)
@@ -206,7 +206,7 @@
 				count++;
 			}
 			if ( count == 0 ) {
-//printf("bad normal\n");
+//ri.Printf("bad normal\n");
 				count = 1;
 			}
 			VectorNormalize2( sum, dv->normal );
Index: src/renderer/tr_main.c
===================================================================
--- src/renderer/tr_main.c	(Revision 2062)
+++ src/renderer/tr_main.c	(Arbeitskopie)
@@ -27,6 +27,7 @@
 #include <string.h> // memcpy
 
 trGlobals_t		tr;
+glGlobals_t		glGlobals;
 
 static float	s_flipMatrix[16] = {
 	// convert from our coordinate system (looking down X)
@@ -454,6 +455,7 @@
 void R_SetupFrustum (viewParms_t *dest, float xmin, float xmax, float ymax, float zProj, float stereoSep)
 {
 	vec3_t ofsorigin;
+	vec3_t	corner[4];
 	float oppleg, adjleg, length;
 	int i;
 	
@@ -471,6 +473,13 @@
 
 		VectorScale(dest->or.axis[0], oppleg, dest->frustum[1].normal);
 		VectorMA(dest->frustum[1].normal, -adjleg, dest->or.axis[1], dest->frustum[1].normal);
+		
+		VectorScale(dest->or.axis[0], zProj, corner[0]);
+		VectorCopy(corner[0], corner[2]);
+		VectorMA(corner[0], xmax, dest->or.axis[1], corner[0]);
+		VectorCopy(corner[0], corner[1]);
+		VectorMA(corner[2], xmin, dest->or.axis[1], corner[2]);
+		VectorCopy(corner[2], corner[3]);
 	}
 	else
 	{
@@ -483,10 +492,18 @@
 		VectorScale(dest->or.axis[0], oppleg / length, dest->frustum[0].normal);
 		VectorMA(dest->frustum[0].normal, zProj / length, dest->or.axis[1], dest->frustum[0].normal);
 
+		VectorScale(dest->or.axis[0], zProj, corner[0]);
+		VectorCopy(corner[0], corner[2]);
+		VectorMA(corner[0], oppleg, dest->or.axis[1], corner[0]);
+		VectorCopy(corner[0], corner[1]);
+
 		oppleg = xmin + stereoSep;
 		length = sqrt(oppleg * oppleg + zProj * zProj);
 		VectorScale(dest->or.axis[0], -oppleg / length, dest->frustum[1].normal);
 		VectorMA(dest->frustum[1].normal, -zProj / length, dest->or.axis[1], dest->frustum[1].normal);
+
+		VectorMA(corner[2], oppleg, dest->or.axis[1], corner[2]);
+		VectorCopy(corner[2], corner[3]);
 	}
 
 	length = sqrt(ymax * ymax + zProj * zProj);
@@ -498,12 +515,100 @@
 
 	VectorScale(dest->or.axis[0], oppleg, dest->frustum[3].normal);
 	VectorMA(dest->frustum[3].normal, -adjleg, dest->or.axis[2], dest->frustum[3].normal);
+
+	VectorMA(corner[0], ymax, dest->or.axis[2], corner[0]);
+	VectorMA(corner[1], -ymax, dest->or.axis[2], corner[1]);
+	VectorMA(corner[2], ymax, dest->or.axis[2], corner[2]);
+	VectorMA(corner[3], -ymax, dest->or.axis[2], corner[3]);
 	
 	for (i=0 ; i<4 ; i++) {
 		dest->frustum[i].type = PLANE_NON_AXIAL;
 		dest->frustum[i].dist = DotProduct (ofsorigin, dest->frustum[i].normal);
 		SetPlaneSignbits( &dest->frustum[i] );
 	}
+	
+	if ( r_nocull->integer ) {
+		dest->frustPlanes = 0;
+		dest->frustType = 0;
+	} else if ( qglBindBufferARB && tr.clusters ) {
+		// Find main view direction and try to clip the opposite
+		// side. The distance is not known, it is added in
+		// R_AddWorldSurfaces.
+
+		if ( corner[0][0] >= 0 && corner[1][0] >= 0 &&
+		     corner[2][0] >= 0 && corner[3][0] >= 0 ) {
+			dest->frustum[4].type = PLANE_NON_AXIAL;
+			dest->frustum[4].normal[0] = 1.0f;
+			dest->frustum[4].normal[1] = 0.0f;
+			dest->frustum[4].normal[2] = 0.0f;
+
+			SetPlaneSignbits( &dest->frustum[4] );
+			
+			dest->frustPlanes = 31;
+			dest->frustType = 1;
+		} else if ( corner[0][0] <= 0 && corner[1][0] <= 0 &&
+			    corner[2][0] <= 0 && corner[3][0] <= 0 ) {
+			dest->frustum[4].type = PLANE_NON_AXIAL;
+			dest->frustum[4].normal[0] = -1.0f;
+			dest->frustum[4].normal[1] = 0.0f;
+			dest->frustum[4].normal[2] = 0.0f;
+
+			SetPlaneSignbits( &dest->frustum[4] );
+			
+			dest->frustPlanes = 31;
+			dest->frustType = 2;
+		} else if ( corner[0][1] >= 0 && corner[1][1] >= 0 &&
+			    corner[2][1] >= 0 && corner[3][1] >= 0 ) {
+			dest->frustum[4].type = PLANE_NON_AXIAL;
+			dest->frustum[4].normal[0] = 0.0f;
+			dest->frustum[4].normal[1] = 1.0f;
+			dest->frustum[4].normal[2] = 0.0f;
+
+			SetPlaneSignbits( &dest->frustum[4] );
+			
+			dest->frustPlanes = 31;
+			dest->frustType = 3;
+		} else if ( corner[0][1] <= 0 && corner[1][1] <= 0 &&
+			    corner[2][1] <= 0 && corner[3][1] <= 0 ) {
+			dest->frustum[4].type = PLANE_NON_AXIAL;
+			dest->frustum[4].normal[0] = 0.0f;
+			dest->frustum[4].normal[1] = -1.0f;
+			dest->frustum[4].normal[2] = 0.0f;
+
+			SetPlaneSignbits( &dest->frustum[4] );
+			
+			dest->frustPlanes = 31;
+			dest->frustType = 4;
+		} else if ( corner[0][2] >= 0 && corner[1][2] >= 0 &&
+			    corner[2][2] >= 0 && corner[3][2] >= 0 ) {
+			dest->frustum[4].type = PLANE_NON_AXIAL;
+			dest->frustum[4].normal[0] = 0.0f;
+			dest->frustum[4].normal[1] = 0.0f;
+			dest->frustum[4].normal[2] = 1.0f;
+
+			SetPlaneSignbits( &dest->frustum[4] );
+			
+			dest->frustPlanes = 31;
+			dest->frustType = 5;
+		} else if ( corner[0][2] <= 0 && corner[1][2] <= 0 &&
+			    corner[2][2] <= 0 && corner[3][2] <= 0 ) {
+			dest->frustum[4].type = PLANE_NON_AXIAL;
+			dest->frustum[4].normal[0] = 0.0f;
+			dest->frustum[4].normal[1] = 0.0f;
+			dest->frustum[4].normal[2] = -1.0f;
+
+			SetPlaneSignbits( &dest->frustum[4] );
+			
+			dest->frustPlanes = 31;
+			dest->frustType = 6;
+		} else {
+			dest->frustPlanes = 15;
+			dest->frustType = 0;
+		}
+	} else {
+		dest->frustPlanes = 15;
+		dest->frustType = 0;
+	}
 }
 
 /*
@@ -857,7 +962,8 @@
 	int numTriangles;
 	shader_t *shader;
 	int		fogNum;
-	int dlighted;
+	int		dlighted;
+	qboolean	culled;
 	vec4_t clip, eye;
 	int i;
 	unsigned int pointOr = 0;
@@ -869,18 +975,31 @@
 
 	R_RotateForViewer();
 
-	R_DecomposeSort( drawSurf->sort, &entityNum, &shader, &fogNum, &dlighted );
+	entityNum = QSORT_ENTITYNUM( drawSurf->sort );
+	shader = tr.shaders[ drawSurf->shaderIndex ];
+	fogNum = QSORT_FOGNUM( drawSurf->sort );
+	dlighted = QSORT_DLIGHT( drawSurf->sort );
+	culled = QSORT_CULLED( drawSurf->sort );
+
+	if( culled )
+		return qtrue;	// culled by RecursiveWorldNode
+
 	RB_BeginSurface( shader, fogNum );
+	
+	tess.indexPtr.p16 = NULL;
 	rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
 
 	assert( tess.numVertexes < 128 );
 
+	RB_SetupVertexBuffer( shader, NULL );
+	rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
+
 	for ( i = 0; i < tess.numVertexes; i++ )
 	{
 		int j;
 		unsigned int pointFlags = 0;
 
-		R_TransformModelToClip( tess.xyz[i], tr.or.modelMatrix, tr.viewParms.projectionMatrix, eye, clip );
+		R_TransformModelToClip( tess.vertexPtr2[i].xyz, tr.or.modelMatrix, tr.viewParms.projectionMatrix, eye, clip );
 
 		for ( j = 0; j < 3; j++ )
 		{
@@ -900,6 +1019,7 @@
 	// trivially reject
 	if ( pointAnd )
 	{
+		RB_ClearVertexBuffer( );
 		return qtrue;
 	}
 
@@ -912,11 +1032,11 @@
 
 	for ( i = 0; i < tess.numIndexes; i += 3 )
 	{
-		vec3_t normal;
+		vec3_t normal, vertexNormal;
 		float dot;
 		float len;
 
-		VectorSubtract( tess.xyz[tess.indexes[i]], tr.viewParms.or.origin, normal );
+		VectorSubtract( tess.vertexPtr2[tess.indexPtr.p16[i]].xyz, tr.viewParms.or.origin, normal );
 
 		len = VectorLengthSquared( normal );			// lose the sqrt
 		if ( len < shortest )
@@ -924,11 +1044,13 @@
 			shortest = len;
 		}
 
-		if ( ( dot = DotProduct( normal, tess.normal[tess.indexes[i]] ) ) >= 0 )
+		VectorCopy( tess.vertexPtr3[tess.indexPtr.p16[i]].normal, vertexNormal );
+		if ( ( dot = DotProduct( normal, vertexNormal ) ) >= 0 )
 		{
 			numTriangles--;
 		}
 	}
+	RB_ClearVertexBuffer( );
 	if ( !numTriangles )
 	{
 		return qtrue;
@@ -957,13 +1079,13 @@
 ========================
 */
 qboolean R_MirrorViewBySurface (drawSurf_t *drawSurf, int entityNum) {
-	vec4_t			clipDest[128];
-	viewParms_t		newParms;
-	viewParms_t		oldParms;
+	vec4_t		clipDest[128];
+	viewParms_t	newParms;
+	viewParms_t	oldParms;
 	orientation_t	surface, camera;
 
 	// don't recursively mirror
-	if (tr.viewParms.isPortal) {
+	if ( tr.viewParms.portalLevel >= glGlobals.portalLevels ) {
 		ri.Printf( PRINT_DEVELOPER, "WARNING: recursive mirror/portal found\n" );
 		return qfalse;
 	}
@@ -978,10 +1100,20 @@
 	}
 
 	// save old viewParms so we can return to it after the mirror view
+	tr.viewParms.noShadows = qtrue;
 	oldParms = tr.viewParms;
+	oldParms.isFirst = qfalse;
 
+	tr.currentEntityNum = entityNum;
+	tr.shiftedEntityNum = entityNum << QSORT_ENTITYNUM_SHIFT;
+	R_AddDrawSurf( drawSurf->surface, tr.preparePortalShader, 0, 0, qfalse );
+	R_AddDrawSurfCmd( tr.refdef.drawSurfs + tr.refdef.numDrawSurfs - 1, 1 );
+	
+	tr.viewParms.portalLevel++;
+	
 	newParms = tr.viewParms;
-	newParms.isPortal = qtrue;
+	newParms.isFirst = qfalse;
+	newParms.noShadows = qfalse;
 	if ( !R_GetPortalOrientations( drawSurf, entityNum, &surface, &camera, 
 		newParms.pvsOrigin, &newParms.isMirror ) ) {
 		return qfalse;		// bad portal, no portalentity
@@ -1002,6 +1134,12 @@
 	R_RenderView (&newParms);
 
 	tr.viewParms = oldParms;
+	tr.currentEntityNum = entityNum;
+	tr.shiftedEntityNum = entityNum << QSORT_ENTITYNUM_SHIFT;
+	R_AddDrawSurf( drawSurf->surface, tr.finalisePortalShader, 0, 0, qfalse );
+	R_AddDrawSurfCmd( tr.refdef.drawSurfs + tr.refdef.numDrawSurfs - 1, 1 );
+	
+	tr.viewParms.noShadows = qfalse;
 
 	return qtrue;
 }
@@ -1049,53 +1187,25 @@
 
 /*
 ===============
-R_Radix
+R_SortSurfaces
+
+Sort the drawSurfs by shader, surface, entity etc.
 ===============
 */
-static ID_INLINE void R_Radix( int byte, int size, drawSurf_t *source, drawSurf_t *dest )
+static int cmpSurfaces( const void *aa, const void *bb )
 {
-  int           count[ 256 ] = { 0 };
-  int           index[ 256 ];
-  int           i;
-  unsigned char *sortKey = NULL;
-  unsigned char *end = NULL;
+  const drawSurf_t *a = aa;
+  const drawSurf_t *b = bb;
+  int diff;
 
-  sortKey = ( (unsigned char *)&source[ 0 ].sort ) + byte;
-  end = sortKey + ( size * sizeof( drawSurf_t ) );
-  for( ; sortKey < end; sortKey += sizeof( drawSurf_t ) )
-    ++count[ *sortKey ];
-
-  index[ 0 ] = 0;
-
-  for( i = 1; i < 256; ++i )
-    index[ i ] = index[ i - 1 ] + count[ i - 1 ];
-
-  sortKey = ( (unsigned char *)&source[ 0 ].sort ) + byte;
-  for( i = 0; i < size; ++i, sortKey += sizeof( drawSurf_t ) )
-    dest[ index[ *sortKey ]++ ] = source[ i ];
+  diff = a->sort - b->sort;
+  if( !diff )
+    diff = (intptr_t)a->surface - (intptr_t)b->surface;
+  return diff;
 }
-
-/*
-===============
-R_RadixSort
-
-Radix sort with 4 byte size buckets
-===============
-*/
-static void R_RadixSort( drawSurf_t *source, int size )
+static void R_SortSurfaces( drawSurf_t *source, int size )
 {
-  static drawSurf_t scratch[ MAX_DRAWSURFS ];
-#ifdef Q3_LITTLE_ENDIAN
-  R_Radix( 0, size, source, scratch );
-  R_Radix( 1, size, scratch, source );
-  R_Radix( 2, size, source, scratch );
-  R_Radix( 3, size, scratch, source );
-#else
-  R_Radix( 3, size, source, scratch );
-  R_Radix( 2, size, scratch, source );
-  R_Radix( 1, size, source, scratch );
-  R_Radix( 0, size, scratch, source );
-#endif //Q3_LITTLE_ENDIAN
+  qsort( source, size, sizeof(drawSurf_t), cmpSurfaces );
 }
 
 //==========================================================================================
@@ -1106,7 +1216,7 @@
 =================
 */
 void R_AddDrawSurf( surfaceType_t *surface, shader_t *shader, 
-				   int fogIndex, int dlightMap ) {
+		    int fogIndex, int dlightMap, qboolean culled ) {
 	int			index;
 
 	// instead of checking for overflow, we just mask the index
@@ -1115,35 +1225,22 @@
 	// the sort data is packed into a single 32 bit value so it can be
 	// compared quickly during the qsorting process
 	tr.refdef.drawSurfs[index].sort = (shader->sortedIndex << QSORT_SHADERNUM_SHIFT) 
-		| tr.shiftedEntityNum | ( fogIndex << QSORT_FOGNUM_SHIFT ) | (int)dlightMap;
+		| tr.shiftedEntityNum | ( fogIndex << QSORT_FOGNUM_SHIFT )
+		| (dlightMap << QSORT_DLIGHT_SHIFT) | (culled ? 1 : 0);
+	tr.refdef.drawSurfs[index].shaderIndex = shader->index;
 	tr.refdef.drawSurfs[index].surface = surface;
 	tr.refdef.numDrawSurfs++;
 }
 
 /*
 =================
-R_DecomposeSort
-=================
-*/
-void R_DecomposeSort( unsigned sort, int *entityNum, shader_t **shader, 
-					 int *fogNum, int *dlightMap ) {
-	*fogNum = ( sort >> QSORT_FOGNUM_SHIFT ) & 31;
-	*shader = tr.sortedShaders[ ( sort >> QSORT_SHADERNUM_SHIFT ) & (MAX_SHADERS-1) ];
-	*entityNum = ( sort >> QSORT_ENTITYNUM_SHIFT ) & 1023;
-	*dlightMap = sort & 3;
-}
-
-/*
-=================
 R_SortDrawSurfs
 =================
 */
 void R_SortDrawSurfs( drawSurf_t *drawSurfs, int numDrawSurfs ) {
 	shader_t		*shader;
-	int				fogNum;
-	int				entityNum;
-	int				dlighted;
-	int				i;
+	int			entityNum;
+	int			i;
 
 	// it is possible for some views to not have any surfaces
 	if ( numDrawSurfs < 1 ) {
@@ -1160,12 +1257,12 @@
 	}
 
 	// sort the drawsurfs by sort type, then orientation, then shader
-	R_RadixSort( drawSurfs, numDrawSurfs );
+	R_SortSurfaces( drawSurfs, numDrawSurfs );
 
 	// check for any pass through drawing, which
 	// may cause another view to be rendered first
 	for ( i = 0 ; i < numDrawSurfs ; i++ ) {
-		R_DecomposeSort( (drawSurfs+i)->sort, &entityNum, &shader, &fogNum, &dlighted );
+		shader = tr.shaders[ (drawSurfs+i)->shaderIndex ];
 
 		if ( shader->sort > SS_PORTAL ) {
 			break;
@@ -1176,15 +1273,17 @@
 			ri.Error (ERR_DROP, "Shader '%s'with sort == SS_BAD", shader->name );
 		}
 
+		entityNum = QSORT_ENTITYNUM( (drawSurfs+i)->sort );
+
 		// if the mirror was completely clipped away, we may need to check another surface
 		if ( R_MirrorViewBySurface( (drawSurfs+i), entityNum) ) {
-			// this is a debug option to see exactly what is being mirrored
-			if ( r_portalOnly->integer ) {
-				return;
-			}
-			break;		// only one mirror view at a time
+			//break;		// only one mirror view at a time
 		}
 	}
+	// this is a debug option to see exactly what is being mirrored
+	if ( r_portalOnly->integer && !tr.viewParms.portalLevel ) {
+		return;
+	}
 
 	R_AddDrawSurfCmd( drawSurfs, numDrawSurfs );
 }
@@ -1217,7 +1316,7 @@
 		// we don't want the hacked weapon position showing in 
 		// mirrors, because the true body position will already be drawn
 		//
-		if ( (ent->e.renderfx & RF_FIRST_PERSON) && tr.viewParms.isPortal) {
+		if ( (ent->e.renderfx & RF_FIRST_PERSON) && tr.viewParms.portalLevel ) {
 			continue;
 		}
 
@@ -1233,11 +1332,11 @@
 			// self blood sprites, talk balloons, etc should not be drawn in the primary
 			// view.  We can't just do this check for all entities, because md3
 			// entities may still want to cast shadows from them
-			if ( (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.isPortal) {
+			if ( (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.portalLevel ) {
 				continue;
 			}
 			shader = R_GetShaderByHandle( ent->e.customShader );
-			R_AddDrawSurf( &entitySurface, shader, R_SpriteFogNum( ent ), 0 );
+			R_AddDrawSurf( &entitySurface, shader, R_SpriteFogNum( ent ), 0, qfalse );
 			break;
 
 		case RT_MODEL:
@@ -1246,7 +1345,7 @@
 
 			tr.currentModel = R_GetModelByHandle( ent->e.hModel );
 			if (!tr.currentModel) {
-				R_AddDrawSurf( &entitySurface, tr.defaultShader, 0, 0 );
+				R_AddDrawSurf( &entitySurface, tr.defaultShader, 0, 0, qfalse );
 			} else {
 				switch ( tr.currentModel->type ) {
 				case MOD_MESH:
@@ -1260,15 +1359,18 @@
 					R_MDRAddAnimSurfaces( ent );
 					break;
 #endif
+				case MOD_IQM:
+					R_AddIQMSurfaces( ent );
+					break;
 				case MOD_BRUSH:
 					R_AddBrushModelSurfaces( ent );
 					break;
 				case MOD_BAD:		// null model axis
-					if ( (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.isPortal) {
+					if ( (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.portalLevel ) {
 						break;
 					}
 					shader = R_GetShaderByHandle( ent->e.customShader );
-					R_AddDrawSurf( &entitySurface, tr.defaultShader, 0, 0 );
+					R_AddDrawSurf( &entitySurface, tr.defaultShader, 0, 0, qfalse );
 					break;
 				default:
 					ri.Error( ERR_DROP, "R_AddEntitySurfaces: Bad modeltype" );
@@ -1315,29 +1417,29 @@
 ================
 */
 void R_DebugPolygon( int color, int numPoints, float *points ) {
-	int		i;
+	glRenderState_t	state;
 
-	GL_State( GLS_DEPTHMASK_TRUE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE );
+	InitState( &state );
 
 	// draw solid shade
+	state.stateBits = GLS_DEPTHMASK_TRUE |
+		GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE;
+	state.faceCulling = CT_FRONT_SIDED;
 
-	qglColor3f( color&1, (color>>1)&1, (color>>2)&1 );
-	qglBegin( GL_POLYGON );
-	for ( i = 0 ; i < numPoints ; i++ ) {
-		qglVertex3fv( points + i * 3 );
-	}
-	qglEnd();
+	state.numImages = 1;
+	state.image[0] = tr.whiteImage;
 
+	SetAttrVec4f( &state, AL_COLOR, color&1, (color>>1)&1,
+		      (color>>2)&1, 1.0f );
+	SetAttrPointer( &state, AL_VERTEX, 0, 3, GL_FLOAT, 0, points );
+	GL_DrawArrays( &state, GL_POLYGON, 0, numPoints );
+
 	// draw wireframe outline
-	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE );
-	qglDepthRange( 0, 0 );
-	qglColor3f( 1, 1, 1 );
-	qglBegin( GL_POLYGON );
-	for ( i = 0 ; i < numPoints ; i++ ) {
-		qglVertex3fv( points + i * 3 );
-	}
-	qglEnd();
-	qglDepthRange( 0, 1 );
+	state.stateBits = GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE |
+		GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE |
+		GLS_DEPTHRANGE_0_TO_0;
+	SetAttrVec4f( &state, AL_COLOR, 1.0f, 1.0f, 1.0f, 1.0f );
+	GL_DrawArrays( &state, GL_POLYGON, 0, numPoints );
 }
 
 /*
@@ -1355,8 +1457,6 @@
 	// the render thread can't make callbacks to the main thread
 	R_SyncRenderThread();
 
-	GL_Bind( tr.whiteImage);
-	GL_Cull( CT_FRONT_SIDED );
 	ri.CM_DrawDebugSurface( R_DebugPolygon );
 }
 
Index: src/renderer/tr_shade.c
===================================================================
--- src/renderer/tr_shade.c	(Revision 2062)
+++ src/renderer/tr_shade.c	(Arbeitskopie)
@@ -34,174 +34,9 @@
   This file deals with applying shaders to surface data in the tess struct.
 */
 
-/*
-================
-R_ArrayElementDiscrete
 
-This is just for OpenGL conformance testing, it should never be the fastest
-================
-*/
-static void APIENTRY R_ArrayElementDiscrete( GLint index ) {
-	qglColor4ubv( tess.svars.colors[ index ] );
-	if ( glState.currenttmu ) {
-		qglMultiTexCoord2fARB( 0, tess.svars.texcoords[ 0 ][ index ][0], tess.svars.texcoords[ 0 ][ index ][1] );
-		qglMultiTexCoord2fARB( 1, tess.svars.texcoords[ 1 ][ index ][0], tess.svars.texcoords[ 1 ][ index ][1] );
-	} else {
-		qglTexCoord2fv( tess.svars.texcoords[ 0 ][ index ] );
-	}
-	qglVertex3fv( tess.xyz[ index ] );
-}
 
 /*
-===================
-R_DrawStripElements
-
-===================
-*/
-static int		c_vertexes;		// for seeing how long our average strips are
-static int		c_begins;
-static void R_DrawStripElements( int numIndexes, const glIndex_t *indexes, void ( APIENTRY *element )(GLint) ) {
-	int i;
-	int last[3] = { -1, -1, -1 };
-	qboolean even;
-
-	c_begins++;
-
-	if ( numIndexes <= 0 ) {
-		return;
-	}
-
-	qglBegin( GL_TRIANGLE_STRIP );
-
-	// prime the strip
-	element( indexes[0] );
-	element( indexes[1] );
-	element( indexes[2] );
-	c_vertexes += 3;
-
-	last[0] = indexes[0];
-	last[1] = indexes[1];
-	last[2] = indexes[2];
-
-	even = qfalse;
-
-	for ( i = 3; i < numIndexes; i += 3 )
-	{
-		// odd numbered triangle in potential strip
-		if ( !even )
-		{
-			// check previous triangle to see if we're continuing a strip
-			if ( ( indexes[i+0] == last[2] ) && ( indexes[i+1] == last[1] ) )
-			{
-				element( indexes[i+2] );
-				c_vertexes++;
-				assert( indexes[i+2] < tess.numVertexes );
-				even = qtrue;
-			}
-			// otherwise we're done with this strip so finish it and start
-			// a new one
-			else
-			{
-				qglEnd();
-
-				qglBegin( GL_TRIANGLE_STRIP );
-				c_begins++;
-
-				element( indexes[i+0] );
-				element( indexes[i+1] );
-				element( indexes[i+2] );
-
-				c_vertexes += 3;
-
-				even = qfalse;
-			}
-		}
-		else
-		{
-			// check previous triangle to see if we're continuing a strip
-			if ( ( last[2] == indexes[i+1] ) && ( last[0] == indexes[i+0] ) )
-			{
-				element( indexes[i+2] );
-				c_vertexes++;
-
-				even = qfalse;
-			}
-			// otherwise we're done with this strip so finish it and start
-			// a new one
-			else
-			{
-				qglEnd();
-
-				qglBegin( GL_TRIANGLE_STRIP );
-				c_begins++;
-
-				element( indexes[i+0] );
-				element( indexes[i+1] );
-				element( indexes[i+2] );
-				c_vertexes += 3;
-
-				even = qfalse;
-			}
-		}
-
-		// cache the last three vertices
-		last[0] = indexes[i+0];
-		last[1] = indexes[i+1];
-		last[2] = indexes[i+2];
-	}
-
-	qglEnd();
-}
-
-
-
-/*
-==================
-R_DrawElements
-
-Optionally performs our own glDrawElements that looks for strip conditions
-instead of using the single glDrawElements call that may be inefficient
-without compiled vertex arrays.
-==================
-*/
-static void R_DrawElements( int numIndexes, const glIndex_t *indexes ) {
-	int		primitives;
-
-	primitives = r_primitives->integer;
-
-	// default is to use triangles if compiled vertex arrays are present
-	if ( primitives == 0 ) {
-		if ( qglLockArraysEXT ) {
-			primitives = 2;
-		} else {
-			primitives = 1;
-		}
-	}
-
-
-	if ( primitives == 2 ) {
-		qglDrawElements( GL_TRIANGLES, 
-						numIndexes,
-						GL_INDEX_TYPE,
-						indexes );
-		return;
-	}
-
-	if ( primitives == 1 ) {
-		R_DrawStripElements( numIndexes,  indexes, qglArrayElement );
-		return;
-	}
-	
-	if ( primitives == 3 ) {
-		R_DrawStripElements( numIndexes,  indexes, R_ArrayElementDiscrete );
-		return;
-	}
-
-	// anything else will cause no drawing
-}
-
-
-/*
 =============================================================
 
 SURFACE SHADERS
@@ -210,7 +45,6 @@
 */
 
 shaderCommands_t	tess;
-static qboolean	setArraysOnce;
 
 /*
 =================
@@ -218,7 +52,8 @@
 
 =================
 */
-static void R_BindAnimatedImage( textureBundle_t *bundle ) {
+static void R_GetAnimatedImage( textureBundle_t *bundle, qboolean combined,
+				image_t **pImage ) {
 	int		index;
 
 	if ( bundle->isVideoMap ) {
@@ -228,10 +63,15 @@
 	}
 
 	if ( bundle->numImageAnimations <= 1 ) {
-		GL_Bind( bundle->image[0] );
+		*pImage = bundle->image[0];
 		return;
 	}
 
+	if ( combined && bundle->combinedImage ) {
+		*pImage = bundle->combinedImage;
+		return;
+	}
+
 	// it is necessary to do this messy calc to make sure animations line up
 	// exactly with waveforms of the same frequency
 	index = myftol( tess.shaderTime * bundle->imageAnimationSpeed * FUNCTABLE_SIZE );
@@ -242,7 +82,7 @@
 	}
 	index %= bundle->numImageAnimations;
 
-	GL_Bind( bundle->image[ index ] );
+	*pImage = bundle->image[ index ];
 }
 
 /*
@@ -250,32 +90,31 @@
 DrawTris
 
 Draws triangle outlines for debugging
+This requires that all vertex pointers etc. are still bound from the StageIterator
 ================
 */
-static void DrawTris (shaderCommands_t *input) {
-	GL_Bind( tr.whiteImage );
-	qglColor3f (1,1,1);
+static void DrawTris ( glRenderState_t *state,
+		       int numIndexes, GLuint IBO, const void *indexes,
+		       GLuint start, GLuint end, GLuint max,
+		       float r, float g, float b ) {
+	state->stateBits = GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE |
+		GLS_DEPTHRANGE_0_TO_0;
 
-	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
-	qglDepthRange( 0, 0 );
+	state->numImages = 1;
+	state->image[0] = tr.whiteImage;
 
-	qglDisableClientState (GL_COLOR_ARRAY);
-	qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
-
-	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
-
-	if (qglLockArraysEXT) {
-		qglLockArraysEXT(0, input->numVertexes);
-		GLimp_LogComment( "glLockArraysEXT\n" );
+	if ( tess.currentStageIteratorFunc == RB_StageIteratorGLSL ) {
+		shader_t *shader = tr.defaultShader;
+		if( tess.dataTexture ) {
+			shader = tr.defaultMD3Shader;
+			state->numImages = 2;
+			state->image[1] = tess.dataTexture;
+		}
+		state->program = shader->GLSLprogram;
 	}
-
-	R_DrawElements( input->numIndexes, input->indexes );
-
-	if (qglUnlockArraysEXT) {
-		qglUnlockArraysEXT();
-		GLimp_LogComment( "glUnlockArraysEXT\n" );
-	}
-	qglDepthRange( 0, 1 );
+	SetAttrVec4f( state, AL_COLOR, r, g, b, 1.0f );
+	
+	GL_DrawElements( state, numIndexes, IBO, indexes, start, end, max );
 }
 
 
@@ -286,24 +125,143 @@
 Draws vertex normals for debugging
 ================
 */
-static void DrawNormals (shaderCommands_t *input) {
+static void DrawNormals ( glRenderState_t *state ) {
 	int		i;
-	vec3_t	temp;
+	vec3_t		*temp;
+	vboInfo_t	*VBO;
 
-	GL_Bind( tr.whiteImage );
-	qglColor3f (1,1,1);
-	qglDepthRange( 0, 0 );	// never occluded
-	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
+	if( backEnd.projection2D )
+		return;
 
-	qglBegin (GL_LINES);
-	for (i = 0 ; i < input->numVertexes ; i++) {
-		qglVertex3fv (input->xyz[i]);
-		VectorMA (input->xyz[i], 2, input->normal[i], temp);
-		qglVertex3fv (temp);
+	if( backEnd.normalProgram && tess.currentStageIteratorFunc == RB_StageIteratorGLSL ) {
+		for( VBO = tess.firstVBO; VBO; VBO = VBO->next ) {
+			GLuint dataVBO;
+
+			if( VBO->vbo )
+				dataVBO = VBO->vbo;
+			else
+				dataVBO = backEnd.worldVBO.vbo;
+
+			if( backEnd.currentEntity->e.reType != RT_MODEL ) {
+				SetAttrVec4f( state, AL_TRANSX,
+					      1.0f, 0.0f, 0.0f, 0.0f );
+				SetAttrVec4f( state, AL_TRANSY,
+					      0.0f, 1.0f, 0.0f, 0.0f );
+				SetAttrVec4f( state, AL_TRANSZ,
+					      0.0f, 0.0f, 1.0f, 0.0f );
+			} else {
+				SetAttrVec4f( state, AL_TRANSX,
+					      backEnd.currentEntity->e.axis[0][0],
+					      backEnd.currentEntity->e.axis[1][0],
+					      backEnd.currentEntity->e.axis[2][0],
+					      backEnd.currentEntity->e.origin[0] );
+				SetAttrVec4f( state, AL_TRANSY,
+					      backEnd.currentEntity->e.axis[0][1],
+					      backEnd.currentEntity->e.axis[1][1],
+					      backEnd.currentEntity->e.axis[2][1],
+					      backEnd.currentEntity->e.origin[1] );
+				SetAttrVec4f( state, AL_TRANSZ,
+					      backEnd.currentEntity->e.axis[0][2],
+					      backEnd.currentEntity->e.axis[1][2],
+					      backEnd.currentEntity->e.axis[2][2],
+					      backEnd.currentEntity->e.origin[2] );
+			}
+
+			if( !tess.dataTexture ) {
+				state->program = backEnd.normalProgram;
+				SetAttrPointer( state, AL_NORMAL, dataVBO,
+						3, GL_FLOAT, sizeof(vaWord3_t),
+						&VBO->offs3->normal );
+			} else {
+				state->program = backEnd.normalProgramMD3;
+				state->numImages = 1;
+				state->image[0] = tess.dataTexture;
+				SetAttrVec4f( state, AL_TIMES,
+					      tess.shaderTime,
+					      backEnd.currentEntity->e.backlerp,
+					      tess.frameOffs,
+					      tess.oldFrameOffs );
+			}
+			state->stateBits = GLS_POLYMODE_LINE |
+				GLS_DEPTHMASK_TRUE |
+				GLS_DEPTHRANGE_0_TO_0;
+			SetAttrVec4f( state, AL_COLOR, 1.0f, 1.0f, 1.0f, 1.0f );
+
+			SetAttrPointer( state, AL_VERTEX, dataVBO,
+					4, GL_FLOAT, sizeof(vaWord2_t),
+					&VBO->offs2->xyz );
+			GL_DrawArrays( state, GL_POINTS, VBO->minIndex,
+				       VBO->maxIndex - VBO->minIndex + 1 );
+		}
+
+		if( tess.numVertexes > 0 ) {
+			state->program = backEnd.normalProgram;
+			state->numImages = 0;
+			SetAttrVec4f( state, AL_COLOR, 1.0f, 1.0f, 1.0f, 1.0f );
+			state->stateBits = GLS_POLYMODE_LINE |
+				GLS_DEPTHMASK_TRUE |
+				GLS_DEPTHRANGE_0_TO_0;
+
+			if( backEnd.currentEntity->e.reType != RT_MODEL ) {
+				SetAttrVec4f( state, AL_TRANSX,
+					      1.0f, 0.0f, 0.0f, 0.0f );
+				SetAttrVec4f( state, AL_TRANSY,
+					      0.0f, 1.0f, 0.0f, 0.0f );
+				SetAttrVec4f( state, AL_TRANSZ,
+					      0.0f, 0.0f, 1.0f, 0.0f );
+			} else {
+				SetAttrVec4f( state, AL_TRANSX,
+					      backEnd.currentEntity->e.axis[0][0],
+					      backEnd.currentEntity->e.axis[1][0],
+					      backEnd.currentEntity->e.axis[2][0],
+					      backEnd.currentEntity->e.origin[0] );
+				SetAttrVec4f( state, AL_TRANSY,
+					      backEnd.currentEntity->e.axis[0][1],
+					      backEnd.currentEntity->e.axis[1][1],
+					      backEnd.currentEntity->e.axis[2][1],
+					      backEnd.currentEntity->e.origin[1] );
+				SetAttrVec4f( state, AL_TRANSZ,
+					      backEnd.currentEntity->e.axis[0][2],
+					      backEnd.currentEntity->e.axis[1][2],
+					      backEnd.currentEntity->e.axis[2][2],
+					      backEnd.currentEntity->e.origin[2] );
+			}
+
+			SetAttrPointer( state, AL_NORMAL, 0,
+					3, GL_FLOAT, sizeof(vaWord3_t),
+					&tess.vertexPtr3->normal );
+			SetAttrPointer( state, AL_VERTEX, 0,
+					4, GL_FLOAT, sizeof(vaWord2_t),
+					&tess.vertexPtr2->xyz );
+			GL_DrawArrays( state, GL_POINTS, 0, tess.numVertexes );
+		}
+	} else {
+		if( tess.numVertexes > 0 ) {
+			temp = RB_AllocScratch( tess.numVertexes * 2 * sizeof(vec3_t) );
+			state->program = NULL;
+			state->numImages = 0;
+			SetAttrVec4f( state, AL_COLOR, 1.0f, 1.0f, 1.0f, 1.0f );
+			state->stateBits = GLS_POLYMODE_LINE |
+				GLS_DEPTHMASK_TRUE |
+				GLS_DEPTHRANGE_0_TO_0;
+
+			if( tess.currentStageIteratorFunc == RB_StageIteratorGLSL )
+				qglLoadMatrixf( backEnd.or.modelMatrix );
+
+			for (i = 0 ; i < tess.numVertexes ; i++) {
+				VectorCopy( tess.vertexPtr2[i].xyz, temp[2*i] );
+				VectorMA( tess.vertexPtr2[i].xyz, 2, tess.vertexPtr3[i].normal, temp[2*i+1] );
+			}
+			SetAttrPointer( state, AL_VERTEX, 0,
+					3, GL_FLOAT, sizeof(vec3_t),
+					temp );
+			GL_DrawArrays( state, GL_LINES, 0, 2 * tess.numVertexes );
+			RB_FreeScratch( temp );
+
+			if( tess.currentStageIteratorFunc == RB_StageIteratorGLSL )
+				qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
+		}
 	}
-	qglEnd ();
-
-	qglDepthRange( 0, 1 );
 }
 
 /*
@@ -320,7 +278,10 @@
 	shader_t *state = (shader->remappedShader) ? shader->remappedShader : shader;
 
 	tess.numIndexes = 0;
+	tess.minIndex = backEnd.worldVBO.maxIndex;
+	tess.maxIndex = 0;
 	tess.numVertexes = 0;
+	tess.firstVBO = NULL;
 	tess.shader = state;
 	tess.fogNum = fogNum;
 	tess.dlightBits = 0;		// will be OR'd in by surface functions
@@ -346,52 +307,48 @@
 t1 = most downstream according to spec
 ===================
 */
-static void DrawMultitextured( shaderCommands_t *input, int stage ) {
+static void DrawMultitextured( glRenderState_t *state,
+			       shaderCommands_t *input,
+			       int stage, GLuint max ) {
 	shaderStage_t	*pStage;
+	int		bundle;
 
 	pStage = tess.xstages[stage];
 
-	GL_State( pStage->stateBits );
+	state->program = NULL;
+	state->stateBits = pStage->stateBits;
 
 	// this is an ugly hack to work around a GeForce driver
 	// bug with multitexture and clip planes
-	if ( backEnd.viewParms.isPortal ) {
+	if ( backEnd.viewParms.portalLevel ) {
 		qglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
 	}
 
 	//
 	// base
 	//
-	GL_SelectTexture( 0 );
-	qglTexCoordPointer( 2, GL_FLOAT, 0, input->svars.texcoords[0] );
-	R_BindAnimatedImage( &pStage->bundle[0] );
+	state->numImages = 1;
+	R_GetAnimatedImage( &pStage->bundle[0], qfalse, &state->image[0] );
 
 	//
-	// lightmap/secondary pass
+	// lightmap/secondary passes
 	//
-	GL_SelectTexture( 1 );
-	qglEnable( GL_TEXTURE_2D );
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+	for ( bundle = 1; bundle < glConfig.numTextureUnits; bundle++ ) {
+		if ( !pStage->bundle[bundle].multitextureEnv )
+			break;
+		
+		if ( r_lightmap->integer ) {
+			GL_TexEnv( bundle, GL_REPLACE );
+		} else {
+			GL_TexEnv( bundle, pStage->bundle[bundle].multitextureEnv );
+		}
 
-	if ( r_lightmap->integer ) {
-		GL_TexEnv( GL_REPLACE );
-	} else {
-		GL_TexEnv( tess.shader->multitextureEnv );
+		R_GetAnimatedImage( &pStage->bundle[bundle], qfalse, &state->image[bundle] );
 	}
 
-	qglTexCoordPointer( 2, GL_FLOAT, 0, input->svars.texcoords[1] );
-
-	R_BindAnimatedImage( &pStage->bundle[1] );
-
-	R_DrawElements( input->numIndexes, input->indexes );
-
-	//
-	// disable texturing on TEXTURE1, then select TEXTURE0
-	//
-	//qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
-	qglDisable( GL_TEXTURE_2D );
-
-	GL_SelectTexture( 0 );
+	state->numImages = bundle;
+	GL_DrawElements( state, input->numIndexes, 0, input->indexPtr.p16,
+			 input->minIndex, input->maxIndex, max );
 }
 
 
@@ -404,7 +361,7 @@
 ===================
 */
 #if idppc_altivec
-static void ProjectDlightTexture_altivec( void ) {
+static void ProjectDlightTexture_altivec( glRenderState_t *state ) {
 	int		i, l;
 	vec_t	origin0, origin1, origin2;
 	float   texCoords0, texCoords1;
@@ -417,22 +374,28 @@
                                                0x00, 0x00, 0x00, 0xff,
                                                0x00, 0x00, 0x00, 0xff,
                                                0x00, 0x00, 0x00, 0xff);
-	float	*texCoords;
-	byte	*colors;
-	byte	clipBits[SHADER_MAX_VERTEXES];
-	float	texCoordsArray[SHADER_MAX_VERTEXES][2];
-	byte	colorArray[SHADER_MAX_VERTEXES][4];
-	unsigned	hitIndexes[SHADER_MAX_INDEXES];
+	vec2_t	*texCoords;
+	color4ub_t	*colors;
+	byte	*clipBits;
+	vec2_t	*texCoordsArray;
+	color4ub_t	*colorArray;
+	GLushort	*hitIndexes;
 	int		numIndexes;
 	float	scale;
 	float	radius;
 	vec3_t	floatColor;
 	float	modulate = 0.0f;
 
-	if ( !backEnd.refdef.num_dlights ) {
+	if ( !backEnd.refdef.num_dlights ||
+	     tess.numVertexes > 65535 ) { // to avoid GLushort overflow
 		return;
 	}
 
+	clipBits = RB_AllocScratch( sizeof(byte) * tess.numVertexes );
+	texCoordsArray = RB_AllocScratch( sizeof(vec2_t) * tess.numVertexes );
+	colorArray = RB_AllocScratch( sizeof(color4ub_t) * tess.numVertexes );
+	hitIndexes = RB_AllocScratch( sizeof(GLushort) * tess.numIndexes );
+
 	// There has to be a better way to do this so that floatColor
 	// and/or modulate are already 16-byte aligned.
 	floatColorVecPerm = vec_lvsl(0,(float *)floatColor);
@@ -446,8 +409,8 @@
 		if ( !( tess.dlightBits & ( 1 << l ) ) ) {
 			continue;	// this surface definately doesn't have any of this light
 		}
-		texCoords = texCoordsArray[0];
-		colors = colorArray[0];
+		texCoords = texCoordsArray;
+		colors = colorArray;
 
 		dl = &backEnd.refdef.dlights[l];
 		origin0 = dl->transformed[0];
@@ -472,13 +435,13 @@
 		floatColorVec0 = vec_ld(0, floatColor);
 		floatColorVec1 = vec_ld(11, floatColor);
 		floatColorVec0 = vec_perm(floatColorVec0,floatColorVec0,floatColorVecPerm);
-		for ( i = 0 ; i < tess.numVertexes ; i++, texCoords += 2, colors += 4 ) {
+		for ( i = 0 ; i < tess.numVertexes ; i++, texCoords++, colors++ ) {
 			int		clip = 0;
 			vec_t dist0, dist1, dist2;
 			
-			dist0 = origin0 - tess.xyz[i][0];
-			dist1 = origin1 - tess.xyz[i][1];
-			dist2 = origin2 - tess.xyz[i][2];
+			dist0 = origin0 - tess.vertexPtr2[i].xyz[0];
+			dist1 = origin1 - tess.vertexPtr2[i].xyz[1];
+			dist2 = origin2 - tess.vertexPtr2[i].xyz[2];
 
 			backEnd.pc.c_dlightVertexes++;
 
@@ -486,10 +449,10 @@
 			texCoords1 = 0.5f + dist1 * scale;
 
 			if( !r_dlightBacks->integer &&
-					// dist . tess.normal[i]
-					( dist0 * tess.normal[i][0] +
-					dist1 * tess.normal[i][1] +
-					dist2 * tess.normal[i][2] ) < 0.0f ) {
+			    // dist . tess.normal[i]
+			    ( dist0 * tess.vertexPtr3[i].normal[0] +
+			      dist1 * tess.vertexPtr3[i].normal[1] +
+			      dist2 * tess.vertexPtr3[i].normal[2] ) < 0.0f ) {
 				clip = 63;
 			} else {
 				if ( texCoords0 < 0.0f ) {
@@ -502,8 +465,8 @@
 				} else if ( texCoords1 > 1.0f ) {
 					clip |= 8;
 				}
-				texCoords[0] = texCoords0;
-				texCoords[1] = texCoords1;
+				(*texCoords)[0] = texCoords0;
+				(*texCoords)[1] = texCoords1;
 
 				// modulate the strength based on the height and color
 				if ( dist2 > radius ) {
@@ -536,11 +499,11 @@
 		// build a list of triangles that need light
 		numIndexes = 0;
 		for ( i = 0 ; i < tess.numIndexes ; i += 3 ) {
-			int		a, b, c;
+			GLushort	a, b, c;
 
-			a = tess.indexes[i];
-			b = tess.indexes[i+1];
-			c = tess.indexes[i+2];
+			a = tess.indexPtr.p16[i];
+			b = tess.indexPtr.p16[i+1];
+			c = tess.indexPtr.p16[i+2];
 			if ( clipBits[a] & clipBits[b] & clipBits[c] ) {
 				continue;	// not lighted
 			}
@@ -554,56 +517,74 @@
 			continue;
 		}
 
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglTexCoordPointer( 2, GL_FLOAT, 0, texCoordsArray[0] );
+		state->program = NULL;
+		GL_VBO( 0, 0 );
+		
+		SetAttrPointer( state, AL_TEXCOORD, 0,
+				2, GL_FLOAT, sizeof(vec2_t),
+				texCoordsArray );
+		SetAttrPointer( state, AL_COLOR, 0,
+				4, GL_UNSIGNED_BYTE, sizeof(color4ub_t),
+				colorArray );
 
-		qglEnableClientState( GL_COLOR_ARRAY );
-		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, colorArray );
-
-		GL_Bind( tr.dlightImage );
+		state->numImages = 1;
+		state->image[0] = tr.dlightImage;
 		// include GLS_DEPTHFUNC_EQUAL so alpha tested surfaces don't add light
 		// where they aren't rendered
 		if ( dl->additive ) {
-			GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
+			state->stateBits = GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE |
+				GLS_DEPTHFUNC_EQUAL;
+		} else {
+			state->stateBits = GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE |
+				GLS_DEPTHFUNC_EQUAL;
 		}
-		else {
-			GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
-		}
-		R_DrawElements( numIndexes, hitIndexes );
+		GL_DrawElements( state, numIndexes, 0, hitIndexes,
+				 0, tess.numVertexes-1, tess.numVertexes-1 );
 		backEnd.pc.c_totalIndexes += numIndexes;
 		backEnd.pc.c_dlightIndexes += numIndexes;
 	}
+
+	RB_FreeScratch( hitIndexes );
+	RB_FreeScratch( colorArray );
+	RB_FreeScratch( texCoordsArray );
+	RB_FreeScratch( clipBits );
 }
 #endif
 
 
-static void ProjectDlightTexture_scalar( void ) {
+static void ProjectDlightTexture_scalar( glRenderState_t *state ) {
 	int		i, l;
 	vec3_t	origin;
-	float	*texCoords;
-	byte	*colors;
-	byte	clipBits[SHADER_MAX_VERTEXES];
-	float	texCoordsArray[SHADER_MAX_VERTEXES][2];
-	byte	colorArray[SHADER_MAX_VERTEXES][4];
-	unsigned	hitIndexes[SHADER_MAX_INDEXES];
+	vec2_t	*texCoords;
+	color4ub_t	*colors;
+	byte	*clipBits;
+	vec2_t	*texCoordsArray;
+	color4ub_t	*colorArray;
+	GLushort	*hitIndexes;
 	int		numIndexes;
 	float	scale;
 	float	radius;
 	vec3_t	floatColor;
 	float	modulate = 0.0f;
 
-	if ( !backEnd.refdef.num_dlights ) {
+	if ( !backEnd.refdef.num_dlights ||
+	     tess.numVertexes > 65535 ) { // to avoid GLushort overflow
 		return;
 	}
 
+	clipBits = RB_AllocScratch( sizeof(byte) * tess.numVertexes );
+	texCoordsArray = RB_AllocScratch( sizeof(vec2_t) * tess.numVertexes );
+	colorArray = RB_AllocScratch( sizeof(color4ub_t) * tess.numVertexes );
+	hitIndexes = RB_AllocScratch( sizeof(GLushort) * tess.numIndexes );
+
 	for ( l = 0 ; l < backEnd.refdef.num_dlights ; l++ ) {
 		dlight_t	*dl;
 
 		if ( !( tess.dlightBits & ( 1 << l ) ) ) {
 			continue;	// this surface definately doesn't have any of this light
 		}
-		texCoords = texCoordsArray[0];
-		colors = colorArray[0];
+		texCoords = texCoordsArray;
+		colors = colorArray;
 
 		dl = &backEnd.refdef.dlights[l];
 		VectorCopy( dl->transformed, origin );
@@ -624,36 +605,34 @@
 			floatColor[2] = dl->color[2] * 255.0f;
 		}
 
-		for ( i = 0 ; i < tess.numVertexes ; i++, texCoords += 2, colors += 4 ) {
+		for ( i = 0 ; i < tess.numVertexes ; i++, texCoords++, colors++ ) {
 			int		clip = 0;
 			vec3_t	dist;
 			
-			VectorSubtract( origin, tess.xyz[i], dist );
+			VectorSubtract( origin, tess.vertexPtr2[i].xyz, dist );
 
 			backEnd.pc.c_dlightVertexes++;
 
-			texCoords[0] = 0.5f + dist[0] * scale;
-			texCoords[1] = 0.5f + dist[1] * scale;
+			(*texCoords)[0] = 0.5f + dist[0] * scale;
+			(*texCoords)[1] = 0.5f + dist[1] * scale;
 
 			if( !r_dlightBacks->integer &&
-					// dist . tess.normal[i]
-					( dist[0] * tess.normal[i][0] +
-					dist[1] * tess.normal[i][1] +
-					dist[2] * tess.normal[i][2] ) < 0.0f ) {
+			    // dist . tess.normal[i]
+			    ( dist[0] * tess.vertexPtr3[i].normal[0] +
+			      dist[1] * tess.vertexPtr3[i].normal[1] +
+			      dist[2] * tess.vertexPtr3[i].normal[2] ) < 0.0f ) {
 				clip = 63;
 			} else {
-				if ( texCoords[0] < 0.0f ) {
+				if ( (*texCoords)[0] < 0.0f ) {
 					clip |= 1;
-				} else if ( texCoords[0] > 1.0f ) {
+				} else if ( (*texCoords)[0] > 1.0f ) {
 					clip |= 2;
 				}
-				if ( texCoords[1] < 0.0f ) {
+				if ( (*texCoords)[1] < 0.0f ) {
 					clip |= 4;
-				} else if ( texCoords[1] > 1.0f ) {
+				} else if ( (*texCoords)[1] > 1.0f ) {
 					clip |= 8;
 				}
-				texCoords[0] = texCoords[0];
-				texCoords[1] = texCoords[1];
 
 				// modulate the strength based on the height and color
 				if ( dist[2] > radius ) {
@@ -672,20 +651,20 @@
 				}
 			}
 			clipBits[i] = clip;
-			colors[0] = myftol(floatColor[0] * modulate);
-			colors[1] = myftol(floatColor[1] * modulate);
-			colors[2] = myftol(floatColor[2] * modulate);
-			colors[3] = 255;
+			(*colors)[0] = myftol(floatColor[0] * modulate);
+			(*colors)[1] = myftol(floatColor[1] * modulate);
+			(*colors)[2] = myftol(floatColor[2] * modulate);
+			(*colors)[3] = 255;
 		}
 
 		// build a list of triangles that need light
 		numIndexes = 0;
 		for ( i = 0 ; i < tess.numIndexes ; i += 3 ) {
-			int		a, b, c;
+			GLushort		a, b, c;
 
-			a = tess.indexes[i];
-			b = tess.indexes[i+1];
-			c = tess.indexes[i+2];
+			a = tess.indexPtr.p16[i];
+			b = tess.indexPtr.p16[i+1];
+			c = tess.indexPtr.p16[i+2];
 			if ( clipBits[a] & clipBits[b] & clipBits[c] ) {
 				continue;	// not lighted
 			}
@@ -698,37 +677,52 @@
 		if ( !numIndexes ) {
 			continue;
 		}
+		
+		state->program = tr.defaultShader->GLSLprogram;
+		
+		SetAttrPointer( state, AL_TEXCOORD, 0,
+				2, GL_FLOAT, sizeof(vec2_t),
+				texCoordsArray );
+		SetAttrPointer( state, AL_COLOR, 0,
+				4, GL_UNSIGNED_BYTE, sizeof(color4ub_t),
+				colorArray );
 
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglTexCoordPointer( 2, GL_FLOAT, 0, texCoordsArray[0] );
-
-		qglEnableClientState( GL_COLOR_ARRAY );
-		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, colorArray );
-
-		GL_Bind( tr.dlightImage );
+		state->numImages = 1;
+		state->image[0] = tr.dlightImage;
+		state->stateBits = 0;
+		if ( tess.xstages[0] )
+			state->stateBits |= tess.xstages[0]->stateBits & GLS_POLYGON_OFFSET;
 		// include GLS_DEPTHFUNC_EQUAL so alpha tested surfaces don't add light
 		// where they aren't rendered
 		if ( dl->additive ) {
-			GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
+			state->stateBits |= GLS_DEPTHFUNC_EQUAL |
+				GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE;
+		} else {
+			state->stateBits |= GLS_DEPTHFUNC_EQUAL |
+				GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE;
 		}
-		else {
-			GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
-		}
-		R_DrawElements( numIndexes, hitIndexes );
+
+		GL_DrawElements( state, numIndexes, 0, hitIndexes,
+				 0, tess.numVertexes-1, tess.numVertexes-1 );
 		backEnd.pc.c_totalIndexes += numIndexes;
 		backEnd.pc.c_dlightIndexes += numIndexes;
 	}
+
+	RB_FreeScratch( hitIndexes );
+	RB_FreeScratch( colorArray );
+	RB_FreeScratch( texCoordsArray );
+	RB_FreeScratch( clipBits );
 }
 
-static void ProjectDlightTexture( void ) {
+static void ProjectDlightTexture( glRenderState_t *state ) {
 #if idppc_altivec
 	if (com_altivec->integer) {
 		// must be in a seperate function or G3 systems will crash.
-		ProjectDlightTexture_altivec();
+		ProjectDlightTexture_altivec( state );
 		return;
 	}
 #endif
-	ProjectDlightTexture_scalar();
+	ProjectDlightTexture_scalar( state );
 }
 
 
@@ -739,33 +733,46 @@
 Blends a fog texture on top of everything else
 ===================
 */
-static void RB_FogPass( void ) {
+static void RB_FogPass( glRenderState_t *state ) {
 	fog_t		*fog;
-	int			i;
 
-	qglEnableClientState( GL_COLOR_ARRAY );
-	qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
+	tess.svars.texcoords[0] = RB_AllocScratch( tess.numVertexes * sizeof(vec2_t) );
 
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
-	qglTexCoordPointer( 2, GL_FLOAT, 0, tess.svars.texcoords[0] );
+	state->stateBits = GLS_DEFAULT;
+	if ( tess.xstages[0] )
+		state->stateBits |= tess.xstages[0]->stateBits & GLS_POLYGON_OFFSET;
+	if ( tess.shader->fogPass == FP_EQUAL )
+		state->stateBits |= GLS_DEPTHFUNC_EQUAL;
 
+	if ( tr.fogShader->GLSLprogram ) {
+		state->program = tr.fogShader->GLSLprogram;
+		state->stateBits |= GLS_SRCBLEND_ONE | GLS_DSTBLEND_SRC_ALPHA;
+	} else {
+		state->program = NULL;
+		state->stateBits |= GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA;
+	}
+
 	fog = tr.world->fogs + tess.fogNum;
 
-	for ( i = 0; i < tess.numVertexes; i++ ) {
-		* ( int * )&tess.svars.colors[i] = fog->colorInt;
-	}
+	RB_CalcFogTexCoords( tess.svars.texcoords[0], tess.numVertexes );
 
-	RB_CalcFogTexCoords( ( float * ) tess.svars.texcoords[0] );
+	SetAttrPointer( state, AL_TEXCOORD, 0,
+			2, GL_FLOAT, sizeof(vec2_t),
+			tess.svars.texcoords[0][0] );
+	SetAttrVec4f( state, AL_COLOR,
+		      fog->parms.color[0],
+		      fog->parms.color[1],
+		      fog->parms.color[2],
+		      1.0f );
 
-	GL_Bind( tr.fogImage );
+	state->numImages = 1;
+	state->image[0] = tr.fogImage;
 
-	if ( tess.shader->fogPass == FP_EQUAL ) {
-		GL_State( GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA | GLS_DEPTHFUNC_EQUAL );
-	} else {
-		GL_State( GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA );
-	}
+	GL_DrawElements( state, tess.numIndexes,
+			 0, tess.indexPtr.p16,
+			 0, tess.numVertexes-1, tess.numVertexes-1 );
 
-	R_DrawElements( tess.numIndexes, tess.indexes );
+	RB_FreeScratch( tess.svars.texcoords[0] );
 }
 
 /*
@@ -773,140 +780,223 @@
 ComputeColors
 ===============
 */
-static void ComputeColors( shaderStage_t *pStage )
+static void ComputeColors( glRenderState_t *state,
+			   vboInfo_t *VBO,
+			   shaderStage_t *pStage,
+			   qboolean skipFog )
 {
 	int		i;
+	alphaGen_t	aGen = pStage->alphaGen;
+	colorGen_t	rgbGen = pStage->rgbGen;
+	color4ub_t	color;
+	fog_t		*fog;
+	qboolean	constRGB, constA;
+	
+	// get rid of AGEN_SKIP
+	if ( aGen == AGEN_SKIP ) {
+		if ( rgbGen == CGEN_EXACT_VERTEX ||
+		     rgbGen == CGEN_VERTEX ) {
+			aGen = AGEN_VERTEX;
+		} else {
+			aGen = AGEN_IDENTITY;
+		}
+	}
+	
+	// no need to multiply by 1
+	if ( tr.identityLight == 1 && rgbGen == CGEN_VERTEX ) {
+		rgbGen = CGEN_EXACT_VERTEX;
+	}
 
+	// check for constant RGB
+	switch( rgbGen ) {
+	case CGEN_IDENTITY_LIGHTING:
+		color[0] = color[1] = color[2] = tr.identityLightByte;
+		constRGB = qtrue;
+		break;
+	case CGEN_IDENTITY:
+		color[0] = color[1] = color[2] = 255;
+		constRGB = qtrue;
+		break;
+	case CGEN_ENTITY:
+		RB_CalcColorFromEntity( &color, 1 );
+		constRGB = qtrue;
+		break;
+	case CGEN_ONE_MINUS_ENTITY:
+		RB_CalcColorFromOneMinusEntity( &color, 1 );
+		constRGB = qtrue;
+		break;
+	case CGEN_WAVEFORM:
+		RB_CalcWaveColor( &pStage->rgbWave, &color, 1 );
+		constRGB = qtrue;
+		break;
+	case CGEN_FOG:
+		fog = tr.world->fogs + tess.fogNum;
+		*(int *)(&color) = fog->colorInt;
+		constRGB = qtrue;
+		break;
+	case CGEN_CONST:
+		*(int *)(&color) = *(int *)pStage->constantColor;		
+		constRGB = qtrue;
+		break;
+	default:
+		constRGB = qfalse;
+		break;
+	}
+
+	// check for constant ALPHA
+	switch( aGen ) {
+	case AGEN_IDENTITY:
+		color[3] = 255;
+		constA = qtrue;
+		break;
+	case AGEN_ENTITY:
+		RB_CalcAlphaFromEntity( &color, 1 );
+		constA = qtrue;
+		break;
+	case AGEN_ONE_MINUS_ENTITY:
+		RB_CalcAlphaFromOneMinusEntity( &color, 1 );
+		constA = qtrue;
+		break;
+	case AGEN_WAVEFORM:
+		RB_CalcWaveAlpha( &pStage->alphaWave, &color, 1 );
+		constA = qtrue;
+		break;
+	case AGEN_CONST:
+		color[3] = pStage->constantColor[3];
+		constA = qtrue;
+		break;
+	default:
+		constA = qfalse;
+		break;
+	}
+
+	if ( !r_greyscale->integer &&
+	     (skipFog || !tess.fogNum || pStage->adjustColorsForFog == ACFF_NONE) ) {
+		// if RGB and ALPHA are constant, just set the GL color
+		if ( constRGB && constA ) {
+			SetAttrVec4f( state, AL_COLOR,
+				      color[0] / 255.0f,
+				      color[1] / 255.0f,
+				      color[2] / 255.0f,
+				      color[3] / 255.0f );
+			tess.svars.colors = NULL;
+			return;
+		}
+		
+		// if RGB and ALPHA are identical to vertex data, bind that
+		if ( aGen == AGEN_VERTEX && rgbGen == CGEN_EXACT_VERTEX ) {
+			if( VBO && VBO->vbo ) {
+				SetAttrPointer( state, AL_COLOR, VBO->vbo,
+						4, GL_UNSIGNED_BYTE, sizeof(vaWord4_t),
+						&VBO->offs4->color );
+			} else if( !tess.vertexPtr4 ) {
+				SetAttrPointer( state, AL_COLOR, backEnd.worldVBO.vbo,
+						4, GL_UNSIGNED_BYTE, sizeof(vaWord4_t),
+						&backEnd.worldVBO.offs4->color );
+			} else {
+				SetAttrPointer( state, AL_COLOR, 0,
+						4, GL_UNSIGNED_BYTE, sizeof(vaWord4_t),
+						&tess.vertexPtr4->color );
+			}
+			tess.svars.colors = NULL;
+			return;
+		}
+	}
+	
+	// we have to allocate a per-Vertex color value
+	tess.svars.colors = RB_AllocScratch( tess.numVertexes * sizeof(color4ub_t) );
+
 	//
 	// rgbGen
 	//
-	switch ( pStage->rgbGen )
+	switch ( rgbGen )
 	{
-		case CGEN_IDENTITY:
-			Com_Memset( tess.svars.colors, 0xff, tess.numVertexes * 4 );
-			break;
-		default:
-		case CGEN_IDENTITY_LIGHTING:
-			Com_Memset( tess.svars.colors, tr.identityLightByte, tess.numVertexes * 4 );
-			break;
-		case CGEN_LIGHTING_DIFFUSE:
-			RB_CalcDiffuseColor( ( unsigned char * ) tess.svars.colors );
-			break;
-		case CGEN_EXACT_VERTEX:
-			Com_Memcpy( tess.svars.colors, tess.vertexColors, tess.numVertexes * sizeof( tess.vertexColors[0] ) );
-			break;
-		case CGEN_CONST:
-			for ( i = 0; i < tess.numVertexes; i++ ) {
-				*(int *)tess.svars.colors[i] = *(int *)pStage->constantColor;
-			}
-			break;
-		case CGEN_VERTEX:
-			if ( tr.identityLight == 1 )
+	case CGEN_BAD:
+	case CGEN_IDENTITY_LIGHTING:
+	case CGEN_IDENTITY:
+	case CGEN_ENTITY:
+	case CGEN_ONE_MINUS_ENTITY:
+	case CGEN_WAVEFORM:
+	case CGEN_FOG:
+	case CGEN_CONST:
+		for ( i = 0; i < tess.numVertexes; i++ ) {
+			*(int *)tess.svars.colors[i] = *(int *)(&color);
+		}
+		break;
+	case CGEN_LIGHTING_DIFFUSE:
+		RB_CalcDiffuseColor( tess.svars.colors, tess.numVertexes );
+		break;
+	case CGEN_EXACT_VERTEX:
+		for ( i = 0; i < tess.numVertexes; i++ )
+		{
+			tess.svars.colors[i][0] = tess.vertexPtr4[i].color[0];
+			tess.svars.colors[i][1] = tess.vertexPtr4[i].color[1];
+			tess.svars.colors[i][2] = tess.vertexPtr4[i].color[2];
+			tess.svars.colors[i][3] = tess.vertexPtr4[i].color[3];
+		}
+		break;
+	case CGEN_VERTEX:
+		for ( i = 0; i < tess.numVertexes; i++ )
+		{
+			tess.svars.colors[i][0] = tess.vertexPtr4[i].color[0] * tr.identityLight;
+			tess.svars.colors[i][1] = tess.vertexPtr4[i].color[1] * tr.identityLight;
+			tess.svars.colors[i][2] = tess.vertexPtr4[i].color[2] * tr.identityLight;
+			tess.svars.colors[i][3] = tess.vertexPtr4[i].color[3];
+		}
+		break;
+	case CGEN_ONE_MINUS_VERTEX:
+		if ( tr.identityLight == 1 )
+		{
+			for ( i = 0; i < tess.numVertexes; i++ )
 			{
-				Com_Memcpy( tess.svars.colors, tess.vertexColors, tess.numVertexes * sizeof( tess.vertexColors[0] ) );
+				tess.svars.colors[i][0] = 255 - tess.vertexPtr4[i].color[0];
+				tess.svars.colors[i][1] = 255 - tess.vertexPtr4[i].color[1];
+				tess.svars.colors[i][2] = 255 - tess.vertexPtr4[i].color[2];
 			}
-			else
+		}
+		else
+		{
+			for ( i = 0; i < tess.numVertexes; i++ )
 			{
-				for ( i = 0; i < tess.numVertexes; i++ )
-				{
-					tess.svars.colors[i][0] = tess.vertexColors[i][0] * tr.identityLight;
-					tess.svars.colors[i][1] = tess.vertexColors[i][1] * tr.identityLight;
-					tess.svars.colors[i][2] = tess.vertexColors[i][2] * tr.identityLight;
-					tess.svars.colors[i][3] = tess.vertexColors[i][3];
-				}
+				tess.svars.colors[i][0] = ( 255 - tess.vertexPtr4[i].color[0] ) * tr.identityLight;
+				tess.svars.colors[i][1] = ( 255 - tess.vertexPtr4[i].color[1] ) * tr.identityLight;
+				tess.svars.colors[i][2] = ( 255 - tess.vertexPtr4[i].color[2] ) * tr.identityLight;
 			}
-			break;
-		case CGEN_ONE_MINUS_VERTEX:
-			if ( tr.identityLight == 1 )
-			{
-				for ( i = 0; i < tess.numVertexes; i++ )
-				{
-					tess.svars.colors[i][0] = 255 - tess.vertexColors[i][0];
-					tess.svars.colors[i][1] = 255 - tess.vertexColors[i][1];
-					tess.svars.colors[i][2] = 255 - tess.vertexColors[i][2];
-				}
-			}
-			else
-			{
-				for ( i = 0; i < tess.numVertexes; i++ )
-				{
-					tess.svars.colors[i][0] = ( 255 - tess.vertexColors[i][0] ) * tr.identityLight;
-					tess.svars.colors[i][1] = ( 255 - tess.vertexColors[i][1] ) * tr.identityLight;
-					tess.svars.colors[i][2] = ( 255 - tess.vertexColors[i][2] ) * tr.identityLight;
-				}
-			}
-			break;
-		case CGEN_FOG:
-			{
-				fog_t		*fog;
-
-				fog = tr.world->fogs + tess.fogNum;
-
-				for ( i = 0; i < tess.numVertexes; i++ ) {
-					* ( int * )&tess.svars.colors[i] = fog->colorInt;
-				}
-			}
-			break;
-		case CGEN_WAVEFORM:
-			RB_CalcWaveColor( &pStage->rgbWave, ( unsigned char * ) tess.svars.colors );
-			break;
-		case CGEN_ENTITY:
-			RB_CalcColorFromEntity( ( unsigned char * ) tess.svars.colors );
-			break;
-		case CGEN_ONE_MINUS_ENTITY:
-			RB_CalcColorFromOneMinusEntity( ( unsigned char * ) tess.svars.colors );
-			break;
+		}
+		break;
 	}
 
 	//
 	// alphaGen
 	//
-	switch ( pStage->alphaGen )
+	switch ( aGen )
 	{
 	case AGEN_SKIP:
-		break;
 	case AGEN_IDENTITY:
-		if ( pStage->rgbGen != CGEN_IDENTITY ) {
-			if ( ( pStage->rgbGen == CGEN_VERTEX && tr.identityLight != 1 ) ||
-				 pStage->rgbGen != CGEN_VERTEX ) {
-				for ( i = 0; i < tess.numVertexes; i++ ) {
-					tess.svars.colors[i][3] = 0xff;
-				}
-			}
-		}
-		break;
+	case AGEN_ENTITY:
+	case AGEN_ONE_MINUS_ENTITY:
+	case AGEN_WAVEFORM:
 	case AGEN_CONST:
-		if ( pStage->rgbGen != CGEN_CONST ) {
-			for ( i = 0; i < tess.numVertexes; i++ ) {
-				tess.svars.colors[i][3] = pStage->constantColor[3];
-			}
+		for ( i = 0; i < tess.numVertexes; i++ ) {
+			tess.svars.colors[i][3] = color[3];
 		}
 		break;
-	case AGEN_WAVEFORM:
-		RB_CalcWaveAlpha( &pStage->alphaWave, ( unsigned char * ) tess.svars.colors );
-		break;
 	case AGEN_LIGHTING_SPECULAR:
-		RB_CalcSpecularAlpha( ( unsigned char * ) tess.svars.colors );
+		RB_CalcSpecularAlpha( tess.svars.colors, tess.numVertexes );
 		break;
-	case AGEN_ENTITY:
-		RB_CalcAlphaFromEntity( ( unsigned char * ) tess.svars.colors );
-		break;
-	case AGEN_ONE_MINUS_ENTITY:
-		RB_CalcAlphaFromOneMinusEntity( ( unsigned char * ) tess.svars.colors );
-		break;
-    case AGEN_VERTEX:
+	case AGEN_VERTEX:
 		if ( pStage->rgbGen != CGEN_VERTEX ) {
 			for ( i = 0; i < tess.numVertexes; i++ ) {
-				tess.svars.colors[i][3] = tess.vertexColors[i][3];
+				tess.svars.colors[i][3] = tess.vertexPtr4[i].color[3];
 			}
 		}
-        break;
-    case AGEN_ONE_MINUS_VERTEX:
-        for ( i = 0; i < tess.numVertexes; i++ )
-        {
-			tess.svars.colors[i][3] = 255 - tess.vertexColors[i][3];
-        }
-        break;
+		break;
+	case AGEN_ONE_MINUS_VERTEX:
+		for ( i = 0; i < tess.numVertexes; i++ )
+		{
+			tess.svars.colors[i][3] = 255 - tess.vertexPtr4[i].color[3];
+		}
+		break;
 	case AGEN_PORTAL:
 		{
 			unsigned char alpha;
@@ -916,7 +1006,7 @@
 				float len;
 				vec3_t v;
 
-				VectorSubtract( tess.xyz[i], backEnd.viewParms.or.origin, v );
+				VectorSubtract( tess.vertexPtr2[i].xyz, backEnd.viewParms.or.origin, v );
 				len = VectorLength( v );
 
 				len /= tess.shader->portalRange;
@@ -948,13 +1038,13 @@
 		switch ( pStage->adjustColorsForFog )
 		{
 		case ACFF_MODULATE_RGB:
-			RB_CalcModulateColorsByFog( ( unsigned char * ) tess.svars.colors );
+			RB_CalcModulateColorsByFog( tess.svars.colors, tess.numVertexes );
 			break;
 		case ACFF_MODULATE_ALPHA:
-			RB_CalcModulateAlphasByFog( ( unsigned char * ) tess.svars.colors );
+			RB_CalcModulateAlphasByFog( tess.svars.colors, tess.numVertexes );
 			break;
 		case ACFF_MODULATE_RGBA:
-			RB_CalcModulateRGBAsByFog( ( unsigned char * ) tess.svars.colors );
+			RB_CalcModulateRGBAsByFog( tess.svars.colors, tess.numVertexes );
 			break;
 		case ACFF_NONE:
 			break;
@@ -972,6 +1062,10 @@
 			tess.svars.colors[i][0] = tess.svars.colors[i][1] = tess.svars.colors[i][2] = scale;
 		}
 	}
+
+	SetAttrPointer( state, AL_COLOR, 0,
+			4, GL_UNSIGNED_BYTE, sizeof(color4ub_t),
+			tess.svars.colors );
 }
 
 /*
@@ -979,44 +1073,92 @@
 ComputeTexCoords
 ===============
 */
-static void ComputeTexCoords( shaderStage_t *pStage ) {
+static void ComputeTexCoords( glRenderState_t *state,
+			      vboInfo_t *VBO,
+			      shaderStage_t *pStage ) {
 	int		i;
 	int		b;
-
+	qboolean	noTexMods;
+	
 	for ( b = 0; b < NUM_TEXTURE_BUNDLES; b++ ) {
 		int tm;
 
+		noTexMods = (pStage->bundle[b].numTexMods == 0) ||
+			(pStage->bundle[b].texMods[0].type == TMOD_NONE);
+		
+		if ( noTexMods && pStage->bundle[b].tcGen == TCGEN_BAD ) {
+			SetAttrUnspec( state, AL_TEXCOORD + b );
+			continue;
+		}
+
+		if ( noTexMods && pStage->bundle[b].tcGen == TCGEN_TEXTURE ) {
+			if( VBO && VBO->vbo ) {
+				SetAttrPointer( state, AL_TEXCOORD + b, VBO->vbo,
+						2, GL_FLOAT, sizeof(vaWord1_t),
+						&VBO->offs1->tc1);
+			} else if( tess.vertexPtr1 == NULL ) {
+				SetAttrPointer( state, AL_TEXCOORD + b, backEnd.worldVBO.vbo,
+						2, GL_FLOAT, sizeof(vaWord1_t),
+						&backEnd.worldVBO.offs1->tc1);
+			} else {
+				SetAttrPointer( state, AL_TEXCOORD + b, 0,
+						2, GL_FLOAT, sizeof(vaWord1_t),
+						&tess.vertexPtr1->tc1 );
+			}
+			tess.svars.texcoords[b] = NULL;
+			continue;
+		}
+
+		if ( noTexMods && pStage->bundle[b].tcGen == TCGEN_LIGHTMAP ) {
+			if( VBO && VBO->vbo ) {
+				SetAttrPointer( state, AL_TEXCOORD + b, VBO->vbo,
+						2, GL_FLOAT, sizeof(vaWord1_t),
+						&VBO->offs1->tc2);
+			} else if( tess.vertexPtr1 == NULL ) {
+				SetAttrPointer( state, AL_TEXCOORD + b, backEnd.worldVBO.vbo,
+						2, GL_FLOAT, sizeof(vaWord1_t),
+						&backEnd.worldVBO.offs1->tc2);
+			} else {
+				SetAttrPointer( state, AL_TEXCOORD + b, 0,
+						2, GL_FLOAT, sizeof(vaWord1_t),
+						&tess.vertexPtr1->tc2 );
+			}
+			tess.svars.texcoords[b] = NULL;
+			continue;
+		}
+
+		tess.svars.texcoords[b] = RB_AllocScratch( tess.numVertexes * sizeof(vec2_t) );
 		//
 		// generate the texture coordinates
 		//
 		switch ( pStage->bundle[b].tcGen )
 		{
 		case TCGEN_IDENTITY:
-			Com_Memset( tess.svars.texcoords[b], 0, sizeof( float ) * 2 * tess.numVertexes );
+			Com_Memset( tess.svars.texcoords[b], 0, sizeof( vec2_t ) * tess.numVertexes );
 			break;
 		case TCGEN_TEXTURE:
 			for ( i = 0 ; i < tess.numVertexes ; i++ ) {
-				tess.svars.texcoords[b][i][0] = tess.texCoords[i][0][0];
-				tess.svars.texcoords[b][i][1] = tess.texCoords[i][0][1];
+				tess.svars.texcoords[b][i][0] = tess.vertexPtr1[i].tc1[0];
+				tess.svars.texcoords[b][i][1] = tess.vertexPtr1[i].tc1[1];
 			}
 			break;
 		case TCGEN_LIGHTMAP:
 			for ( i = 0 ; i < tess.numVertexes ; i++ ) {
-				tess.svars.texcoords[b][i][0] = tess.texCoords[i][1][0];
-				tess.svars.texcoords[b][i][1] = tess.texCoords[i][1][1];
+				tess.svars.texcoords[b][i][0] = tess.vertexPtr1[i].tc2[0];
+				tess.svars.texcoords[b][i][1] = tess.vertexPtr1[i].tc2[1];
 			}
 			break;
 		case TCGEN_VECTOR:
 			for ( i = 0 ; i < tess.numVertexes ; i++ ) {
-				tess.svars.texcoords[b][i][0] = DotProduct( tess.xyz[i], pStage->bundle[b].tcGenVectors[0] );
-				tess.svars.texcoords[b][i][1] = DotProduct( tess.xyz[i], pStage->bundle[b].tcGenVectors[1] );
+				tess.svars.texcoords[b][i][0] = DotProduct( tess.vertexPtr2[i].xyz, pStage->bundle[b].tcGenVectors[0] );
+				tess.svars.texcoords[b][i][1] = DotProduct( tess.vertexPtr2[i].xyz, pStage->bundle[b].tcGenVectors[1] );
 			}
 			break;
 		case TCGEN_FOG:
-			RB_CalcFogTexCoords( ( float * ) tess.svars.texcoords[b] );
+			RB_CalcFogTexCoords( tess.svars.texcoords[b], tess.numVertexes );
 			break;
 		case TCGEN_ENVIRONMENT_MAPPED:
-			RB_CalcEnvironmentTexCoords( ( float * ) tess.svars.texcoords[b] );
+			RB_CalcEnvironmentTexCoords( tess.svars.texcoords[b], tess.numVertexes );
 			break;
 		case TCGEN_BAD:
 			return;
@@ -1034,37 +1176,37 @@
 
 			case TMOD_TURBULENT:
 				RB_CalcTurbulentTexCoords( &pStage->bundle[b].texMods[tm].wave, 
-						                 ( float * ) tess.svars.texcoords[b] );
+							   tess.svars.texcoords[b], tess.numVertexes );
 				break;
 
 			case TMOD_ENTITY_TRANSLATE:
 				RB_CalcScrollTexCoords( backEnd.currentEntity->e.shaderTexCoord,
-									 ( float * ) tess.svars.texcoords[b] );
+							tess.svars.texcoords[b], tess.numVertexes );
 				break;
 
 			case TMOD_SCROLL:
 				RB_CalcScrollTexCoords( pStage->bundle[b].texMods[tm].scroll,
-										 ( float * ) tess.svars.texcoords[b] );
+							tess.svars.texcoords[b], tess.numVertexes );
 				break;
 
 			case TMOD_SCALE:
 				RB_CalcScaleTexCoords( pStage->bundle[b].texMods[tm].scale,
-									 ( float * ) tess.svars.texcoords[b] );
+						       tess.svars.texcoords[b], tess.numVertexes );
 				break;
 			
 			case TMOD_STRETCH:
 				RB_CalcStretchTexCoords( &pStage->bundle[b].texMods[tm].wave, 
-						               ( float * ) tess.svars.texcoords[b] );
+							 tess.svars.texcoords[b], tess.numVertexes );
 				break;
 
 			case TMOD_TRANSFORM:
 				RB_CalcTransformTexCoords( &pStage->bundle[b].texMods[tm],
-						                 ( float * ) tess.svars.texcoords[b] );
+							   tess.svars.texcoords[b], tess.numVertexes );
 				break;
 
 			case TMOD_ROTATE:
 				RB_CalcRotateTexCoords( pStage->bundle[b].texMods[tm].rotateSpeed,
-										( float * ) tess.svars.texcoords[b] );
+							tess.svars.texcoords[b], tess.numVertexes );
 				break;
 
 			default:
@@ -1072,15 +1214,21 @@
 				break;
 			}
 		}
+		SetAttrPointer( state, AL_TEXCOORD + b, 0,
+				2, GL_FLOAT, sizeof(vec2_t),
+				tess.svars.texcoords[b] );
 	}
 }
 
 /*
 ** RB_IterateStagesGeneric
 */
-static void RB_IterateStagesGeneric( shaderCommands_t *input )
+static void RB_IterateStagesGenericVBO( glRenderState_t *state,
+					vboInfo_t *VBO, GLuint max,
+					qboolean skipDetail )
 {
 	int stage;
+	int bundle;
 
 	for ( stage = 0; stage < MAX_SHADER_STAGES; stage++ )
 	{
@@ -1091,46 +1239,120 @@
 			break;
 		}
 
-		ComputeColors( pStage );
-		ComputeTexCoords( pStage );
+		// if the surface was invisible in the last frame, skip
+		// all detail stages
+		if ( skipDetail && pStage->isDetail )
+			continue;
 
-		if ( !setArraysOnce )
+		state->stateBits = pStage->stateBits;
+
+		ComputeColors( state, VBO, pStage, qtrue );
+		ComputeTexCoords( state, VBO, pStage );
+
+		//
+		// set state
+		//
+		state->numImages = 1;
+		if ( pStage->bundle[0].vertexLightmap && ( (r_vertexLight->integer && !r_uiFullScreen->integer) || glConfig.hardwareType == GLHW_PERMEDIA2 ) && r_lightmap->integer )
 		{
-			qglEnableClientState( GL_COLOR_ARRAY );
-			qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, input->svars.colors );
+			state->image[0] = tr.whiteImage;
 		}
+		else 
+			R_GetAnimatedImage( &pStage->bundle[0], qfalse, &state->image[0] );
+		
+		//
+		// do multitexture
+		//
+		for ( bundle = 1; bundle < glConfig.numTextureUnits; bundle++ ) {
+			if ( !pStage->bundle[bundle].multitextureEnv )
+				break;
 
+			// this is an ugly hack to work around a GeForce driver
+			// bug with multitexture and clip planes
+			if ( backEnd.viewParms.portalLevel ) {
+				qglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
+			}
+			
+			if ( r_lightmap->integer ) {
+				GL_TexEnv( bundle, GL_REPLACE );
+			} else {
+				GL_TexEnv( bundle, pStage->bundle[bundle].multitextureEnv );
+			}
+			R_GetAnimatedImage( &pStage->bundle[bundle], qfalse, &state->image[bundle] );
+		}
+		state->numImages = bundle;
+
+		GL_DrawElements( state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				 VBO->minIndex, VBO->maxIndex, max );
+		
+		// allow skipping out to show just lightmaps during development
+		if ( r_lightmap->integer && ( pStage->bundle[0].isLightmap || pStage->bundle[1].isLightmap || pStage->bundle[0].vertexLightmap ) )
+		{
+			break;
+		}
+	}
+}
+static void RB_IterateStagesGeneric( glRenderState_t *state,
+				     shaderCommands_t *input,
+				     GLuint max, qboolean skipDetail )
+{
+	int stage, b;
+
+	for ( stage = 0; stage < MAX_SHADER_STAGES; stage++ )
+	{
+		shaderStage_t *pStage = tess.xstages[stage];
+
+		if ( !pStage )
+		{
+			break;
+		}
+
+		if ( skipDetail && pStage->isDetail )
+			continue;
+
+		ComputeColors( state, NULL, pStage, (tess.vertexPtr1 == NULL) );
+		ComputeTexCoords( state, NULL, pStage );
+
 		//
 		// do multitexture
 		//
 		if ( pStage->bundle[1].image[0] != 0 )
 		{
-			DrawMultitextured( input, stage );
+			DrawMultitextured( state, input, stage, max );
 		}
 		else
 		{
-			if ( !setArraysOnce )
-			{
-				qglTexCoordPointer( 2, GL_FLOAT, 0, input->svars.texcoords[0] );
-			}
-
 			//
 			// set state
 			//
+			state->stateBits = pStage->stateBits;
+			state->numImages = 1;
 			if ( pStage->bundle[0].vertexLightmap && ( (r_vertexLight->integer && !r_uiFullScreen->integer) || glConfig.hardwareType == GLHW_PERMEDIA2 ) && r_lightmap->integer )
 			{
-				GL_Bind( tr.whiteImage );
+				state->image[0] = tr.whiteImage;
 			}
 			else 
-				R_BindAnimatedImage( &pStage->bundle[0] );
+				R_GetAnimatedImage( &pStage->bundle[0], qfalse, &state->image[0] );
 
-			GL_State( pStage->stateBits );
-
 			//
 			// draw
 			//
-			R_DrawElements( input->numIndexes, input->indexes );
+			GL_DrawElements( state, input->numIndexes,
+					 0, input->indexPtr.p16,
+					 input->minIndex, input->maxIndex, max );
 		}
+
+		for ( b = NUM_TEXTURE_BUNDLES - 1; b >= 0; b-- ) {
+			if ( input->svars.texcoords[b] != NULL ) {
+				RB_FreeScratch( input->svars.texcoords[b] );
+				input->svars.texcoords[b] = NULL;
+			}
+		}
+		if ( input->svars.colors != NULL ) {
+			RB_FreeScratch( input->svars.colors );
+			input->svars.colors = NULL;
+		}
+
 		// allow skipping out to show just lightmaps during development
 		if ( r_lightmap->integer && ( pStage->bundle[0].isLightmap || pStage->bundle[1].isLightmap || pStage->bundle[0].vertexLightmap ) )
 		{
@@ -1146,6 +1368,11 @@
 void RB_StageIteratorGeneric( void )
 {
 	shaderCommands_t *input;
+	GLuint            max;
+	vboInfo_t        *VBO;
+	glRenderState_t   state;
+	GLuint            glQueryID = 0, *glQueryResult = NULL;
+	qboolean          skipDetails = qfalse;
 
 	input = &tess;
 
@@ -1161,96 +1388,98 @@
 		GLimp_LogComment( va("--- RB_StageIteratorGeneric( %s ) ---\n", tess.shader->name) );
 	}
 
+	InitState( &state );
+
 	//
 	// set face culling appropriately
 	//
-	GL_Cull( input->shader->cullType );
+	state.faceCulling = input->shader->cullType;
 
-	// set polygon offset if necessary
-	if ( input->shader->polygonOffset )
-	{
-		qglEnable( GL_POLYGON_OFFSET_FILL );
-		qglPolygonOffset( r_offsetFactor->value, r_offsetUnits->value );
+	if( qglBeginQueryARB &&
+	    !backEnd.viewParms.portalLevel ) {
+		if ( backEnd.currentEntity == &tr.worldEntity ) {
+			glQueryID = tess.shader->QueryID;
+			glQueryResult = &tess.shader->QueryResult;
+		}
 	}
-
-	//
-	// if there is only a single pass then we can enable color
-	// and texture arrays before we compile, otherwise we need
-	// to avoid compiling those arrays since they will change
-	// during multipass rendering
-	//
-	if ( tess.numPasses > 1 || input->shader->multitextureEnv )
-	{
-		setArraysOnce = qfalse;
-		qglDisableClientState (GL_COLOR_ARRAY);
-		qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
+	
+	if( glQueryID ) {
+		GL_GetQuery( glQueryID, glQueryResult );
+		GL_StartQuery( glQueryID, glQueryResult );
+		skipDetails = (QUERY_RESULT(glQueryResult) == 0);
 	}
-	else
-	{
-		setArraysOnce = qtrue;
 
-		qglEnableClientState( GL_COLOR_ARRAY);
-		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
+	for( VBO = tess.firstVBO; VBO; VBO = VBO->next ) {
+		vec3_t		*vertexes;
+		vboInfo_t	*dataVBO;
+		
+		if ( VBO->vbo ) {
+			dataVBO = VBO;
+			max = VBO->maxIndex;
+			vertexes = &VBO->offs2->xyz;
+		} else {
+			dataVBO = &backEnd.worldVBO;
+			max = backEnd.worldVBO.maxIndex;
+			vertexes = &backEnd.worldVBO.offs2->xyz;
+		}
 
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
-		qglTexCoordPointer( 2, GL_FLOAT, 0, tess.svars.texcoords[0] );
-	}
+		SetAttrPointer( &state, AL_VERTEX, dataVBO->vbo,
+				3, GL_FLOAT, sizeof(vaWord2_t),
+				&dataVBO->offs2->xyz );
 
-	//
-	// lock XYZ
-	//
-	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
-	if (qglLockArraysEXT)
-	{
-		qglLockArraysEXT(0, input->numVertexes);
-		GLimp_LogComment( "glLockArraysEXT\n" );
-	}
+		RB_IterateStagesGenericVBO( &state, VBO, max, skipDetails );
 
-	//
-	// enable color and texcoord arrays after the lock if necessary
-	//
-	if ( !setArraysOnce )
-	{
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglEnableClientState( GL_COLOR_ARRAY );
+		if ( r_showtris->integer && !input->shader->isDepth ) {
+			DrawTris( &state, VBO->numIndexes, 
+				  VBO->ibo, VBO->offsIdx,
+				  VBO->minIndex,
+				  VBO->maxIndex, max,
+				  1.0f, 1.0f, 0.0f );
+		}
+		if ( r_shownormals->integer ) {
+			DrawNormals( &state );
+		}
 	}
 
-	//
-	// call shader function
-	//
-	RB_IterateStagesGeneric( input );
-
-	// 
-	// now do any dynamic lighting needed
-	//
-	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE
-		&& !(tess.shader->surfaceFlags & (SURF_NODLIGHT | SURF_SKY) ) ) {
-		ProjectDlightTexture();
+	if ( tess.numIndexes > 0 ) {
+		vec3_t	*vertexes;
+		GLuint	dataVBO;
+		
+		if ( input->vertexPtr1 ) {
+			dataVBO = 0;
+			max = tess.numIndexes-1;
+			vertexes = &input->vertexPtr2[0].xyz;
+		} else {
+			dataVBO = backEnd.worldVBO.vbo;
+			max = backEnd.worldVBO.maxIndex;
+			vertexes = &backEnd.worldVBO.offs2->xyz;
+		}
+		//
+		// lock XYZ
+		//
+		SetAttrPointer( &state, AL_VERTEX, dataVBO,
+				3, GL_FLOAT, sizeof(vaWord2_t),
+				vertexes );
+		
+		//
+		// call shader function
+		//
+		RB_IterateStagesGeneric( &state, input, max, skipDetails );
+		
+		if ( r_showtris->integer && !input->shader->isDepth ) {
+			DrawTris( &state, tess.numIndexes,
+				  0, tess.indexPtr.p16,
+				  tess.minIndex, tess.maxIndex, max,
+				  1.0f, 0.0f, 0.0f );
+		}
+		if ( r_shownormals->integer ) {
+			DrawNormals( &state );
+		}
 	}
 
-	//
-	// now do fog
-	//
-	if ( tess.fogNum && tess.shader->fogPass ) {
-		RB_FogPass();
+	if( glQueryID ) {
+		GL_EndQuery( glQueryID, glQueryResult );
 	}
-
-	// 
-	// unlock arrays
-	//
-	if (qglUnlockArraysEXT) 
-	{
-		qglUnlockArraysEXT();
-		GLimp_LogComment( "glUnlockArraysEXT\n" );
-	}
-
-	//
-	// reset polygon offset
-	//
-	if ( input->shader->polygonOffset )
-	{
-		qglDisable( GL_POLYGON_OFFSET_FILL );
-	}
 }
 
 
@@ -1261,17 +1490,16 @@
 {
 	shaderCommands_t *input;
 	shader_t		*shader;
+	GLuint            max;
+	vboInfo_t        *VBO;
+	glRenderState_t  state;
+	GLuint            glQueryID = 0, *glQueryResult = NULL;
 
 	input = &tess;
 
 	shader = input->shader;
 
 	//
-	// compute colors
-	//
-	RB_CalcDiffuseColor( ( unsigned char * ) tess.svars.colors );
-
-	//
 	// log this call
 	//
 	if ( r_logFile->integer ) 
@@ -1281,65 +1509,138 @@
 		GLimp_LogComment( va("--- RB_StageIteratorVertexLitTexturedUnfogged( %s ) ---\n", tess.shader->name) );
 	}
 
+	InitState( &state );
+
 	//
 	// set face culling appropriately
 	//
-	GL_Cull( input->shader->cullType );
+	state.stateBits = tess.xstages[0]->stateBits;
+	state.faceCulling = input->shader->cullType;
 
-	//
-	// set arrays and lock
-	//
-	qglEnableClientState( GL_COLOR_ARRAY);
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
+	state.numImages = 1;
+	R_GetAnimatedImage( &tess.xstages[0]->bundle[0], qfalse, &state.image[0] );
 
-	qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
-	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
-	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);
-
-	if ( qglLockArraysEXT )
-	{
-		qglLockArraysEXT(0, input->numVertexes);
-		GLimp_LogComment( "glLockArraysEXT\n" );
+	if( qglBeginQueryARB &&
+	    !backEnd.viewParms.portalLevel ) {
+		if ( backEnd.currentEntity == &tr.worldEntity ) {
+			glQueryID = tess.shader->QueryID;
+			glQueryResult = &tess.shader->QueryResult;
+		}
 	}
+	
+	if( glQueryID ) {
+		GL_StartQuery( glQueryID, glQueryResult );
+	}
 
 	//
-	// call special shade routine
+	// set arrays and lock
 	//
-	R_BindAnimatedImage( &tess.xstages[0]->bundle[0] );
-	GL_State( tess.xstages[0]->stateBits );
-	R_DrawElements( input->numIndexes, input->indexes );
+	for( VBO = input->firstVBO; VBO; VBO = VBO->next ) {
+		vboInfo_t	*dataVBO;
+		
+		if ( VBO->vbo ) {
+			dataVBO = VBO;
+			max = VBO->maxIndex;
+		} else {
+			dataVBO = &backEnd.worldVBO;
+			max = backEnd.worldVBO.maxIndex;
+		}
 
-	// 
-	// now do any dynamic lighting needed
-	//
-	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
-		ProjectDlightTexture();
+		SetAttrPointer( &state, AL_COLOR, dataVBO->vbo,
+				4, GL_UNSIGNED_BYTE, sizeof(vaWord4_t),
+				&dataVBO->offs4->color );
+		SetAttrPointer( &state, AL_TEXCOORD, dataVBO->vbo,
+				2, GL_FLOAT, sizeof(vaWord1_t),
+				&dataVBO->offs1->tc1 );
+		SetAttrPointer( &state, AL_VERTEX, dataVBO->vbo,
+				3, GL_FLOAT, sizeof(vaWord2_t),
+				&dataVBO->offs2->xyz );
+		
+		//
+		// call special shade routine
+		//
+		GL_DrawElements( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx, 
+				 VBO->minIndex, VBO->maxIndex, max );
+		
+		if ( r_showtris->integer && !input->shader->isDepth ) {
+			DrawTris( &state, VBO->numIndexes,
+				  VBO->ibo, VBO->offsIdx,
+				  VBO->minIndex,
+				  VBO->maxIndex, max,
+				  1.0f, 1.0f, 0.0f );
+		}
+		if ( r_shownormals->integer ) {
+			DrawNormals( &state );
+		}
 	}
+	if ( input->numIndexes > 0 ) {
+		vec3_t		*vertexes;
+		vec2_t		*tcs;
+		GLuint		dataVBO;
 
-	//
-	// now do fog
-	//
-	if ( tess.fogNum && tess.shader->fogPass ) {
-		RB_FogPass();
+		//
+		// compute colors
+		//
+		tess.svars.colors = RB_AllocScratch( tess.numVertexes * sizeof(color4ub_t) );
+		RB_CalcDiffuseColor( tess.svars.colors, tess.numVertexes );
+
+		if ( input->vertexPtr1 ) {
+			dataVBO = 0;
+			max = tess.numVertexes-1;
+			vertexes = &input->vertexPtr2[0].xyz;
+			tcs = &input->vertexPtr1[0].tc1;
+		} else {
+			dataVBO = backEnd.worldVBO.vbo;
+			max = backEnd.worldVBO.maxIndex;
+			vertexes = &backEnd.worldVBO.offs2->xyz;
+			tcs = &backEnd.worldVBO.offs1->tc1;
+		}
+		
+		SetAttrPointer( &state, AL_COLOR, 0,
+				4, GL_UNSIGNED_BYTE, sizeof(color4ub_t),
+				tess.svars.colors );
+		SetAttrPointer( &state, AL_TEXCOORD, dataVBO,
+				2, GL_FLOAT, sizeof(vaWord1_t),
+				tcs );
+		SetAttrPointer( &state, AL_VERTEX, dataVBO,
+				3, GL_FLOAT, sizeof(vaWord2_t),
+				vertexes );
+		
+		//
+		// call special shade routine
+		//
+		GL_DrawElements( &state, input->numIndexes,
+				 0, input->indexPtr.p16,
+				 input->minIndex, input->maxIndex, max );
+
+		if ( r_showtris->integer && !input->shader->isDepth ) {
+			DrawTris( &state, input->numIndexes,
+				  0, input->indexPtr.p16,
+				  input->minIndex, input->maxIndex, max,
+				  1.0f, 0.0f, 0.0f );
+		}
+		if ( r_shownormals->integer ) {
+			DrawNormals( &state );
+		}
+		RB_FreeScratch( tess.svars.colors );
 	}
 
-	// 
-	// unlock arrays
-	//
-	if (qglUnlockArraysEXT) 
-	{
-		qglUnlockArraysEXT();
-		GLimp_LogComment( "glUnlockArraysEXT\n" );
+	if( glQueryID ) {
+		GL_EndQuery( glQueryID, glQueryResult );
 	}
 }
 
-//define	REPLACE_MODE
-
 void RB_StageIteratorLightmappedMultitexture( void ) {
 	shaderCommands_t *input;
+	GLuint            max;
+	vboInfo_t        *VBO;
+	glRenderState_t   state;
+	GLuint            glQueryID = 0, *glQueryResult = NULL;
 
 	input = &tess;
 
+	InitState( &state );
+
 	//
 	// log this call
 	//
@@ -1352,92 +1653,661 @@
 	//
 	// set face culling appropriately
 	//
-	GL_Cull( input->shader->cullType );
+	state.stateBits = GLS_DEFAULT;
+	state.faceCulling = input->shader->cullType;
 
-	//
-	// set color, pointers, and lock
-	//
-	GL_State( GLS_DEFAULT );
-	qglVertexPointer( 3, GL_FLOAT, 16, input->xyz );
+	SetAttrVec4f( &state, AL_COLOR, 1.0f, 1.0f, 1.0f, 1.0f );
 
-#ifdef REPLACE_MODE
-	qglDisableClientState( GL_COLOR_ARRAY );
-	qglColor3f( 1, 1, 1 );
-	qglShadeModel( GL_FLAT );
-#else
-	qglEnableClientState( GL_COLOR_ARRAY );
-	qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.constantColor255 );
-#endif
+	state.numImages = 2;
+	R_GetAnimatedImage( &tess.xstages[0]->bundle[0], qfalse, &state.image[0] );
+	R_GetAnimatedImage( &tess.xstages[0]->bundle[1], qfalse, &state.image[1] );
 
-	//
-	// select base stage
-	//
-	GL_SelectTexture( 0 );
-
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-	R_BindAnimatedImage( &tess.xstages[0]->bundle[0] );
-	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
-
-	//
-	// configure second stage
-	//
-	GL_SelectTexture( 1 );
-	qglEnable( GL_TEXTURE_2D );
 	if ( r_lightmap->integer ) {
-		GL_TexEnv( GL_REPLACE );
+		GL_TexEnv( 1, GL_REPLACE );
 	} else {
-		GL_TexEnv( GL_MODULATE );
+		GL_TexEnv( 1, GL_MODULATE );
 	}
-	R_BindAnimatedImage( &tess.xstages[0]->bundle[1] );
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][1] );
 
-	//
-	// lock arrays
-	//
-	if ( qglLockArraysEXT ) {
-		qglLockArraysEXT(0, input->numVertexes);
-		GLimp_LogComment( "glLockArraysEXT\n" );
+	if( qglBeginQueryARB &&
+	    !backEnd.viewParms.portalLevel ) {
+		if ( backEnd.currentEntity == &tr.worldEntity ) {
+			glQueryID = tess.shader->QueryID;
+			glQueryResult = &tess.shader->QueryResult;
+		}
 	}
+	
+	if( glQueryID ) {
+		GL_StartQuery( glQueryID, glQueryResult );
+	}
 
-	R_DrawElements( input->numIndexes, input->indexes );
+	for( VBO = tess.firstVBO; VBO; VBO = VBO->next ) {
+		vboInfo_t	*dataVBO;
+		
+		if ( VBO->vbo ) {
+			dataVBO = VBO;
+			max = VBO->maxIndex;
+		} else {
+			dataVBO = &backEnd.worldVBO;
+			max = backEnd.worldVBO.maxIndex;
+		}
+		//
+		// set color, pointers, and lock
+		//
+		SetAttrPointer( &state, AL_VERTEX, dataVBO->vbo,
+				3, GL_FLOAT, sizeof(vaWord2_t),
+				&dataVBO->offs2->xyz );
+		
+		//
+		// select base stage
+		//
+		SetAttrPointer( &state, AL_TEXCOORD, dataVBO->vbo,
+				2, GL_FLOAT, sizeof(vaWord1_t),
+				&dataVBO->offs1->tc1 );
+		
+		//
+		// configure second stage
+		//
+		SetAttrPointer( &state, AL_TEXCOORD2, dataVBO->vbo,
+				2, GL_FLOAT, sizeof(vaWord1_t),
+				&dataVBO->offs1->tc2 );
+		
+		GL_DrawElements( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				 VBO->minIndex, VBO->maxIndex, max );
+		
+		if ( r_showtris->integer && !input->shader->isDepth ) {
+			DrawTris( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				  VBO->minIndex,
+				  VBO->maxIndex, max,
+				  1.0f, 1.0f, 0.0f );
+		}
+		if ( r_shownormals->integer ) {
+			DrawNormals( &state );
+		}
+	}
+	if ( tess.numIndexes > 0 ) {
+		vec3_t	*vertexes;
+		vec2_t	*tcs1, *tcs2;
+		GLuint   dataVBO;
 
-	//
-	// disable texturing on TEXTURE1, then select TEXTURE0
-	//
-	qglDisable( GL_TEXTURE_2D );
-	qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
+		if ( tess.vertexPtr1 ) {
+			dataVBO = 0;
+			max = tess.numVertexes-1;
+			vertexes = &input->vertexPtr2[0].xyz;
+			tcs1 = &input->vertexPtr1[0].tc1;
+			tcs2 = &input->vertexPtr1[0].tc2;
+		} else {
+			dataVBO = backEnd.worldVBO.vbo;
+			max = backEnd.worldVBO.maxIndex;
+			vertexes = &backEnd.worldVBO.offs2->xyz;
+			tcs1 = &backEnd.worldVBO.offs1->tc1;
+			tcs2 = &backEnd.worldVBO.offs1->tc2;
+		}
 
-	GL_SelectTexture( 0 );
-#ifdef REPLACE_MODE
-	GL_TexEnv( GL_MODULATE );
-	qglShadeModel( GL_SMOOTH );
-#endif
+		//
+		// set color, pointers, and lock
+		//
+		SetAttrPointer( &state, AL_VERTEX, dataVBO,
+				3, GL_FLOAT, sizeof(vaWord2_t),
+				vertexes );
 
-	// 
-	// now do any dynamic lighting needed
-	//
-	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
-		ProjectDlightTexture();
+		
+		//
+		// select base stage
+		//
+		SetAttrPointer( &state, AL_TEXCOORD, dataVBO,
+				2, GL_FLOAT, sizeof(vaWord1_t),
+				tcs1 );
+		
+		//
+		// configure second stage
+		//
+		SetAttrPointer( &state, AL_TEXCOORD2, dataVBO,
+				2, GL_FLOAT, sizeof(vaWord1_t),
+				tcs2 );
+		
+		GL_DrawElements( &state, input->numIndexes,
+				 0, input->indexPtr.p16,
+				 input->minIndex, input->maxIndex, max );
+
+		if ( r_showtris->integer && !input->shader->isDepth ) {
+			DrawTris( &state, input->numIndexes,
+				  0, input->indexPtr.p16,
+				  input->minIndex, input->maxIndex, max,
+				  1.0f, 0.0f, 0.0f );
+		}
+		if ( r_shownormals->integer ) {
+			DrawNormals( &state );
+		}
 	}
 
+	if( glQueryID ) {
+		GL_EndQuery( glQueryID, glQueryResult );
+	}
+}
+
+/*
+** RB_StageIteratorGLSL
+*/
+void RB_StageIteratorGLSL( void ) {
+	shaderCommands_t	*input = &tess;
+	shader_t		*shader = input->shader;
+	GLuint			max;
+	int			i;
+	vboInfo_t		*VBO;
+	glRenderState_t		state;
+	GLuint            glQueryID = 0, *glQueryResult = NULL;
+
 	//
-	// now do fog
+	// log this call
 	//
-	if ( tess.fogNum && tess.shader->fogPass ) {
-		RB_FogPass();
+	if ( r_logFile->integer ) 
+	{
+		// don't just call LogComment, or we will get
+		// a call to va() every frame!
+		GLimp_LogComment( va("--- RB_StageIteratorGLSL( %s ) ---\n", shader->name) );
 	}
 
+	InitState( &state );
 	//
-	// unlock arrays
+	// set face culling appropriately
 	//
-	if ( qglUnlockArraysEXT ) {
-		qglUnlockArraysEXT();
-		GLimp_LogComment( "glUnlockArraysEXT\n" );
+	state.stateBits = shader->stages[0]->stateBits;
+	state.faceCulling = shader->cullType;
+	state.program = shader->GLSLprogram;
+	state.numImages = shader->numUnfoggedPasses;
+
+	// bind all required textures
+	for( i = 0; i < state.numImages; i++ ) {
+		if( !shader->stages[i] )
+			break;
+		
+		R_GetAnimatedImage( &shader->stages[i]->bundle[0], qtrue, &state.image[i] );
 	}
+	if( tess.dataTexture ) {
+		// bind data texture
+		state.image[state.numImages++] = tess.dataTexture;
+	}
+	
+	// bind attributes
+	SetAttrVec4f( &state, AL_CAMERAPOS,
+		      backEnd.viewParms.or.origin[0],
+		      backEnd.viewParms.or.origin[1],
+		      backEnd.viewParms.or.origin[2],
+		      0.0f );
+	if( backEnd.currentEntity->e.reType == RT_SPRITE ) {
+		SetAttrPointer( &state, AL_TIMES, 0,
+				3, GL_FLOAT, sizeof(vaWord3_t),
+				tess.vertexPtr3[0].normal );
+	} else {
+		SetAttrVec4f( &state, AL_TIMES,
+			      tess.shaderTime,
+			      backEnd.currentEntity->e.backlerp,
+			      tess.frameOffs,
+			      tess.oldFrameOffs );
+	}
+
+	if( backEnd.currentEntity->e.reType != RT_MODEL ) {
+		SetAttrVec4f( &state, AL_TRANSX,
+			      1.0f, 0.0f, 0.0f, 0.0f );
+		SetAttrVec4f( &state, AL_TRANSY,
+			      0.0f, 1.0f, 0.0f, 0.0f );
+		SetAttrVec4f( &state, AL_TRANSZ,
+			      0.0f, 0.0f, 1.0f, 0.0f );
+	} else {
+		SetAttrVec4f( &state, AL_TRANSX,
+			      backEnd.currentEntity->e.axis[0][0],
+			      backEnd.currentEntity->e.axis[1][0],
+			      backEnd.currentEntity->e.axis[2][0],
+			      backEnd.currentEntity->e.origin[0] );
+		SetAttrVec4f( &state, AL_TRANSY,
+			      backEnd.currentEntity->e.axis[0][1],
+			      backEnd.currentEntity->e.axis[1][1],
+			      backEnd.currentEntity->e.axis[2][1],
+			      backEnd.currentEntity->e.origin[1] );
+		SetAttrVec4f( &state, AL_TRANSZ,
+			      backEnd.currentEntity->e.axis[0][2],
+			      backEnd.currentEntity->e.axis[1][2],
+			      backEnd.currentEntity->e.axis[2][2],
+			      backEnd.currentEntity->e.origin[2] );
+	}
+	SetAttrVec4f( &state, AL_AMBIENTLIGHT,
+		      backEnd.currentEntity->ambientLight[0] / 255.0f,
+		      backEnd.currentEntity->ambientLight[1] / 255.0f,
+		      backEnd.currentEntity->ambientLight[2] / 255.0f,
+		      1.0f );
+	SetAttrVec4f( &state, AL_DIRECTEDLIGHT,
+		      backEnd.currentEntity->directedLight[0] / 255.0f,
+		      backEnd.currentEntity->directedLight[1] / 255.0f,
+		      backEnd.currentEntity->directedLight[2] / 255.0f,
+		      1.0f );
+	if( backEnd.currentEntity == &tr.worldEntity ||
+	    !backEnd.currentEntity->lightingCalculated ) {
+		SetAttrVec4f( &state, AL_LIGHTDIR,
+			      tr.sunDirection[0],
+			      tr.sunDirection[1],
+			      tr.sunDirection[2],
+			      tr.deluxeOffset );
+	} else {
+		SetAttrVec4f( &state, AL_LIGHTDIR,
+			      backEnd.currentEntity->lightDir[0],
+			      backEnd.currentEntity->lightDir[1],
+			      backEnd.currentEntity->lightDir[2],
+			      tr.deluxeOffset );
+	}
+	
+	if( qglBeginQueryARB &&
+	    !backEnd.viewParms.portalLevel ) {
+		if ( backEnd.currentEntity == &tr.worldEntity ) {
+			glQueryID = tess.shader->QueryID;
+			glQueryResult = &tess.shader->QueryResult;
+		}
+	}
+	
+	if( glQueryID ) {
+		GL_StartQuery( glQueryID, glQueryResult );
+	}
+
+	for( VBO = input->firstVBO; VBO; VBO = VBO->next ) {
+		int		minIndex, maxIndex;
+		vaWord1_t	*word1;
+		vaWord2_t	*word2;
+		vaWord3_t	*word3;
+		vaWord4_t	*word4;
+		vboInfo_t	*dataVBO;
+
+		if ( VBO->vbo ) {
+			dataVBO = VBO;
+		} else {
+			dataVBO = &backEnd.worldVBO;
+		}
+
+		max = dataVBO->maxIndex;
+		word1 = dataVBO->offs1;
+		word2 = dataVBO->offs2;
+		word3 = dataVBO->offs3;
+		word4 = dataVBO->offs4;
+			
+		if( shader->lightmapIndex == LIGHTMAP_MD3 ) {
+			minIndex = 0;
+			maxIndex = max;
+			
+			SetAttrPointer( &state, AL_VERTEX, dataVBO->vbo,
+					4, GL_FLOAT, sizeof(vaWord2_t),
+					&word2->xyz );
+			SetAttrVec4f( &state, AL_NORMAL,
+				      0.0f, 0.0f, 0.0f, 0.0f );
+			SetAttrVec4f( &state, AL_TEXCOORD,
+				      0.0f, 0.0f, 0.0f, 0.0f );
+			SetAttrVec4f( &state, AL_COLOR,
+				      1.0f, 1.0f, 1.0f, 1.0f );
+		} else {
+			minIndex = VBO->minIndex;
+			maxIndex = VBO->maxIndex;
+			
+			SetAttrPointer( &state, AL_VERTEX, dataVBO->vbo,
+					4, GL_FLOAT, sizeof(vaWord2_t),
+					&word2->xyz );
+			SetAttrPointer( &state, AL_NORMAL, dataVBO->vbo,
+					3, GL_FLOAT, sizeof(vaWord3_t),
+					&word3->normal );
+			
+			if( !backEnd.currentEntity->e.shaderRGBA[3] ) {
+				SetAttrPointer( &state, AL_COLOR, dataVBO->vbo,
+						4, GL_UNSIGNED_BYTE, sizeof(vaWord4_t),
+						&word4->color );
+			} else {
+				SetAttrVec4f( &state, AL_COLOR,
+					      backEnd.currentEntity->e.shaderRGBA[0] / 255.0f,
+					      backEnd.currentEntity->e.shaderRGBA[1] / 255.0f,
+					      backEnd.currentEntity->e.shaderRGBA[2] / 255.0f,
+					      backEnd.currentEntity->e.shaderRGBA[3] / 255.0f );
+			}
+			SetAttrPointer( &state, AL_TEXCOORD, dataVBO->vbo,
+					4, GL_FLOAT, sizeof(vaWord1_t),
+					&word1->tc1[0] );
+		
+		}
+		
+		GL_DrawElements( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				 minIndex, maxIndex, max );
+	}
+
+	if ( input->numIndexes > 0 ) {
+		vaWord1_t	*word1;
+		vaWord2_t	*word2;
+		vaWord3_t	*word3;
+		vaWord4_t	*word4;
+		GLuint		dataVBO;
+		
+		if ( input->vertexPtr1 ) {
+			dataVBO = 0;
+			max = input->numIndexes-1;
+			word1 = input->vertexPtr1;
+			word2 = input->vertexPtr2;
+			word3 = input->vertexPtr3;
+			word4 = input->vertexPtr4;
+		} else {
+			dataVBO = backEnd.worldVBO.vbo;
+			max = backEnd.worldVBO.maxIndex;
+			word1 = backEnd.worldVBO.offs1;
+			word2 = backEnd.worldVBO.offs2;
+			word3 = backEnd.worldVBO.offs3;
+			word4 = backEnd.worldVBO.offs4;
+		}
+
+		SetAttrPointer( &state, AL_NORMAL, dataVBO,
+				3, GL_FLOAT, sizeof(vaWord3_t),
+				&word3->normal );
+		
+		SetAttrPointer( &state, AL_VERTEX, dataVBO,
+				4, GL_FLOAT, sizeof(vaWord2_t),
+				&word2->xyz );
+
+		if( !backEnd.currentEntity->e.shaderRGBA[3] ) {
+			SetAttrPointer( &state, AL_COLOR, dataVBO,
+					4, GL_UNSIGNED_BYTE, sizeof(vaWord4_t),
+					&word4->color );
+		} else {
+			SetAttrVec4f( &state, AL_COLOR,
+				      backEnd.currentEntity->e.shaderRGBA[0] / 255.0f,
+				      backEnd.currentEntity->e.shaderRGBA[1] / 255.0f,
+				      backEnd.currentEntity->e.shaderRGBA[2] / 255.0f,
+				      backEnd.currentEntity->e.shaderRGBA[3] / 255.0f );
+		}
+		SetAttrPointer( &state, AL_TEXCOORD, dataVBO,
+				4, GL_FLOAT, sizeof(vaWord1_t),
+				&word1->tc1[0] );
+
+		//
+		// call shader function
+		//
+		GL_DrawElements( &state, input->numIndexes,
+				 0, input->indexPtr.p16,
+				 input->minIndex, input->maxIndex, max );
+	}
+	
+	if ( r_showtris->integer && !shader->isDepth ) {
+		for( VBO = input->firstVBO; VBO; VBO = VBO->next ) {
+			int		minIndex, maxIndex;
+			vboInfo_t	*dataVBO;
+			
+			if ( VBO->vbo ) {
+				dataVBO = VBO;
+			} else {
+				dataVBO = &backEnd.worldVBO;
+			}
+			
+			if( shader->lightmapIndex == LIGHTMAP_MD3 ) {
+				minIndex = 0;
+				maxIndex = dataVBO->maxIndex;
+			} else {
+				minIndex = VBO->minIndex;
+				maxIndex = VBO->maxIndex;
+			}
+			SetAttrPointer( &state, AL_VERTEX, dataVBO->vbo,
+					4, GL_FLOAT, sizeof(vaWord2_t),
+					&dataVBO->offs2->xyz );
+			
+			DrawTris( &state, VBO->numIndexes,
+				  VBO->ibo, VBO->offsIdx,
+				  VBO->minIndex,
+				  VBO->maxIndex, dataVBO->maxIndex,
+				  0.0f, 0.0f, 1.0f );
+		}
+		
+		if ( input->numIndexes > 0 ) {
+			vaWord2_t	*word2;
+			GLuint		dataVBO;
+
+			if ( input->vertexPtr1 ) {
+				dataVBO = 0;
+				max = input->numIndexes-1;
+				word2 = input->vertexPtr2;
+			} else {
+				dataVBO = backEnd.worldVBO.vbo;
+				max = backEnd.worldVBO.maxIndex;
+				word2 = backEnd.worldVBO.offs2;
+			}
+
+			SetAttrPointer( &state, AL_VERTEX, dataVBO,
+					4, GL_FLOAT, sizeof(vaWord2_t),
+					&word2->xyz );
+
+			DrawTris( &state, input->numIndexes,
+				  0, input->indexPtr.p16,
+				  input->minIndex, input->maxIndex, max,
+				  0.0f, 1.0f, 0.0f );
+		}
+	}
+	if ( r_shownormals->integer ) {
+		DrawNormals( &state );
+	}
+
+	if( glQueryID ) {
+		GL_EndQuery( glQueryID, glQueryResult );
+	}
 }
 
 /*
+** RB_StageIteratorPreparePortal
+*/
+void RB_StageIteratorPreparePortal( void ) {
+	vboInfo_t	*VBO;
+	int		level;
+	GLuint		stencilVal, stencilMask;
+	glRenderState_t state;
+	
+	InitState( &state );
+
+	// render mirror area to stencil buffer (depth test enabled)
+	state.stateBits = GLS_COLORMASK_FALSE;
+	state.faceCulling = CT_FRONT_SIDED;
+	level = backEnd.viewParms.portalLevel + 1;
+
+	SetAttrVec4f( &state, AL_COLOR,
+		      (level&4)?1.0f:0.0f,
+		      (level&2)?1.0f:0.0f,
+		      (level&1)?1.0f:0.0f,
+		      1.0f );
+
+	if( !backEnd.viewParms.portalLevel && !r_measureOverdraw->integer ) {
+		qglEnable( GL_STENCIL_TEST );
+	}
+	
+	stencilMask = (level - 1) << glGlobals.shadowBits;
+	stencilVal = (level ^ (level >> 1)) << glGlobals.shadowBits;
+	
+	qglStencilMask( glGlobals.portalMask );
+	qglStencilFunc( GL_EQUAL, stencilVal, stencilMask );
+	qglStencilOp( GL_KEEP, GL_KEEP, GL_REPLACE );
+	
+	for( VBO = tess.firstVBO; VBO; VBO = VBO->next ) {
+		int	max;
+
+		if ( VBO->vbo ) {
+			SetAttrPointer( &state, AL_VERTEX, VBO->vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&VBO->offs2->xyz );
+			max = VBO->maxIndex;
+		} else {
+			SetAttrPointer( &state, AL_VERTEX, backEnd.worldVBO.vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&backEnd.worldVBO.offs2->xyz );
+			max = backEnd.worldVBO.maxIndex;
+		}
+
+		SetAttrVec4f( &state, AL_TEXCOORD, 0.0f, 0.0f, 0.0f, 0.0f );
+		
+		GL_DrawElements( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				 VBO->minIndex, VBO->maxIndex, max );
+	}
+	
+	if ( tess.numIndexes > 0 ) {
+		int	max;
+
+		if ( tess.vertexPtr1 ) {
+			SetAttrPointer( &state, AL_VERTEX, 0,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&tess.vertexPtr2[0].xyz );
+			max = tess.numIndexes-1;
+		} else {
+			SetAttrPointer( &state, AL_VERTEX, backEnd.worldVBO.vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&backEnd.worldVBO.offs2->xyz );
+			max = backEnd.worldVBO.maxIndex;
+		}
+		SetAttrVec4f( &state, AL_TEXCOORD, 0.0f, 0.0f, 0.0f, 0.0f );
+		
+		//
+		// call shader function
+		//
+		GL_DrawElements( &state, tess.numIndexes, 0, tess.indexPtr.p16,
+				 tess.minIndex, tess.maxIndex, max );
+	}
+	
+	// set depth to max on mirror area (depth test disabled)
+	state.stateBits = GLS_COLORMASK_FALSE | GLS_DEPTHMASK_TRUE |
+		GLS_DEPTHRANGE_1_TO_1 | GLS_DEPTHFUNC_ALWAYS;
+
+	if( r_measureOverdraw->integer ) {
+		qglStencilMask( glGlobals.shadowMask );
+		qglStencilFunc( GL_EQUAL, stencilVal, glGlobals.portalMask );
+		qglStencilOp( GL_KEEP, GL_INCR, GL_INCR );
+	} else {
+		qglStencilFunc( GL_EQUAL, stencilVal, glGlobals.portalMask );
+		qglStencilOp( GL_KEEP, GL_KEEP, GL_KEEP );
+	}
+	
+	for( VBO = tess.firstVBO; VBO; VBO = VBO->next ) {
+		int	max;
+
+		if ( VBO->vbo ) {
+			SetAttrPointer( &state, AL_VERTEX, VBO->vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&VBO->offs2->xyz );
+			max = VBO->maxIndex;
+		} else {
+			SetAttrPointer( &state, AL_VERTEX, backEnd.worldVBO.vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&backEnd.worldVBO.offs2->xyz );
+			max = backEnd.worldVBO.maxIndex;
+		}
+
+		GL_DrawElements( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				 VBO->minIndex, VBO->maxIndex, max );
+	}
+	
+	if ( tess.numIndexes > 0 ) {
+		int	max;
+
+		if ( tess.vertexPtr1 ) {
+			SetAttrPointer( &state, AL_VERTEX, 0,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&tess.vertexPtr2[0].xyz );
+			max = tess.numIndexes-1;
+		} else {
+			SetAttrPointer( &state, AL_VERTEX, backEnd.worldVBO.vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&backEnd.worldVBO.offs2->xyz );
+			max = backEnd.worldVBO.maxIndex;
+		}
+		
+		//
+		// call shader function
+		//
+		GL_DrawElements( &state, tess.numIndexes, 0, tess.indexPtr.p16,
+				 tess.minIndex, tess.maxIndex, max );
+	}
+	// keep stencil test enabled !
+}
+
+/*
+** RB_StageIteratorFinalisePortal
+*/
+void RB_StageIteratorFinalisePortal( void ) {
+	vboInfo_t	*VBO;
+	int		level;
+	GLuint		stencilVal, stencilMask;
+	glRenderState_t state;
+
+	InitState( &state );
+	
+	// clear stencil bits
+	state.stateBits = GLS_COLORMASK_FALSE | GLS_DEPTHMASK_TRUE |
+		GLS_DEPTHRANGE_1_TO_1 | GLS_DEPTHFUNC_ALWAYS;
+	state.faceCulling = CT_FRONT_SIDED;
+	SetAttrVec4f( &state, AL_COLOR, 0.0f, 0.0f, 0.0f, 0.0f );
+	SetAttrVec4f( &state, AL_TEXCOORD, 0.0f, 0.0f, 0.0f, 0.0f );
+	
+	level = backEnd.viewParms.portalLevel;
+	stencilMask = level << glGlobals.shadowBits;
+	stencilVal = (level ^ (level >> 1)) << glGlobals.shadowBits;
+	
+	qglStencilMask( glGlobals.portalMask );
+	qglStencilFunc( GL_EQUAL, stencilVal, stencilMask );
+	qglStencilOp( GL_KEEP, GL_KEEP, GL_REPLACE );
+	
+	for( VBO = tess.firstVBO; VBO; VBO = VBO->next ) {
+		int	max;
+
+		if ( VBO->vbo ) {
+			SetAttrPointer( &state, AL_VERTEX, VBO->vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&VBO->offs2->xyz );
+			max = VBO->maxIndex;
+		} else {
+			SetAttrPointer( &state, AL_VERTEX, backEnd.worldVBO.vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&backEnd.worldVBO.offs2->xyz );
+			max = backEnd.worldVBO.maxIndex;
+		}
+
+		GL_DrawElements( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				 VBO->minIndex, VBO->maxIndex, max );
+	}
+	
+	if ( tess.numIndexes > 0 ) {
+		int	max;
+
+		if ( tess.vertexPtr1 ) {
+			SetAttrPointer( &state, AL_VERTEX, 0,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&tess.vertexPtr2[0].xyz );
+			max = tess.numIndexes-1;
+		} else {
+			SetAttrPointer( &state, AL_VERTEX, backEnd.worldVBO.vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&backEnd.worldVBO.offs2->xyz );
+			max = backEnd.worldVBO.maxIndex;
+		}
+		
+		//
+		// call shader function
+		//
+		GL_DrawElements( &state, tess.numIndexes, 0, tess.indexPtr.p16,
+				 tess.minIndex, tess.maxIndex, max );
+	}
+
+	if( !backEnd.viewParms.portalLevel ) {
+		if( r_measureOverdraw->integer ) {
+			qglStencilMask( glGlobals.shadowMask );
+			qglStencilFunc( GL_ALWAYS, 0, 0 );
+			qglStencilOp( GL_KEEP, GL_INCR, GL_INCR );
+		} else {
+			qglDisable( GL_STENCIL_TEST );
+		}
+	} else {
+		qglStencilFunc( GL_EQUAL, stencilVal, glGlobals.portalMask );
+		if( r_measureOverdraw->integer ) {
+			qglStencilMask( glGlobals.shadowMask );
+			qglStencilOp( GL_KEEP, GL_INCR, GL_INCR );
+		} else {
+			qglStencilOp( GL_KEEP, GL_KEEP, GL_KEEP );
+		}
+	}
+}
+
+/*
 ** RB_EndSurface
 */
 void RB_EndSurface( void ) {
@@ -1445,15 +2315,14 @@
 
 	input = &tess;
 
-	if (input->numIndexes == 0) {
+	RB_FlushVertexBuffer( );
+
+	if (input->numIndexes == 0 && !input->firstVBO ) {
 		return;
 	}
-
-	if (input->indexes[SHADER_MAX_INDEXES-1] != 0) {
-		ri.Error (ERR_DROP, "RB_EndSurface() - SHADER_MAX_INDEXES hit");
-	}	
-	if (input->xyz[SHADER_MAX_VERTEXES-1][0] != 0) {
-		ri.Error (ERR_DROP, "RB_EndSurface() - SHADER_MAX_VERTEXES hit");
+	
+	if ( !tess.shader ) {
+		return;
 	}
 
 	if ( tess.shader == tr.shadowShader ) {
@@ -1479,18 +2348,78 @@
 	//
 	tess.currentStageIteratorFunc();
 
+	if ( r_flush->integer ) {
+		qglFlush();
+	}
+
+	// clear shader so we can tell we don't have any unclosed surfaces
+	tess.numIndexes = 0;
+	tess.firstVBO = NULL;
+
+	GLimp_LogComment( "----------\n" );
+}
+
+/*
+** RB_LightSurface
+*/
+void RB_LightSurface( void ) {
+	shaderCommands_t *input;
+	glRenderState_t   state;
+
+	input = &tess;
+
+	if (input->numIndexes == 0) {
+		return;
+	}
+
+	// for debugging of sort order issues, stop rendering after a given sort value
+	if ( r_debugSort->integer && r_debugSort->integer < tess.shader->sort ) {
+		return;
+	}
+
+	RB_DeformTessGeometry();
+
 	//
-	// draw debugging stuff
+	// log this call
 	//
-	if ( r_showtris->integer ) {
-		DrawTris (input);
+	if ( r_logFile->integer ) 
+	{
+		// don't just call LogComment, or we will get
+		// a call to va() every frame!
+		GLimp_LogComment( va("--- RB_LightSurface( %s ) ---\n", tess.shader->name) );
 	}
-	if ( r_shownormals->integer ) {
-		DrawNormals (input);
+
+	InitState( &state );
+	//
+	// set face culling appropriately
+	//
+	state.faceCulling = input->shader->cullType;
+
+	SetAttrPointer( &state, AL_VERTEX, 0, 3, GL_FLOAT, sizeof(vaWord2_t),
+			input->vertexPtr2[0].xyz);
+
+	// 
+	// now do any dynamic lighting needed
+	//
+	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE
+	     && !(tess.shader->surfaceFlags & (SURF_NODLIGHT | SURF_SKY) ) ) {
+		ProjectDlightTexture( &state );
 	}
+	
+	//
+	// now do fog
+	//
+	if ( tess.fogNum && tess.shader->fogPass ) {
+		RB_FogPass( &state );
+	}
+
+	if ( r_flush->integer ) {
+		qglFlush();
+	}
+
 	// clear shader so we can tell we don't have any unclosed surfaces
 	tess.numIndexes = 0;
+	tess.firstVBO = NULL;
 
 	GLimp_LogComment( "----------\n" );
 }
-
Index: src/renderer/iqm.h
===================================================================
--- src/renderer/iqm.h	(Revision 0)
+++ src/renderer/iqm.h	(Revision 0)
@@ -0,0 +1,107 @@
+#ifndef __IQM_H__
+#define __IQM_H__
+
+#define IQM_MAGIC "INTERQUAKEMODEL"
+#define IQM_VERSION 1
+
+typedef struct iqmheader
+{
+    char magic[16];
+    unsigned int version;
+    unsigned int filesize;
+    unsigned int flags;
+    unsigned int num_text, ofs_text;
+    unsigned int num_meshes, ofs_meshes;
+    unsigned int num_vertexarrays, num_vertexes, ofs_vertexarrays;
+    unsigned int num_triangles, ofs_triangles, ofs_adjacency;
+    unsigned int num_joints, ofs_joints;
+    unsigned int num_poses, ofs_poses;
+    unsigned int num_anims, ofs_anims;
+    unsigned int num_frames, num_framechannels, ofs_frames, ofs_bounds;
+    unsigned int num_comment, ofs_comment;
+    unsigned int num_extensions, ofs_extensions;
+} iqmHeader_t;
+
+typedef struct iqmmesh
+{
+    unsigned int name;
+    unsigned int material;
+    unsigned int first_vertex, num_vertexes;
+    unsigned int first_triangle, num_triangles;
+} iqmMesh_t;
+
+enum
+{
+    IQM_POSITION     = 0,
+    IQM_TEXCOORD     = 1,
+    IQM_NORMAL       = 2,
+    IQM_TANGENT      = 3,
+    IQM_BLENDINDEXES = 4,
+    IQM_BLENDWEIGHTS = 5,
+    IQM_COLOR        = 6,
+    IQM_CUSTOM       = 0x10
+};
+
+enum
+{
+    IQM_BYTE   = 0,
+    IQM_UBYTE  = 1,
+    IQM_SHORT  = 2,
+    IQM_USHORT = 3,
+    IQM_INT    = 4,
+    IQM_UINT   = 5,
+    IQM_HALF   = 6,
+    IQM_FLOAT  = 7,
+    IQM_DOUBLE = 8,
+};
+
+typedef struct iqmtriangle
+{
+    unsigned int vertex[3];
+} iqmTriangle_t;
+
+typedef struct iqmjoint
+{
+    unsigned int name;
+    int parent;
+    float translate[3], rotate[3], scale[3];
+} iqmJoint_t;
+
+typedef struct iqmpose
+{
+    int parent;
+    unsigned int mask;
+    float channeloffset[9];
+    float channelscale[9];
+} iqmPose_t;
+
+typedef struct iqmanim
+{
+    unsigned int name;
+    unsigned int first_frame, num_frames;
+    float framerate;
+    unsigned int flags;
+} iqmAnim_t;
+
+enum
+{
+    IQM_LOOP = 1<<0
+};
+
+typedef struct iqmvertexarray
+{
+    unsigned int type;
+    unsigned int flags;
+    unsigned int format;
+    unsigned int size;
+    unsigned int offset;
+} iqmVertexArray_t;
+
+typedef struct iqmbounds
+{
+    float bbmin[3], bbmax[3];
+    float xyradius, radius;
+} iqmBounds_t;
+
+#endif
+
Index: src/renderer/tr_image_png.c
===================================================================
--- src/renderer/tr_image_png.c	(Revision 2062)
+++ src/renderer/tr_image_png.c	(Arbeitskopie)
@@ -1903,7 +1903,7 @@
  *  The PNG loader
  */
 
-void R_LoadPNG(const char *name, byte **pic, int *width, int *height)
+void R_LoadPNG(const char *name, texImage_t *pic, int *width, int *height)
 {
 	struct BufferedFile *ThePNG;
 	byte *OutBuffer;
@@ -1946,7 +1946,7 @@
 	 *  Zero out return values.
 	 */
 
-	*pic = NULL;
+	pic->numMipmaps = 0;
 
 	if(width)
 	{
@@ -2065,7 +2065,7 @@
 	{
 		CloseBufferedFile(ThePNG);
 
-		Com_Printf(S_COLOR_YELLOW "%s: invalid image size\n", name);
+		ri.Printf( PRINT_WARNING, "%s: invalid image size\n", name );
 
 		return; 
 	}
@@ -2458,7 +2458,9 @@
 	 *  update the pointer to the image data
 	 */
 
-	*pic = OutBuffer;
+	pic->format = GL_RGBA8;
+	pic->numMipmaps = 1;
+	pic->data[0] = OutBuffer;
 
 	/*
 	 *  Fill width and height.
Index: src/renderer/tr_world.c
===================================================================
--- src/renderer/tr_world.c	(Revision 2062)
+++ src/renderer/tr_world.c	(Arbeitskopie)
@@ -166,7 +166,12 @@
 	int			i;
 	dlight_t	*dl;
 
-	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
+        if ( !dlightBits ) { 
+		face->dlightBits[ tr.smpFrame ] = dlightBits; 
+		return dlightBits; 
+	} 
+	
+ 	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
 		if ( ! ( dlightBits & ( 1 << i ) ) ) {
 			continue;
 		}
@@ -190,7 +195,12 @@
 	int			i;
 	dlight_t	*dl;
 
-	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
+        if ( !dlightBits ) { 
+		grid->dlightBits[ tr.smpFrame ] = dlightBits; 
+		return dlightBits; 
+	}
+	
+ 	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
 		if ( ! ( dlightBits & ( 1 << i ) ) ) {
 			continue;
 		}
@@ -216,10 +226,6 @@
 
 
 static int R_DlightTrisurf( srfTriangles_t *surf, int dlightBits ) {
-	// FIXME: more dlight culling to trisurfs...
-	surf->dlightBits[ tr.smpFrame ] = dlightBits;
-	return dlightBits;
-#if 0
 	int			i;
 	dlight_t	*dl;
 
@@ -228,12 +234,12 @@
 			continue;
 		}
 		dl = &tr.refdef.dlights[i];
-		if ( dl->origin[0] - dl->radius > grid->meshBounds[1][0]
-			|| dl->origin[0] + dl->radius < grid->meshBounds[0][0]
-			|| dl->origin[1] - dl->radius > grid->meshBounds[1][1]
-			|| dl->origin[1] + dl->radius < grid->meshBounds[0][1]
-			|| dl->origin[2] - dl->radius > grid->meshBounds[1][2]
-			|| dl->origin[2] + dl->radius < grid->meshBounds[0][2] ) {
+		if ( dl->origin[0] - dl->radius > surf->bounds[1][0]
+			|| dl->origin[0] + dl->radius < surf->bounds[0][0]
+			|| dl->origin[1] - dl->radius > surf->bounds[1][1]
+			|| dl->origin[1] + dl->radius < surf->bounds[0][1]
+			|| dl->origin[2] - dl->radius > surf->bounds[1][2]
+			|| dl->origin[2] + dl->radius < surf->bounds[0][2] ) {
 			// dlight doesn't reach the bounds
 			dlightBits &= ~( 1 << i );
 		}
@@ -243,9 +249,8 @@
 		tr.pc.c_dlightSurfacesCulled++;
 	}
 
-	grid->dlightBits[ tr.smpFrame ] = dlightBits;
+	surf->dlightBits[ tr.smpFrame ] = dlightBits;
 	return dlightBits;
-#endif
 }
 
 /*
@@ -258,11 +263,11 @@
 ====================
 */
 static int R_DlightSurface( msurface_t *surf, int dlightBits ) {
-	if ( *surf->data == SF_FACE ) {
+	if ( surf->type == SF_FACE ) {
 		dlightBits = R_DlightFace( (srfSurfaceFace_t *)surf->data, dlightBits );
-	} else if ( *surf->data == SF_GRID ) {
+	} else if ( surf->type == SF_GRID ) {
 		dlightBits = R_DlightGrid( (srfGridMesh_t *)surf->data, dlightBits );
-	} else if ( *surf->data == SF_TRIANGLES ) {
+	} else if ( surf->type == SF_TRIANGLES ) {
 		dlightBits = R_DlightTrisurf( (srfTriangles_t *)surf->data, dlightBits );
 	} else {
 		dlightBits = 0;
@@ -282,7 +287,7 @@
 R_AddWorldSurface
 ======================
 */
-static void R_AddWorldSurface( msurface_t *surf, int dlightBits ) {
+static void R_AddWorldSurface( msurface_t *surf, int dlightBits, qboolean culled ) {
 	if ( surf->viewCount == tr.viewCount ) {
 		return;		// already in this view
 	}
@@ -291,17 +296,24 @@
 	// FIXME: bmodel fog?
 
 	// try to cull before dlighting or adding
-	if ( R_CullSurface( surf->data, surf->shader ) ) {
+	culled = culled || R_CullSurface( surf->data, surf->shader );
+	if ( !qglBindBufferARB && culled ) {
 		return;
 	}
 
-	// check for dlighting
-	if ( dlightBits ) {
+	if( !culled ) {
+		// check for dlighting
 		dlightBits = R_DlightSurface( surf, dlightBits );
 		dlightBits = ( dlightBits != 0 );
+	} else {
+		dlightBits = 0;
 	}
 
-	R_AddDrawSurf( surf->data, surf->shader, surf->fogIndex, dlightBits );
+	if( surf->shader->depthShader ) {
+		// no fog or light for the depth shader needed
+		R_AddDrawSurf( surf->data, surf->shader->depthShader, 0, 0, culled );
+	}
+	R_AddDrawSurf( surf->data, surf->shader, surf->fogIndex, dlightBits, culled );
 }
 
 /*
@@ -325,7 +337,7 @@
 
 	pModel = R_GetModelByHandle( ent->e.hModel );
 
-	bmodel = pModel->bmodel;
+	bmodel = pModel->modelData.brush.bmodel;
 
 	clip = R_CullLocalBox( bmodel->bounds );
 	if ( clip == CULL_OUT ) {
@@ -335,7 +347,7 @@
 	R_DlightBmodel( bmodel );
 
 	for ( i = 0 ; i < bmodel->numSurfaces ; i++ ) {
-		R_AddWorldSurface( bmodel->firstSurface + i, tr.currentEntity->needDlights );
+		R_AddWorldSurface( bmodel->firstSurface + i, tr.currentEntity->needDlights, qfalse );
 	}
 }
 
@@ -354,10 +366,11 @@
 R_RecursiveWorldNode
 ================
 */
-static void R_RecursiveWorldNode( mnode_t *node, int planeBits, int dlightBits ) {
-
+static void R_RecursiveWorldNode( mnode_t *node, int planeBits, int dlightBits,
+				  mnode_t ***culledNodes, qboolean culled ) {
 	do {
 		int			newDlights[2];
+		int			r;
 
 		// if the node wasn't marked as potentially visible, exit
 		if (node->visframe != tr.visCount) {
@@ -367,49 +380,54 @@
 		// if the bounding volume is outside the frustum, nothing
 		// inside can be visible OPTIMIZE: don't do this all the way to leafs?
 
-		if ( !r_nocull->integer ) {
-			int		r;
-
-			if ( planeBits & 1 ) {
-				r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[0]);
-				if (r == 2) {
-					return;						// culled
-				}
-				if ( r == 1 ) {
-					planeBits &= ~1;			// all descendants will also be in front
-				}
+		if ( planeBits & 1 ) {
+			r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[0]);
+			if (r == 2) {
+				culled = qtrue;				// culled
 			}
-
-			if ( planeBits & 2 ) {
-				r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[1]);
-				if (r == 2) {
-					return;						// culled
-				}
-				if ( r == 1 ) {
-					planeBits &= ~2;			// all descendants will also be in front
-				}
+			if ( r == 1 ) {
+				planeBits &= ~1;			// all descendants will also be in front
 			}
-
-			if ( planeBits & 4 ) {
-				r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[2]);
-				if (r == 2) {
-					return;						// culled
-				}
-				if ( r == 1 ) {
-					planeBits &= ~4;			// all descendants will also be in front
-				}
+		}
+		
+		if ( planeBits & 2 ) {
+			r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[1]);
+			if (r == 2) {
+				culled = qtrue;				// culled
 			}
+			if ( r == 1 ) {
+				planeBits &= ~2;			// all descendants will also be in front
+			}
+		}
+		
+		if ( planeBits & 4 ) {
+			r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[2]);
+			if (r == 2) {
+				culled = qtrue;				// culled
+			}
+			if ( r == 1 ) {
+				planeBits &= ~4;			// all descendants will also be in front
+			}
+		}
+		
+		if ( planeBits & 8 ) {
+			r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[3]);
+			if (r == 2) {
+				culled = qtrue;				// culled
+			}
+			if ( r == 1 ) {
+				planeBits &= ~8;			// all descendants will also be in front
+			}
+		}
 
-			if ( planeBits & 8 ) {
-				r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[3]);
-				if (r == 2) {
-					return;						// culled
-				}
-				if ( r == 1 ) {
-					planeBits &= ~8;			// all descendants will also be in front
-				}
+		if ( planeBits & 16 ) {
+			r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[4]);
+			if (r == 2) {
+				return;						// culled
 			}
-
+			if ( r == 1 ) {
+				planeBits &= ~16;			// all descendants will also be in front
+			}
 		}
 
 		if ( node->contents != -1 ) {
@@ -422,7 +440,7 @@
 		// determine which dlights are needed
 		newDlights[0] = 0;
 		newDlights[1] = 0;
-		if ( dlightBits ) {
+		if ( dlightBits && !culled ) {
 			int	i;
 
 			for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
@@ -444,14 +462,18 @@
 		}
 
 		// recurse down the children, front side first
-		R_RecursiveWorldNode (node->children[0], planeBits, newDlights[0] );
+		R_RecursiveWorldNode (node->children[0], planeBits, newDlights[0], culledNodes, culled );
 
 		// tail recurse
 		node = node->children[1];
 		dlightBits = newDlights[1];
 	} while ( 1 );
 
-	{
+	if( culled ) {
+		// culled nodes are added after the not-culled nodes
+		**culledNodes = node;
+		(*culledNodes)++;
+	} else {
 		// leaf node, so add mark surfaces
 		int			c;
 		msurface_t	*surf, **mark;
@@ -486,11 +508,10 @@
 			// the surface may have already been added if it
 			// spans multiple leafs
 			surf = *mark;
-			R_AddWorldSurface( surf, dlightBits );
+			R_AddWorldSurface( surf, dlightBits, qfalse );
 			mark++;
 		}
 	}
-
 }
 
 
@@ -580,12 +601,13 @@
 	// current viewcluster
 	leaf = R_PointInLeaf( tr.viewParms.pvsOrigin );
 	cluster = leaf->cluster;
+	tr.viewParms.viewCluster = cluster;
 
 	// if the cluster is the same and the area visibility matrix
 	// hasn't changed, we don't need to mark everything again
 
 	// if r_showcluster was just turned on, remark everything 
-	if ( tr.viewCluster == cluster && !tr.refdef.areamaskModified 
+	if ( tr.visCluster == cluster && !tr.refdef.areamaskModified
 		&& !r_showcluster->modified ) {
 		return;
 	}
@@ -598,9 +620,9 @@
 	}
 
 	tr.visCount++;
-	tr.viewCluster = cluster;
+	tr.visCluster = cluster;
 
-	if ( r_novis->integer || tr.viewCluster == -1 ) {
+	if ( r_novis->integer || tr.visCluster == -1 ) {
 		for (i=0 ; i<tr.world->numnodes ; i++) {
 			if (tr.world->nodes[i].contents != CONTENTS_SOLID) {
 				tr.world->nodes[i].visframe = tr.visCount;
@@ -609,7 +631,7 @@
 		return;
 	}
 
-	vis = R_ClusterPVS (tr.viewCluster);
+	vis = R_ClusterPVS (tr.viewParms.viewCluster);
 	
 	for (i=0,leaf=tr.world->nodes ; i<tr.world->numnodes ; i++, leaf++) {
 		cluster = leaf->cluster;
@@ -623,7 +645,8 @@
 		}
 
 		// check for door connection
-		if ( (tr.refdef.areamask[leaf->area>>3] & (1<<(leaf->area&7)) ) ) {
+		if ( !qglBindBufferARB &&
+		     (tr.refdef.areamask[leaf->area>>3] & (1<<(leaf->area&7)) ) ) {
 			continue;		// not visible
 		}
 
@@ -644,6 +667,8 @@
 =============
 */
 void R_AddWorldSurfaces (void) {
+	mnode_t **buf, **ptr;
+
 	if ( !r_drawworld->integer ) {
 		return;
 	}
@@ -660,10 +685,56 @@
 
 	// clear out the visible min/max
 	ClearBounds( tr.viewParms.visBounds[0], tr.viewParms.visBounds[1] );
-
+	
+	switch ( tr.viewParms.frustType ) {
+	case 1:
+		tr.viewParms.frustum[4].dist = tr.clusters[tr.viewParms.viewCluster].mins[0];
+		break;
+	case 2:
+		tr.viewParms.frustum[4].dist = -tr.clusters[tr.viewParms.viewCluster].maxs[0];
+		break;
+	case 3:
+		tr.viewParms.frustum[4].dist = tr.clusters[tr.viewParms.viewCluster].mins[1];
+		break;
+	case 4:
+		tr.viewParms.frustum[4].dist = -tr.clusters[tr.viewParms.viewCluster].maxs[1];
+		break;
+	case 5:
+		tr.viewParms.frustum[4].dist = tr.clusters[tr.viewParms.viewCluster].mins[2];
+		break;
+	case 6:
+		tr.viewParms.frustum[4].dist = -tr.clusters[tr.viewParms.viewCluster].maxs[2];
+		break;
+	}
+	
 	// perform frustum culling and add all the potentially visible surfaces
-	if ( tr.refdef.num_dlights > 32 ) {
-		tr.refdef.num_dlights = 32 ;
+	if ( tr.refdef.num_dlights > MAX_TEXTURE_DLIGHTS ) {
+		tr.refdef.num_dlights = MAX_TEXTURE_DLIGHTS ;
 	}
-	R_RecursiveWorldNode( tr.world->nodes, 15, ( 1 << tr.refdef.num_dlights ) - 1 );
+	
+	buf = ri.Hunk_AllocateTempMemory( (tr.world->numnodes - tr.world->numDecisionNodes) * sizeof(mnode_t *) );
+	ptr = buf;
+	R_RecursiveWorldNode( tr.world->nodes, tr.viewParms.frustPlanes, ( 1 << tr.refdef.num_dlights ) - 1, &ptr, qfalse );
+	if( qglGenBuffersARB ) {
+		while( ptr > buf ) {
+			int			c;
+			msurface_t	*surf, **mark;
+
+			ptr--;
+
+			tr.pc.c_leafs++;
+
+			// add the individual surfaces
+			mark = (*ptr)->firstmarksurface;
+			c = (*ptr)->nummarksurfaces;
+			while (c--) {
+				// the surface may have already been added if it
+				// spans multiple leafs
+				surf = *mark;
+				R_AddWorldSurface( surf, 0, qtrue );
+				mark++;
+			}
+		}
+	}
+	ri.Hunk_FreeTempMemory( buf );
 }
Index: src/renderer/tr_backend.c
===================================================================
--- src/renderer/tr_backend.c	(Revision 2062)
+++ src/renderer/tr_backend.c	(Arbeitskopie)
@@ -25,217 +25,146 @@
 backEndData_t	*backEndData[SMP_FRAMES];
 backEndState_t	backEnd;
 
-
-static float	s_flipMatrix[16] = {
-	// convert from our coordinate system (looking down X)
-	// to OpenGL's coordinate system (looking down -Z)
-	0, 0, -1, 0,
-	-1, 0, 0, 0,
-	0, 1, 0, 0,
-	0, 0, 0, 1
-};
-
-
 /*
-** GL_Bind
+** GL_BindTexture
+** 
+** binds a texture to texture unit 0 for texture manipulation.
+** This is called by the frontend, so it may use a separate context for SMP,
+** in which case the glState must not be changed !
 */
-void GL_Bind( image_t *image ) {
-	int texnum;
-
-	if ( !image ) {
-		ri.Printf( PRINT_WARNING, "GL_Bind: NULL image\n" );
-		texnum = tr.defaultImage->texnum;
-	} else {
-		texnum = image->texnum;
+void GL_BindTexture( int texnum ) {
+	if( GLimp_IsSMPActive() ) {
+		if( qglActiveTextureARB )
+			qglActiveTextureARB( GL_TEXTURE0_ARB );
+		qglBindTexture( GL_TEXTURE_2D, texnum );
+	} else if ( glState.currenttextures[0] != texnum ) {
+		glState.currenttextures[0] = texnum;
+		qglBindTexture( GL_TEXTURE_2D, texnum );
 	}
-
-	if ( r_nobind->integer && tr.dlightImage ) {		// performance evaluation option
-		texnum = tr.dlightImage->texnum;
-	}
-
-	if ( glState.currenttextures[glState.currenttmu] != texnum ) {
-		image->frameUsed = tr.frameCount;
-		glState.currenttextures[glState.currenttmu] = texnum;
-		qglBindTexture (GL_TEXTURE_2D, texnum);
-	}
 }
 
 /*
-** GL_SelectTexture
+** GL_UnbindAllTextures
+**
+** unbind all texture units for renderer cleanup.
 */
-void GL_SelectTexture( int unit )
-{
-	if ( glState.currenttmu == unit )
-	{
-		return;
-	}
+void GL_UnbindAllTextures( void ) {
+	int	i;
 
-	if ( unit == 0 )
-	{
-		qglActiveTextureARB( GL_TEXTURE0_ARB );
-		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE0_ARB )\n" );
-		qglClientActiveTextureARB( GL_TEXTURE0_ARB );
-		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE0_ARB )\n" );
+	for( i = 0; i < NUM_TEXTURE_BUNDLES; i++ ) {
+		if( i >= glGlobals.maxTextureImageUnits )
+			break;
+
+		if( glState.currenttextures[i] ) {
+			glState.currenttextures[i] = 0;
+			glState.texEnabled[i] = qfalse;
+			if( qglActiveTextureARB )
+				qglActiveTextureARB( GL_TEXTURE0_ARB + i );
+			qglBindTexture( GL_TEXTURE_2D, 0 );
+			qglDisable( GL_TEXTURE_2D );
+		}
 	}
-	else if ( unit == 1 )
-	{
-		qglActiveTextureARB( GL_TEXTURE1_ARB );
-		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE1_ARB )\n" );
-		qglClientActiveTextureARB( GL_TEXTURE1_ARB );
-		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE1_ARB )\n" );
-	} else {
-		ri.Error( ERR_DROP, "GL_SelectTexture: unit = %i", unit );
-	}
-
-	glState.currenttmu = unit;
 }
 
-
 /*
-** GL_BindMultitexture
+** GL_Bind
+**
+** bind a list of images to the texture units. For GLSL shader it's not
+** required to glEnable them and we may keep unused textures bound, so
+** we can avoid to rebind them later.
 */
-void GL_BindMultitexture( image_t *image0, GLuint env0, image_t *image1, GLuint env1 ) {
-	int		texnum0, texnum1;
-
-	texnum0 = image0->texnum;
-	texnum1 = image1->texnum;
-
-	if ( r_nobind->integer && tr.dlightImage ) {		// performance evaluation option
-		texnum0 = texnum1 = tr.dlightImage->texnum;
+static void GL_BindImages( int count, image_t **images, qboolean isGLSL ) {
+	int i, texnum;
+	
+	if( !qglActiveTextureARB && count > 1 ) {
+		ri.Printf( PRINT_WARNING, "GL_BindImages: Multitexturing not enabled\n" );
+		count = 1;
 	}
-
-	if ( glState.currenttextures[1] != texnum1 ) {
-		GL_SelectTexture( 1 );
-		image1->frameUsed = tr.frameCount;
-		glState.currenttextures[1] = texnum1;
-		qglBindTexture( GL_TEXTURE_2D, texnum1 );
+	
+	for( i = 0; i < count; i++ ) {
+		if ( !images[i] ) {
+			ri.Printf( PRINT_WARNING, "GL_BindImages: NULL image\n" );
+			texnum = tr.defaultImage->texnum;
+		} else {
+			texnum = images[i]->texnum;
+		}
+		
+		if ( r_nobind->integer && tr.dlightImage ) {		// performance evaluation option
+			texnum = tr.dlightImage->texnum;
+		}
+		
+		if ( glState.currenttextures[i] != texnum ) {
+			images[i]->frameUsed = tr.frameCount;
+			glState.currenttextures[i] = texnum;
+			if( qglActiveTextureARB )
+				qglActiveTextureARB( GL_TEXTURE0_ARB + i );
+			qglBindTexture( GL_TEXTURE_2D, texnum );
+		}
+		if( !isGLSL /*&& !glState.texEnabled[i]*/ ) {
+			qglEnable( GL_TEXTURE_2D );
+			glState.texEnabled[i] = qtrue;
+		}
 	}
-	if ( glState.currenttextures[0] != texnum0 ) {
-		GL_SelectTexture( 0 );
-		image0->frameUsed = tr.frameCount;
-		glState.currenttextures[0] = texnum0;
-		qglBindTexture( GL_TEXTURE_2D, texnum0 );
-	}
-}
 
+	// have to disable further textures for non-GLSL shaders
+	for( ; i < MAX_SHADER_STAGES; i++ ) {
+		if( i >= glGlobals.maxTextureImageUnits )
+			break;
 
-/*
-** GL_Cull
-*/
-void GL_Cull( int cullType ) {
-	if ( glState.faceCulling == cullType ) {
-		return;
-	}
+		if( glState.currenttextures[i] ) {
+			if( qglActiveTextureARB )
+				qglActiveTextureARB( GL_TEXTURE0_ARB + i );
+			qglBindTexture( GL_TEXTURE_2D, 0 );
+			glState.currenttextures[i] = 0;
 
-	glState.faceCulling = cullType;
-
-	if ( cullType == CT_TWO_SIDED ) 
-	{
-		qglDisable( GL_CULL_FACE );
-	} 
-	else 
-	{
-		qglEnable( GL_CULL_FACE );
-
-		if ( cullType == CT_BACK_SIDED )
-		{
-			if ( backEnd.viewParms.isMirror )
-			{
-				qglCullFace( GL_FRONT );
+			if( !isGLSL && glState.texEnabled[i] ) {
+				qglDisable( GL_TEXTURE_2D );
+				glState.texEnabled[i] = qfalse;
 			}
-			else
-			{
-				qglCullFace( GL_BACK );
-			}
 		}
-		else
-		{
-			if ( backEnd.viewParms.isMirror )
-			{
-				qglCullFace( GL_BACK );
-			}
-			else
-			{
-				qglCullFace( GL_FRONT );
-			}
-		}
 	}
 }
 
 /*
-** GL_TexEnv
-*/
-void GL_TexEnv( int env )
-{
-	if ( env == glState.texEnv[glState.currenttmu] )
-	{
-		return;
-	}
+==================
+SetRenderState
 
-	glState.texEnv[glState.currenttmu] = env;
-
-
-	switch ( env )
-	{
-	case GL_MODULATE:
-		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
-		break;
-	case GL_REPLACE:
-		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );
-		break;
-	case GL_DECAL:
-		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL );
-		break;
-	case GL_ADD:
-		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_ADD );
-		break;
-	default:
-		ri.Error( ERR_DROP, "GL_TexEnv: invalid env '%d' passed\n", env );
-		break;
-	}
-}
-
-/*
-** GL_State
-**
-** This routine is responsible for setting the most commonly changed state
-** in Q3.
+set all OpenGL state to the values passed in state, avoid calling gl functions
+if the state doesn't actually change
+==================
 */
-void GL_State( unsigned long stateBits )
-{
+static void GL_State( unsigned long stateBits ) {
 	unsigned long diff = stateBits ^ glState.glStateBits;
 
-	if ( !diff )
-	{
+	if ( !diff ) {
 		return;
 	}
 
 	//
 	// check depthFunc bits
 	//
-	if ( diff & GLS_DEPTHFUNC_EQUAL )
-	{
-		if ( stateBits & GLS_DEPTHFUNC_EQUAL )
-		{
+	if ( diff & GLS_DEPTHFUNC_BITS ) {
+		switch( stateBits & GLS_DEPTHFUNC_BITS ) {
+		case GLS_DEPTHFUNC_EQUAL:
 			qglDepthFunc( GL_EQUAL );
-		}
-		else
-		{
+			break;
+		case GLS_DEPTHFUNC_ALWAYS:
+			qglDepthFunc( GL_ALWAYS );
+			break;
+		default:
 			qglDepthFunc( GL_LEQUAL );
+			break;
 		}
 	}
 
 	//
 	// check blend bits
 	//
-	if ( diff & ( GLS_SRCBLEND_BITS | GLS_DSTBLEND_BITS ) )
-	{
+	if ( diff & ( GLS_SRCBLEND_BITS | GLS_DSTBLEND_BITS ) ) {
 		GLenum srcFactor, dstFactor;
 
-		if ( stateBits & ( GLS_SRCBLEND_BITS | GLS_DSTBLEND_BITS ) )
-		{
-			switch ( stateBits & GLS_SRCBLEND_BITS )
-			{
+		if ( stateBits & ( GLS_SRCBLEND_BITS | GLS_DSTBLEND_BITS ) ) {
+			switch ( stateBits & GLS_SRCBLEND_BITS ) {
 			case GLS_SRCBLEND_ZERO:
 				srcFactor = GL_ZERO;
 				break;
@@ -269,8 +198,7 @@
 				break;
 			}
 
-			switch ( stateBits & GLS_DSTBLEND_BITS )
-			{
+			switch ( stateBits & GLS_DSTBLEND_BITS ) {
 			case GLS_DSTBLEND_ZERO:
 				dstFactor = GL_ZERO;
 				break;
@@ -313,29 +241,41 @@
 	//
 	// check depthmask
 	//
-	if ( diff & GLS_DEPTHMASK_TRUE )
-	{
-		if ( stateBits & GLS_DEPTHMASK_TRUE )
-		{
+	if ( diff & GLS_DEPTHMASK_TRUE ) {
+		if ( stateBits & GLS_DEPTHMASK_TRUE ) {
 			qglDepthMask( GL_TRUE );
-		}
-		else
-		{
+		} else {
 			qglDepthMask( GL_FALSE );
 		}
 	}
 
 	//
+	// check colormask
+	//
+	if ( diff & GLS_COLORMASK_FALSE ) {
+		if ( stateBits & GLS_COLORMASK_FALSE ) {
+			qglColorMask( GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE );
+		} else {
+			qglColorMask( GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE );
+		}
+	}
+
+	// check polygon offset
+	if ( diff & GLS_POLYGON_OFFSET ) {
+		if ( stateBits & GLS_POLYGON_OFFSET ) {
+			qglEnable( GL_POLYGON_OFFSET_FILL );
+			qglPolygonOffset( r_offsetFactor->value, r_offsetUnits->value );
+		} else {
+			qglDisable( GL_POLYGON_OFFSET_FILL );
+		}
+	}
+	//
 	// fill/line mode
 	//
-	if ( diff & GLS_POLYMODE_LINE )
-	{
-		if ( stateBits & GLS_POLYMODE_LINE )
-		{
+	if ( diff & GLS_POLYMODE_LINE ) {
+		if ( stateBits & GLS_POLYMODE_LINE ) {
 			qglPolygonMode( GL_FRONT_AND_BACK, GL_LINE );
-		}
-		else
-		{
+		} else {
 			qglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
 		}
 	}
@@ -343,25 +283,39 @@
 	//
 	// depthtest
 	//
-	if ( diff & GLS_DEPTHTEST_DISABLE )
-	{
-		if ( stateBits & GLS_DEPTHTEST_DISABLE )
-		{
+	if ( diff & GLS_DEPTHTEST_DISABLE ) {
+		if ( stateBits & GLS_DEPTHTEST_DISABLE ) {
 			qglDisable( GL_DEPTH_TEST );
-		}
-		else
-		{
+		} else {
 			qglEnable( GL_DEPTH_TEST );
 		}
 	}
 
 	//
+	// depth range
+	//
+	if ( diff & GLS_DEPTHRANGE_BITS ) {
+		switch ( stateBits & GLS_DEPTHRANGE_BITS ) {
+		case GLS_DEPTHRANGE_0_TO_1:
+			qglDepthRange( 0.0f, 1.0f );
+			break;
+		case GLS_DEPTHRANGE_0_TO_0:
+			qglDepthRange( 0.0f, 0.0f );
+			break;
+		case GLS_DEPTHRANGE_1_TO_1:
+			qglDepthRange( 1.0f, 1.0f );
+			break;
+		case GLS_DEPTHRANGE_0_TO_03:
+			qglDepthRange( 0.0f, 0.3f );
+			break;
+		}
+	}
+
+	//
 	// alpha test
 	//
-	if ( diff & GLS_ATEST_BITS )
-	{
-		switch ( stateBits & GLS_ATEST_BITS )
-		{
+	if ( diff & GLS_ATEST_BITS ) {
+		switch ( stateBits & GLS_ATEST_BITS ) {
 		case 0:
 			qglDisable( GL_ALPHA_TEST );
 			break;
@@ -385,10 +339,590 @@
 
 	glState.glStateBits = stateBits;
 }
+static void GL_Cull( int cullType ) {
+	if ( glState.faceCulling == cullType ) {
+		return;
+	}
 
+	glState.faceCulling = cullType;
 
+	if ( cullType == CT_TWO_SIDED ) 
+	{
+		qglDisable( GL_CULL_FACE );
+	} 
+	else 
+	{
+		qglEnable( GL_CULL_FACE );
 
+		if ( cullType == CT_BACK_SIDED )
+		{
+			if ( backEnd.viewParms.isMirror )
+			{
+				qglCullFace( GL_FRONT );
+			}
+			else
+			{
+				qglCullFace( GL_BACK );
+			}
+		}
+		else
+		{
+			if ( backEnd.viewParms.isMirror )
+			{
+				qglCullFace( GL_BACK );
+			}
+			else
+			{
+				qglCullFace( GL_FRONT );
+			}
+		}
+	}
+}
+void GL_Program( GLSLprogram_t *program )
+{
+	if ( glState.currentProgram != program ) {
+		glState.currentProgram = program;
+		qglUseProgram( program ? program->handle : 0 );
+	}
+}
+static void DisableAttributePointer( int attr ) {
+	switch( attr ) {
+	case AL_VERTEX:
+		qglDisableClientState( GL_VERTEX_ARRAY );
+		break;
+	case AL_NORMAL:
+		qglDisableClientState( GL_NORMAL_ARRAY );
+		break;
+	case AL_COLOR:
+		qglDisableClientState( GL_COLOR_ARRAY );
+		break;
+	case AL_TEXCOORD:
+	case AL_TEXCOORD2:
+	case AL_TEXCOORD3:
+	case AL_TEXCOORD4:
+		if( qglClientActiveTextureARB )
+			qglClientActiveTextureARB( attr - AL_TEXCOORD + GL_TEXTURE0_ARB );
+		qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
+		break;
+	default:
+		qglDisableVertexAttribArrayARB( attr );
+		break;
+	}
+}
+static void EnableAttributePointer( int attr ) {
+	switch( attr ) {
+	case AL_VERTEX:
+		qglEnableClientState( GL_VERTEX_ARRAY );
+		break;
+	case AL_NORMAL:
+		qglEnableClientState( GL_NORMAL_ARRAY );
+		break;
+	case AL_COLOR:
+		qglEnableClientState( GL_COLOR_ARRAY );
+		break;
+	case AL_TEXCOORD:
+	case AL_TEXCOORD2:
+	case AL_TEXCOORD3:
+	case AL_TEXCOORD4:
+		if( qglClientActiveTextureARB )
+			qglClientActiveTextureARB( attr - AL_TEXCOORD + GL_TEXTURE0_ARB );
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+		break;
+	default:
+		qglEnableVertexAttribArrayARB( attr );
+		break;
+	}
+}
+static void SetAttribute4f( int attr, vec_t *values ) {
+	switch( attr ) {
+	case AL_VERTEX:
+		qglVertex4fv( values );
+		break;
+	case AL_NORMAL:
+		qglNormal3fv( values );
+		break;
+	case AL_COLOR:
+		qglColor4fv( values );
+		break;
+	case AL_TEXCOORD:
+		qglTexCoord4fv( values );
+		break;
+	case AL_TEXCOORD2:
+	case AL_TEXCOORD3:
+	case AL_TEXCOORD4:
+		if( qglMultiTexCoord4fvARB )
+			qglMultiTexCoord4fvARB( attr - AL_TEXCOORD + GL_TEXTURE0_ARB, values );
+		break;
+	default:
+		qglVertexAttrib4fvARB( attr, values );
+		break;
+	}
+	glState.glAttribute[attr].attrStatus = attrIsValue;
+	glState.glAttribute[attr].currentValues[0] = values[0];
+	glState.glAttribute[attr].currentValues[1] = values[1];
+	glState.glAttribute[attr].currentValues[2] = values[2];
+	glState.glAttribute[attr].currentValues[3] = values[3];
+}
+static void SetAttributePointer( int attr, GLuint VBO, GLint size,
+				 GLenum type, GLsizei stride, void *ptr ) {
+	GL_VBO( VBO );
+	switch( attr ) {
+	case AL_VERTEX:
+		qglVertexPointer( size, type, stride, ptr );
+		break;
+	case AL_NORMAL:
+		qglNormalPointer( type, stride, ptr );
+		break;
+	case AL_COLOR:
+		qglColorPointer( size, type, stride, ptr );
+		break;
+	case AL_TEXCOORD:
+	case AL_TEXCOORD2:
+	case AL_TEXCOORD3:
+	case AL_TEXCOORD4:
+		if( qglClientActiveTextureARB )
+			qglClientActiveTextureARB( attr - AL_TEXCOORD + GL_TEXTURE0_ARB );
+		qglTexCoordPointer( size, type, stride, ptr );
+		break;
+	default:
+		qglVertexAttribPointerARB( attr, size, type, GL_FALSE, stride, ptr );
+		break;
+	}
+	glState.glAttribute[attr].attrStatus = attrIsPointer;
+	glState.glAttribute[attr].vbo = VBO;
+	glState.glAttribute[attr].ptr = ptr;
+}
+static void SetRenderState( glRenderState_t *state, qboolean *doLock ) {
+	int i;
+	unsigned int attributes;
+
+	if(backEnd.currentEntity &&
+	   (backEnd.currentEntity->e.renderfx & RF_DEPTHHACK) ) {
+		if( (state->stateBits & GLS_DEPTHRANGE_BITS) == GLS_DEPTHRANGE_0_TO_1 )
+			state->stateBits |= GLS_DEPTHRANGE_0_TO_03;
+	}
+
+	GL_State( state->stateBits );
+	GL_Cull( state->faceCulling );
+	GL_Program( state->program );
+	GL_BindImages( state->numImages, state->image, state->program != NULL );
+
+	if( state->program )
+		attributes = state->program->attributes;
+	else
+		attributes = (1 << AL_VERTEX) | (1 << AL_NORMAL) |
+			(1 << AL_COLOR) | (1 << AL_TEXCOORD) |
+			(1 << AL_TEXCOORD2) | (1 << AL_TEXCOORD3) |
+			(1 << AL_TEXCOORD4);
+
+	*doLock = qfalse;
+	for( i = 0; i < AL_NUMATTRIBUTES; i++ ) {
+		if( state->attrib[i].attrType == RA_UNSPEC ||
+		    !(attributes & (1 << i)) ) {
+			if( glState.glAttribute[i].attrStatus == attrIsPointer ) {
+				// diable pointer for unspecified attrs,
+				// otherwise OpenGL may segfault
+				DisableAttributePointer( i );
+				glState.glAttribute[i].attrStatus = attrIsUndefined;
+			}
+		} else if( state->attrib[i].attrType == RA_VEC ) {
+			if( glState.glAttribute[i].attrStatus == attrIsPointer ) {
+				DisableAttributePointer( i );
+				SetAttribute4f( i, state->attrib[i].vec );
+			} else if( glState.glAttribute[i].attrStatus == attrIsValue &&
+				   glState.glAttribute[i].currentValues[0] == state->attrib[i].vec[0] &&
+				   glState.glAttribute[i].currentValues[1] == state->attrib[i].vec[1] &&
+				   glState.glAttribute[i].currentValues[2] == state->attrib[i].vec[2] &&
+				   glState.glAttribute[i].currentValues[3] == state->attrib[i].vec[3] ) {
+				// do nothing, unchanged attribute
+			} else {
+				SetAttribute4f( i, state->attrib[i].vec );
+			}
+		} else {
+			if( state->attrib[i].VBO == 0 )
+				*doLock = qtrue;
+
+			if( glState.glAttribute[i].attrStatus == attrIsPointer ) {
+				if( state->attrib[i].VBO == 0 ||
+				    state->attrib[i].VBO == backEnd.streamVBO.ibo ||
+				    glState.glAttribute[i].vbo != state->attrib[i].VBO ||
+				    glState.glAttribute[i].ptr != state->attrib[i].ptr ) {
+					// pointer or VBO changed
+					// for VBO 0/streamVBO the pointer is always updated
+					// because the engine may reuse buffers
+					SetAttributePointer( i, state->attrib[i].VBO,
+							     state->attrib[i].size,
+							     state->attrib[i].type,
+							     state->attrib[i].stride,
+							     state->attrib[i].ptr );
+				}
+			} else {
+				EnableAttributePointer( i );
+				SetAttributePointer( i, state->attrib[i].VBO,
+						     state->attrib[i].size,
+						     state->attrib[i].type,
+						     state->attrib[i].stride,
+						     state->attrib[i].ptr );
+			}
+		}
+	}
+}
+
+void GL_StartQuery( GLuint query, GLuint *result ) {
+	if( !(*result & QUERY_RUNNING_BIT) )
+		qglBeginQueryARB( GL_SAMPLES_PASSED_ARB, query );
+}
+void GL_EndQuery( GLuint query, GLuint *result ) {
+	if( !(*result & QUERY_RUNNING_BIT) )
+		qglEndQueryARB( GL_SAMPLES_PASSED_ARB );
+	*result |= QUERY_RUNNING_BIT;
+}
+void GL_GetQuery( GLuint query, GLuint *result ) {
+	GLuint available;
+
+	if( *result & QUERY_RUNNING_BIT ) {
+		qglGetQueryObjectuivARB( query,
+					 GL_QUERY_RESULT_AVAILABLE_ARB,
+					 &available);
+		if ( available ) {
+			qglGetQueryObjectuivARB( query,
+						 GL_QUERY_RESULT_ARB,
+						 result);
+
+			if( *result & QUERY_RUNNING_BIT )
+				*result = QUERY_MASK;		// overflow
+		}
+	}
+}
+
+void GL_DrawElements( glRenderState_t *state,
+		      int numIndexes, GLuint IBO, const void *indexes,
+		      GLuint start, GLuint end, GLuint max ) {
+	GLenum  type = max > 65535 ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT;
+	qboolean doLock;
+
+	if( numIndexes <= 0 )
+		return;
+
+	SetRenderState( state, &doLock );
+	GL_IBO( IBO );
+	
+	if( doLock && qglLockArraysEXT ) {
+		qglLockArraysEXT( start, end - start + 1 );
+	}
+	if ( qglDrawRangeElementsEXT )
+		qglDrawRangeElementsEXT( GL_TRIANGLES, 
+					 start, end,
+					 numIndexes,
+					 type,
+					 indexes );
+	else
+		qglDrawElements( GL_TRIANGLES,
+				 numIndexes,
+				 type,
+				 indexes );
+	if( doLock && qglLockArraysEXT ) {
+		qglUnlockArraysEXT( );
+	}
+}
+void GL_DrawArrays( glRenderState_t *state,
+		    GLenum mode, GLint first, GLuint count ) {
+	qboolean doLock;
+
+	SetRenderState( state, &doLock );
+	
+	if( doLock && qglLockArraysEXT ) {
+		qglLockArraysEXT( first, count );
+	}
+	qglDrawArrays( mode, first, count );
+	if( doLock && qglLockArraysEXT ) {
+		qglUnlockArraysEXT( );
+	}
+}
+
+
 /*
+** GL_TexEnv
+*/
+void GL_TexEnv( int tmu, int env )
+{
+	if ( env == glState.texEnv[tmu] )
+	{
+		return;
+	}
+
+	if( qglActiveTextureARB ) {
+		glState.texEnv[tmu] = env;
+		qglActiveTextureARB( GL_TEXTURE0_ARB + tmu );
+	}
+
+	switch ( env )
+	{
+	case GL_MODULATE:
+		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
+		break;
+	case GL_REPLACE:
+		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );
+		break;
+	case GL_DECAL:
+		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL );
+		break;
+	case GL_ADD:
+		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_ADD );
+		break;
+	default:
+		ri.Error( ERR_DROP, "GL_TexEnv: invalid env '%d' passed\n", env );
+		break;
+	}
+}
+
+/*
+** GL_State
+**
+** This routine is responsible for setting the most commonly changed state
+** in Q3.
+*/
+void GL_VBO( GLuint vbo )
+{
+	if ( glState.currentVBO != vbo ) {
+		glState.currentVBO = vbo;
+		qglBindBufferARB (GL_ARRAY_BUFFER_ARB, vbo );
+	}
+}
+void GL_IBO( GLuint ibo )
+{
+	if ( glState.currentIBO != ibo ) {
+		glState.currentIBO = ibo;
+		qglBindBufferARB (GL_ELEMENT_ARRAY_BUFFER_ARB, ibo );
+	}
+}
+
+// simple, fast allocator for the backend thread
+// memory must be freed in LIFO order
+static byte	*scratchStart, *scratchPtr;
+static size_t	freeScratch;
+void RB_InitScratchMemory( void ) {
+	freeScratch = r_scratchmegs->integer;
+	if( freeScratch <= SMP_SCRATCHMEGS )
+		freeScratch = SMP_SCRATCHMEGS;
+	freeScratch *= 1024 * 1024;
+
+	scratchStart = scratchPtr = ri.Hunk_Alloc( freeScratch, h_low );
+}
+void *RB_AllocScratch( size_t amount ) {
+	byte *mem = scratchPtr;
+
+	amount = (amount + 31) & -32;
+	if( amount > freeScratch ) {
+		ri.Error( ERR_DROP, "RB_AllocScratch: out of scratch memory, try to increase /r_scratchmegs\n" );
+	}
+	scratchPtr += amount;
+	freeScratch -= amount;
+	return mem;
+}
+void RB_FreeScratch( void *ptr ) {
+	if( (byte *)ptr < scratchStart || (byte *)ptr > scratchPtr ) {
+		ri.Error( ERR_DROP, "RB_FreeScratch: bad pointer\n" );
+	}
+	freeScratch += (scratchPtr - (byte *)ptr);
+	scratchPtr = ptr;
+}
+
+GLSLshader_t *RB_CompileShader( GLenum type, const char **code, int parts ) {
+	GLSLshader_t	*shader;
+	GLint 		status;
+	GLint		i, j;
+	unsigned int	hash;
+	const char	*ptr;
+	
+	// try to reuse existing shader
+	for( i = 0, hash = 0; i < parts; i++ ) {
+		for( ptr = code[i]; *ptr; ptr++ ) {
+			hash = *ptr + hash * 65599;
+		}
+	}
+	
+	for( i = 0; i < tr.numGLSLshaders; i++ ) {
+		if( tr.GLSLshaders[i]->hash == hash ) {
+			GLint   length;
+			char    *source, *sourcePtr;
+			qboolean same = qtrue;
+
+			qglGetShaderiv( tr.GLSLshaders[i]->handle,
+					GL_SHADER_SOURCE_LENGTH,
+					&length );
+			sourcePtr = source = ri.Hunk_AllocateTempMemory( length + 1 );
+			qglGetShaderSource( tr.GLSLshaders[i]->handle, length + 1,
+					    NULL, source );
+			
+			for( j = 0; j < parts; j++ ) {
+				for( ptr = code[j]; *ptr; ptr++, sourcePtr++ ) {
+					if( *ptr != *sourcePtr )
+						break;
+				}
+			}
+			same = *sourcePtr == '\0';
+			ri.Hunk_FreeTempMemory( source );
+
+			if( same )
+				return tr.GLSLshaders[i];
+		}
+	}
+
+	shader = ri.Hunk_Alloc( sizeof(GLSLprogram_t), h_low );
+	shader->handle = qglCreateShader( type );
+	shader->hash = hash;
+	qglShaderSource( shader->handle, parts, code, NULL );
+	qglCompileShader( shader->handle );
+	qglGetShaderiv( shader->handle, GL_OBJECT_COMPILE_STATUS_ARB, &status );
+	if( !status ) {
+		char *log;
+		GLint len;
+		qglGetShaderiv( shader->handle, GL_OBJECT_INFO_LOG_LENGTH_ARB, &len );
+		log = ri.Hunk_AllocateTempMemory( len + 1 );
+		qglGetShaderInfoLog( shader->handle, len + 1, &len, log );
+		
+		ri.Printf( PRINT_WARNING, "compile shader error: %s\n", log );
+		while( parts > 0 ) {
+			ri.Printf( PRINT_WARNING, "%s", *(code++) );
+			parts--;
+		}
+		
+		ri.Hunk_FreeTempMemory( log );
+		qglDeleteShader( shader->handle );
+		return NULL;
+	}
+	tr.GLSLshaders[tr.numGLSLshaders++] = shader;
+	return shader;
+}
+
+GLSLprogram_t *RB_CompileGSProgram( const char *name,
+				    const char **VScode, int VSparts,
+				    const char **GScode, int GSparts,
+				    int nVerticesOut, int inType, int outType,
+				    const char **FScode, int FSparts,
+				    unsigned int attributes ) {
+	GLSLshader_t	*VertexShader = NULL;
+	GLSLshader_t	*GeometryShader = NULL;
+	GLSLshader_t	*FragmentShader = NULL;
+	GLint		Program;
+	GLint		i;
+	GLSLprogram_t	*newProgram;
+
+	// find shaders
+	if( VSparts > 0 ) {
+		VertexShader = RB_CompileShader( GL_VERTEX_SHADER_ARB, VScode, VSparts );
+		if( !VertexShader )
+			return NULL;  // compilation error
+	}
+	if( GSparts > 0 ) {
+		GeometryShader = RB_CompileShader( GL_GEOMETRY_SHADER_EXT, GScode, GSparts );
+		if( !GeometryShader )
+			return NULL;  // compilation error
+	}
+	if( FSparts > 0 ) {
+		FragmentShader = RB_CompileShader( GL_FRAGMENT_SHADER_ARB, FScode, FSparts );
+		if( !FragmentShader )
+			return NULL;  // compilation error
+	}
+
+	// try to reuse existing program
+	for( i = 0; i < tr.numGLSLprograms; i++ ) {
+		if( tr.GLSLprograms[i]->vertex == VertexShader &&
+		    tr.GLSLprograms[i]->geometry == GeometryShader &&
+		    tr.GLSLprograms[i]->fragment == FragmentShader ) {
+			return tr.GLSLprograms[i];
+		}
+	}
+
+	Program = qglCreateProgram();
+	if( VertexShader )
+		qglAttachShader( Program, VertexShader->handle );
+	if( GeometryShader ) {
+		qglAttachShader( Program, GeometryShader->handle );
+
+		qglProgramParameteriEXT( Program, GL_GEOMETRY_VERTICES_OUT_EXT, nVerticesOut );
+		qglProgramParameteriEXT( Program, GL_GEOMETRY_INPUT_TYPE_EXT, inType );
+		qglProgramParameteriEXT( Program, GL_GEOMETRY_OUTPUT_TYPE_EXT, outType );
+	}
+	if( FragmentShader )
+		qglAttachShader( Program, FragmentShader->handle );
+	
+	if( attributes & (1 << AL_CAMERAPOS) )
+		qglBindAttribLocationARB( Program, AL_CAMERAPOS,     "aCameraPos" );
+	if( attributes & (1 << AL_TIMES) )
+		qglBindAttribLocationARB( Program, AL_TIMES,         "aTimes" );
+	if( attributes & (1 << AL_TRANSX) )
+		qglBindAttribLocationARB( Program, AL_TRANSX,        "aTransX" );
+	if( attributes & (1 << AL_TRANSY) )
+		qglBindAttribLocationARB( Program, AL_TRANSY,        "aTransY" );
+	if( attributes & (1 << AL_TRANSZ) )
+		qglBindAttribLocationARB( Program, AL_TRANSZ,        "aTransZ" );
+	if( attributes & (1 << AL_AMBIENTLIGHT) )
+		qglBindAttribLocationARB( Program, AL_AMBIENTLIGHT,  "aAmbientLight" );
+	if( attributes & (1 << AL_DIRECTEDLIGHT) )
+		qglBindAttribLocationARB( Program, AL_DIRECTEDLIGHT, "aDirectedLight" );
+	if( attributes & (1 << AL_LIGHTDIR) )
+		qglBindAttribLocationARB( Program, AL_LIGHTDIR,      "aLightDir" );
+	
+	qglLinkProgram( Program );
+	qglGetProgramiv( Program, GL_OBJECT_LINK_STATUS_ARB, &i );
+	if ( !i ) {
+		char *log;
+		qglGetProgramiv( Program, GL_OBJECT_INFO_LOG_LENGTH_ARB, &i );
+		log = ri.Hunk_AllocateTempMemory( i + 1 );
+		qglGetProgramInfoLog( Program, i + 1, &i, log );
+		
+		ri.Printf( PRINT_WARNING, "link shader %s error: %s\n", name, log );
+		while( VSparts > 0 ) {
+			ri.Printf( PRINT_WARNING, "%s", *(VScode++) );
+			VSparts--;
+		}
+		while( GSparts > 0 ) {
+			ri.Printf( PRINT_WARNING, "%s", *(GScode++) );
+			GSparts--;
+		}
+		while( FSparts > 0 ) {
+			ri.Printf( PRINT_WARNING, "%s", *(FScode++) );
+			FSparts--;
+		}
+
+		ri.Hunk_FreeTempMemory( log );
+		qglDeleteProgram( Program );
+		if( FragmentShader )
+			qglDeleteShader( FragmentShader->handle );
+		if( GeometryShader )
+			qglDeleteShader( GeometryShader->handle );
+		if( VertexShader )
+			qglDeleteShader( VertexShader->handle );
+		return NULL;
+	}
+
+	newProgram = ri.Hunk_Alloc( sizeof(GLSLprogram_t), h_low );
+	tr.GLSLprograms[tr.numGLSLprograms++] = newProgram;
+	
+	newProgram->handle = Program;
+
+	newProgram->vertex = VertexShader;
+	newProgram->geometry = GeometryShader;
+	newProgram->fragment = FragmentShader;
+	newProgram->attributes = attributes;
+
+	return newProgram;
+}
+GLSLprogram_t *RB_CompileProgram( const char *name,
+				  const char **VScode, int VSparts,
+				  const char **FScode, int FSparts,
+				  unsigned int attributes ) {
+	return RB_CompileGSProgram( name, VScode, VSparts,
+				    NULL, 0,
+				    0, 0, 0,
+				    FScode, FSparts,
+				    attributes );
+}
+
+
+/*
 ================
 RB_Hyperspace
 
@@ -411,8 +945,29 @@
 
 
 static void SetViewportAndScissor( void ) {
+	float	mat[16], scale;
+	vec4_t	q, c;
+	
+	Com_Memcpy( mat, backEnd.viewParms.projectionMatrix, sizeof(mat) );
+	if( backEnd.viewParms.portalLevel ) {
+		c[0] = -DotProduct( backEnd.viewParms.portalPlane.normal, backEnd.viewParms.or.axis[1] );
+		c[1] = DotProduct( backEnd.viewParms.portalPlane.normal, backEnd.viewParms.or.axis[2] );
+		c[2] = -DotProduct( backEnd.viewParms.portalPlane.normal, backEnd.viewParms.or.axis[0] );
+		c[3] = DotProduct( backEnd.viewParms.portalPlane.normal, backEnd.viewParms.or.origin ) - backEnd.viewParms.portalPlane.dist;
+		
+		q[0] = (c[0] < 0.0f ? -1.0f : 1.0f) / mat[0];
+		q[1] = (c[1] < 0.0f ? -1.0f : 1.0f) / mat[5];
+		q[2] = -1.0f;
+		q[3] = (1.0f + mat[10]) / mat[14];
+		
+		scale = 2.0f / (DotProduct( c, q ) + c[3] * q[3]);
+		mat[2]  = c[0] * scale;
+		mat[6]  = c[1] * scale;
+		mat[10] = c[2] * scale + 1.0f;
+		mat[14] = c[3] * scale;
+	}
 	qglMatrixMode(GL_PROJECTION);
-	qglLoadMatrixf( backEnd.viewParms.projectionMatrix );
+	qglLoadMatrixf( mat );
 	qglMatrixMode(GL_MODELVIEW);
 
 	// set the window clipping
@@ -454,22 +1009,25 @@
 	// ensures that depth writes are enabled for the depth clear
 	GL_State( GLS_DEFAULT );
 	// clear relevant buffers
-	clearBits = GL_DEPTH_BUFFER_BIT;
-
-	if ( r_measureOverdraw->integer || r_shadows->integer == 2 )
-	{
-		clearBits |= GL_STENCIL_BUFFER_BIT;
-	}
-	if ( r_fastsky->integer && !( backEnd.refdef.rdflags & RDF_NOWORLDMODEL ) )
-	{
-		clearBits |= GL_COLOR_BUFFER_BIT;	// FIXME: only if sky shaders have been used
+	if ( backEnd.viewParms.isFirst ) {
+		clearBits = GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT;
+		
+		if ( r_clear->integer ) {
+			clearBits |= GL_COLOR_BUFFER_BIT;
+			qglClearColor( 1.0f, 0.0f, 0.5f, 1.0f );
+		}
+		if ( r_fastsky->integer && !( backEnd.refdef.rdflags & RDF_NOWORLDMODEL ) )
+		{
+			clearBits |= GL_COLOR_BUFFER_BIT;	// FIXME: only if sky shaders have been used
 #ifdef _DEBUG
-		qglClearColor( 0.8f, 0.7f, 0.4f, 1.0f );	// FIXME: get color of sky
+			qglClearColor( 0.8f, 0.7f, 0.4f, 1.0f );	// FIXME: get color of sky
 #else
-		qglClearColor( 0.0f, 0.0f, 0.0f, 1.0f );	// FIXME: get color of sky
+			qglClearColor( 0.0f, 0.0f, 0.0f, 1.0f );	// FIXME: get color of sky
 #endif
+		}
+		qglStencilMask( glGlobals.portalMask | glGlobals.shadowMask );
+		qglClear( clearBits );
 	}
-	qglClear( clearBits );
 
 	if ( ( backEnd.refdef.rdflags & RDF_HYPERSPACE ) )
 	{
@@ -485,33 +1043,309 @@
 
 	// we will only draw a sun if there was sky rendered in this view
 	backEnd.skyRenderedThisView = qfalse;
+}
 
-	// clip to the plane of the portal
-	if ( backEnd.viewParms.isPortal ) {
-		float	plane[4];
-		double	plane2[4];
 
-		plane[0] = backEnd.viewParms.portalPlane.normal[0];
-		plane[1] = backEnd.viewParms.portalPlane.normal[1];
-		plane[2] = backEnd.viewParms.portalPlane.normal[2];
-		plane[3] = backEnd.viewParms.portalPlane.dist;
+/*
+==================
+RB_FindShaderVBO
+==================
+*/
+static int
+findShaderVBO( vboInfo_t **root, int VBOkey ) {
+	vboInfo_t node, *left, *right, *tmp;
+	qboolean  found = qfalse;
 
-		plane2[0] = DotProduct (backEnd.viewParms.or.axis[0], plane);
-		plane2[1] = DotProduct (backEnd.viewParms.or.axis[1], plane);
-		plane2[2] = DotProduct (backEnd.viewParms.or.axis[2], plane);
-		plane2[3] = DotProduct (plane, backEnd.viewParms.or.origin) - plane[3];
+	if ( !*root )
+		return qfalse;
 
-		qglLoadMatrixf( s_flipMatrix );
-		qglClipPlane (GL_CLIP_PLANE0, plane2);
-		qglEnable (GL_CLIP_PLANE0);
+	node.left = node.right = NULL;
+	left = right = &node;
+	
+	while( 1 ) {
+		if( VBOkey < (*root)->key ) {
+			tmp = (*root)->left;
+			if( !tmp )
+				break;
+			if( VBOkey < tmp->key ) {
+				(*root)->left = tmp->right;
+				tmp->right = *root;
+				*root = tmp;
+				if( !(*root)->left )
+					break;
+			}
+			right->left = *root;
+			right = *root;
+			*root = (*root)->left;
+		} else if( VBOkey > (*root)->key ) {
+			tmp = (*root)->right;
+			if( !tmp )
+				break;
+			if( VBOkey > tmp->key ) {
+				(*root)->right = tmp->left;
+				tmp->left = *root;
+				*root = tmp;
+				if( !(*root)->right )
+					break;
+			}
+			left->right = *root;
+			left = *root;
+			*root = (*root)->right;
+		} else {
+			found = qtrue;
+			break;
+		}
+	}
+        left->right = (*root)->left;
+	right->left = (*root)->right;
+        (*root)->left = node.right;
+        (*root)->right = node.left;
+	return found;
+}
+
+static void newShaderVBO( vboInfo_t **root, int VBOkey )
+{
+	vboInfo_t *new;
+
+	if ( !backEnd.vboReserveCount ) {
+		backEnd.vboReserve = ri.Hunk_Alloc( sizeof(vboInfo_t) *
+						    (backEnd.vboReserveCount = 1000),
+						    h_dontcare );
+	}
+	
+	new = backEnd.vboReserve++;
+	backEnd.vboReserveCount--;
+	
+	// requires that the tree has been splayed with findShaderVBO
+	// before
+	if( !*root ) {
+		new->left = new->right = NULL;
 	} else {
-		qglDisable (GL_CLIP_PLANE0);
+		if( VBOkey < (*root)->key ) {
+			new->left = (*root)->left;
+			(*root)->left = NULL;
+			new->right = *root;
+		} else if ( VBOkey > (*root)->key ) {
+			new->right = (*root)->right;
+			(*root)->right = NULL;
+			new->left = *root;
+		} else
+			return; // should not happen
 	}
+	*root = new;
 }
 
+vboInfo_t *RB_CreateShaderVBO( vboInfo_t **root, int VBOkey ) {
+	if( !findShaderVBO( root, VBOkey ) ) {
+		newShaderVBO( root, VBOkey );
+		(*root)->vbo = 0;
+		(*root)->ibo = 0;
+	}
+	(*root)->key = VBOkey;
+	
+	return *root;
+}
+void RB_CopyVBO( vboInfo_t **root, int VBOkeyNew, int VBOkeyOld ) {
+	vboInfo_t *oldVBO;
+	if( !findShaderVBO( root, VBOkeyOld ) )
+		return;
 
+	oldVBO = *root;
+	
+	if( !findShaderVBO( root, VBOkeyNew ) ) {
+		newShaderVBO( root, VBOkeyNew );
+		(*root)->vbo = oldVBO->vbo;
+		(*root)->ibo = oldVBO->ibo;
+		(*root)->numIndexes = oldVBO->numIndexes;
+		(*root)->minIndex = oldVBO->minIndex;
+		(*root)->maxIndex = oldVBO->maxIndex;
+		(*root)->offs1 = oldVBO->offs1;
+		(*root)->offs2 = oldVBO->offs2;
+		(*root)->offs3 = oldVBO->offs3;
+		(*root)->offs4 = oldVBO->offs4;
+		(*root)->offsIdx = oldVBO->offsIdx;
+	}
+	(*root)->key = VBOkeyNew;
+}
+
 #define	MAC_EVENT_PUMP_MSEC		5
 
+
+void RB_ClearVertexBuffer( void ) {
+	tess.indexPtr.p16 = NULL;
+	tess.indexInc = 0;
+	tess.vertexPtr1 = NULL;
+	tess.vertexPtr2 = NULL;
+	tess.vertexPtr3 = NULL;
+	tess.vertexPtr4 = NULL;
+
+	tess.numVertexes = tess.numIndexes = tess.maxIndex = 0;
+}
+void RB_SetupVertexBuffer(shader_t *shader, vboInfo_t *vbo) {
+	const size_t	vertexSize = sizeof(vaWord1_t) + sizeof(vaWord2_t)
+		+ sizeof(vaWord3_t) + sizeof(vaWord4_t);
+	size_t		requiredSizeVBO;
+	size_t		requiredSizeRAM;
+	byte		*vboPtr, *ramPtr;
+
+	if ( shader == tr.shadowShader ) {
+		// need more room for stencil shadows
+		tess.numVertexes *= 2;
+		tess.numIndexes *= 6;
+	}
+
+	if ( tess.numVertexes > 65536 ) {
+		tess.indexInc = sizeof(GLuint);
+	} else {
+		tess.indexInc = sizeof(GLushort);
+	}
+
+	// round to next multiple of 4 vertexes for alignment
+	tess.numVertexes = (tess.numVertexes + 3) & -4;
+
+	if( vbo && vbo->ibo ) {
+		if( vbo->vbo ) {
+			// VBO for vertex and index data
+			requiredSizeVBO = vertexSize * tess.numVertexes;
+		} else {
+			// VBO for indexes only (use worldVBO for data)
+			if( backEnd.worldVBO.maxIndex >= 65536 ) {
+				tess.indexInc = sizeof(GLuint);
+			} else {
+				tess.indexInc = sizeof(GLushort);
+			}
+			requiredSizeVBO = 0;
+		}
+		requiredSizeVBO += tess.indexInc * tess.numIndexes;
+		requiredSizeRAM = 0;
+	} else {
+		if( vbo && vbo->vbo ) {
+			// VBO for vertex data only (building worldVBO)
+			requiredSizeVBO = vertexSize * tess.numVertexes;
+			requiredSizeRAM = tess.indexInc * tess.numIndexes;
+		} else {
+			// all in RAM
+			requiredSizeRAM = vertexSize * tess.numVertexes;
+			requiredSizeRAM += tess.indexInc * tess.numIndexes;
+			requiredSizeVBO = 0;
+		}
+	}
+
+	if( requiredSizeVBO > 0 ) {
+		tess.streaming = vbo;
+
+		if( vbo->ibo ) {
+			GLenum	usage;
+			GL_IBO( vbo->ibo );
+
+			if( vbo->ibo == backEnd.streamVBO.ibo )
+				usage = GL_STREAM_DRAW_ARB;
+			else
+				usage = GL_STATIC_DRAW_ARB;
+			qglBufferDataARB(GL_ELEMENT_ARRAY_BUFFER_ARB,
+					 requiredSizeVBO, NULL, usage );
+			vboPtr = qglMapBufferARB( GL_ELEMENT_ARRAY_BUFFER,
+						  GL_WRITE_ONLY_ARB );
+		} else {
+			GL_IBO( vbo->vbo );
+			qglBufferDataARB(GL_ELEMENT_ARRAY_BUFFER_ARB,
+					 requiredSizeVBO, NULL, GL_STATIC_DRAW_ARB );
+			vboPtr = qglMapBufferARB( GL_ELEMENT_ARRAY_BUFFER,
+						  GL_WRITE_ONLY_ARB );
+		}
+	} else {
+		vboPtr = NULL;
+	}
+
+	if( requiredSizeRAM > 0 ) {
+		requiredSizeRAM += 16 + sizeof(int);
+
+		if ( tess.vertexBuffer ) {
+			if ( *(int *)tess.vertexBufferEnd != 0xDEADBEEF) {
+				ri.Error( ERR_DROP, "VertexBuffer overflow" );
+			}
+			if ( tess.vertexBufferEnd - tess.vertexBuffer < requiredSizeRAM - sizeof(int) ) {
+				ri.Free( tess.vertexBuffer );
+				tess.vertexBuffer = tess.vertexBufferEnd = NULL;
+			}
+		}
+		
+		if ( !tess.vertexBuffer ) {
+			tess.vertexBuffer = ri.Malloc( requiredSizeRAM );
+			tess.vertexBufferEnd = tess.vertexBuffer + requiredSizeRAM - sizeof(int);
+			*(int *)tess.vertexBufferEnd = 0xDEADBEEF;
+		}
+
+		ramPtr = (byte *)(((intptr_t)tess.vertexBuffer + 15) & -16);
+	} else {
+		ramPtr = NULL;
+	}
+
+	if( vbo && vbo->vbo ) {
+		tess.vertexPtr1 = (vaWord1_t *)vboPtr;
+		vboPtr += tess.numVertexes * sizeof(vaWord1_t);
+		vbo->offs1 = (vaWord1_t *)NULL;
+
+		tess.vertexPtr2 = (vaWord2_t *)vboPtr;
+		vboPtr += tess.numVertexes * sizeof(vaWord2_t);
+		vbo->offs2 = (vaWord2_t *)(tess.numVertexes + vbo->offs1);
+
+		tess.vertexPtr3 = (vaWord3_t *)vboPtr;
+		vboPtr += tess.numVertexes * sizeof(vaWord3_t);
+		vbo->offs3 = (vaWord3_t *)(tess.numVertexes + vbo->offs2);
+
+		tess.vertexPtr4 = (vaWord4_t *)vboPtr;
+		vboPtr += tess.numVertexes * sizeof(vaWord4_t);
+		vbo->offs4 = (vaWord4_t *)(tess.numVertexes + vbo->offs3);
+	} else if( !vbo || !vbo->ibo ) {
+		tess.vertexPtr1 = (vaWord1_t *)ramPtr;
+		ramPtr += tess.numVertexes * sizeof(vaWord1_t);
+
+		tess.vertexPtr2 = (vaWord2_t *)ramPtr;
+		ramPtr += tess.numVertexes * sizeof(vaWord2_t);
+
+		tess.vertexPtr3 = (vaWord3_t *)ramPtr;
+		ramPtr += tess.numVertexes * sizeof(vaWord3_t);
+
+		tess.vertexPtr4 = (vaWord4_t *)ramPtr;
+		ramPtr += tess.numVertexes * sizeof(vaWord4_t);
+	} else {
+		tess.vertexPtr1 = NULL;
+		tess.vertexPtr2 = NULL;
+		tess.vertexPtr3 = NULL;
+		tess.vertexPtr4 = NULL;
+	}
+
+	if( vbo && vbo->ibo ) {
+		tess.indexPtr.p16 = (GLushort *)vboPtr;
+		if( vbo->vbo )
+			vbo->offsIdx = (GLushort *)(tess.numVertexes + vbo->offs4);
+		else
+			vbo->offsIdx = (GLushort *)NULL;
+	} else {
+		tess.indexPtr.p16 = (GLushort *)ramPtr;
+	}
+
+	tess.numVertexes = tess.numIndexes = tess.maxIndex = 0;
+}
+void RB_FlushVertexBuffer( void ) {
+	if( tess.streaming ) {
+		qglUnmapBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB );
+
+		// the data is already in the stream VBO
+		tess.streaming->numIndexes = tess.numIndexes;
+		tess.streaming->minIndex = tess.minIndex;
+		tess.streaming->maxIndex = tess.maxIndex;
+
+		tess.streaming->next = tess.firstVBO;
+		tess.firstVBO = tess.streaming;
+
+		tess.streaming = NULL;
+		tess.numIndexes = tess.numVertexes = 0;
+	}
+}
+
+
 /*
 ==================
 RB_RenderDrawSurfList
@@ -522,12 +1356,13 @@
 	int				fogNum, oldFogNum;
 	int				entityNum, oldEntityNum;
 	int				dlighted, oldDlighted;
-	qboolean		depthRange, oldDepthRange, isCrosshair, wasCrosshair;
-	int				i;
-	drawSurf_t		*drawSurf;
-	int				oldSort;
+	qboolean		culled;
+	qboolean		depthRange, oldDepthRange, isCrosshair, wasCrosshair, worldMatrix;
+	int				i, j, k;
+	int				oldSort, endSort, sortMask;
 	float			originalTime;
-
+	qboolean		isGLSL = qfalse;
+	
 	// save original time for entity shader offsets
 	originalTime = backEnd.refdef.floatTime;
 
@@ -547,29 +1382,50 @@
 
 	backEnd.pc.c_surfaces += numDrawSurfs;
 
-	for (i = 0, drawSurf = drawSurfs ; i < numDrawSurfs ; i++, drawSurf++) {
-		if ( drawSurf->sort == oldSort ) {
-			// fast path, same as previous sort
-			rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
-			continue;
-		}
-		oldSort = drawSurf->sort;
-		R_DecomposeSort( drawSurf->sort, &entityNum, &shader, &fogNum, &dlighted );
+	RB_ClearVertexBuffer ();
+	
+	qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
+	worldMatrix = qtrue;
+	
+	for( i = 0; i < numDrawSurfs ; ) {
+		entityNum = QSORT_ENTITYNUM( drawSurfs[i].sort );
+		shader = tr.shaders[ drawSurfs[i].shaderIndex ];
+		fogNum = QSORT_FOGNUM( drawSurfs[i].sort );
+		dlighted = QSORT_DLIGHT( drawSurfs[i].sort );
+		culled = QSORT_CULLED( drawSurfs[i].sort );
 
 		//
 		// change the tess parameters if needed
 		// a "entityMergable" shader is a shader that can have surfaces from seperate
 		// entities merged into a single batch, like smoke and blood puff sprites
-		if (shader != oldShader || fogNum != oldFogNum || dlighted != oldDlighted 
-			|| ( entityNum != oldEntityNum && !shader->entityMergable ) ) {
-			if (oldShader != NULL) {
-				RB_EndSurface();
-			}
+		if( shader->entityMergable ) {
+			sortMask = QSORT_SHADERNUM_MASK
+				| QSORT_FOGNUM_MASK
+				| QSORT_DLIGHT_MASK;
+		} else {
+			sortMask = QSORT_SHADERNUM_MASK
+				| QSORT_ENTITYNUM_MASK
+				| QSORT_FOGNUM_MASK
+				| QSORT_DLIGHT_MASK;
+		}
+		if( (drawSurfs[i].sort & sortMask) != (oldSort & sortMask) ) {
 			RB_BeginSurface( shader, fogNum );
 			oldShader = shader;
 			oldFogNum = fogNum;
 			oldDlighted = dlighted;
+			
+			// combine sprite entities if possible, they don't use
+			// VBOs anyway
+			if (//shader->entityMergable &&
+			    backEnd.refdef.entities[entityNum].e.reType == RT_SPRITE) {
+				sortMask = QSORT_SHADERNUM_MASK;
+			} else {
+				sortMask = QSORT_SHADERNUM_MASK | QSORT_ENTITYNUM_MASK;
+			}
+			isGLSL = (shader->optimalStageIteratorFunc == RB_StageIteratorGLSL);
+			oldEntityNum = -1;
 		}
+		oldSort = drawSurfs[i].sort;
 
 		//
 		// change the modelview matrix if needed
@@ -583,14 +1439,22 @@
 				// we have to reset the shaderTime as well otherwise image animations start
 				// from the wrong frame
 				tess.shaderTime = backEnd.refdef.floatTime - tess.shader->timeOffset;
-
+				
 				// set up the transformation matrix
 				R_RotateForEntity( backEnd.currentEntity, &backEnd.viewParms, &backEnd.or );
-
+				
 				// set up the dynamic lighting if needed
 				if ( backEnd.currentEntity->needDlights ) {
-					R_TransformDlights( backEnd.refdef.num_dlights, backEnd.refdef.dlights, &backEnd.or );
+				  R_TransformDlights( backEnd.refdef.num_dlights, backEnd.refdef.dlights, &backEnd.or );
 				}
+				if( !isGLSL ) {
+					qglLoadMatrixf( backEnd.or.modelMatrix );
+					worldMatrix = qfalse;
+					
+				} else if( !worldMatrix ) {
+					qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
+					worldMatrix = qtrue;
+				}
 
 				if(backEnd.currentEntity->e.renderfx & RF_DEPTHHACK)
 				{
@@ -607,13 +1471,15 @@
 				// we have to reset the shaderTime as well otherwise image animations on
 				// the world (like water) continue with the wrong frame
 				tess.shaderTime = backEnd.refdef.floatTime - tess.shader->timeOffset;
-				R_TransformDlights( backEnd.refdef.num_dlights, backEnd.refdef.dlights, &backEnd.or );
+				if( !worldMatrix ) {
+					qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
+					worldMatrix = qtrue;
+					R_TransformDlights( backEnd.refdef.num_dlights, backEnd.refdef.dlights, &backEnd.or );
+				}
 			}
 
-			qglLoadMatrixf( backEnd.or.modelMatrix );
-
 			//
-			// change depthrange. Also change projection matrix so first person weapon does not look like coming
+			// change projection matrix so first person weapon does not look like coming
 			// out of the screen.
 			//
 			if (oldDepthRange != depthRange || wasCrosshair != isCrosshair)
@@ -643,9 +1509,6 @@
 							qglMatrixMode(GL_MODELVIEW);
 						}
 					}
-
-					if(!oldDepthRange)
-						qglDepthRange (0, 0.3);
 				}
 				else
 				{
@@ -655,8 +1518,6 @@
 						qglLoadMatrixf(backEnd.viewParms.projectionMatrix);
 						qglMatrixMode(GL_MODELVIEW);
 					}
-
-					qglDepthRange (0, 1);
 				}
 
 				oldDepthRange = depthRange;
@@ -666,31 +1527,211 @@
 			oldEntityNum = entityNum;
 		}
 
-		// add the triangles for this surface
-		rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
-	}
+		// look if we can use a VBO for this shader/entity
+		int VBOkey = 0;
+		vboInfo_t **VBOtree = &shader->VBOs;
+		
+		if ( shader->useVBO ) {
+			if (entityNum == ENTITYNUM_WORLD) {
+				if ( backEnd.viewParms.viewCluster >= 0 ) {
+					VBOkey = VBOKEY_VIS | ((backEnd.viewParms.frustType << 24 | backEnd.viewParms.viewCluster) & VBOKEY_IDXMASK);
+				}
+			} else {
+				trRefEntity_t	*ent = backEnd.currentEntity;
+				if ( ent->e.reType == RT_MODEL ) {
+					model_t *model = R_GetModelByHandle( ent->e.hModel );
+					if ( model->type == MOD_BRUSH ) {
+						VBOkey = VBOKEY_MODEL | (ent->e.hModel & VBOKEY_IDXMASK);
+					} else if ( *drawSurfs[i].surface == SF_MD3_TEXTURE ) {
+						srfMD3Texture_t *surf = (srfMD3Texture_t *)drawSurfs[i].surface;
+						VBOkey = VBOKEY_MD3TEX;
+						VBOtree = &surf->VBO;
+						tess.dataTexture = surf->image;
+						tess.frameOffs    = (ent->e.frame / surf->framesPerRow) * surf->scaleY +
+							(ent->e.frame & (surf->framesPerRow - 1)) * surf->scaleX;
+						tess.oldFrameOffs = (ent->e.oldframe / surf->framesPerRow) * surf->scaleY +
+							(ent->e.oldframe & (surf->framesPerRow - 1)) * surf->scaleX;
+					} else if ( model->type == MOD_MESH &&
+						ent->e.frame == ent->e.oldframe ) {
+						// combine hModel and frame number into key
+						// allows 65536 models with 256 frames
+						VBOkey = VBOKEY_MD3 | (ent->e.hModel << 8) | ent->e.frame;
+					}
+				}
+			}
+		}
 
-	backEnd.refdef.floatTime = originalTime;
+		if ( VBOkey == VBOKEY_MD3TEX ) {
+			// add one VBO per surface
+			k = i;
 
-	// draw the contents of the last shader batch
-	if (oldShader != NULL) {
+			(*VBOtree)->next = tess.firstVBO;
+			tess.firstVBO = *VBOtree;
+			
+			if ( (drawSurfs[i].sort & ~sortMask) == 0 )
+				k++;
+			i++;
+		} else if ( VBOkey == 0 || !findShaderVBO( VBOtree, VBOkey) ) {
+			vboInfo_t	*vbo;
+
+			// build a vertex buffer
+			RB_ClearVertexBuffer( );
+
+			// we also want to collect dynamically lit
+			// vertexes, even if we have to collect them twice
+			endSort = (oldSort - sortMask) & sortMask;
+			
+			k = i;
+			for ( j = i; j < numDrawSurfs ; j++ ) {
+				if( drawSurfs[j].sort >= endSort )
+					break;
+				if( QSORT_CULLED( drawSurfs[j].sort )
+				    && VBOkey == 0 )
+					continue;
+				if( (drawSurfs[j].sort & ~sortMask) == 0 )
+					k++;
+				rb_surfaceTable[ *drawSurfs[j].surface ]( drawSurfs[j].surface );
+			}
+			
+			if ( tess.numVertexes == 0 || tess.numIndexes == 0 ) {
+				i = j;
+				continue;
+			}
+
+			if ( VBOkey > 0 &&
+			     tess.numIndexes >= r_VBOminSize->integer &&
+			     r_VBOminSize->integer >= 0 ) {
+				// create new VBO
+				
+				newShaderVBO( VBOtree, VBOkey );
+				vbo = *VBOtree;
+
+				// allocate VBOs
+				qglGenBuffersARB(1, &vbo->ibo);
+				if ( entityNum == ENTITYNUM_WORLD ) {
+					vbo->vbo = 0;
+				} else {
+					vbo->vbo = vbo->ibo;
+				}
+				
+				vbo->key = VBOkey;
+			} else if ( isGLSL ) {
+				vbo = &backEnd.streamVBO;
+				if( entityNum == ENTITYNUM_WORLD ) {
+					backEnd.streamVBO.vbo = 0;
+				} else {
+					backEnd.streamVBO.vbo = backEnd.streamVBO.ibo;
+				}
+			} else {
+				vbo = NULL;
+				VBOkey = 0;
+			}
+
+			RB_SetupVertexBuffer( shader, vbo );
+			for ( ; i < j; i++ ) {
+				tess.fogNum = QSORT_FOGNUM( drawSurfs[i].sort );
+				entityNum = QSORT_ENTITYNUM( drawSurfs[i].sort );
+				if( QSORT_CULLED( drawSurfs[i].sort )
+				    && VBOkey == 0 )
+					continue;
+				if ( oldEntityNum != entityNum ) {
+					backEnd.currentEntity = &backEnd.refdef.entities[entityNum];
+					backEnd.refdef.floatTime = originalTime - backEnd.currentEntity->e.shaderTime;
+					// we have to reset the shaderTime as well otherwise image animations start
+					// from the wrong frame
+					tess.shaderTime = backEnd.refdef.floatTime - tess.shader->timeOffset;
+					
+					// set up the transformation matrix
+					R_RotateForEntity( backEnd.currentEntity, &backEnd.viewParms, &backEnd.or );
+					
+					// set up the dynamic lighting if needed
+					if ( backEnd.currentEntity->needDlights ) {
+						R_TransformDlights( backEnd.refdef.num_dlights, backEnd.refdef.dlights, &backEnd.or );
+					}
+					
+					oldEntityNum = entityNum;
+					
+				}
+				rb_surfaceTable[ *drawSurfs[i].surface ]( drawSurfs[i].surface );
+			}
+		} else {
+			// find surfaces requiring fog or dlight
+			// and skip surfaces contained in VBO
+			endSort = (oldSort - sortMask) & sortMask;
+
+			k = i;
+			for( j = i; j < numDrawSurfs; j++ ) {
+				if( drawSurfs[j].sort >= endSort)
+					break;
+				if( (drawSurfs[j].sort & ~sortMask) == 0 )
+					k++;
+			}
+			i = j;
+
+			// add VBO
+			(*VBOtree)->next = tess.firstVBO;
+			tess.firstVBO = *VBOtree;
+		}
+
 		RB_EndSurface();
+		RB_ClearVertexBuffer ();
+		tess.dataTexture = NULL;
+		
+		if( 1 || !isGLSL ) {
+			// remaining surfaces have to be dlighted or fogged
+			while ( k < i ) {
+				oldSort = drawSurfs[k].sort;
+
+				entityNum = QSORT_ENTITYNUM( drawSurfs[k].sort );
+				shader = tr.shaders[ drawSurfs[k].shaderIndex ];
+				fogNum = QSORT_FOGNUM( drawSurfs[k].sort );
+				dlighted = QSORT_DLIGHT( drawSurfs[k].sort );
+				culled = QSORT_CULLED( drawSurfs[k].sort );
+
+				if( culled ) {
+					k++;
+					continue;
+				}
+				RB_BeginSurface( shader, fogNum );
+				for ( j = k; j < i ; j++ ) {
+					if( drawSurfs[j].sort != oldSort)
+						break;
+					rb_surfaceTable[ *drawSurfs[j].surface ]( drawSurfs[j].surface );
+				}
+				
+				if ( tess.numVertexes > 0 && tess.numIndexes > 0 ) {
+					RB_SetupVertexBuffer( shader, NULL );
+					for ( ; k < j; k++ ) {
+						rb_surfaceTable[ *drawSurfs[k].surface ]( drawSurfs[k].surface );
+					}
+					RB_LightSurface();
+				} else {
+					k = j;
+				}
+				RB_ClearVertexBuffer ();
+			}
+		}
 	}
 
+	backEnd.refdef.floatTime = originalTime;
+
+	GL_VBO( 0 );
+
 	// go back to the world modelview matrix
-	qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
-	if ( depthRange ) {
-		qglDepthRange (0, 1);
+	if( !worldMatrix ) {
+		qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
 	}
 
+	if( !backEnd.viewParms.noShadows ) {
 #if 0
-	RB_DrawSun();
+		RB_DrawSun();
 #endif
-	// darken down any stencil shadows
-	RB_ShadowFinish();		
+		// darken down any stencil shadows
+		RB_ShadowFinish();
 
-	// add light flares on lights that aren't obscured
-	RB_RenderFlares();
+		// add light flares on lights that aren't obscured
+		RB_RenderFlares();
+	}
 }
 
 
@@ -708,7 +1749,7 @@
 
 ================
 */
-void	RB_SetGL2D (void) {
+void	RB_SetGL2D ( glRenderState_t *state ) {
 	backEnd.projection2D = qtrue;
 
 	// set 2D virtual screen size
@@ -720,13 +1761,11 @@
 	qglMatrixMode(GL_MODELVIEW);
     qglLoadIdentity ();
 
-	GL_State( GLS_DEPTHTEST_DISABLE |
-			  GLS_SRCBLEND_SRC_ALPHA |
-			  GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA );
+	state->stateBits = GLS_DEPTHTEST_DISABLE |
+		GLS_SRCBLEND_SRC_ALPHA |
+		GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA;
+	state->faceCulling = CT_TWO_SIDED;
 
-	qglDisable( GL_CULL_FACE );
-	qglDisable( GL_CLIP_PLANE0 );
-
 	// set time for 2D shaders
 	backEnd.refdef.time = ri.Milliseconds();
 	backEnd.refdef.floatTime = backEnd.refdef.time * 0.001f;
@@ -735,82 +1774,50 @@
 
 /*
 =============
-RE_StretchRaw
+RB_StretchRaw
 
-FIXME: not exactly backend
 Stretches a raw 32 bit power of 2 bitmap image over the given screen rectangle.
 Used for cinematics.
 =============
 */
-void RE_StretchRaw (int x, int y, int w, int h, int cols, int rows, const byte *data, int client, qboolean dirty) {
-	int			i, j;
-	int			start, end;
+const void *RB_StretchRaw ( const void *data ) {
+	const stretchRawCommand_t	*cmd;
+	vec2_t			texCoords[4], vertexes[4];
+	glRenderState_t		state;
 
-	if ( !tr.registered ) {
-		return;
-	}
-	R_SyncRenderThread();
+	cmd = (const stretchRawCommand_t *)data;
 
 	// we definately want to sync every frame for the cinematics
 	qglFinish();
 
-	start = end = 0;
-	if ( r_speeds->integer ) {
-		start = ri.Milliseconds();
-	}
+	InitState( &state );
+	RB_SetGL2D( &state );
+	state.program = NULL;
+	state.numImages = 1;
+	state.image[0] = tr.scratchImage[cmd->client];
 
-	// make sure rows and cols are powers of 2
-	for ( i = 0 ; ( 1 << i ) < cols ; i++ ) {
-	}
-	for ( j = 0 ; ( 1 << j ) < rows ; j++ ) {
-	}
-	if ( ( 1 << i ) != cols || ( 1 << j ) != rows) {
-		ri.Error (ERR_DROP, "Draw_StretchRaw: size not a power of 2: %i by %i", cols, rows);
-	}
+	SetAttrVec4f(&state, AL_COLOR, tr.identityLight, tr.identityLight,
+		     tr.identityLight, 1.0f );
 
-	GL_Bind( tr.scratchImage[client] );
+	texCoords[0][0] = cmd->s1;        texCoords[0][1] = cmd->t1;
+	vertexes[0][0] = cmd->x;          vertexes[0][1] = cmd->y;
+	texCoords[1][0] = cmd->s2;        texCoords[1][1] = cmd->t1;
+	vertexes[1][0] = cmd->x + cmd->w; vertexes[1][1] = cmd->y;
+	texCoords[2][0] = cmd->s2;        texCoords[2][1] = cmd->t2;
+	vertexes[2][0] = cmd->x + cmd->w; vertexes[2][1] = cmd->y + cmd->h;
+	texCoords[3][0] = cmd->s1;        texCoords[3][1] = cmd->t2;
+	vertexes[3][0] = cmd->x;          vertexes[3][1] = cmd->y + cmd->h;
 
-	// if the scratchImage isn't in the format we want, specify it as a new texture
-	if ( cols != tr.scratchImage[client]->width || rows != tr.scratchImage[client]->height ) {
-		tr.scratchImage[client]->width = tr.scratchImage[client]->uploadWidth = cols;
-		tr.scratchImage[client]->height = tr.scratchImage[client]->uploadHeight = rows;
-		qglTexImage2D( GL_TEXTURE_2D, 0, GL_RGB8, cols, rows, 0, GL_RGBA, GL_UNSIGNED_BYTE, data );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );	
-	} else {
-		if (dirty) {
-			// otherwise, just subimage upload it so that drivers can tell we are going to be changing
-			// it and don't try and do a texture compression
-			qglTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, cols, rows, GL_RGBA, GL_UNSIGNED_BYTE, data );
-		}
-	}
+	SetAttrPointer( &state, AL_VERTEX, 0, 2, GL_FLOAT, 0, vertexes );
+	SetAttrPointer( &state, AL_TEXCOORD, 0, 2, GL_FLOAT, 0, texCoords );
+	GL_DrawArrays( &state, GL_QUADS, 0, 4 );
 
-	if ( r_speeds->integer ) {
-		end = ri.Milliseconds();
-		ri.Printf( PRINT_ALL, "qglTexSubImage2D %i, %i: %i msec\n", cols, rows, end - start );
-	}
-
-	RB_SetGL2D();
-
-	qglColor3f( tr.identityLight, tr.identityLight, tr.identityLight );
-
-	qglBegin (GL_QUADS);
-	qglTexCoord2f ( 0.5f / cols,  0.5f / rows );
-	qglVertex2f (x, y);
-	qglTexCoord2f ( ( cols - 0.5f ) / cols ,  0.5f / rows );
-	qglVertex2f (x+w, y);
-	qglTexCoord2f ( ( cols - 0.5f ) / cols, ( rows - 0.5f ) / rows );
-	qglVertex2f (x+w, y+h);
-	qglTexCoord2f ( 0.5f / cols, ( rows - 0.5f ) / rows );
-	qglVertex2f (x, y+h);
-	qglEnd ();
+	return cmd + 1;
 }
 
 void RE_UploadCinematic (int w, int h, int cols, int rows, const byte *data, int client, qboolean dirty) {
 
-	GL_Bind( tr.scratchImage[client] );
+	GL_BindTexture( tr.scratchImage[client]->texnum );
 
 	// if the scratchImage isn't in the format we want, specify it as a new texture
 	if ( cols != tr.scratchImage[client]->width || rows != tr.scratchImage[client]->height ) {
@@ -855,74 +1862,155 @@
 RB_StretchPic
 =============
 */
+static qboolean overlap(const stretchPicCommand_t *a,
+			const stretchPicCommand_t *b ) {
+	if( a->x >= b->x + b->w || b->x >= a->x + a->w )
+		return qfalse;
+
+	if( a->y >= b->y + b->h || b->y >= a->y + a->h )
+		return qfalse;
+
+	return qtrue;
+}
 const void *RB_StretchPic ( const void *data ) {
+	struct pic {
+		const stretchPicCommand_t	*cmd;
+		color4ub_t			color;
+	} *pics;
 	const stretchPicCommand_t	*cmd;
-	shader_t *shader;
-	int		numVerts, numIndexes;
+	shader_t	*shader;
+	GLushort	indexes[6] = { 3, 0, 2, 2, 0, 1 };
+	int		i, j, k, n;
 
 	cmd = (const stretchPicCommand_t *)data;
 
 	if ( !backEnd.projection2D ) {
-		RB_SetGL2D();
+		glRenderState_t dummy;
+		RB_SetGL2D( &dummy );
 	}
 
-	shader = cmd->shader;
-	if ( shader != tess.shader ) {
-		if ( tess.numIndexes ) {
-			RB_EndSurface();
-		}
-		backEnd.currentEntity = &backEnd.entity2D;
-		RB_BeginSurface( shader, 0 );
+	backEnd.currentEntity = &backEnd.entity2D;
+	
+	// read all the following StretchPic commands
+	n = 1;
+	data = cmd+1;
+	for(;;) {
+		if ( *(int *)data == RC_STRETCH_PIC ) {
+			n++;
+			data = data + sizeof(stretchPicCommand_t);
+		} else if ( *(int *)data == RC_SET_COLOR ) {
+			data = data + sizeof(setColorCommand_t);
+		} else
+			break;
 	}
 
-	RB_CHECKOVERFLOW( 4, 6 );
-	numVerts = tess.numVertexes;
-	numIndexes = tess.numIndexes;
+	// add current color to each pic
+	pics = (struct pic *)RB_AllocScratch(n * sizeof(struct pic));
+	for( i = 0; ; ) {
+		if( cmd->commandId == RC_STRETCH_PIC ) {
+			pics[i].cmd = cmd;
+			*(int *)pics[i].color = *(int *)backEnd.color2D;
+			i++; cmd++;
+		} else if( cmd->commandId == RC_SET_COLOR ) {
+			cmd = RB_SetColor( cmd );
+		} else
+			break;
+	}
 
-	tess.numVertexes += 4;
-	tess.numIndexes += 6;
+	// try to reorder by shader
+	shader = pics[0].cmd->shader;
+	for( i = 1; i < n ; i++ ) {
+		for( j = i; j < n; j++ ) {
+			if( pics[j].cmd->shader == shader ) {
+				while( j > i &&
+				       !overlap( pics[j].cmd, pics[j-1].cmd ) ) {
 
-	tess.indexes[ numIndexes ] = numVerts + 3;
-	tess.indexes[ numIndexes + 1 ] = numVerts + 0;
-	tess.indexes[ numIndexes + 2 ] = numVerts + 2;
-	tess.indexes[ numIndexes + 3 ] = numVerts + 2;
-	tess.indexes[ numIndexes + 4 ] = numVerts + 0;
-	tess.indexes[ numIndexes + 5 ] = numVerts + 1;
+					struct pic tmp = pics[j];
+					pics[j] = pics[j-1];
+					pics[j-1] = tmp;
+					j--;
+				}
+				break;
+			}
+		}
+		shader = pics[i].cmd->shader;
+	}
 
-	*(int *)tess.vertexColors[ numVerts ] =
-		*(int *)tess.vertexColors[ numVerts + 1 ] =
-		*(int *)tess.vertexColors[ numVerts + 2 ] =
-		*(int *)tess.vertexColors[ numVerts + 3 ] = *(int *)backEnd.color2D;
+	// draw maximal batches
+	for( i = 0; i < n; ) {
+		shader = pics[i].cmd->shader;
+		for( j = i+1; j < n; j++ ) {
+			if( pics[j].cmd->shader != shader )
+				break;
+		}
 
-	tess.xyz[ numVerts ][0] = cmd->x;
-	tess.xyz[ numVerts ][1] = cmd->y;
-	tess.xyz[ numVerts ][2] = 0;
+		j -= i;
+		RB_BeginSurface( shader, 0 );
+		tess.numVertexes = 4 * j;
+		tess.numIndexes  = 6 * j;
 
-	tess.texCoords[ numVerts ][0][0] = cmd->s1;
-	tess.texCoords[ numVerts ][0][1] = cmd->t1;
+		backEnd.streamVBO.vbo = backEnd.streamVBO.ibo;
+		RB_SetupVertexBuffer( shader, &backEnd.streamVBO );
+		tess.numVertexes = 4 * j;
+		tess.numIndexes  = 6 * j;
+		tess.minIndex = 0;
+		tess.maxIndex = 4 * j - 1;
 
-	tess.xyz[ numVerts + 1 ][0] = cmd->x + cmd->w;
-	tess.xyz[ numVerts + 1 ][1] = cmd->y;
-	tess.xyz[ numVerts + 1 ][2] = 0;
+		for( k = 0; k < j; k++, i++ ) {
+			tess.indexPtr.p16[6*k+0] = indexes[0] + 4*k;
+			tess.indexPtr.p16[6*k+1] = indexes[1] + 4*k;
+			tess.indexPtr.p16[6*k+2] = indexes[2] + 4*k;
+			tess.indexPtr.p16[6*k+3] = indexes[3] + 4*k;
+			tess.indexPtr.p16[6*k+4] = indexes[4] + 4*k;
+			tess.indexPtr.p16[6*k+5] = indexes[5] + 4*k;
 
-	tess.texCoords[ numVerts + 1 ][0][0] = cmd->s2;
-	tess.texCoords[ numVerts + 1 ][0][1] = cmd->t1;
+			*(int *)(&tess.vertexPtr4[4*k+0].color) =
+			*(int *)(&tess.vertexPtr4[4*k+1].color) =
+			*(int *)(&tess.vertexPtr4[4*k+2].color) =
+			*(int *)(&tess.vertexPtr4[4*k+3].color) = *(int *)&pics[i].color;
 
-	tess.xyz[ numVerts + 2 ][0] = cmd->x + cmd->w;
-	tess.xyz[ numVerts + 2 ][1] = cmd->y + cmd->h;
-	tess.xyz[ numVerts + 2 ][2] = 0;
+			tess.vertexPtr2[4*k+0].xyz[0] = pics[i].cmd->x;
+			tess.vertexPtr2[4*k+0].xyz[1] = pics[i].cmd->y;
+			tess.vertexPtr2[4*k+0].xyz[2] = 0.0f;
+			tess.vertexPtr2[4*k+0].fogNum = 0.0f;
+			tess.vertexPtr1[4*k+0].tc1[0] = pics[i].cmd->s1;
+			tess.vertexPtr1[4*k+0].tc1[1] = pics[i].cmd->t1;
+			tess.vertexPtr1[4*k+0].tc2[0] = pics[i].cmd->s1;
+			tess.vertexPtr1[4*k+0].tc2[1] = pics[i].cmd->t1;
 
-	tess.texCoords[ numVerts + 2 ][0][0] = cmd->s2;
-	tess.texCoords[ numVerts + 2 ][0][1] = cmd->t2;
+			tess.vertexPtr2[4*k+1].xyz[0] = pics[i].cmd->x + pics[i].cmd->w;
+			tess.vertexPtr2[4*k+1].xyz[1] = pics[i].cmd->y;
+			tess.vertexPtr2[4*k+1].xyz[2] = 0.0f;
+			tess.vertexPtr2[4*k+1].fogNum = 0.0f;
+			tess.vertexPtr1[4*k+1].tc1[0] = pics[i].cmd->s2;
+			tess.vertexPtr1[4*k+1].tc1[1] = pics[i].cmd->t1;
+			tess.vertexPtr1[4*k+1].tc2[0] = pics[i].cmd->s2;
+			tess.vertexPtr1[4*k+1].tc2[1] = pics[i].cmd->t1;
 
-	tess.xyz[ numVerts + 3 ][0] = cmd->x;
-	tess.xyz[ numVerts + 3 ][1] = cmd->y + cmd->h;
-	tess.xyz[ numVerts + 3 ][2] = 0;
+			tess.vertexPtr2[4*k+2].xyz[0] = pics[i].cmd->x + pics[i].cmd->w;
+			tess.vertexPtr2[4*k+2].xyz[1] = pics[i].cmd->y + pics[i].cmd->h;
+			tess.vertexPtr2[4*k+2].xyz[2] = 0.0f;
+			tess.vertexPtr2[4*k+2].fogNum = 0.0f;
+			tess.vertexPtr1[4*k+2].tc1[0] = pics[i].cmd->s2;
+			tess.vertexPtr1[4*k+2].tc1[1] = pics[i].cmd->t2;
+			tess.vertexPtr1[4*k+2].tc2[0] = pics[i].cmd->s2;
+			tess.vertexPtr1[4*k+2].tc2[1] = pics[i].cmd->t2;
 
-	tess.texCoords[ numVerts + 3 ][0][0] = cmd->s1;
-	tess.texCoords[ numVerts + 3 ][0][1] = cmd->t2;
+			tess.vertexPtr2[4*k+3].xyz[0] = pics[i].cmd->x;
+			tess.vertexPtr2[4*k+3].xyz[1] = pics[i].cmd->y + pics[i].cmd->h;
+			tess.vertexPtr2[4*k+3].xyz[2] = 0.0f;
+			tess.vertexPtr2[4*k+3].fogNum = 0.0f;
+			tess.vertexPtr1[4*k+3].tc1[0] = pics[i].cmd->s1;
+			tess.vertexPtr1[4*k+3].tc1[1] = pics[i].cmd->t2;
+			tess.vertexPtr1[4*k+3].tc2[0] = pics[i].cmd->s1;
+			tess.vertexPtr1[4*k+3].tc2[1] = pics[i].cmd->t2;
+		}
+		RB_EndSurface ();
+		RB_ClearVertexBuffer ();
+	}
 
-	return (const void *)(cmd + 1);
+	RB_FreeScratch( pics );
+	return (const void *)cmd;
 }
 
 
@@ -936,7 +2024,7 @@
 	const drawSurfsCommand_t	*cmd;
 
 	// finish any 2D drawing if needed
-	if ( tess.numIndexes ) {
+	if ( tess.numIndexes || tess.firstVBO ) {
 		RB_EndSurface();
 	}
 
@@ -944,7 +2032,7 @@
 
 	backEnd.refdef = cmd->refdef;
 	backEnd.viewParms = cmd->viewParms;
-
+	
 	RB_RenderDrawSurfList( cmd->drawSurfs, cmd->numDrawSurfs );
 
 	return (const void *)(cmd + 1);
@@ -964,12 +2052,6 @@
 
 	qglDrawBuffer( cmd->buffer );
 
-	// clear screen for debugging
-	if ( r_clear->integer ) {
-		qglClearColor( 1, 0, 0.5, 1 );
-		qglClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
-	}
-
 	return (const void *)(cmd + 1);
 }
 
@@ -988,9 +2070,12 @@
 	image_t	*image;
 	float	x, y, w, h;
 	int		start, end;
+	vec2_t	vertexes[4], texCoords[4];
+	glRenderState_t	state;
 
+	InitState( &state );
 	if ( !backEnd.projection2D ) {
-		RB_SetGL2D();
+		RB_SetGL2D( &state );
 	}
 
 	qglClear( GL_COLOR_BUFFER_BIT );
@@ -999,13 +2084,22 @@
 
 	start = ri.Milliseconds();
 
+	texCoords[0][0] = 0.0f; texCoords[0][1] = 0.0f;
+	texCoords[1][0] = 1.0f; texCoords[1][1] = 0.0f;
+	texCoords[2][0] = 1.0f; texCoords[2][1] = 1.0f;
+	texCoords[3][0] = 0.0f; texCoords[3][1] = 1.0f;
+	
+	SetAttrPointer( &state, AL_TEXCOORD, 0, 2, GL_FLOAT, 0, texCoords );
+	state.numImages = 1;
+
 	for ( i=0 ; i<tr.numImages ; i++ ) {
 		image = tr.images[i];
+		state.image[0] = image;
 
-		w = glConfig.vidWidth / 20;
-		h = glConfig.vidHeight / 15;
-		x = i % 20 * w;
-		y = i / 20 * h;
+		w = glConfig.vidWidth / 40;
+		h = glConfig.vidHeight / 30;
+		x = i % 40 * w;
+		y = i / 40 * h;
 
 		// show in proportional size in mode 2
 		if ( r_showImages->integer == 2 ) {
@@ -1013,24 +2107,18 @@
 			h *= image->uploadHeight / 512.0f;
 		}
 
-		GL_Bind( image );
-		qglBegin (GL_QUADS);
-		qglTexCoord2f( 0, 0 );
-		qglVertex2f( x, y );
-		qglTexCoord2f( 1, 0 );
-		qglVertex2f( x + w, y );
-		qglTexCoord2f( 1, 1 );
-		qglVertex2f( x + w, y + h );
-		qglTexCoord2f( 0, 1 );
-		qglVertex2f( x, y + h );
-		qglEnd();
+		vertexes[0][0] = x;   vertexes[0][1] = y;
+		vertexes[1][0] = x+w; vertexes[1][1] = y;
+		vertexes[2][0] = x+w; vertexes[2][1] = y+h;
+		vertexes[3][0] = x;   vertexes[3][1] = y+h;
+		
+		SetAttrPointer( &state, AL_VERTEX, 0, 2, GL_FLOAT, 0, vertexes );
+		GL_DrawArrays( &state, GL_QUADS, 0, 4 );
 	}
-
 	qglFinish();
 
 	end = ri.Milliseconds();
-	ri.Printf( PRINT_ALL, "%i msec to draw all images\n", end - start );
-
+	ri.Printf( PRINT_DEVELOPER, "%i msec to draw all images\n", end - start );
 }
 
 /*
@@ -1058,7 +2146,7 @@
 {
 	const clearDepthCommand_t *cmd = data;
 	
-	if(tess.numIndexes)
+	if(tess.numIndexes || tess.firstVBO )
 		RB_EndSurface();
 
 	// texture swapping test
@@ -1080,7 +2168,7 @@
 	const swapBuffersCommand_t	*cmd;
 
 	// finish any 2D drawing if needed
-	if ( tess.numIndexes ) {
+	if ( tess.numIndexes || tess.firstVBO ) {
 		RB_EndSurface();
 	}
 
@@ -1098,18 +2186,17 @@
 		long sum = 0;
 		unsigned char *stencilReadback;
 
-		stencilReadback = ri.Hunk_AllocateTempMemory( glConfig.vidWidth * glConfig.vidHeight );
+		stencilReadback = RB_AllocScratch( glConfig.vidWidth * glConfig.vidHeight );
 		qglReadPixels( 0, 0, glConfig.vidWidth, glConfig.vidHeight, GL_STENCIL_INDEX, GL_UNSIGNED_BYTE, stencilReadback );
 
 		for ( i = 0; i < glConfig.vidWidth * glConfig.vidHeight; i++ ) {
-			sum += stencilReadback[i];
+			sum += stencilReadback[i] & glGlobals.shadowMask;
 		}
 
 		backEnd.pc.c_overDraw += sum;
-		ri.Hunk_FreeTempMemory( stencilReadback );
+		RB_FreeScratch( stencilReadback );
 	}
 
-
 	if ( !glState.finishCalled ) {
 		qglFinish();
 	}
@@ -1118,8 +2205,28 @@
 
 	GLimp_EndFrame();
 
+	if ( qglGenQueriesARB ) {
+		int shader;
+
+		for( shader = 0; shader < tr.numGLSLprograms; shader++ ) {
+			tr.GLSLprograms[shader]->QuerySum = 0;
+		}
+
+		for( shader = 0; shader < tr.numShaders; shader++ ) {
+			if ( tr.shaders[shader]->QueryID ) {
+				GL_GetQuery( tr.shaders[shader]->QueryID,
+					     &tr.shaders[shader]->QueryResult );
+			}
+			if( tr.shaders[shader]->GLSLprogram ) {
+				tr.shaders[shader]->GLSLprogram->QuerySum += QUERY_RESULT(&tr.shaders[shader]->QueryResult);
+				if( tr.shaders[shader]->GLSLprogram->QuerySum > QUERY_MASK )
+					tr.shaders[shader]->GLSLprogram->QuerySum = QUERY_MASK;
+			}
+		}
+	}
+
 	backEnd.projection2D = qfalse;
-
+	
 	return (const void *)(cmd + 1);
 }
 
@@ -1150,6 +2257,9 @@
 		case RC_STRETCH_PIC:
 			data = RB_StretchPic( data );
 			break;
+		case RC_STRETCH_RAW:
+			data = RB_StretchRaw( data );
+			break;
 		case RC_DRAW_SURFS:
 			data = RB_DrawSurfs( data );
 			break;
@@ -1191,6 +2301,9 @@
 void RB_RenderThread( void ) {
 	const void	*data;
 
+	// set default state
+	GL_SetDefaultState();
+
 	// wait for either a rendering command or a quit command
 	while ( 1 ) {
 		// sleep until we have work to do
Index: src/qcommon/q_shared.h
===================================================================
--- src/qcommon/q_shared.h	(Revision 2062)
+++ src/qcommon/q_shared.h	(Arbeitskopie)
@@ -485,6 +485,7 @@
 #define VectorClear(a)			((a)[0]=(a)[1]=(a)[2]=0)
 #define VectorNegate(a,b)		((b)[0]=-(a)[0],(b)[1]=-(a)[1],(b)[2]=-(a)[2])
 #define VectorSet(v, x, y, z)	((v)[0]=(x), (v)[1]=(y), (v)[2]=(z))
+#define Vector2Copy(a,b)		((b)[0]=(a)[0],(b)[1]=(a)[1])
 #define Vector4Copy(a,b)		((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2],(b)[3]=(a)[3])
 #define Vector4Add(a,b,c)    ((c)[0]=(a)[0]+(b)[0],(c)[1]=(a)[1]+(b)[1],(c)[2]=(a)[2]+(b)[2],(c)[3]=(a)[3]+(b)[3])
 #define Vector4Lerp( f, s, e, r ) ((r)[0]=(s)[0]+(f)*((e)[0]-(s)[0]),\
Index: src/qcommon/qcommon.h
===================================================================
--- src/qcommon/qcommon.h	(Revision 2062)
+++ src/qcommon/qcommon.h	(Arbeitskopie)
@@ -829,6 +829,7 @@
 extern	int		time_game;
 extern	int		time_frontend;
 extern	int		time_backend;		// renderer backend time
+extern	int		time_GL;
 
 extern	int		com_frameTime;
 extern	int		com_frameMsec;
Index: src/qcommon/qfiles.h
===================================================================
--- src/qcommon/qfiles.h	(Revision 2062)
+++ src/qcommon/qfiles.h	(Arbeitskopie)
@@ -36,8 +36,8 @@
 #endif
 
 // surface geometry should not exceed these limits
-#define	SHADER_MAX_VERTEXES	1000
-#define	SHADER_MAX_INDEXES	(6*SHADER_MAX_VERTEXES)
+//#define	SHADER_MAX_VERTEXES	1000
+//#define	SHADER_MAX_INDEXES	(6*SHADER_MAX_VERTEXES)
 
 
 // the maximum size of game relative pathnames
Index: src/qcommon/common.c
===================================================================
--- src/qcommon/common.c	(Revision 2062)
+++ src/qcommon/common.c	(Arbeitskopie)
@@ -87,6 +87,7 @@
 int		time_game;
 int		time_frontend;		// renderer frontend time
 int		time_backend;		// renderer backend time
+int		time_GL;		// time to render reported by GL_EXT_timer_query
 
 int			com_frameTime;
 int			com_frameMsec;
@@ -2940,8 +2941,8 @@
 		sv -= time_game;
 		cl -= time_frontend + time_backend;
 
-		Com_Printf ("frame:%i all:%3i sv:%3i ev:%3i cl:%3i gm:%3i rf:%3i bk:%3i\n", 
-					 com_frameNumber, all, sv, ev, cl, time_game, time_frontend, time_backend );
+		Com_Printf ("frame:%i all:%3i sv:%3i ev:%3i cl:%3i gm:%3i rf:%3i bk:%3i gl:%3i\n", 
+			    com_frameNumber, all, sv, ev, cl, time_game, time_frontend, time_backend, time_GL );
 	}	
 
 	//
Index: src/cgame/cg_buildable.c
===================================================================
--- src/cgame/cg_buildable.c	(Revision 2062)
+++ src/cgame/cg_buildable.c	(Arbeitskopie)
@@ -551,7 +551,8 @@
                                               const vec3_t mins, const vec3_t maxs,
                                               vec3_t outAxis[ 3 ], vec3_t outOrigin )
 {
-  vec3_t  forward, start, end;
+  vec3_t  forward, start, end, newMaxs;
+  vec_t   w, h;
   trace_t tr;
 
   AngleVectors( angles, forward, NULL, NULL );
@@ -572,7 +573,12 @@
 
   VectorMA( inOrigin, -TRACE_DEPTH, normal, end );
   VectorMA( inOrigin, 1.0f, normal, start );
-  CG_CapTrace( &tr, start, mins, maxs, end, skipNumber,
+  VectorCopy( maxs, newMaxs );
+  w = maxs[0] - mins[0];
+  h = maxs[2] - mins[2];
+  if( h < w )
+    newMaxs[2] += w - h;
+  CG_CapTrace( &tr, start, mins, newMaxs, end, skipNumber,
                CONTENTS_SOLID | CONTENTS_PLAYERCLIP );
 
   if( tr.fraction == 1.0f )
Index: src/client/cl_scrn.c
===================================================================
--- src/client/cl_scrn.c	(Revision 2062)
+++ src/client/cl_scrn.c	(Arbeitskopie)
@@ -558,9 +558,9 @@
 		}
 
 		if ( com_speeds->integer ) {
-			re.EndFrame( &time_frontend, &time_backend );
+			re.EndFrame( &time_frontend, &time_backend, &time_GL );
 		} else {
-			re.EndFrame( NULL, NULL );
+			re.EndFrame( NULL, NULL, NULL );
 		}
 	}
 	
Index: Makefile
===================================================================
--- Makefile	(Revision 2062)
+++ Makefile	(Arbeitskopie)
@@ -1322,8 +1322,10 @@
   $(B)/client/tr_image_jpg.o \
   $(B)/client/tr_image_bmp.o \
   $(B)/client/tr_image_tga.o \
+  $(B)/client/tr_image_dds.o \
   $(B)/client/tr_image_pcx.o \
   $(B)/client/tr_init.o \
+  $(B)/client/tr_iqm.o \
   $(B)/client/tr_light.o \
   $(B)/client/tr_main.o \
   $(B)/client/tr_marks.o \
