diff -uNr tremulous-ggp1-src.p/Makefile tremulous-ggp1-src/Makefile
--- tremulous-ggp1-src.p/Makefile	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/Makefile	2012-07-19 04:25:52.041556450 +0200
@@ -1321,8 +1321,10 @@
   $(B)/client/tr_image_jpg.o \
   $(B)/client/tr_image_bmp.o \
   $(B)/client/tr_image_tga.o \
+  $(B)/client/tr_image_dds.o \
   $(B)/client/tr_image_pcx.o \
   $(B)/client/tr_init.o \
+  $(B)/client/tr_iqm.o \
   $(B)/client/tr_light.o \
   $(B)/client/tr_main.o \
   $(B)/client/tr_marks.o \
diff -uNr tremulous-ggp1-src.p/Makefile.orig tremulous-ggp1-src/Makefile.orig
--- tremulous-ggp1-src.p/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/Makefile.orig	2012-07-19 04:25:20.181556046 +0200
@@ -0,0 +1,1952 @@
+#
+# Tremulous Makefile
+#
+# GNU Make required
+#
+
+COMPILE_PLATFORM=$(shell uname|sed -e s/_.*//|tr '[:upper:]' '[:lower:]'|sed -e 's/\//_/g')
+
+COMPILE_ARCH=$(shell uname -m | sed -e s/i.86/x86/)
+
+ifeq ($(COMPILE_PLATFORM),sunos)
+  # Solaris uname and GNU uname differ
+  COMPILE_ARCH=$(shell uname -p | sed -e s/i.86/x86/)
+endif
+ifeq ($(COMPILE_PLATFORM),darwin)
+  # Apple does some things a little differently...
+  COMPILE_ARCH=$(shell uname -p | sed -e s/i.86/x86/)
+endif
+
+ifndef BUILD_STANDALONE
+  BUILD_STANDALONE =
+endif
+ifndef BUILD_CLIENT
+  BUILD_CLIENT     =
+endif
+ifndef BUILD_CLIENT_SMP
+  BUILD_CLIENT_SMP =
+endif
+ifndef BUILD_SERVER
+  BUILD_SERVER     =
+endif
+ifndef BUILD_GAME_SO
+  BUILD_GAME_SO    =
+endif
+ifndef BUILD_GAME_QVM
+  BUILD_GAME_QVM   =
+endif
+ifndef BUILD_MISSIONPACK
+  BUILD_MISSIONPACK=
+endif
+
+ifneq ($(PLATFORM),darwin)
+  BUILD_CLIENT_SMP = 0
+endif
+
+#############################################################################
+#
+# If you require a different configuration from the defaults below, create a
+# new file named "Makefile.local" in the same directory as this file and define
+# your parameters there. This allows you to change configuration without
+# causing problems with keeping up to date with the repository.
+#
+#############################################################################
+-include Makefile.local
+
+ifndef PLATFORM
+PLATFORM=$(COMPILE_PLATFORM)
+endif
+export PLATFORM
+
+ifeq ($(COMPILE_ARCH),powerpc)
+  COMPILE_ARCH=ppc
+endif
+ifeq ($(COMPILE_ARCH),powerpc64)
+  COMPILE_ARCH=ppc64
+endif
+
+ifndef ARCH
+ARCH=$(COMPILE_ARCH)
+endif
+export ARCH
+
+ifneq ($(PLATFORM),$(COMPILE_PLATFORM))
+  CROSS_COMPILING=1
+else
+  CROSS_COMPILING=0
+
+  ifneq ($(ARCH),$(COMPILE_ARCH))
+    CROSS_COMPILING=1
+  endif
+endif
+export CROSS_COMPILING
+
+ifndef COPYDIR
+COPYDIR="/usr/local/games/tremulous"
+endif
+
+ifndef COPYBINDIR
+COPYBINDIR=$(COPYDIR)
+endif
+
+ifndef MOUNT_DIR
+MOUNT_DIR=src
+endif
+
+ifndef BUILD_DIR
+BUILD_DIR=build
+endif
+
+ifndef TEMPDIR
+TEMPDIR=/tmp
+endif
+
+ifndef GENERATE_DEPENDENCIES
+GENERATE_DEPENDENCIES=1
+endif
+
+ifndef USE_OPENAL
+USE_OPENAL=1
+endif
+
+ifndef USE_OPENAL_DLOPEN
+USE_OPENAL_DLOPEN=1
+endif
+
+ifndef USE_CURL
+USE_CURL=1
+endif
+
+ifndef USE_CURL_DLOPEN
+  ifeq ($(PLATFORM),mingw32)
+    USE_CURL_DLOPEN=0
+  else
+    USE_CURL_DLOPEN=1
+  endif
+endif
+
+ifndef USE_CODEC_VORBIS
+USE_CODEC_VORBIS=0
+endif
+
+ifndef USE_MUMBLE
+USE_MUMBLE=1
+endif
+
+ifndef USE_VOIP
+USE_VOIP=1
+endif
+
+ifndef USE_INTERNAL_SPEEX
+USE_INTERNAL_SPEEX=1
+endif
+
+ifndef USE_INTERNAL_ZLIB
+USE_INTERNAL_ZLIB=1
+endif
+
+ifndef USE_INTERNAL_JPEG
+USE_INTERNAL_JPEG=1
+endif
+
+ifndef USE_LOCAL_HEADERS
+USE_LOCAL_HEADERS=1
+endif
+
+ifndef BUILD_MASTER_SERVER
+BUILD_MASTER_SERVER=0
+endif
+
+ifndef DEBUG_CFLAGS
+DEBUG_CFLAGS=-g -O0
+endif
+
+#############################################################################
+
+BD=$(BUILD_DIR)/debug-$(PLATFORM)-$(ARCH)
+BR=$(BUILD_DIR)/release-$(PLATFORM)-$(ARCH)
+CDIR=$(MOUNT_DIR)/client
+SDIR=$(MOUNT_DIR)/server
+RDIR=$(MOUNT_DIR)/renderer
+CMDIR=$(MOUNT_DIR)/qcommon
+SDLDIR=$(MOUNT_DIR)/sdl
+ASMDIR=$(MOUNT_DIR)/asm
+SYSDIR=$(MOUNT_DIR)/sys
+GDIR=$(MOUNT_DIR)/game
+CGDIR=$(MOUNT_DIR)/cgame
+NDIR=$(MOUNT_DIR)/null
+UIDIR=$(MOUNT_DIR)/ui
+JPDIR=$(MOUNT_DIR)/jpeg-8c
+SPEEXDIR=$(MOUNT_DIR)/libspeex
+ZDIR=$(MOUNT_DIR)/zlib
+Q3ASMDIR=$(MOUNT_DIR)/tools/asm
+LBURGDIR=$(MOUNT_DIR)/tools/lcc/lburg
+Q3CPPDIR=$(MOUNT_DIR)/tools/lcc/cpp
+Q3LCCETCDIR=$(MOUNT_DIR)/tools/lcc/etc
+Q3LCCSRCDIR=$(MOUNT_DIR)/tools/lcc/src
+SDLHDIR=$(MOUNT_DIR)/SDL12
+LIBSDIR=$(MOUNT_DIR)/libs
+MASTERDIR=$(MOUNT_DIR)/master
+TEMPDIR=/tmp
+
+bin_path=$(shell which $(1) 2> /dev/null)
+
+# We won't need this if we only build the server
+ifneq ($(BUILD_CLIENT),0)
+  # set PKG_CONFIG_PATH to influence this, e.g.
+  # PKG_CONFIG_PATH=/opt/cross/i386-mingw32msvc/lib/pkgconfig
+  ifneq ($(call bin_path, pkg-config),)
+    CURL_CFLAGS=$(shell pkg-config --silence-errors --cflags libcurl)
+    CURL_LIBS=$(shell pkg-config --silence-errors --libs libcurl)
+    OPENAL_CFLAGS=$(shell pkg-config --silence-errors --cflags openal)
+    OPENAL_LIBS=$(shell pkg-config --silence-errors --libs openal)
+    SDL_CFLAGS=$(shell pkg-config --silence-errors --cflags sdl|sed 's/-Dmain=SDL_main//')
+    SDL_LIBS=$(shell pkg-config --silence-errors --libs sdl)
+  endif
+  # Use sdl-config if all else fails
+  ifeq ($(SDL_CFLAGS),)
+    ifneq ($(call bin_path, sdl-config),)
+      SDL_CFLAGS=$(shell sdl-config --cflags)
+      SDL_LIBS=$(shell sdl-config --libs)
+    endif
+  endif
+endif
+
+# version info
+VERSION=gpp1
+
+USE_SVN=
+ifeq ($(wildcard .svn),.svn)
+  SVN_REV=$(shell LANG=C svnversion .)
+  ifneq ($(SVN_REV),)
+    VERSION:=$(VERSION)_SVN$(SVN_REV)
+    USE_SVN=1
+  endif
+endif
+
+
+#############################################################################
+# SETUP AND BUILD -- LINUX
+#############################################################################
+
+## Defaults
+LIB=lib
+
+INSTALL=install
+MKDIR=mkdir
+
+ifneq (,$(findstring "$(PLATFORM)", "linux" "gnu_kfreebsd" "kfreebsd-gnu"))
+
+  ifeq ($(ARCH),axp)
+    ARCH=alpha
+  else
+  ifeq ($(ARCH),x86_64)
+    LIB=lib64
+  else
+  ifeq ($(ARCH),ppc64)
+    LIB=lib64
+  else
+  ifeq ($(ARCH),s390x)
+    LIB=lib64
+  endif
+  endif
+  endif
+  endif
+
+  BASE_CFLAGS = -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes \
+    -pipe -DUSE_ICON
+  CLIENT_CFLAGS = $(SDL_CFLAGS)
+  SERVER_CFLAGS =
+
+  ifeq ($(USE_OPENAL),1)
+    CLIENT_CFLAGS += -DUSE_OPENAL
+    ifeq ($(USE_OPENAL_DLOPEN),1)
+      CLIENT_CFLAGS += -DUSE_OPENAL_DLOPEN
+    endif
+  endif
+
+  ifeq ($(USE_CURL),1)
+    CLIENT_CFLAGS += -DUSE_CURL
+    ifeq ($(USE_CURL_DLOPEN),1)
+      CLIENT_CFLAGS += -DUSE_CURL_DLOPEN
+    endif
+  endif
+
+  ifeq ($(USE_CODEC_VORBIS),1)
+    CLIENT_CFLAGS += -DUSE_CODEC_VORBIS
+  endif
+
+  OPTIMIZEVM = -O3 -funroll-loops -fomit-frame-pointer
+  OPTIMIZE = $(OPTIMIZEVM) -ffast-math
+
+  ifeq ($(ARCH),x86_64)
+    OPTIMIZEVM = -O3 -fomit-frame-pointer -funroll-loops \
+      -falign-loops=2 -falign-jumps=2 -falign-functions=2 \
+      -fstrength-reduce
+    OPTIMIZE = $(OPTIMIZEVM) -ffast-math
+    HAVE_VM_COMPILED = true
+  else
+  ifeq ($(ARCH),x86)
+    OPTIMIZEVM = -O3 -march=i586 -fomit-frame-pointer \
+      -funroll-loops -falign-loops=2 -falign-jumps=2 \
+      -falign-functions=2 -fstrength-reduce
+    OPTIMIZE = $(OPTIMIZEVM) -ffast-math
+    HAVE_VM_COMPILED=true
+  else
+  ifeq ($(ARCH),ppc)
+    BASE_CFLAGS += -maltivec
+    HAVE_VM_COMPILED=true
+  endif
+  ifeq ($(ARCH),ppc64)
+    BASE_CFLAGS += -maltivec
+    HAVE_VM_COMPILED=true
+  endif
+  ifeq ($(ARCH),sparc)
+    OPTIMIZE += -mtune=ultrasparc3 -mv8plus
+    OPTIMIZEVM += -mtune=ultrasparc3 -mv8plus
+    HAVE_VM_COMPILED=true
+  endif
+  ifeq ($(ARCH),alpha)
+    # According to http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=410555
+    # -ffast-math will cause the client to die with SIGFPE on Alpha
+    OPTIMIZE = $(OPTIMIZEVM)
+  endif
+  endif
+  endif
+
+  ifneq ($(HAVE_VM_COMPILED),true)
+    BASE_CFLAGS += -DNO_VM_COMPILED
+  endif
+
+  SHLIBEXT=so
+  SHLIBCFLAGS=-fPIC -fvisibility=hidden
+  SHLIBLDFLAGS=-shared $(LDFLAGS)
+
+  THREAD_LIBS=-lpthread
+  LIBS=-ldl -lm
+
+  CLIENT_LIBS=$(SDL_LIBS) -lGL
+
+  ifeq ($(USE_OPENAL),1)
+    ifneq ($(USE_OPENAL_DLOPEN),1)
+      CLIENT_LIBS += -lopenal
+    endif
+  endif
+
+  ifeq ($(USE_CURL),1)
+    ifneq ($(USE_CURL_DLOPEN),1)
+      CLIENT_LIBS += -lcurl
+    endif
+  endif
+
+  ifeq ($(USE_CODEC_VORBIS),1)
+    CLIENT_LIBS += -lvorbisfile -lvorbis -logg
+  endif
+
+  ifeq ($(USE_MUMBLE),1)
+    CLIENT_LIBS += -lrt
+  endif
+
+  ifeq ($(USE_LOCAL_HEADERS),1)
+    CLIENT_CFLAGS += -I$(SDLHDIR)/include
+  endif
+
+  ifeq ($(ARCH),x86)
+    # linux32 make ...
+    BASE_CFLAGS += -m32
+  else
+  ifeq ($(ARCH),ppc64)
+    BASE_CFLAGS += -m64
+  endif
+  endif
+else # ifeq Linux
+
+#############################################################################
+# SETUP AND BUILD -- MAC OS X
+#############################################################################
+
+ifeq ($(PLATFORM),darwin)
+  HAVE_VM_COMPILED=true
+  LIBS = -framework Cocoa
+  CLIENT_LIBS=
+  OPTIMIZEVM=
+
+  BASE_CFLAGS = -Wall -Wimplicit -Wstrict-prototypes
+  CLIENT_CFLAGS = 
+  SERVER_CFLAGS =
+
+  ifeq ($(ARCH),ppc)
+    BASE_CFLAGS += -faltivec
+    OPTIMIZEVM += -O3
+  endif
+  ifeq ($(ARCH),ppc64)
+    BASE_CFLAGS += -faltivec
+  endif
+  ifeq ($(ARCH),x86)
+    OPTIMIZEVM += -march=prescott -mfpmath=sse
+    # x86 vm will crash without -mstackrealign since MMX instructions will be
+    # used no matter what and they corrupt the frame pointer in VM calls
+    BASE_CFLAGS += -mstackrealign
+  endif
+
+  BASE_CFLAGS += -fno-strict-aliasing -DMACOS_X -fno-common -pipe
+
+  ifeq ($(USE_OPENAL),1)
+    BASE_CFLAGS += -DUSE_OPENAL
+    ifneq ($(USE_OPENAL_DLOPEN),1)
+      CLIENT_LIBS += -framework OpenAL
+    else
+      CLIENT_CFLAGS += -DUSE_OPENAL_DLOPEN
+    endif
+  endif
+
+  ifeq ($(USE_CURL),1)
+    CLIENT_CFLAGS += -DUSE_CURL
+    ifneq ($(USE_CURL_DLOPEN),1)
+      CLIENT_LIBS += -lcurl
+    else
+      CLIENT_CFLAGS += -DUSE_CURL_DLOPEN
+    endif
+  endif
+
+  ifeq ($(USE_CODEC_VORBIS),1)
+    CLIENT_CFLAGS += -DUSE_CODEC_VORBIS
+    CLIENT_LIBS += -lvorbisfile -lvorbis -logg
+  endif
+
+  BASE_CFLAGS += -D_THREAD_SAFE=1
+
+  ifeq ($(USE_LOCAL_HEADERS),1)
+    BASE_CFLAGS += -I$(SDLHDIR)/include
+  endif
+
+  # We copy sdlmain before ranlib'ing it so that subversion doesn't think
+  #  the file has been modified by each build.
+  LIBSDLMAIN=$(B)/libSDLmain.a
+  LIBSDLMAINSRC=$(LIBSDIR)/macosx/libSDLmain.a
+  CLIENT_LIBS += -framework IOKit -framework OpenGL \
+    $(LIBSDIR)/macosx/libSDL-1.2.0.dylib
+
+  OPTIMIZEVM += -falign-loops=16
+  OPTIMIZE = $(OPTIMIZEVM) -ffast-math
+
+  ifneq ($(HAVE_VM_COMPILED),true)
+    BASE_CFLAGS += -DNO_VM_COMPILED
+  endif
+
+  SHLIBEXT=dylib
+  SHLIBCFLAGS=-fPIC -fno-common
+  SHLIBLDFLAGS=-dynamiclib $(LDFLAGS)
+
+  NOTSHLIBCFLAGS=-mdynamic-no-pic
+
+  TOOLS_CFLAGS += -DMACOS_X
+
+else # ifeq darwin
+
+
+#############################################################################
+# SETUP AND BUILD -- MINGW32
+#############################################################################
+
+ifeq ($(PLATFORM),mingw32)
+
+  # Some MinGW installations define CC to cc, but don't actually provide cc,
+  # so explicitly use gcc instead (which is the only option anyway)
+  ifeq ($(call bin_path, $(CC)),)
+    CC=gcc
+  endif
+
+  ifndef WINDRES
+    WINDRES=windres
+  endif
+
+  BASE_CFLAGS = -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes \
+    -DUSE_ICON
+  CLIENT_CFLAGS =
+  SERVER_CFLAGS =
+
+  # In the absence of wspiapi.h, require Windows XP or later
+  ifeq ($(shell test -e $(CMDIR)/wspiapi.h; echo $$?),1)
+    BASE_CFLAGS += -DWINVER=0x501
+  endif
+
+  ifeq ($(USE_OPENAL),1)
+    CLIENT_CFLAGS += -DUSE_OPENAL
+    CLIENT_CFLAGS += $(OPENAL_CFLAGS)
+    ifeq ($(USE_OPENAL_DLOPEN),1)
+      CLIENT_CFLAGS += -DUSE_OPENAL_DLOPEN
+    else
+      CLIENT_LDFLAGS += $(OPENAL_LDFLAGS)
+    endif
+  endif
+
+  ifeq ($(USE_CODEC_VORBIS),1)
+    CLIENT_CFLAGS += -DUSE_CODEC_VORBIS
+  endif
+
+  ifeq ($(ARCH),x64)
+    OPTIMIZEVM = -O3 -fno-omit-frame-pointer \
+      -falign-loops=2 -funroll-loops -falign-jumps=2 -falign-functions=2 \
+      -fstrength-reduce
+    OPTIMIZE = $(OPTIMIZEVM) --fast-math
+    HAVE_VM_COMPILED = true
+  endif
+  ifeq ($(ARCH),x86)
+    OPTIMIZEVM = -O3 -march=i586 -fno-omit-frame-pointer \
+      -falign-loops=2 -funroll-loops -falign-jumps=2 -falign-functions=2 \
+      -fstrength-reduce
+    OPTIMIZE = $(OPTIMIZEVM) -ffast-math
+    HAVE_VM_COMPILED = true
+  endif
+
+  SHLIBEXT=dll
+  SHLIBCFLAGS=
+  SHLIBLDFLAGS=-shared $(LDFLAGS)
+
+  BINEXT=.exe
+
+  LIBS= -lws2_32 -lwinmm -lpsapi
+  CLIENT_LDFLAGS = -mwindows
+  CLIENT_LIBS = -lgdi32 -lole32 -lopengl32
+
+  ifeq ($(USE_CURL),1)
+    CLIENT_CFLAGS += -DUSE_CURL
+    CLIENT_CFLAGS += $(CURL_CFLAGS)
+    ifneq ($(USE_CURL_DLOPEN),1)
+      ifeq ($(USE_LOCAL_HEADERS),1)
+        CLIENT_CFLAGS += -DCURL_STATICLIB
+        ifeq ($(ARCH),x64)
+	  CLIENT_LIBS += $(LIBSDIR)/win64/libcurl.a
+	else
+          CLIENT_LIBS += $(LIBSDIR)/win32/libcurl.a
+        endif
+      else
+        CLIENT_LIBS += $(CURL_LIBS)
+      endif
+    endif
+  endif
+
+  ifeq ($(USE_CODEC_VORBIS),1)
+    CLIENT_LIBS += -lvorbisfile -lvorbis -logg
+  endif
+
+  ifeq ($(ARCH),x86)
+    # build 32bit
+    BASE_CFLAGS += -m32
+  else
+    BASE_CFLAGS += -m64
+  endif
+
+  # libmingw32 must be linked before libSDLmain
+  CLIENT_LIBS += -lmingw32
+  ifeq ($(USE_LOCAL_HEADERS),1)
+    CLIENT_CFLAGS += -I$(SDLHDIR)/include
+    ifeq ($(ARCH), x86)
+    CLIENT_LIBS += $(LIBSDIR)/win32/libSDLmain.a \
+                      $(LIBSDIR)/win32/libSDL.dll.a
+    else
+    CLIENT_LIBS += $(LIBSDIR)/win64/libSDLmain.a \
+                      $(LIBSDIR)/win64/libSDL.dll.a \
+                      $(LIBSDIR)/win64/libSDL.a
+    endif
+  else
+    CLIENT_CFLAGS += $(SDL_CFLAGS)
+    CLIENT_LIBS += $(SDL_LIBS)
+  endif
+
+  BUILD_CLIENT_SMP = 0
+
+else # ifeq mingw32
+
+#############################################################################
+# SETUP AND BUILD -- FREEBSD
+#############################################################################
+
+ifeq ($(PLATFORM),freebsd)
+
+  # flags
+  BASE_CFLAGS = $(shell env MACHINE_ARCH=$(ARCH) make -f /dev/null -VCFLAGS) \
+    -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes \
+    -DUSE_ICON -DMAP_ANONYMOUS=MAP_ANON
+  CLIENT_CFLAGS = $(SDL_CFLAGS)
+  SERVER_CFLAGS = 
+  HAVE_VM_COMPILED = true
+
+  OPTIMIZEVM = -O3 -funroll-loops -fomit-frame-pointer
+  OPTIMIZE = $(OPTIMIZEVM) -ffast-math
+
+  SHLIBEXT=so
+  SHLIBCFLAGS=-fPIC
+  SHLIBLDFLAGS=-shared $(LDFLAGS)
+
+  THREAD_LIBS=-lpthread
+  # don't need -ldl (FreeBSD)
+  LIBS=-lm
+
+  CLIENT_LIBS =
+
+  CLIENT_LIBS += $(SDL_LIBS) -lGL
+
+  # optional features/libraries
+  ifeq ($(USE_OPENAL),1)
+    CLIENT_CFLAGS += -DUSE_OPENAL
+    ifeq ($(USE_OPENAL_DLOPEN),1)
+      CLIENT_CFLAGS += -DUSE_OPENAL_DLOPEN
+      CLIENT_LIBS += $(THREAD_LIBS) -lopenal
+    endif
+  endif
+
+  ifeq ($(USE_CURL),1)
+    CLIENT_CFLAGS += -DUSE_CURL
+    ifeq ($(USE_CURL_DLOPEN),1)
+      CLIENT_CFLAGS += -DUSE_CURL_DLOPEN
+      CLIENT_LIBS += -lcurl
+    endif
+  endif
+
+  ifeq ($(USE_CODEC_VORBIS),1)
+    CLIENT_CFLAGS += -DUSE_CODEC_VORBIS
+  endif
+
+  ifeq ($(USE_CODEC_VORBIS),1)
+    CLIENT_LIBS += -lvorbisfile -lvorbis -logg
+  endif
+
+  # cross-compiling tweaks
+  ifeq ($(ARCH),i386)
+    ifeq ($(CROSS_COMPILING),1)
+      BASE_CFLAGS += -m32
+    endif
+  endif
+  ifeq ($(ARCH),amd64)
+    ifeq ($(CROSS_COMPILING),1)
+      BASE_CFLAGS += -m64
+    endif
+  endif
+
+else # ifeq freebsd
+
+#############################################################################
+# SETUP AND BUILD -- OPENBSD
+#############################################################################
+
+ifeq ($(PLATFORM),openbsd)
+
+  #default to i386, no tests done on anything else
+  ARCH=i386
+
+  BASE_CFLAGS = -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes \
+    -DUSE_ICON
+  CLIENT_CFLAGS = $(SDL_CFLAGS)
+  SERVER_CFLAGS = 
+
+  ifeq ($(USE_OPENAL),1)
+    CLIENT_CFLAGS += -DUSE_OPENAL
+    ifeq ($(USE_OPENAL_DLOPEN),1)
+      CLIENT_CFLAGS += -DUSE_OPENAL_DLOPEN
+    endif
+  endif
+
+  ifeq ($(USE_CODEC_VORBIS),1)
+    CLIENT_CFLAGS += -DUSE_CODEC_VORBIS
+  endif
+
+  ifeq ($(USE_CURL),1)
+    CLIENT_CFLAGS += -DUSE_CURL $(CURL_CFLAGS)
+    USE_CURL_DLOPEN=0
+  endif
+
+  BASE_CFLAGS += -DNO_VM_COMPILED
+  HAVE_VM_COMPILED=false
+
+  SHLIBEXT=so
+  SHLIBNAME=.$(SHLIBEXT)
+  SHLIBCFLAGS=-fPIC
+  SHLIBLDFLAGS=-shared $(LDFLAGS)
+
+  THREAD_LIBS=-pthread
+  LIBS=-lm
+
+  CLIENT_LIBS =
+
+  CLIENT_LIBS += $(SDL_LIBS) -lGL
+
+  ifeq ($(USE_OPENAL),1)
+    ifneq ($(USE_OPENAL_DLOPEN),1)
+      CLIENT_LIBS += $(THREAD_LIBS) -lossaudio -lopenal
+    endif
+  endif
+
+  ifeq ($(USE_CODEC_VORBIS),1)
+    CLIENT_LIBS += -lvorbisfile -lvorbis -logg
+  endif
+
+  ifeq ($(USE_CURL),1) 
+    ifneq ($(USE_CURL_DLOPEN),1)
+      CLIENT_LIBS += -lcurl
+    endif
+  endif
+
+else # ifeq openbsd
+
+#############################################################################
+# SETUP AND BUILD -- NETBSD
+#############################################################################
+
+ifeq ($(PLATFORM),netbsd)
+
+  ifeq ($(shell uname -m),i386)
+    ARCH=x86
+  endif
+
+  LIBS=-lm
+  SHLIBEXT=so
+  SHLIBCFLAGS=-fPIC
+  SHLIBLDFLAGS=-shared $(LDFLAGS)
+  THREAD_LIBS=-lpthread
+
+  BASE_CFLAGS = -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes
+  CLIENT_CFLAGS =
+  SERVER_CFLAGS =
+
+  ifneq ($(ARCH),x86)
+    BASE_CFLAGS += -DNO_VM_COMPILED
+  endif
+
+  BUILD_CLIENT = 0
+  BUILD_GAME_QVM = 0
+
+else # ifeq netbsd
+
+#############################################################################
+# SETUP AND BUILD -- IRIX
+#############################################################################
+
+ifeq ($(PLATFORM),irix64)
+
+  ARCH=mips  #default to MIPS
+
+  CC = c99
+  MKDIR = mkdir -p
+
+  BASE_CFLAGS=-Dstricmp=strcasecmp -Xcpluscomm -woff 1185 \
+    -I. -I$(ROOT)/usr/include -DNO_VM_COMPILED
+  CLIENT_CFLAGS = $(SDL_CFLAGS)
+  OPTIMIZE = -O3
+  
+  SHLIBEXT=so
+  SHLIBCFLAGS=
+  SHLIBLDFLAGS=-shared
+
+  LIBS=-ldl -lm -lgen
+  # FIXME: The X libraries probably aren't necessary?
+  CLIENT_LIBS=-L/usr/X11/$(LIB) $(SDL_LIBS) -lGL \
+    -lX11 -lXext -lm
+
+else # ifeq IRIX
+
+#############################################################################
+# SETUP AND BUILD -- SunOS
+#############################################################################
+
+ifeq ($(PLATFORM),sunos)
+
+  CC=gcc
+  INSTALL=ginstall
+  MKDIR=gmkdir
+  COPYDIR="/usr/local/share/games/tremulous"
+
+  ifneq (,$(findstring i86pc,$(shell uname -m)))
+    ARCH=x86
+  else #default to sparc
+    ARCH=sparc
+  endif
+
+  ifneq ($(ARCH),x86)
+    ifneq ($(ARCH),sparc)
+      $(error arch $(ARCH) is currently not supported)
+    endif
+  endif
+
+  BASE_CFLAGS = -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes \
+    -pipe -DUSE_ICON
+  CLIENT_CFLAGS = $(SDL_CFLAGS)
+  SERVER_CFLAGS =
+
+  OPTIMIZEVM = -O3 -funroll-loops
+
+  ifeq ($(ARCH),sparc)
+    OPTIMIZEVM += -O3 \
+      -fstrength-reduce -falign-functions=2 \
+      -mtune=ultrasparc3 -mv8plus -mno-faster-structs
+    HAVE_VM_COMPILED=true
+  else
+  ifeq ($(ARCH),x86)
+    OPTIMIZEVM += -march=i586 -fomit-frame-pointer \
+      -falign-loops=2 -falign-jumps=2 \
+      -falign-functions=2 -fstrength-reduce
+    HAVE_VM_COMPILED=true
+    BASE_CFLAGS += -m32
+    CLIENT_CFLAGS += -I/usr/X11/include/NVIDIA
+    CLIENT_LDFLAGS += -L/usr/X11/lib/NVIDIA -R/usr/X11/lib/NVIDIA
+  endif
+  endif
+  
+  OPTIMIZE = $(OPTIMIZEVM) -ffast-math
+
+  ifneq ($(HAVE_VM_COMPILED),true)
+    BASE_CFLAGS += -DNO_VM_COMPILED
+  endif
+
+  SHLIBEXT=so
+  SHLIBCFLAGS=-fPIC
+  SHLIBLDFLAGS=-shared $(LDFLAGS)
+
+  THREAD_LIBS=-lpthread
+  LIBS=-lsocket -lnsl -ldl -lm
+
+  BOTCFLAGS=-O0
+
+  CLIENT_LIBS +=$(SDL_LIBS) -lGL -lX11 -lXext -liconv -lm
+
+else # ifeq sunos
+
+#############################################################################
+# SETUP AND BUILD -- GENERIC
+#############################################################################
+  BASE_CFLAGS=-DNO_VM_COMPILED
+  OPTIMIZE = -O3
+
+  SHLIBEXT=so
+  SHLIBCFLAGS=-fPIC
+  SHLIBLDFLAGS=-shared
+
+endif #Linux
+endif #darwin
+endif #mingw32
+endif #FreeBSD
+endif #OpenBSD
+endif #NetBSD
+endif #IRIX
+endif #SunOS
+
+TARGETS =
+
+ifndef FULLBINEXT
+  FULLBINEXT=.$(ARCH)$(BINEXT)
+endif
+
+ifndef SHLIBNAME
+  SHLIBNAME=$(ARCH).$(SHLIBEXT)
+endif
+
+ifneq ($(BUILD_SERVER),0)
+  TARGETS += $(B)/tremded$(FULLBINEXT)
+endif
+
+ifneq ($(BUILD_CLIENT),0)
+  TARGETS += $(B)/tremulous$(FULLBINEXT)
+  ifneq ($(BUILD_CLIENT_SMP),0)
+    TARGETS += $(B)/tremulous-smp$(FULLBINEXT)
+  endif
+endif
+
+ifneq ($(BUILD_GAME_SO),0)
+  TARGETS += \
+    $(B)/base/cgame$(SHLIBNAME) \
+    $(B)/base/game$(SHLIBNAME) \
+    $(B)/base/ui$(SHLIBNAME)
+endif
+
+ifneq ($(BUILD_GAME_QVM),0)
+  ifneq ($(CROSS_COMPILING),1)
+    TARGETS += \
+      $(B)/base/vm/cgame.qvm \
+      $(B)/base/vm/game.qvm \
+      $(B)/base/vm/ui.qvm
+  endif
+endif
+
+ifeq ($(USE_MUMBLE),1)
+  CLIENT_CFLAGS += -DUSE_MUMBLE
+endif
+
+ifeq ($(USE_VOIP),1)
+  CLIENT_CFLAGS += -DUSE_VOIP
+  SERVER_CFLAGS += -DUSE_VOIP
+  ifeq ($(USE_INTERNAL_SPEEX),1)
+    CLIENT_CFLAGS += -DFLOATING_POINT -DUSE_ALLOCA -I$(SPEEXDIR)/include
+  else
+    CLIENT_LIBS += -lspeex -lspeexdsp
+  endif
+endif
+
+ifeq ($(USE_INTERNAL_ZLIB),1)
+  BASE_CFLAGS += -DNO_GZIP
+  BASE_CFLAGS += -I$(ZDIR)
+else
+  LIBS += -lz
+endif
+
+ifeq ($(USE_INTERNAL_JPEG),1)
+  BASE_CFLAGS += -DUSE_INTERNAL_JPEG
+  BASE_CFLAGS += -I$(JPDIR)
+else
+  CLIENT_LIBS += -ljpeg
+endif
+
+ifdef DEFAULT_BASEDIR
+  BASE_CFLAGS += -DDEFAULT_BASEDIR=\\\"$(DEFAULT_BASEDIR)\\\"
+endif
+
+ifeq ($(USE_LOCAL_HEADERS),1)
+  BASE_CFLAGS += -DUSE_LOCAL_HEADERS
+endif
+
+ifeq ($(BUILD_STANDALONE),1)
+  BASE_CFLAGS += -DSTANDALONE
+endif
+
+ifeq ($(GENERATE_DEPENDENCIES),1)
+  DEPEND_CFLAGS = -MMD
+else
+  DEPEND_CFLAGS =
+endif
+
+ifeq ($(NO_STRIP),1)
+  STRIP_FLAG =
+else
+  STRIP_FLAG = -s
+endif
+
+BASE_CFLAGS += -DPRODUCT_VERSION=\\\"$(VERSION)\\\"
+
+ifeq ($(V),1)
+echo_cmd=@:
+Q=
+else
+echo_cmd=@echo
+Q=@
+endif
+
+define DO_CC
+$(echo_cmd) "CC $<"
+$(Q)$(CC) $(NOTSHLIBCFLAGS) $(CFLAGS) $(CLIENT_CFLAGS) $(OPTIMIZE) -o $@ -c $<
+endef
+
+define DO_SMP_CC
+$(echo_cmd) "SMP_CC $<"
+$(Q)$(CC) $(NOTSHLIBCFLAGS) $(CFLAGS) $(CLIENT_CFLAGS) $(OPTIMIZE) -DSMP -o $@ -c $<
+endef
+
+ifeq ($(GENERATE_DEPENDENCIES),1)
+  DO_QVM_DEP=cat $(@:%.o=%.d) | sed -e 's/\.o/\.asm/g' >> $(@:%.o=%.d)
+endif
+
+define DO_SHLIB_CC
+$(echo_cmd) "SHLIB_CC $<"
+$(Q)$(CC) $(SHLIBCFLAGS) $(CFLAGS) $(OPTIMIZEVM) -o $@ -c $<
+$(Q)$(DO_QVM_DEP)
+endef
+
+define DO_GAME_CC
+$(echo_cmd) "GAME_CC $<"
+$(Q)$(CC) -DGAME $(SHLIBCFLAGS) $(CFLAGS) $(OPTIMIZEVM) -o $@ -c $<
+$(Q)$(DO_QVM_DEP)
+endef
+
+define DO_CGAME_CC
+$(echo_cmd) "CGAME_CC $<"
+$(Q)$(CC) -DCGAME $(SHLIBCFLAGS) $(CFLAGS) $(OPTIMIZEVM) -o $@ -c $<
+$(Q)$(DO_QVM_DEP)
+endef
+
+define DO_UI_CC
+$(echo_cmd) "UI_CC $<"
+$(Q)$(CC) -DUI $(SHLIBCFLAGS) $(CFLAGS) $(OPTIMIZEVM) -o $@ -c $<
+$(Q)$(DO_QVM_DEP)
+endef
+
+define DO_AS
+$(echo_cmd) "AS $<"
+$(Q)$(CC) $(CFLAGS) $(OPTIMIZE) -x assembler-with-cpp -o $@ -c $<
+endef
+
+define DO_DED_CC
+$(echo_cmd) "DED_CC $<"
+$(Q)$(CC) $(NOTSHLIBCFLAGS) -DDEDICATED $(CFLAGS) $(SERVER_CFLAGS) $(OPTIMIZE) -o $@ -c $<
+endef
+
+define DO_WINDRES
+$(echo_cmd) "WINDRES $<"
+$(Q)$(WINDRES) -i $< -o $@
+endef
+
+
+#############################################################################
+# MAIN TARGETS
+#############################################################################
+
+default: release
+all: debug release
+
+debug:
+	@$(MAKE) targets B=$(BD) CFLAGS="$(CFLAGS) $(BASE_CFLAGS) $(DEPEND_CFLAGS)" \
+	  OPTIMIZE="$(DEBUG_CFLAGS)" OPTIMIZEVM="$(DEBUG_CFLAGS)" \
+	  CLIENT_CFLAGS="$(CLIENT_CFLAGS)" SERVER_CFLAGS="$(SERVER_CFLAGS)" V=$(V)
+ifeq ($(BUILD_MASTER_SERVER),1)
+	$(MAKE) -C $(MASTERDIR) debug
+endif
+
+release:
+	@$(MAKE) targets B=$(BR) CFLAGS="$(CFLAGS) $(BASE_CFLAGS) $(DEPEND_CFLAGS)" \
+	  OPTIMIZE="-DNDEBUG $(OPTIMIZE)" OPTIMIZEVM="-DNDEBUG $(OPTIMIZEVM)" \
+	  CLIENT_CFLAGS="$(CLIENT_CFLAGS)" SERVER_CFLAGS="$(SERVER_CFLAGS)" V=$(V)
+ifeq ($(BUILD_MASTER_SERVER),1)
+	$(MAKE) -C $(MASTERDIR) release
+endif
+
+# Create the build directories, check libraries and print out
+# an informational message, then start building
+targets: makedirs
+	@echo ""
+	@echo "Building Tremulous in $(B):"
+	@echo "  PLATFORM: $(PLATFORM)"
+	@echo "  ARCH: $(ARCH)"
+	@echo "  VERSION: $(VERSION)"
+	@echo "  COMPILE_PLATFORM: $(COMPILE_PLATFORM)"
+	@echo "  COMPILE_ARCH: $(COMPILE_ARCH)"
+	@echo "  CC: $(CC)"
+	@echo ""
+	@echo "  CFLAGS:"
+	-@for i in $(CFLAGS); \
+	do \
+		echo "    $$i"; \
+	done
+	-@for i in $(OPTIMIZE); \
+	do \
+		echo "    $$i"; \
+	done
+	@echo ""
+	@echo "  CLIENT_CFLAGS:"
+	-@for i in $(CLIENT_CFLAGS); \
+	do \
+		echo "    $$i"; \
+	done
+	@echo ""
+	@echo "  SERVER_CFLAGS:"
+	-@for i in $(SERVER_CFLAGS); \
+	do \
+		echo "    $$i"; \
+	done
+	@echo ""
+	@echo "  LDFLAGS:"
+	-@for i in $(LDFLAGS); \
+	do \
+		echo "    $$i"; \
+	done
+	@echo ""
+	@echo "  LIBS:"
+	-@for i in $(LIBS); \
+	do \
+		echo "    $$i"; \
+	done
+	@echo ""
+	@echo "  CLIENT_LIBS:"
+	-@for i in $(CLIENT_LIBS); \
+	do \
+		echo "    $$i"; \
+	done
+	@echo ""
+	@echo "  Output:"
+	-@for i in $(TARGETS); \
+	do \
+		echo "    $$i"; \
+	done
+	@echo ""
+ifneq ($(TARGETS),)
+	@$(MAKE) $(TARGETS) V=$(V)
+endif
+
+makedirs:
+	@if [ ! -d $(BUILD_DIR) ];then $(MKDIR) $(BUILD_DIR);fi
+	@if [ ! -d $(B) ];then $(MKDIR) $(B);fi
+	@if [ ! -d $(B)/client ];then $(MKDIR) $(B)/client;fi
+	@if [ ! -d $(B)/clientsmp ];then $(MKDIR) $(B)/clientsmp;fi
+	@if [ ! -d $(B)/ded ];then $(MKDIR) $(B)/ded;fi
+	@if [ ! -d $(B)/base ];then $(MKDIR) $(B)/base;fi
+	@if [ ! -d $(B)/base/cgame ];then $(MKDIR) $(B)/base/cgame;fi
+	@if [ ! -d $(B)/base/game ];then $(MKDIR) $(B)/base/game;fi
+	@if [ ! -d $(B)/base/ui ];then $(MKDIR) $(B)/base/ui;fi
+	@if [ ! -d $(B)/base/qcommon ];then $(MKDIR) $(B)/base/qcommon;fi
+	@if [ ! -d $(B)/base/vm ];then $(MKDIR) $(B)/base/vm;fi
+	@if [ ! -d $(B)/tools ];then $(MKDIR) $(B)/tools;fi
+	@if [ ! -d $(B)/tools/asm ];then $(MKDIR) $(B)/tools/asm;fi
+	@if [ ! -d $(B)/tools/etc ];then $(MKDIR) $(B)/tools/etc;fi
+	@if [ ! -d $(B)/tools/rcc ];then $(MKDIR) $(B)/tools/rcc;fi
+	@if [ ! -d $(B)/tools/cpp ];then $(MKDIR) $(B)/tools/cpp;fi
+	@if [ ! -d $(B)/tools/lburg ];then $(MKDIR) $(B)/tools/lburg;fi
+
+#############################################################################
+# QVM BUILD TOOLS
+#############################################################################
+
+TOOLS_OPTIMIZE = -g -Wall -fno-strict-aliasing
+TOOLS_CFLAGS += $(TOOLS_OPTIMIZE) \
+                -DTEMPDIR=\"$(TEMPDIR)\" -DSYSTEM=\"\" \
+                -I$(Q3LCCSRCDIR) \
+                -I$(LBURGDIR)
+TOOLS_LIBS =
+TOOLS_LDFLAGS =
+
+ifeq ($(GENERATE_DEPENDENCIES),1)
+	TOOLS_CFLAGS += -MMD
+endif
+
+define DO_TOOLS_CC
+$(echo_cmd) "TOOLS_CC $<"
+$(Q)$(CC) $(TOOLS_CFLAGS) -o $@ -c $<
+endef
+
+define DO_TOOLS_CC_DAGCHECK
+$(echo_cmd) "TOOLS_CC_DAGCHECK $<"
+$(Q)$(CC) $(TOOLS_CFLAGS) -Wno-unused -o $@ -c $<
+endef
+
+LBURG       = $(B)/tools/lburg/lburg$(BINEXT)
+DAGCHECK_C  = $(B)/tools/rcc/dagcheck.c
+Q3RCC       = $(B)/tools/q3rcc$(BINEXT)
+Q3CPP       = $(B)/tools/q3cpp$(BINEXT)
+Q3LCC       = $(B)/tools/q3lcc$(BINEXT)
+Q3ASM       = $(B)/tools/q3asm$(BINEXT)
+
+LBURGOBJ= \
+	$(B)/tools/lburg/lburg.o \
+	$(B)/tools/lburg/gram.o
+
+$(B)/tools/lburg/%.o: $(LBURGDIR)/%.c
+	$(DO_TOOLS_CC)
+
+$(LBURG): $(LBURGOBJ)
+	$(echo_cmd) "LD $@"
+	$(Q)$(CC) $(TOOLS_CFLAGS) $(TOOLS_LDFLAGS) -o $@ $^ $(TOOLS_LIBS)
+
+Q3RCCOBJ = \
+  $(B)/tools/rcc/alloc.o \
+  $(B)/tools/rcc/bind.o \
+  $(B)/tools/rcc/bytecode.o \
+  $(B)/tools/rcc/dag.o \
+  $(B)/tools/rcc/dagcheck.o \
+  $(B)/tools/rcc/decl.o \
+  $(B)/tools/rcc/enode.o \
+  $(B)/tools/rcc/error.o \
+  $(B)/tools/rcc/event.o \
+  $(B)/tools/rcc/expr.o \
+  $(B)/tools/rcc/gen.o \
+  $(B)/tools/rcc/init.o \
+  $(B)/tools/rcc/inits.o \
+  $(B)/tools/rcc/input.o \
+  $(B)/tools/rcc/lex.o \
+  $(B)/tools/rcc/list.o \
+  $(B)/tools/rcc/main.o \
+  $(B)/tools/rcc/null.o \
+  $(B)/tools/rcc/output.o \
+  $(B)/tools/rcc/prof.o \
+  $(B)/tools/rcc/profio.o \
+  $(B)/tools/rcc/simp.o \
+  $(B)/tools/rcc/stmt.o \
+  $(B)/tools/rcc/string.o \
+  $(B)/tools/rcc/sym.o \
+  $(B)/tools/rcc/symbolic.o \
+  $(B)/tools/rcc/trace.o \
+  $(B)/tools/rcc/tree.o \
+  $(B)/tools/rcc/types.o
+
+$(DAGCHECK_C): $(LBURG) $(Q3LCCSRCDIR)/dagcheck.md
+	$(echo_cmd) "LBURG $(Q3LCCSRCDIR)/dagcheck.md"
+	$(Q)$(LBURG) $(Q3LCCSRCDIR)/dagcheck.md $@
+
+$(B)/tools/rcc/dagcheck.o: $(DAGCHECK_C)
+	$(DO_TOOLS_CC_DAGCHECK)
+
+$(B)/tools/rcc/%.o: $(Q3LCCSRCDIR)/%.c
+	$(DO_TOOLS_CC)
+
+$(Q3RCC): $(Q3RCCOBJ)
+	$(echo_cmd) "LD $@"
+	$(Q)$(CC) $(TOOLS_CFLAGS) $(TOOLS_LDFLAGS) -o $@ $^ $(TOOLS_LIBS)
+
+Q3CPPOBJ = \
+	$(B)/tools/cpp/cpp.o \
+	$(B)/tools/cpp/lex.o \
+	$(B)/tools/cpp/nlist.o \
+	$(B)/tools/cpp/tokens.o \
+	$(B)/tools/cpp/macro.o \
+	$(B)/tools/cpp/eval.o \
+	$(B)/tools/cpp/include.o \
+	$(B)/tools/cpp/hideset.o \
+	$(B)/tools/cpp/getopt.o \
+	$(B)/tools/cpp/unix.o
+
+$(B)/tools/cpp/%.o: $(Q3CPPDIR)/%.c
+	$(DO_TOOLS_CC)
+
+$(Q3CPP): $(Q3CPPOBJ)
+	$(echo_cmd) "LD $@"
+	$(Q)$(CC) $(TOOLS_CFLAGS) $(TOOLS_LDFLAGS) -o $@ $^ $(TOOLS_LIBS)
+
+Q3LCCOBJ = \
+	$(B)/tools/etc/lcc.o \
+	$(B)/tools/etc/bytecode.o
+
+$(B)/tools/etc/%.o: $(Q3LCCETCDIR)/%.c
+	$(DO_TOOLS_CC)
+
+$(Q3LCC): $(Q3LCCOBJ) $(Q3RCC) $(Q3CPP)
+	$(echo_cmd) "LD $@"
+	$(Q)$(CC) $(TOOLS_CFLAGS) $(TOOLS_LDFLAGS) -o $@ $(Q3LCCOBJ) $(TOOLS_LIBS)
+
+define DO_Q3LCC
+$(echo_cmd) "Q3LCC $<"
+$(Q)$(Q3LCC) -o $@ $<
+endef
+
+define DO_CGAME_Q3LCC
+$(echo_cmd) "CGAME_Q3LCC $<"
+$(Q)$(Q3LCC) -DPRODUCT_VERSION=\"$(VERSION)\" -DCGAME -o $@ $<
+endef
+
+define DO_GAME_Q3LCC
+$(echo_cmd) "GAME_Q3LCC $<"
+$(Q)$(Q3LCC) -DPRODUCT_VERSION=\"$(VERSION)\" -DGAME -o $@ $<
+endef
+
+define DO_UI_Q3LCC
+$(echo_cmd) "UI_Q3LCC $<"
+$(Q)$(Q3LCC) -DPRODUCT_VERSION=\"$(VERSION)\" -DUI -o $@ $<
+endef
+
+
+Q3ASMOBJ = \
+  $(B)/tools/asm/q3asm.o \
+  $(B)/tools/asm/cmdlib.o
+
+$(B)/tools/asm/%.o: $(Q3ASMDIR)/%.c
+	$(DO_TOOLS_CC)
+
+$(Q3ASM): $(Q3ASMOBJ)
+	$(echo_cmd) "LD $@"
+	$(Q)$(CC) $(TOOLS_CFLAGS) $(TOOLS_LDFLAGS) -o $@ $^ $(TOOLS_LIBS)
+
+
+#############################################################################
+# CLIENT/SERVER
+#############################################################################
+
+Q3OBJ = \
+  $(B)/client/cl_cgame.o \
+  $(B)/client/cl_cin.o \
+  $(B)/client/cl_console.o \
+  $(B)/client/cl_input.o \
+  $(B)/client/cl_keys.o \
+  $(B)/client/cl_main.o \
+  $(B)/client/cl_net_chan.o \
+  $(B)/client/cl_parse.o \
+  $(B)/client/cl_scrn.o \
+  $(B)/client/cl_ui.o \
+  $(B)/client/cl_avi.o \
+  \
+  $(B)/client/cm_load.o \
+  $(B)/client/cm_patch.o \
+  $(B)/client/cm_polylib.o \
+  $(B)/client/cm_test.o \
+  $(B)/client/cm_trace.o \
+  \
+  $(B)/client/cmd.o \
+  $(B)/client/common.o \
+  $(B)/client/cvar.o \
+  $(B)/client/files.o \
+  $(B)/client/md4.o \
+  $(B)/client/md5.o \
+  $(B)/client/msg.o \
+  $(B)/client/net_chan.o \
+  $(B)/client/net_ip.o \
+  $(B)/client/huffman.o \
+  $(B)/client/parse.o \
+  \
+  $(B)/client/snd_adpcm.o \
+  $(B)/client/snd_dma.o \
+  $(B)/client/snd_mem.o \
+  $(B)/client/snd_mix.o \
+  $(B)/client/snd_wavelet.o \
+  \
+  $(B)/client/snd_main.o \
+  $(B)/client/snd_codec.o \
+  $(B)/client/snd_codec_wav.o \
+  $(B)/client/snd_codec_ogg.o \
+  \
+  $(B)/client/qal.o \
+  $(B)/client/snd_openal.o \
+  \
+  $(B)/client/cl_curl.o \
+  \
+  $(B)/client/sv_ccmds.o \
+  $(B)/client/sv_client.o \
+  $(B)/client/sv_game.o \
+  $(B)/client/sv_init.o \
+  $(B)/client/sv_main.o \
+  $(B)/client/sv_net_chan.o \
+  $(B)/client/sv_snapshot.o \
+  $(B)/client/sv_world.o \
+  \
+  $(B)/client/q_math.o \
+  $(B)/client/q_shared.o \
+  \
+  $(B)/client/unzip.o \
+  $(B)/client/ioapi.o \
+  $(B)/client/puff.o \
+  $(B)/client/vm.o \
+  $(B)/client/vm_interpreted.o \
+  \
+  $(B)/client/tr_animation.o \
+  $(B)/client/tr_backend.o \
+  $(B)/client/tr_bsp.o \
+  $(B)/client/tr_cmds.o \
+  $(B)/client/tr_curve.o \
+  $(B)/client/tr_flares.o \
+  $(B)/client/tr_font.o \
+  $(B)/client/tr_image.o \
+  $(B)/client/tr_image_png.o \
+  $(B)/client/tr_image_jpg.o \
+  $(B)/client/tr_image_bmp.o \
+  $(B)/client/tr_image_tga.o \
+  $(B)/client/tr_image_pcx.o \
+  $(B)/client/tr_init.o \
+  $(B)/client/tr_light.o \
+  $(B)/client/tr_main.o \
+  $(B)/client/tr_marks.o \
+  $(B)/client/tr_mesh.o \
+  $(B)/client/tr_model.o \
+  $(B)/client/tr_noise.o \
+  $(B)/client/tr_scene.o \
+  $(B)/client/tr_shade.o \
+  $(B)/client/tr_shade_calc.o \
+  $(B)/client/tr_shader.o \
+  $(B)/client/tr_shadows.o \
+  $(B)/client/tr_sky.o \
+  $(B)/client/tr_surface.o \
+  $(B)/client/tr_world.o \
+  \
+  $(B)/client/sdl_gamma.o \
+  $(B)/client/sdl_input.o \
+  $(B)/client/sdl_snd.o \
+  \
+  $(B)/client/con_passive.o \
+  $(B)/client/con_log.o \
+  $(B)/client/sys_main.o
+
+ifneq ($(USE_INTERNAL_JPEG),0)
+  Q3OBJ += \
+    $(B)/client/jaricom.o \
+    $(B)/client/jcapimin.o \
+    $(B)/client/jcapistd.o \
+    $(B)/client/jcarith.o \
+    $(B)/client/jccoefct.o  \
+    $(B)/client/jccolor.o \
+    $(B)/client/jcdctmgr.o \
+    $(B)/client/jchuff.o   \
+    $(B)/client/jcinit.o \
+    $(B)/client/jcmainct.o \
+    $(B)/client/jcmarker.o \
+    $(B)/client/jcmaster.o \
+    $(B)/client/jcomapi.o \
+    $(B)/client/jcparam.o \
+    $(B)/client/jcprepct.o \
+    $(B)/client/jcsample.o \
+    $(B)/client/jctrans.o \
+    $(B)/client/jdapimin.o \
+    $(B)/client/jdapistd.o \
+    $(B)/client/jdarith.o \
+    $(B)/client/jdatadst.o \
+    $(B)/client/jdatasrc.o \
+    $(B)/client/jdcoefct.o \
+    $(B)/client/jdcolor.o \
+    $(B)/client/jddctmgr.o \
+    $(B)/client/jdhuff.o \
+    $(B)/client/jdinput.o \
+    $(B)/client/jdmainct.o \
+    $(B)/client/jdmarker.o \
+    $(B)/client/jdmaster.o \
+    $(B)/client/jdmerge.o \
+    $(B)/client/jdpostct.o \
+    $(B)/client/jdsample.o \
+    $(B)/client/jdtrans.o \
+    $(B)/client/jerror.o \
+    $(B)/client/jfdctflt.o \
+    $(B)/client/jfdctfst.o \
+    $(B)/client/jfdctint.o \
+    $(B)/client/jidctflt.o \
+    $(B)/client/jidctfst.o \
+    $(B)/client/jidctint.o \
+    $(B)/client/jmemmgr.o \
+    $(B)/client/jmemnobs.o \
+    $(B)/client/jquant1.o \
+    $(B)/client/jquant2.o \
+    $(B)/client/jutils.o
+endif
+
+ifeq ($(ARCH),x86)
+  Q3OBJ += \
+    $(B)/client/snd_mixa.o \
+    $(B)/client/matha.o \
+    $(B)/client/ftola.o \
+    $(B)/client/snapvectora.o
+endif
+
+ifeq ($(USE_VOIP),1)
+ifeq ($(USE_INTERNAL_SPEEX),1)
+Q3OBJ += \
+  $(B)/client/bits.o \
+  $(B)/client/buffer.o \
+  $(B)/client/cb_search.o \
+  $(B)/client/exc_10_16_table.o \
+  $(B)/client/exc_10_32_table.o \
+  $(B)/client/exc_20_32_table.o \
+  $(B)/client/exc_5_256_table.o \
+  $(B)/client/exc_5_64_table.o \
+  $(B)/client/exc_8_128_table.o \
+  $(B)/client/fftwrap.o \
+  $(B)/client/filterbank.o \
+  $(B)/client/filters.o \
+  $(B)/client/gain_table.o \
+  $(B)/client/gain_table_lbr.o \
+  $(B)/client/hexc_10_32_table.o \
+  $(B)/client/hexc_table.o \
+  $(B)/client/high_lsp_tables.o \
+  $(B)/client/jitter.o \
+  $(B)/client/kiss_fft.o \
+  $(B)/client/kiss_fftr.o \
+  $(B)/client/lpc.o \
+  $(B)/client/lsp.o \
+  $(B)/client/lsp_tables_nb.o \
+  $(B)/client/ltp.o \
+  $(B)/client/mdf.o \
+  $(B)/client/modes.o \
+  $(B)/client/modes_wb.o \
+  $(B)/client/nb_celp.o \
+  $(B)/client/preprocess.o \
+  $(B)/client/quant_lsp.o \
+  $(B)/client/resample.o \
+  $(B)/client/sb_celp.o \
+  $(B)/client/smallft.o \
+  $(B)/client/speex.o \
+  $(B)/client/speex_callbacks.o \
+  $(B)/client/speex_header.o \
+  $(B)/client/stereo.o \
+  $(B)/client/vbr.o \
+  $(B)/client/vq.o \
+  $(B)/client/window.o
+endif
+endif
+
+ifeq ($(USE_INTERNAL_ZLIB),1)
+Q3OBJ += \
+  $(B)/client/adler32.o \
+  $(B)/client/crc32.o \
+  $(B)/client/inffast.o \
+  $(B)/client/inflate.o \
+  $(B)/client/inftrees.o \
+  $(B)/client/zutil.o
+endif
+
+ifeq ($(HAVE_VM_COMPILED),true)
+  ifeq ($(ARCH),x86)
+    Q3OBJ += $(B)/client/vm_x86.o
+  endif
+  ifeq ($(ARCH),x86_64)
+    Q3OBJ += $(B)/client/vm_x86_64.o $(B)/client/vm_x86_64_assembler.o
+  endif
+  ifeq ($(ARCH),amd64)
+    Q3OBJ += $(B)/client/vm_x86_64.o $(B)/client/vm_x86_64_assembler.o
+  endif
+  ifeq ($(ARCH),x64)
+    Q3OBJ += $(B)/client/vm_x86_64.o $(B)/client/vm_x86_64_assembler.o
+  endif
+  ifeq ($(ARCH),ppc)
+    Q3OBJ += $(B)/client/vm_powerpc.o $(B)/client/vm_powerpc_asm.o
+  endif
+  ifeq ($(ARCH),ppc64)
+    Q3OBJ += $(B)/client/vm_powerpc.o $(B)/client/vm_powerpc_asm.o
+  endif
+  ifeq ($(ARCH),sparc)
+    Q3OBJ += $(B)/client/vm_sparc.o
+  endif
+endif
+
+ifeq ($(PLATFORM),mingw32)
+  Q3OBJ += \
+    $(B)/client/win_resource.o \
+    $(B)/client/sys_win32.o
+else
+  Q3OBJ += \
+    $(B)/client/sys_unix.o
+endif
+
+ifeq ($(PLATFORM),darwin)
+  Q3OBJ += \
+    $(B)/client/sys_osx.o
+endif
+
+ifeq ($(USE_MUMBLE),1)
+  Q3OBJ += \
+    $(B)/client/libmumblelink.o
+endif
+
+Q3POBJ += \
+  $(B)/client/sdl_glimp.o
+
+Q3POBJ_SMP += \
+  $(B)/clientsmp/sdl_glimp.o
+
+$(B)/tremulous$(FULLBINEXT): $(Q3OBJ) $(Q3POBJ) $(LIBSDLMAIN)
+	$(echo_cmd) "LD $@"
+	$(Q)$(CC) $(CLIENT_CFLAGS) $(CFLAGS) $(CLIENT_LDFLAGS) $(LDFLAGS) \
+		-o $@ $(Q3OBJ) $(Q3POBJ) \
+		$(LIBSDLMAIN) $(CLIENT_LIBS) $(LIBS)
+
+$(B)/tremulous-smp$(FULLBINEXT): $(Q3OBJ) $(Q3POBJ_SMP) $(LIBSDLMAIN)
+	$(echo_cmd) "LD $@"
+	$(Q)$(CC) $(CLIENT_CFLAGS) $(CFLAGS) $(CLIENT_LDFLAGS) $(LDFLAGS) $(THREAD_LDFLAGS) \
+		-o $@ $(Q3OBJ) $(Q3POBJ_SMP) \
+		$(THREAD_LIBS) $(LIBSDLMAIN) $(CLIENT_LIBS) $(LIBS)
+
+ifneq ($(strip $(LIBSDLMAIN)),)
+ifneq ($(strip $(LIBSDLMAINSRC)),)
+$(LIBSDLMAIN) : $(LIBSDLMAINSRC)
+	cp $< $@
+	ranlib $@
+endif
+endif
+
+
+
+#############################################################################
+# DEDICATED SERVER
+#############################################################################
+
+Q3DOBJ = \
+  $(B)/ded/sv_client.o \
+  $(B)/ded/sv_ccmds.o \
+  $(B)/ded/sv_game.o \
+  $(B)/ded/sv_init.o \
+  $(B)/ded/sv_main.o \
+  $(B)/ded/sv_net_chan.o \
+  $(B)/ded/sv_snapshot.o \
+  $(B)/ded/sv_world.o \
+  \
+  $(B)/ded/cm_load.o \
+  $(B)/ded/cm_patch.o \
+  $(B)/ded/cm_polylib.o \
+  $(B)/ded/cm_test.o \
+  $(B)/ded/cm_trace.o \
+  $(B)/ded/cmd.o \
+  $(B)/ded/common.o \
+  $(B)/ded/cvar.o \
+  $(B)/ded/files.o \
+  $(B)/ded/md4.o \
+  $(B)/ded/msg.o \
+  $(B)/ded/net_chan.o \
+  $(B)/ded/net_ip.o \
+  $(B)/ded/huffman.o \
+  $(B)/ded/parse.o \
+  \
+  $(B)/ded/q_math.o \
+  $(B)/ded/q_shared.o \
+  \
+  $(B)/ded/unzip.o \
+  $(B)/ded/ioapi.o \
+  $(B)/ded/vm.o \
+  $(B)/ded/vm_interpreted.o \
+  \
+  $(B)/ded/null_client.o \
+  $(B)/ded/null_input.o \
+  $(B)/ded/null_snddma.o \
+  \
+  $(B)/ded/con_log.o \
+  $(B)/ded/sys_main.o
+
+ifeq ($(ARCH),x86)
+  Q3DOBJ += \
+      $(B)/ded/ftola.o \
+      $(B)/ded/snapvectora.o \
+      $(B)/ded/matha.o
+endif
+
+ifeq ($(USE_INTERNAL_ZLIB),1)
+Q3DOBJ += \
+  $(B)/ded/adler32.o \
+  $(B)/ded/crc32.o \
+  $(B)/ded/inffast.o \
+  $(B)/ded/inflate.o \
+  $(B)/ded/inftrees.o \
+  $(B)/ded/zutil.o
+endif
+
+ifeq ($(HAVE_VM_COMPILED),true)
+  ifeq ($(ARCH),x86)
+    Q3DOBJ += $(B)/ded/vm_x86.o
+  endif
+  ifeq ($(ARCH),x86_64)
+    Q3DOBJ += $(B)/ded/vm_x86_64.o $(B)/ded/vm_x86_64_assembler.o
+  endif
+  ifeq ($(ARCH),amd64)
+    Q3DOBJ += $(B)/ded/vm_x86_64.o $(B)/ded/vm_x86_64_assembler.o
+  endif
+  ifeq ($(ARCH),x64)
+    Q3DOBJ += $(B)/ded/vm_x86_64.o $(B)/ded/vm_x86_64_assembler.o
+  endif
+  ifeq ($(ARCH),ppc)
+    Q3DOBJ += $(B)/ded/vm_powerpc.o $(B)/ded/vm_powerpc_asm.o
+  endif
+  ifeq ($(ARCH),ppc64)
+    Q3DOBJ += $(B)/ded/vm_powerpc.o $(B)/ded/vm_powerpc_asm.o
+  endif
+  ifeq ($(ARCH),sparc)
+    Q3DOBJ += $(B)/ded/vm_sparc.o
+  endif
+endif
+
+ifeq ($(PLATFORM),mingw32)
+  Q3DOBJ += \
+    $(B)/ded/win_resource.o \
+    $(B)/ded/sys_win32.o \
+    $(B)/ded/con_win32.o
+else
+  Q3DOBJ += \
+    $(B)/ded/sys_unix.o \
+    $(B)/ded/con_tty.o
+endif
+
+ifeq ($(PLATFORM),darwin)
+  Q3DOBJ += \
+    $(B)/ded/sys_osx.o
+endif
+
+$(B)/tremded$(FULLBINEXT): $(Q3DOBJ)
+	$(echo_cmd) "LD $@"
+	$(Q)$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(Q3DOBJ) $(LIBS)
+
+
+
+#############################################################################
+## TREMULOUS CGAME
+#############################################################################
+
+CGOBJ_ = \
+  $(B)/base/cgame/cg_main.o \
+  $(B)/base/cgame/bg_misc.o \
+  $(B)/base/cgame/bg_pmove.o \
+  $(B)/base/cgame/bg_slidemove.o \
+  $(B)/base/cgame/bg_lib.o \
+  $(B)/base/cgame/bg_alloc.o \
+  $(B)/base/cgame/bg_voice.o \
+  $(B)/base/cgame/cg_consolecmds.o \
+  $(B)/base/cgame/cg_buildable.o \
+  $(B)/base/cgame/cg_animation.o \
+  $(B)/base/cgame/cg_animmapobj.o \
+  $(B)/base/cgame/cg_draw.o \
+  $(B)/base/cgame/cg_drawtools.o \
+  $(B)/base/cgame/cg_ents.o \
+  $(B)/base/cgame/cg_event.o \
+  $(B)/base/cgame/cg_marks.o \
+  $(B)/base/cgame/cg_players.o \
+  $(B)/base/cgame/cg_playerstate.o \
+  $(B)/base/cgame/cg_predict.o \
+  $(B)/base/cgame/cg_servercmds.o \
+  $(B)/base/cgame/cg_snapshot.o \
+  $(B)/base/cgame/cg_view.o \
+  $(B)/base/cgame/cg_weapons.o \
+  $(B)/base/cgame/cg_scanner.o \
+  $(B)/base/cgame/cg_attachment.o \
+  $(B)/base/cgame/cg_trails.o \
+  $(B)/base/cgame/cg_particles.o \
+  $(B)/base/cgame/cg_tutorial.o \
+  $(B)/base/ui/ui_shared.o \
+  \
+  $(B)/base/qcommon/q_math.o \
+  $(B)/base/qcommon/q_shared.o
+
+CGOBJ = $(CGOBJ_) $(B)/base/cgame/cg_syscalls.o
+CGVMOBJ = $(CGOBJ_:%.o=%.asm)
+
+$(B)/base/cgame$(SHLIBNAME): $(CGOBJ)
+	$(echo_cmd) "LD $@"
+	$(Q)$(CC) $(CFLAGS) $(SHLIBLDFLAGS) -o $@ $(CGOBJ)
+
+$(B)/base/vm/cgame.qvm: $(CGVMOBJ) $(CGDIR)/cg_syscalls.asm $(Q3ASM)
+	$(echo_cmd) "Q3ASM $@"
+	$(Q)$(Q3ASM) -o $@ $(CGVMOBJ) $(CGDIR)/cg_syscalls.asm
+
+
+
+#############################################################################
+## TREMULOUS GAME
+#############################################################################
+
+GOBJ_ = \
+  $(B)/base/game/g_main.o \
+  $(B)/base/game/bg_misc.o \
+  $(B)/base/game/bg_pmove.o \
+  $(B)/base/game/bg_slidemove.o \
+  $(B)/base/game/bg_lib.o \
+  $(B)/base/game/bg_alloc.o \
+  $(B)/base/game/bg_voice.o \
+  $(B)/base/game/g_active.o \
+  $(B)/base/game/g_client.o \
+  $(B)/base/game/g_cmds.o \
+  $(B)/base/game/g_combat.o \
+  $(B)/base/game/g_physics.o \
+  $(B)/base/game/g_buildable.o \
+  $(B)/base/game/g_misc.o \
+  $(B)/base/game/g_missile.o \
+  $(B)/base/game/g_mover.o \
+  $(B)/base/game/g_session.o \
+  $(B)/base/game/g_spawn.o \
+  $(B)/base/game/g_svcmds.o \
+  $(B)/base/game/g_target.o \
+  $(B)/base/game/g_team.o \
+  $(B)/base/game/g_trigger.o \
+  $(B)/base/game/g_utils.o \
+  $(B)/base/game/g_maprotation.o \
+  $(B)/base/game/g_weapon.o \
+  $(B)/base/game/g_admin.o \
+  $(B)/base/game/g_namelog.o \
+  \
+  $(B)/base/qcommon/q_math.o \
+  $(B)/base/qcommon/q_shared.o
+
+GOBJ = $(GOBJ_) $(B)/base/game/g_syscalls.o
+GVMOBJ = $(GOBJ_:%.o=%.asm)
+
+$(B)/base/game$(SHLIBNAME): $(GOBJ)
+	$(echo_cmd) "LD $@"
+	$(Q)$(CC) $(CFLAGS) $(SHLIBLDFLAGS) -o $@ $(GOBJ)
+
+$(B)/base/vm/game.qvm: $(GVMOBJ) $(GDIR)/g_syscalls.asm $(Q3ASM)
+	$(echo_cmd) "Q3ASM $@"
+	$(Q)$(Q3ASM) -o $@ $(GVMOBJ) $(GDIR)/g_syscalls.asm
+
+
+
+#############################################################################
+## TREMULOUS UI
+#############################################################################
+
+UIOBJ_ = \
+  $(B)/base/ui/ui_main.o \
+  $(B)/base/ui/ui_atoms.o \
+  $(B)/base/ui/ui_shared.o \
+  $(B)/base/ui/ui_gameinfo.o \
+  \
+  $(B)/base/ui/bg_misc.o \
+  $(B)/base/ui/bg_lib.o \
+  $(B)/base/qcommon/q_math.o \
+  $(B)/base/qcommon/q_shared.o
+
+UIOBJ = $(UIOBJ_) $(B)/base/ui/ui_syscalls.o
+UIVMOBJ = $(UIOBJ_:%.o=%.asm)
+
+$(B)/base/ui$(SHLIBNAME): $(UIOBJ)
+	$(echo_cmd) "LD $@"
+	$(Q)$(CC) $(CFLAGS) $(SHLIBLDFLAGS) -o $@ $(UIOBJ)
+
+$(B)/base/vm/ui.qvm: $(UIVMOBJ) $(UIDIR)/ui_syscalls.asm $(Q3ASM)
+	$(echo_cmd) "Q3ASM $@"
+	$(Q)$(Q3ASM) -o $@ $(UIVMOBJ) $(UIDIR)/ui_syscalls.asm
+
+
+
+#############################################################################
+## CLIENT/SERVER RULES
+#############################################################################
+
+$(B)/client/%.o: $(ASMDIR)/%.s
+	$(DO_AS)
+
+$(B)/client/%.o: $(CDIR)/%.c
+	$(DO_CC)
+
+$(B)/client/%.o: $(SDIR)/%.c
+	$(DO_CC)
+
+$(B)/client/%.o: $(CMDIR)/%.c
+	$(DO_CC)
+
+$(B)/client/%.o: $(JPDIR)/%.c
+	$(DO_CC)
+
+$(B)/client/%.o: $(SPEEXDIR)/%.c
+	$(DO_CC)
+
+$(B)/client/%.o: $(ZDIR)/%.c
+	$(DO_CC)
+
+$(B)/client/%.o: $(RDIR)/%.c
+	$(DO_CC)
+
+$(B)/client/%.o: $(SDLDIR)/%.c
+	$(DO_CC)
+
+$(B)/clientsmp/%.o: $(SDLDIR)/%.c
+	$(DO_SMP_CC)
+
+$(B)/client/%.o: $(SYSDIR)/%.c
+	$(DO_CC)
+
+$(B)/client/%.o: $(SYSDIR)/%.m
+	$(DO_CC)
+
+$(B)/client/%.o: $(SYSDIR)/%.rc
+	$(DO_WINDRES)
+
+
+$(B)/ded/%.o: $(ASMDIR)/%.s
+	$(DO_AS)
+
+$(B)/ded/%.o: $(SDIR)/%.c
+	$(DO_DED_CC)
+
+$(B)/ded/%.o: $(CMDIR)/%.c
+	$(DO_DED_CC)
+
+$(B)/ded/%.o: $(ZDIR)/%.c
+	$(DO_DED_CC)
+
+$(B)/ded/%.o: $(SYSDIR)/%.c
+	$(DO_DED_CC)
+
+$(B)/ded/%.o: $(SYSDIR)/%.m
+	$(DO_DED_CC)
+
+$(B)/ded/%.o: $(SYSDIR)/%.rc
+	$(DO_WINDRES)
+
+$(B)/ded/%.o: $(NDIR)/%.c
+	$(DO_DED_CC)
+
+# Extra dependencies to ensure the SVN version is incorporated
+ifeq ($(USE_SVN),1)
+  $(B)/client/cl_console.o : .svn/entries
+  $(B)/client/common.o : .svn/entries
+  $(B)/ded/common.o : .svn/entries
+endif
+
+
+#############################################################################
+## GAME MODULE RULES
+#############################################################################
+
+$(B)/base/cgame/bg_%.o: $(GDIR)/bg_%.c
+	$(DO_CGAME_CC)
+
+$(B)/base/cgame/%.o: $(CGDIR)/%.c
+	$(DO_CGAME_CC)
+
+$(B)/base/cgame/bg_%.asm: $(GDIR)/bg_%.c $(Q3LCC)
+	$(DO_CGAME_Q3LCC)
+
+$(B)/base/cgame/%.asm: $(CGDIR)/%.c $(Q3LCC)
+	$(DO_CGAME_Q3LCC)
+
+
+$(B)/base/game/%.o: $(GDIR)/%.c
+	$(DO_GAME_CC)
+
+$(B)/base/game/%.asm: $(GDIR)/%.c $(Q3LCC)
+	$(DO_GAME_Q3LCC)
+
+
+$(B)/base/ui/bg_%.o: $(GDIR)/bg_%.c
+	$(DO_UI_CC)
+
+$(B)/base/ui/%.o: $(UIDIR)/%.c
+	$(DO_UI_CC)
+
+$(B)/base/ui/bg_%.asm: $(GDIR)/bg_%.c $(Q3LCC)
+	$(DO_UI_Q3LCC)
+
+$(B)/base/ui/%.asm: $(UIDIR)/%.c $(Q3LCC)
+	$(DO_UI_Q3LCC)
+
+
+$(B)/base/qcommon/%.o: $(CMDIR)/%.c
+	$(DO_SHLIB_CC)
+
+$(B)/base/qcommon/%.asm: $(CMDIR)/%.c $(Q3LCC)
+	$(DO_Q3LCC)
+
+
+#############################################################################
+# MISC
+#############################################################################
+
+OBJ = $(Q3OBJ) $(Q3POBJ) $(Q3POBJ_SMP) $(Q3DOBJ) \
+  $(GOBJ) $(CGOBJ) $(UIOBJ) \
+  $(GVMOBJ) $(CGVMOBJ) $(UIVMOBJ)
+TOOLSOBJ = $(LBURGOBJ) $(Q3CPPOBJ) $(Q3RCCOBJ) $(Q3LCCOBJ) $(Q3ASMOBJ)
+
+
+clean: clean-debug clean-release
+	@$(MAKE) -C $(MASTERDIR) clean
+
+clean-debug:
+	@$(MAKE) clean2 B=$(BD)
+
+clean-release:
+	@$(MAKE) clean2 B=$(BR)
+
+clean2:
+	@echo "CLEAN $(B)"
+	@rm -f $(OBJ)
+	@rm -f $(OBJ_D_FILES)
+	@rm -f $(TARGETS)
+
+toolsclean: toolsclean-debug toolsclean-release
+
+toolsclean-debug:
+	@$(MAKE) toolsclean2 B=$(BD)
+
+toolsclean-release:
+	@$(MAKE) toolsclean2 B=$(BR)
+
+toolsclean2:
+	@echo "TOOLS_CLEAN $(B)"
+	@rm -f $(TOOLSOBJ)
+	@rm -f $(TOOLSOBJ_D_FILES)
+	@rm -f $(LBURG) $(DAGCHECK_C) $(Q3RCC) $(Q3CPP) $(Q3LCC) $(Q3ASM)
+
+distclean: clean toolsclean
+	@rm -rf $(BUILD_DIR)
+
+dist:
+	rm -rf tremulous-$(SVN_VERSION)
+	svn export . tremulous-$(SVN_VERSION)
+	tar --owner=root --group=root --force-local -cjf tremulous-$(SVN_VERSION).tar.bz2 tremulous-$(SVN_VERSION)
+	rm -rf tremulous-$(SVN_VERSION)
+
+#############################################################################
+# DEPENDENCIES
+#############################################################################
+
+ifneq ($(B),)
+  OBJ_D_FILES=$(filter %.d,$(OBJ:%.o=%.d))
+  TOOLSOBJ_D_FILES=$(filter %.d,$(TOOLSOBJ:%.o=%.d))
+  -include $(OBJ_D_FILES) $(TOOLSOBJ_D_FILES)
+endif
+
+.PHONY: all clean clean2 clean-debug clean-release copyfiles \
+	debug default dist distclean makedirs \
+	release targets \
+	toolsclean toolsclean2 toolsclean-debug toolsclean-release \
+	$(OBJ_D_FILES) $(TOOLSOBJ_D_FILES)
diff -uNr tremulous-ggp1-src.p/src/cgame/cg_buildable.c.orig tremulous-ggp1-src/src/cgame/cg_buildable.c.orig
--- tremulous-ggp1-src.p/src/cgame/cg_buildable.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/cgame/cg_buildable.c.orig	2012-07-19 04:25:20.000000000 +0200
@@ -0,0 +1,1474 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+
+
+#include "cg_local.h"
+
+char *cg_buildableSoundNames[ MAX_BUILDABLE_ANIMATIONS ] =
+{
+  "construct1.wav",
+  "construct2.wav",
+  "idle1.wav",
+  "idle2.wav",
+  "idle3.wav",
+  "attack1.wav",
+  "attack2.wav",
+  "spawn1.wav",
+  "spawn2.wav",
+  "pain1.wav",
+  "pain2.wav",
+  "destroy1.wav",
+  "destroy2.wav",
+  "destroyed.wav"
+};
+
+static sfxHandle_t defaultAlienSounds[ MAX_BUILDABLE_ANIMATIONS ];
+static sfxHandle_t defaultHumanSounds[ MAX_BUILDABLE_ANIMATIONS ];
+
+/*
+===================
+CG_AlienBuildableExplosion
+
+Generated a bunch of gibs launching out from a location
+===================
+*/
+void CG_AlienBuildableExplosion( vec3_t origin, vec3_t dir )
+{
+  particleSystem_t  *ps;
+
+  trap_S_StartSound( origin, ENTITYNUM_WORLD, CHAN_AUTO, cgs.media.alienBuildableExplosion );
+
+  //particle system
+  ps = CG_SpawnNewParticleSystem( cgs.media.alienBuildableDestroyedPS );
+
+  if( CG_IsParticleSystemValid( &ps ) )
+  {
+    CG_SetAttachmentPoint( &ps->attachment, origin );
+    CG_SetParticleSystemNormal( ps, dir );
+    CG_AttachToPoint( &ps->attachment );
+  }
+}
+
+/*
+=================
+CG_HumanBuildableExplosion
+
+Called for human buildables as they are destroyed
+=================
+*/
+void CG_HumanBuildableExplosion( vec3_t origin, vec3_t dir )
+{
+  particleSystem_t  *ps;
+
+  trap_S_StartSound( origin, ENTITYNUM_WORLD, CHAN_AUTO, cgs.media.humanBuildableExplosion );
+
+  //particle system
+  ps = CG_SpawnNewParticleSystem( cgs.media.humanBuildableDestroyedPS );
+
+  if( CG_IsParticleSystemValid( &ps ) )
+  {
+    CG_SetAttachmentPoint( &ps->attachment, origin );
+    CG_SetParticleSystemNormal( ps, dir );
+    CG_AttachToPoint( &ps->attachment );
+  }
+}
+
+
+#define CREEP_SIZE            64.0f
+#define CREEP_DISTANCE        64.0f
+
+/*
+==================
+CG_Creep
+==================
+*/
+static void CG_Creep( centity_t *cent )
+{
+  int           msec;
+  float         size, frac;
+  trace_t       tr;
+  vec3_t        temp, origin;
+  int           scaleUpTime = BG_Buildable( cent->currentState.modelindex )->buildTime;
+  int           time;
+
+  time = cent->currentState.time;
+
+  //should the creep be growing or receding?
+  if( time >= 0 )
+  {
+    msec = cg.time - time;
+    if( msec >= 0 && msec < scaleUpTime )
+      frac = (float)msec / scaleUpTime;
+    else
+      frac = 1.0f;
+  }
+  else if( time < 0 )
+  {
+    msec = cg.time + time;
+    if( msec >= 0 && msec < CREEP_SCALEDOWN_TIME )
+      frac = 1.0f - ( (float)msec / CREEP_SCALEDOWN_TIME );
+    else
+      frac = 0.0f;
+  }
+
+  VectorCopy( cent->currentState.origin2, temp );
+  VectorScale( temp, -CREEP_DISTANCE, temp );
+  VectorAdd( temp, cent->lerpOrigin, temp );
+
+  CG_Trace( &tr, cent->lerpOrigin, NULL, NULL, temp, cent->currentState.number, MASK_PLAYERSOLID );
+
+  VectorCopy( tr.endpos, origin );
+
+  size = CREEP_SIZE * frac;
+
+  if( size > 0.0f && tr.fraction < 1.0f )
+    CG_ImpactMark( cgs.media.creepShader, origin, cent->currentState.origin2,
+                   0.0f, 1.0f, 1.0f, 1.0f, 1.0f, qfalse, size, qtrue );
+}
+
+/*
+======================
+CG_ParseBuildableAnimationFile
+
+Read a configuration file containing animation counts and rates
+models/buildables/hivemind/animation.cfg, etc
+======================
+*/
+static qboolean CG_ParseBuildableAnimationFile( const char *filename, buildable_t buildable )
+{
+  char          *text_p;
+  int           len;
+  int           i;
+  char          *token;
+  float         fps;
+  char          text[ 20000 ];
+  fileHandle_t  f;
+  animation_t   *animations;
+
+  animations = cg_buildables[ buildable ].animations;
+
+  // load the file
+  len = trap_FS_FOpenFile( filename, &f, FS_READ );
+  if( len < 0 )
+    return qfalse;
+
+  if( len == 0 || len >= sizeof( text ) - 1 )
+  {
+    trap_FS_FCloseFile( f );
+    CG_Printf( "File %s is %s\n", filename, len == 0 ? "empty" : "too long" );
+    return qfalse;
+  }
+
+  trap_FS_Read( text, len, f );
+  text[ len ] = 0;
+  trap_FS_FCloseFile( f );
+
+  // parse the text
+  text_p = text;
+
+  // read information for each frame
+  for( i = BANIM_NONE + 1; i < MAX_BUILDABLE_ANIMATIONS; i++ )
+  {
+
+    token = COM_Parse( &text_p );
+    if( !*token )
+      break;
+
+    animations[ i ].firstFrame = atoi( token );
+
+    token = COM_Parse( &text_p );
+    if( !*token )
+      break;
+
+    animations[ i ].numFrames = atoi( token );
+    animations[ i ].reversed = qfalse;
+    animations[ i ].flipflop = qfalse;
+
+    // if numFrames is negative the animation is reversed
+    if( animations[ i ].numFrames < 0 )
+    {
+      animations[ i ].numFrames = -animations[ i ].numFrames;
+      animations[ i ].reversed = qtrue;
+    }
+
+    token = COM_Parse( &text_p );
+    if ( !*token )
+      break;
+
+    animations[i].loopFrames = atoi( token );
+
+    token = COM_Parse( &text_p );
+    if( !*token )
+      break;
+
+    fps = atof( token );
+    if( fps == 0 )
+      fps = 1;
+
+    animations[ i ].frameLerp = 1000 / fps;
+    animations[ i ].initialLerp = 1000 / fps;
+  }
+
+  if( i != MAX_BUILDABLE_ANIMATIONS )
+  {
+    CG_Printf( "Error parsing animation file: %s\n", filename );
+    return qfalse;
+  }
+
+  return qtrue;
+}
+
+/*
+======================
+CG_ParseBuildableSoundFile
+
+Read a configuration file containing sound properties
+sound/buildables/hivemind/sound.cfg, etc
+======================
+*/
+static qboolean CG_ParseBuildableSoundFile( const char *filename, buildable_t buildable )
+{
+  char          *text_p;
+  int           len;
+  int           i;
+  char          *token;
+  char          text[ 20000 ];
+  fileHandle_t  f;
+  sound_t       *sounds;
+
+  sounds = cg_buildables[ buildable ].sounds;
+
+  // load the file
+  len = trap_FS_FOpenFile( filename, &f, FS_READ );
+  if ( len < 0 )
+    return qfalse;
+
+  if ( len == 0 || len >= sizeof( text ) - 1 )
+  {
+    trap_FS_FCloseFile( f );
+    CG_Printf( "File %s is %s\n", filename, len == 0 ? "empty" : "too long" );
+    return qfalse;
+  }
+
+  trap_FS_Read( text, len, f );
+  text[len] = 0;
+  trap_FS_FCloseFile( f );
+
+  // parse the text
+  text_p = text;
+
+  // read information for each frame
+  for( i = BANIM_NONE + 1; i < MAX_BUILDABLE_ANIMATIONS; i++ )
+  {
+
+    token = COM_Parse( &text_p );
+    if ( !*token )
+      break;
+
+    sounds[ i ].enabled = atoi( token );
+
+    token = COM_Parse( &text_p );
+    if ( !*token )
+      break;
+
+    sounds[ i ].looped = atoi( token );
+
+  }
+
+  if( i != MAX_BUILDABLE_ANIMATIONS )
+  {
+    CG_Printf( "Error parsing sound file: %s\n", filename );
+    return qfalse;
+  }
+
+  return qtrue;
+}
+/*
+===============
+CG_InitBuildables
+
+Initialises the animation db
+===============
+*/
+void CG_InitBuildables( void )
+{
+  char          filename[ MAX_QPATH ];
+  char          soundfile[ MAX_QPATH ];
+  char          *buildableName;
+  char          *modelFile;
+  int           i;
+  int           j;
+  fileHandle_t  f;
+
+  memset( cg_buildables, 0, sizeof( cg_buildables ) );
+
+  //default sounds
+  for( j = BANIM_NONE + 1; j < MAX_BUILDABLE_ANIMATIONS; j++ )
+  {
+    strcpy( soundfile, cg_buildableSoundNames[ j - 1 ] );
+
+    Com_sprintf( filename, sizeof( filename ), "sound/buildables/alien/%s", soundfile );
+    defaultAlienSounds[ j ] = trap_S_RegisterSound( filename, qfalse );
+
+    Com_sprintf( filename, sizeof( filename ), "sound/buildables/human/%s", soundfile );
+    defaultHumanSounds[ j ] = trap_S_RegisterSound( filename, qfalse );
+  }
+
+  cg.buildablesFraction = 0.0f;
+
+  for( i = BA_NONE + 1; i < BA_NUM_BUILDABLES; i++ )
+  {
+    buildableName = BG_Buildable( i )->name;
+
+    //animation.cfg
+    Com_sprintf( filename, sizeof( filename ), "models/buildables/%s/animation.cfg", buildableName );
+    if ( !CG_ParseBuildableAnimationFile( filename, i ) )
+      Com_Printf( S_COLOR_YELLOW "WARNING: failed to load animation file %s\n", filename );
+
+    //sound.cfg
+    Com_sprintf( filename, sizeof( filename ), "sound/buildables/%s/sound.cfg", buildableName );
+    if ( !CG_ParseBuildableSoundFile( filename, i ) )
+      Com_Printf( S_COLOR_YELLOW "WARNING: failed to load sound file %s\n", filename );
+
+    //models
+    for( j = 0; j <= 3; j++ )
+    {
+      modelFile = BG_BuildableConfig( i )->models[ j ];
+      if( strlen( modelFile ) > 0 )
+        cg_buildables[ i ].models[ j ] = trap_R_RegisterModel( modelFile );
+    }
+
+    //sounds
+    for( j = BANIM_NONE + 1; j < MAX_BUILDABLE_ANIMATIONS; j++ )
+    {
+      strcpy( soundfile, cg_buildableSoundNames[ j - 1 ] );
+      Com_sprintf( filename, sizeof( filename ), "sound/buildables/%s/%s", buildableName, soundfile );
+
+      if( cg_buildables[ i ].sounds[ j ].enabled )
+      {
+        if( trap_FS_FOpenFile( filename, &f, FS_READ ) > 0 )
+        {
+          //file exists so close it
+          trap_FS_FCloseFile( f );
+
+          cg_buildables[ i ].sounds[ j ].sound = trap_S_RegisterSound( filename, qfalse );
+        }
+        else
+        {
+          //file doesn't exist - use default
+          if( BG_Buildable( i )->team == TEAM_ALIENS )
+            cg_buildables[ i ].sounds[ j ].sound = defaultAlienSounds[ j ];
+          else
+            cg_buildables[ i ].sounds[ j ].sound = defaultHumanSounds[ j ];
+        }
+      }
+    }
+
+    cg.buildablesFraction = (float)i / (float)( BA_NUM_BUILDABLES - 1 );
+    trap_UpdateScreen( );
+  }
+
+  cgs.media.teslaZapTS = CG_RegisterTrailSystem( "models/buildables/tesla/zap" );
+}
+
+/*
+===============
+CG_SetBuildableLerpFrameAnimation
+
+may include ANIM_TOGGLEBIT
+===============
+*/
+static void CG_SetBuildableLerpFrameAnimation( buildable_t buildable, lerpFrame_t *lf, int newAnimation )
+{
+  animation_t *anim;
+
+  lf->animationNumber = newAnimation;
+
+  if( newAnimation < 0 || newAnimation >= MAX_BUILDABLE_ANIMATIONS )
+    CG_Error( "Bad animation number: %i", newAnimation );
+
+  anim = &cg_buildables[ buildable ].animations[ newAnimation ];
+
+  //this item has just spawned so lf->frameTime will be zero
+  if( !lf->animation )
+    lf->frameTime = cg.time + 1000; //1 sec delay before starting the spawn anim
+
+  lf->animation = anim;
+  lf->animationTime = lf->frameTime + anim->initialLerp;
+
+  if( cg_debugAnim.integer )
+    CG_Printf( "Anim: %i\n", newAnimation );
+}
+
+/*
+===============
+CG_RunBuildableLerpFrame
+
+Sets cg.snap, cg.oldFrame, and cg.backlerp
+cg.time should be between oldFrameTime and frameTime after exit
+===============
+*/
+static void CG_RunBuildableLerpFrame( centity_t *cent )
+{
+  buildable_t           buildable = cent->currentState.modelindex;
+  lerpFrame_t           *lf = &cent->lerpFrame;
+  buildableAnimNumber_t newAnimation = cent->buildableAnim & ~( ANIM_TOGGLEBIT|ANIM_FORCEBIT );
+
+  // see if the animation sequence is switching
+  if( newAnimation != lf->animationNumber || !lf->animation )
+  {
+    if( cg_debugRandom.integer )
+      CG_Printf( "newAnimation: %d lf->animationNumber: %d lf->animation: %d\n",
+                 newAnimation, lf->animationNumber, lf->animation );
+
+    CG_SetBuildableLerpFrameAnimation( buildable, lf, newAnimation );
+
+    if( !cg_buildables[ buildable ].sounds[ newAnimation ].looped &&
+        cg_buildables[ buildable ].sounds[ newAnimation ].enabled )
+    {
+      if( cg_debugRandom.integer )
+        CG_Printf( "Sound for animation %d for a %s\n",
+            newAnimation, BG_Buildable( buildable )->humanName );
+
+      trap_S_StartSound( cent->lerpOrigin, cent->currentState.number, CHAN_AUTO,
+        cg_buildables[ buildable ].sounds[ newAnimation ].sound );
+    }
+  }
+
+  if( cg_buildables[ buildable ].sounds[ lf->animationNumber ].looped &&
+      cg_buildables[ buildable ].sounds[ lf->animationNumber ].enabled )
+    trap_S_AddLoopingSound( cent->currentState.number, cent->lerpOrigin, vec3_origin,
+      cg_buildables[ buildable ].sounds[ lf->animationNumber ].sound );
+
+  CG_RunLerpFrame( lf, 1.0f );
+
+  // animation ended
+  if( lf->frameTime == cg.time )
+  {
+    cent->buildableAnim = cent->currentState.torsoAnim;
+    cent->buildableIdleAnim = qtrue;
+  }
+}
+
+/*
+===============
+CG_BuildableAnimation
+===============
+*/
+static void CG_BuildableAnimation( centity_t *cent, int *old, int *now, float *backLerp )
+{
+  entityState_t *es = &cent->currentState;
+
+  //if no animation is set default to idle anim
+  if( cent->buildableAnim == BANIM_NONE )
+  {
+    cent->buildableAnim = es->torsoAnim;
+    cent->buildableIdleAnim = qtrue;
+  }
+
+  //display the first frame of the construction anim if not yet spawned
+  if( !( es->eFlags & EF_B_SPAWNED ) )
+  {
+    animation_t *anim = &cg_buildables[ es->modelindex ].animations[ BANIM_CONSTRUCT1 ];
+
+    //so that when animation starts for real it has sensible numbers
+    cent->lerpFrame.oldFrameTime =
+      cent->lerpFrame.frameTime =
+      cent->lerpFrame.animationTime =
+      cg.time;
+
+    *old      = cent->lerpFrame.oldFrame = anim->firstFrame;
+    *now      = cent->lerpFrame.frame    = anim->firstFrame;
+    *backLerp = cent->lerpFrame.backlerp = 0.0f;
+
+    //ensure that an animation is triggered once the buildable has spawned
+    cent->oldBuildableAnim = BANIM_NONE;
+  }
+  else
+  {
+    if( ( cent->oldBuildableAnim ^ es->legsAnim ) & ANIM_TOGGLEBIT )
+    {
+      if( cg_debugAnim.integer )
+        CG_Printf( "%d->%d l:%d t:%d %s(%d)\n",
+                   cent->oldBuildableAnim, cent->buildableAnim,
+                   es->legsAnim, es->torsoAnim,
+                   BG_Buildable( es->modelindex )->humanName, es->number );
+
+      if( cent->buildableAnim == es->torsoAnim || es->legsAnim & ANIM_FORCEBIT )
+      {
+        cent->buildableAnim = cent->oldBuildableAnim = es->legsAnim;
+        cent->buildableIdleAnim = qfalse;
+      }
+      else
+      {
+        cent->buildableAnim = cent->oldBuildableAnim = es->torsoAnim;
+        cent->buildableIdleAnim = qtrue;
+      }
+    }
+    else if( cent->buildableIdleAnim == qtrue &&
+             cent->buildableAnim != es->torsoAnim )
+    {
+      cent->buildableAnim = es->torsoAnim;
+    }
+
+    CG_RunBuildableLerpFrame( cent );
+
+    *old      = cent->lerpFrame.oldFrame;
+    *now      = cent->lerpFrame.frame;
+    *backLerp = cent->lerpFrame.backlerp;
+  }
+}
+
+#define TRACE_DEPTH 64.0f
+
+/*
+===============
+CG_PositionAndOrientateBuildable
+===============
+*/
+static void CG_PositionAndOrientateBuildable( const vec3_t angles, const vec3_t inOrigin,
+                                              const vec3_t normal, const int skipNumber,
+                                              const vec3_t mins, const vec3_t maxs,
+                                              vec3_t outAxis[ 3 ], vec3_t outOrigin )
+{
+  vec3_t  forward, start, end;
+  trace_t tr, box_tr;
+  float mag, fraction;
+
+  AngleVectors( angles, forward, NULL, NULL );
+  VectorCopy( normal, outAxis[ 2 ] );
+  ProjectPointOnPlane( outAxis[ 0 ], forward, outAxis[ 2 ] );
+
+  if( !VectorNormalize( outAxis[ 0 ] ) )
+  {
+    AngleVectors( angles, NULL, NULL, forward );
+    ProjectPointOnPlane( outAxis[ 0 ], forward, outAxis[ 2 ] );
+    VectorNormalize( outAxis[ 0 ] );
+  }
+
+  CrossProduct( outAxis[ 0 ], outAxis[ 2 ], outAxis[ 1 ] );
+  outAxis[ 1 ][ 0 ] = -outAxis[ 1 ][ 0 ];
+  outAxis[ 1 ][ 1 ] = -outAxis[ 1 ][ 1 ];
+  outAxis[ 1 ][ 2 ] = -outAxis[ 1 ][ 2 ];
+
+  VectorMA( inOrigin, -TRACE_DEPTH, normal, end );
+  VectorMA( inOrigin, 1.0f, normal, start );
+
+  // Take both capsule and box traces. If the capsule trace does not differ
+  //  significantly from the box trace use it. This may cause buildables to be
+  //  positioned *inside* the surface on which it is placed. This is intentional
+
+  CG_CapTrace( &tr, start, mins, maxs, end, skipNumber,
+               CONTENTS_SOLID | CONTENTS_PLAYERCLIP );
+
+  CG_Trace( &box_tr, start, mins, maxs, end, skipNumber,
+            CONTENTS_SOLID | CONTENTS_PLAYERCLIP );
+
+  mag = Distance( tr.endpos, box_tr.endpos );
+
+  fraction = tr.fraction;
+
+  // this is either too far off of the bbox to be useful for gameplay purposes
+  //  or the model is positioned in thin air anyways.
+  if( mag > 15.0f || tr.fraction == 1.0f )
+    fraction = box_tr.fraction; 
+
+  VectorMA( inOrigin, fraction * -TRACE_DEPTH, normal, outOrigin );
+}
+
+/*
+==================
+CG_GhostBuildable
+==================
+*/
+void CG_GhostBuildable( buildable_t buildable )
+{
+  refEntity_t     ent;
+  playerState_t   *ps;
+  vec3_t          angles, entity_origin;
+  vec3_t          mins, maxs;
+  trace_t         tr;
+  float           scale;
+
+  ps = &cg.predictedPlayerState;
+
+  memset( &ent, 0, sizeof( ent ) );
+
+  BG_BuildableBoundingBox( buildable, mins, maxs );
+
+  BG_PositionBuildableRelativeToPlayer( ps, mins, maxs, CG_Trace, entity_origin, angles, &tr );
+
+  CG_PositionAndOrientateBuildable( ps->viewangles, entity_origin, tr.plane.normal, ps->clientNum,
+                                    mins, maxs, ent.axis, ent.origin );
+
+  //offset on the Z axis if required
+  VectorMA( ent.origin, BG_BuildableConfig( buildable )->zOffset, tr.plane.normal, ent.origin );
+
+  VectorCopy( ent.origin, ent.lightingOrigin );
+  VectorCopy( ent.origin, ent.oldorigin ); // don't positionally lerp at all
+
+  ent.hModel = cg_buildables[ buildable ].models[ 0 ];
+
+  if( ps->stats[ STAT_BUILDABLE ] & SB_VALID_TOGGLEBIT )
+    ent.customShader = cgs.media.greenBuildShader;
+  else
+    ent.customShader = cgs.media.redBuildShader;
+
+  //rescale the model
+  scale = BG_BuildableConfig( buildable )->modelScale;
+
+  if( scale != 1.0f )
+  {
+    VectorScale( ent.axis[ 0 ], scale, ent.axis[ 0 ] );
+    VectorScale( ent.axis[ 1 ], scale, ent.axis[ 1 ] );
+    VectorScale( ent.axis[ 2 ], scale, ent.axis[ 2 ] );
+
+    ent.nonNormalizedAxes = qtrue;
+  }
+  else
+    ent.nonNormalizedAxes = qfalse;
+
+  // add to refresh list
+  trap_R_AddRefEntityToScene( &ent );
+}
+
+/*
+==================
+CG_BuildableParticleEffects
+==================
+*/
+static void CG_BuildableParticleEffects( centity_t *cent )
+{
+  entityState_t   *es = &cent->currentState;
+  team_t          team = BG_Buildable( es->modelindex )->team;
+  int             health = es->generic1;
+  float           healthFrac = (float)health / BG_Buildable( es->modelindex )->health;
+
+  if( !( es->eFlags & EF_B_SPAWNED ) )
+    return;
+
+  if( team == TEAM_HUMANS )
+  {
+    if( healthFrac < 0.33f && !CG_IsParticleSystemValid( &cent->buildablePS ) )
+    {
+      cent->buildablePS = CG_SpawnNewParticleSystem( cgs.media.humanBuildableDamagedPS );
+
+      if( CG_IsParticleSystemValid( &cent->buildablePS ) )
+      {
+        CG_SetAttachmentCent( &cent->buildablePS->attachment, cent );
+        CG_AttachToCent( &cent->buildablePS->attachment );
+      }
+    }
+    else if( healthFrac >= 0.33f && CG_IsParticleSystemValid( &cent->buildablePS ) )
+      CG_DestroyParticleSystem( &cent->buildablePS );
+  }
+  else if( team == TEAM_ALIENS )
+  {
+    if( healthFrac < 0.33f && !CG_IsParticleSystemValid( &cent->buildablePS ) )
+    {
+      cent->buildablePS = CG_SpawnNewParticleSystem( cgs.media.alienBuildableDamagedPS );
+
+      if( CG_IsParticleSystemValid( &cent->buildablePS ) )
+      {
+        CG_SetAttachmentCent( &cent->buildablePS->attachment, cent );
+        CG_SetParticleSystemNormal( cent->buildablePS, es->origin2 );
+        CG_AttachToCent( &cent->buildablePS->attachment );
+      }
+    }
+    else if( healthFrac >= 0.33f && CG_IsParticleSystemValid( &cent->buildablePS ) )
+      CG_DestroyParticleSystem( &cent->buildablePS );
+  }
+}
+
+/*
+==================
+CG_BuildableStatusParse
+==================
+*/
+void CG_BuildableStatusParse( const char *filename, buildStat_t *bs )
+{
+  pc_token_t token;
+  int        handle;
+  const char *s;
+  int        i;
+  float      f;
+  vec4_t     c;
+
+  handle = trap_Parse_LoadSource( filename );
+  if( !handle )
+    return;
+  while( 1 )
+  {
+    if( !trap_Parse_ReadToken( handle, &token ) )
+      break;
+    if( !Q_stricmp( token.string, "frameShader" ) )
+    {
+      if( PC_String_Parse( handle, &s ) )
+        bs->frameShader = trap_R_RegisterShader( s );
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "overlayShader" ) )
+    {
+      if( PC_String_Parse( handle, &s ) )
+        bs->overlayShader = trap_R_RegisterShader( s );
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "noPowerShader" ) )
+    {
+      if( PC_String_Parse( handle, &s ) )
+        bs->noPowerShader = trap_R_RegisterShader( s );
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "markedShader" ) )
+    {
+      if( PC_String_Parse( handle, &s ) )
+        bs->markedShader = trap_R_RegisterShader( s );
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "healthSevereColor" ) )
+    {
+      if( PC_Color_Parse( handle, &c ) )
+        Vector4Copy( c, bs->healthSevereColor );
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "healthHighColor" ) )
+    {
+      if( PC_Color_Parse( handle, &c ) )
+        Vector4Copy( c, bs->healthHighColor );
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "healthElevatedColor" ) )
+    {
+      if( PC_Color_Parse( handle, &c ) )
+        Vector4Copy( c, bs->healthElevatedColor );
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "healthGuardedColor" ) )
+    {
+      if( PC_Color_Parse( handle, &c ) )
+        Vector4Copy( c, bs->healthGuardedColor );
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "healthLowColor" ) )
+    {
+      if( PC_Color_Parse( handle, &c ) )
+        Vector4Copy( c, bs->healthLowColor );
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "foreColor" ) )
+    {
+      if( PC_Color_Parse( handle, &c ) )
+        Vector4Copy( c, bs->foreColor );
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "backColor" ) )
+    {
+      if( PC_Color_Parse( handle, &c ) )
+        Vector4Copy( c, bs->backColor );
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "frameHeight" ) )
+    {
+      if( PC_Int_Parse( handle, &i ) )
+        bs->frameHeight = i;
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "frameWidth" ) )
+    {
+      if( PC_Int_Parse( handle, &i ) )
+        bs->frameWidth = i;
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "healthPadding" ) )
+    {
+      if( PC_Int_Parse( handle, &i ) )
+        bs->healthPadding = i;
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "overlayHeight" ) )
+    {
+      if( PC_Int_Parse( handle, &i ) )
+        bs->overlayHeight = i;
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "overlayWidth" ) )
+    {
+      if( PC_Int_Parse( handle, &i ) )
+        bs->overlayWidth = i;
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "verticalMargin" ) )
+    {
+      if( PC_Float_Parse( handle, &f ) )
+        bs->verticalMargin = f;
+      continue;
+    }
+    else if( !Q_stricmp( token.string, "horizontalMargin" ) )
+    {
+      if( PC_Float_Parse( handle, &f ) )
+        bs->horizontalMargin = f;
+      continue;
+    }
+    else
+    {
+      Com_Printf("CG_BuildableStatusParse: unknown token %s in %s\n",
+        token.string, filename );
+      bs->loaded = qfalse;
+      trap_Parse_FreeSource( handle );
+      return;
+    }
+  }
+  bs->loaded = qtrue;
+  trap_Parse_FreeSource( handle );
+}
+
+#define STATUS_FADE_TIME      200
+#define STATUS_MAX_VIEW_DIST  900.0f
+#define STATUS_PEEK_DIST      20
+/*
+==================
+CG_BuildableStatusDisplay
+==================
+*/
+static void CG_BuildableStatusDisplay( centity_t *cent )
+{
+  entityState_t   *es = &cent->currentState;
+  vec3_t          origin;
+  float           healthScale;
+  int             health;
+  float           x, y;
+  vec4_t          color;
+  qboolean        powered, marked;
+  trace_t         tr;
+  float           d;
+  buildStat_t     *bs;
+  int             i, j;
+  int             entNum;
+  vec3_t          trOrigin;
+  vec3_t          right;
+  qboolean        visible = qfalse;
+  vec3_t          mins, maxs;
+  entityState_t   *hit;
+  int             anim;
+
+  if( BG_Buildable( es->modelindex )->team == TEAM_ALIENS )
+    bs = &cgs.alienBuildStat;
+  else
+    bs = &cgs.humanBuildStat;
+
+  if( !bs->loaded )
+    return;
+
+  d = Distance( cent->lerpOrigin, cg.refdef.vieworg );
+  if( d > STATUS_MAX_VIEW_DIST )
+    return;
+
+  Vector4Copy( bs->foreColor, color );
+
+  // trace for center point
+  BG_BuildableBoundingBox( es->modelindex, mins, maxs );
+
+  // hack for shrunken barricades
+  anim = es->torsoAnim & ~( ANIM_FORCEBIT | ANIM_TOGGLEBIT );
+  if( es->modelindex == BA_A_BARRICADE &&
+      ( anim == BANIM_DESTROYED || !( es->eFlags & EF_B_SPAWNED ) ) )
+    maxs[ 2 ] = (int)( maxs[ 2 ] * BARRICADE_SHRINKPROP );
+
+  VectorCopy( cent->lerpOrigin, origin );
+
+  // center point
+  origin[ 2 ] += mins[ 2 ];
+  origin[ 2 ] += ( abs( mins[ 2 ] ) + abs( maxs[ 2 ] ) ) / 2;
+
+  entNum = cg.predictedPlayerState.clientNum;
+
+  // if first try fails, step left, step right
+  for( j = 0; j < 3; j++ )
+  {
+    VectorCopy( cg.refdef.vieworg, trOrigin );
+    switch( j )
+    {
+      case 1:
+        // step right
+        AngleVectors( cg.refdefViewAngles, NULL, right, NULL );
+        VectorMA( trOrigin, STATUS_PEEK_DIST, right, trOrigin );
+        break;
+      case 2:
+        // step left
+        AngleVectors( cg.refdefViewAngles, NULL, right, NULL );
+        VectorMA( trOrigin, -STATUS_PEEK_DIST, right, trOrigin );
+        break;
+      default:
+        break;
+    }
+    // look through up to 3 players and/or transparent buildables
+    for( i = 0; i < 3; i++ )
+    {
+      CG_Trace( &tr, trOrigin, NULL, NULL, origin, entNum, MASK_SHOT );
+      if( tr.entityNum == cent->currentState.number )
+      {
+        visible = qtrue;
+        break;
+      }
+
+      if( tr.entityNum == ENTITYNUM_WORLD )
+        break;
+
+      hit  = &cg_entities[ tr.entityNum ].currentState;
+
+      if( tr.entityNum < MAX_CLIENTS || ( hit->eType == ET_BUILDABLE &&
+          ( !( es->eFlags & EF_B_SPAWNED ) ||
+            BG_Buildable( hit->modelindex )->transparentTest ) ) )
+      {
+        entNum = tr.entityNum;
+        VectorCopy( tr.endpos, trOrigin );
+      }
+      else
+        break;
+    }
+  }
+  // hack to make the kit obscure view
+  if( cg_drawGun.integer && visible &&
+      cg.predictedPlayerState.stats[ STAT_TEAM ] == TEAM_HUMANS &&
+      CG_WorldToScreen( origin, &x, &y ) )
+  {
+    if( x > 450 && y > 290 )
+      visible = qfalse;
+  }
+
+  if( !visible && cent->buildableStatus.visible )
+  {
+    cent->buildableStatus.visible   = qfalse;
+    cent->buildableStatus.lastTime  = cg.time;
+  }
+  else if( visible && !cent->buildableStatus.visible )
+  {
+    cent->buildableStatus.visible   = qtrue;
+    cent->buildableStatus.lastTime  = cg.time;
+  }
+
+  // Fade up
+  if( cent->buildableStatus.visible )
+  {
+    if( cent->buildableStatus.lastTime + STATUS_FADE_TIME > cg.time )
+      color[ 3 ] = (float)( cg.time - cent->buildableStatus.lastTime ) / STATUS_FADE_TIME;
+  }
+
+  // Fade down
+  if( !cent->buildableStatus.visible )
+  {
+    if( cent->buildableStatus.lastTime + STATUS_FADE_TIME > cg.time )
+      color[ 3 ] = 1.0f - (float)( cg.time - cent->buildableStatus.lastTime ) / STATUS_FADE_TIME;
+    else
+      return;
+  }
+
+  health = es->generic1;
+  healthScale = (float)health / BG_Buildable( es->modelindex )->health;
+
+  if( health > 0 && healthScale < 0.01f )
+    healthScale = 0.01f;
+  else if( healthScale < 0.0f )
+    healthScale = 0.0f;
+  else if( healthScale > 1.0f )
+    healthScale = 1.0f;
+
+  if( CG_WorldToScreen( origin, &x, &y ) )
+  {
+    float  picH = bs->frameHeight;
+    float  picW = bs->frameWidth;
+    float  picX = x;
+    float  picY = y;
+    float  scale;
+    float  subH, subY;
+    float  clipX, clipY, clipW, clipH;
+    vec4_t frameColor;
+
+    // this is fudged to get the width/height in the cfg to be more realistic
+    scale = ( picH / d ) * 3;
+
+    powered = es->eFlags & EF_B_POWERED;
+    marked = es->eFlags & EF_B_MARKED;
+
+    picH *= scale;
+    picW *= scale;
+    picX -= ( picW * 0.5f );
+    picY -= ( picH * 0.5f );
+
+    // sub-elements such as icons and number
+    subH = picH - ( picH * bs->verticalMargin );
+    subY = picY + ( picH * 0.5f ) - ( subH * 0.5f );
+
+    clipW = ( 640.0f * cg_viewsize.integer ) / 100.0f;
+    clipH = ( 480.0f * cg_viewsize.integer ) / 100.0f;
+    clipX = 320.0f - ( clipW * 0.5f );
+    clipY = 240.0f - ( clipH * 0.5f );
+    CG_SetClipRegion( clipX, clipY, clipW, clipH );
+
+    if( bs->frameShader )
+    {
+      Vector4Copy( bs->backColor, frameColor );
+      frameColor[ 3 ] = color[ 3 ];
+      trap_R_SetColor( frameColor );
+      CG_DrawPic( picX, picY, picW, picH, bs->frameShader );
+      trap_R_SetColor( NULL );
+    }
+
+    if( health > 0 )
+    {
+      float hX, hY, hW, hH;
+      vec4_t healthColor;
+
+      hX = picX + ( bs->healthPadding * scale );
+      hY = picY + ( bs->healthPadding * scale );
+      hH = picH - ( bs->healthPadding * 2.0f * scale );
+      hW = picW * healthScale - ( bs->healthPadding * 2.0f * scale );
+
+      if( healthScale == 1.0f )
+        Vector4Copy( bs->healthLowColor, healthColor );
+      else if( healthScale >= 0.75f )
+        Vector4Copy( bs->healthGuardedColor, healthColor );
+      else if( healthScale >= 0.50f )
+        Vector4Copy( bs->healthElevatedColor, healthColor );
+      else if( healthScale >= 0.25f )
+        Vector4Copy( bs->healthHighColor, healthColor );
+      else
+        Vector4Copy( bs->healthSevereColor, healthColor );
+
+      healthColor[ 3 ] = color[ 3 ];
+      trap_R_SetColor( healthColor );
+
+      CG_DrawPic( hX, hY, hW, hH, cgs.media.whiteShader );
+      trap_R_SetColor( NULL );
+    }
+
+    if( bs->overlayShader )
+    {
+      float oW = bs->overlayWidth;
+      float oH = bs->overlayHeight;
+      float oX = x;
+      float oY = y;
+
+      oH *= scale;
+      oW *= scale;
+      oX -= ( oW * 0.5f );
+      oY -= ( oH * 0.5f );
+
+      trap_R_SetColor( frameColor );
+      CG_DrawPic( oX, oY, oW, oH, bs->overlayShader );
+      trap_R_SetColor( NULL );
+    }
+
+    trap_R_SetColor( color );
+    if( !powered )
+    {
+      float pX;
+
+      pX = picX + ( subH * bs->horizontalMargin );
+      CG_DrawPic( pX, subY, subH, subH, bs->noPowerShader );
+    }
+
+    if( marked )
+    {
+      float mX;
+
+      mX = picX + picW - ( subH * bs->horizontalMargin ) - subH;
+      CG_DrawPic( mX, subY, subH, subH, bs->markedShader );
+    }
+
+    {
+      float nX;
+      int healthMax;
+      int healthPoints;
+
+      healthMax = BG_Buildable( es->modelindex )->health;
+      healthPoints = (int)( healthScale * healthMax );
+      if( health > 0 && healthPoints < 1 )
+        healthPoints = 1;
+      nX = picX + ( picW * 0.5f ) - 2.0f - ( ( subH * 4 ) * 0.5f );
+
+      if( healthPoints > 999 )
+        nX -= 0.0f;
+      else if( healthPoints > 99 )
+        nX -= subH * 0.5f;
+      else if( healthPoints > 9 )
+        nX -= subH * 1.0f;
+      else
+        nX -= subH * 1.5f;
+
+      CG_DrawField( nX, subY, 4, subH, subH, healthPoints );
+    }
+
+    trap_R_SetColor( NULL );
+    CG_ClearClipRegion( );
+  }
+}
+
+/*
+==================
+CG_SortDistance
+==================
+*/
+static int CG_SortDistance( const void *a, const void *b )
+{
+  centity_t    *aent, *bent;
+  float        adist, bdist;
+
+  aent = &cg_entities[ *(int *)a ];
+  bent = &cg_entities[ *(int *)b ];
+  adist = Distance( cg.refdef.vieworg, aent->lerpOrigin );
+  bdist = Distance( cg.refdef.vieworg, bent->lerpOrigin );
+  if( adist > bdist )
+    return -1;
+  else if( adist < bdist )
+    return 1;
+  else
+    return 0;
+}
+
+/*
+==================
+CG_PlayerIsBuilder
+==================
+*/
+static qboolean CG_PlayerIsBuilder( buildable_t buildable )
+{
+  switch( cg.predictedPlayerState.weapon )
+  {
+    case WP_ABUILD:
+    case WP_ABUILD2:
+    case WP_HBUILD:
+      return BG_Buildable( buildable )->team ==
+             BG_Weapon( cg.predictedPlayerState.weapon )->team;
+
+    default:
+      return qfalse;
+  }
+}
+
+/*
+==================
+CG_BuildableRemovalPending
+==================
+*/
+static qboolean CG_BuildableRemovalPending( int entityNum )
+{
+  int           i;
+  playerState_t *ps = &cg.snap->ps;
+
+  if( !( ps->stats[ STAT_BUILDABLE ] & SB_VALID_TOGGLEBIT ) )
+    return qfalse;
+
+  for( i = 0; i < MAX_MISC; i++ )
+  {
+    if( ps->misc[ i ] == entityNum )
+      return qtrue;
+  }
+
+  return qfalse;
+}
+
+/*
+==================
+CG_DrawBuildableStatus
+==================
+*/
+void CG_DrawBuildableStatus( void )
+{
+  int             i;
+  centity_t       *cent;
+  entityState_t   *es;
+  int             buildableList[ MAX_ENTITIES_IN_SNAPSHOT ];
+  int             buildables = 0;
+
+  for( i = 0; i < cg.snap->numEntities; i++ )
+  {
+    cent  = &cg_entities[ cg.snap->entities[ i ].number ];
+    es    = &cent->currentState;
+
+    if( es->eType == ET_BUILDABLE && CG_PlayerIsBuilder( es->modelindex ) )
+      buildableList[ buildables++ ] = cg.snap->entities[ i ].number;
+  }
+
+  qsort( buildableList, buildables, sizeof( int ), CG_SortDistance );
+  for( i = 0; i < buildables; i++ )
+    CG_BuildableStatusDisplay( &cg_entities[ buildableList[ i ] ] );
+}
+
+#define BUILDABLE_SOUND_PERIOD  500
+
+/*
+==================
+CG_Buildable
+==================
+*/
+void CG_Buildable( centity_t *cent )
+{
+  refEntity_t     ent;
+  entityState_t   *es = &cent->currentState;
+  vec3_t          angles;
+  vec3_t          surfNormal, xNormal, mins, maxs;
+  vec3_t          refNormal = { 0.0f, 0.0f, 1.0f };
+  float           rotAngle;
+  team_t          team = BG_Buildable( es->modelindex )->team;
+  float           scale;
+  int             health;
+
+  //must be before EF_NODRAW check
+  if( team == TEAM_ALIENS )
+    CG_Creep( cent );
+
+  // if set to invisible, skip
+  if( es->eFlags & EF_NODRAW )
+  {
+    if( CG_IsParticleSystemValid( &cent->buildablePS ) )
+      CG_DestroyParticleSystem( &cent->buildablePS );
+
+    return;
+  }
+
+  memset ( &ent, 0, sizeof( ent ) );
+
+  VectorCopy( cent->lerpOrigin, ent.origin );
+  VectorCopy( cent->lerpOrigin, ent.oldorigin );
+  VectorCopy( cent->lerpOrigin, ent.lightingOrigin );
+
+  VectorCopy( es->origin2, surfNormal );
+
+  VectorCopy( es->angles, angles );
+  BG_BuildableBoundingBox( es->modelindex, mins, maxs );
+
+  if( es->pos.trType == TR_STATIONARY )
+  {
+    // Positioning a buildable involves potentially up to two traces, and
+    // seeing as buildables rarely move, we cache the results and recalculate
+    // only if the buildable moves or changes orientation
+    if( VectorCompare( cent->buildableCache.cachedOrigin, cent->lerpOrigin ) &&
+        VectorCompare( cent->buildableCache.cachedNormal, surfNormal ) )
+    {
+      VectorCopy( cent->buildableCache.axis[ 0 ], ent.axis[ 0 ] );
+      VectorCopy( cent->buildableCache.axis[ 1 ], ent.axis[ 1 ] );
+      VectorCopy( cent->buildableCache.axis[ 2 ], ent.axis[ 2 ] );
+      VectorCopy( cent->buildableCache.origin, ent.origin );
+    }
+    else
+    {
+      CG_PositionAndOrientateBuildable( angles, ent.origin, surfNormal,
+                                        es->number, mins, maxs, ent.axis,
+                                        ent.origin );
+      VectorCopy( ent.axis[ 0 ], cent->buildableCache.axis[ 0 ] );
+      VectorCopy( ent.axis[ 1 ], cent->buildableCache.axis[ 1 ] );
+      VectorCopy( ent.axis[ 2 ], cent->buildableCache.axis[ 2 ] );
+      VectorCopy( ent.origin, cent->buildableCache.origin );
+      VectorCopy( cent->lerpOrigin, cent->buildableCache.cachedOrigin );
+      VectorCopy( surfNormal, cent->buildableCache.cachedNormal );
+    }
+  }
+
+  //offset on the Z axis if required
+  VectorMA( ent.origin, BG_BuildableConfig( es->modelindex )->zOffset, surfNormal, ent.origin );
+
+  VectorCopy( ent.origin, ent.oldorigin ); // don't positionally lerp at all
+  VectorCopy( ent.origin, ent.lightingOrigin );
+
+  ent.hModel = cg_buildables[ es->modelindex ].models[ 0 ];
+
+  if( !( es->eFlags & EF_B_SPAWNED ) )
+  {
+    sfxHandle_t prebuildSound = cgs.media.humanBuildablePrebuild;
+
+    if( team == TEAM_HUMANS )
+    {
+      ent.customShader = cgs.media.humanSpawningShader;
+      prebuildSound = cgs.media.humanBuildablePrebuild;
+    }
+    else if( team == TEAM_ALIENS )
+      prebuildSound = cgs.media.alienBuildablePrebuild;
+
+    trap_S_AddLoopingSound( es->number, cent->lerpOrigin, vec3_origin, prebuildSound );
+  }
+
+  CG_BuildableAnimation( cent, &ent.oldframe, &ent.frame, &ent.backlerp );
+
+  //rescale the model
+  scale = BG_BuildableConfig( es->modelindex )->modelScale;
+
+  if( scale != 1.0f )
+  {
+    VectorScale( ent.axis[ 0 ], scale, ent.axis[ 0 ] );
+    VectorScale( ent.axis[ 1 ], scale, ent.axis[ 1 ] );
+    VectorScale( ent.axis[ 2 ], scale, ent.axis[ 2 ] );
+
+    ent.nonNormalizedAxes = qtrue;
+  }
+  else
+    ent.nonNormalizedAxes = qfalse;
+
+  if( CG_PlayerIsBuilder( es->modelindex ) && CG_BuildableRemovalPending( es->number ) )
+    ent.customShader = cgs.media.redBuildShader;
+
+  //add to refresh list
+  trap_R_AddRefEntityToScene( &ent );
+
+  CrossProduct( surfNormal, refNormal, xNormal );
+  VectorNormalize( xNormal );
+  rotAngle = RAD2DEG( acos( DotProduct( surfNormal, refNormal ) ) );
+
+  //turret barrel bit
+  if( cg_buildables[ es->modelindex ].models[ 1 ] )
+  {
+    refEntity_t turretBarrel;
+    vec3_t      flatAxis[ 3 ];
+
+    memset( &turretBarrel, 0, sizeof( turretBarrel ) );
+
+    turretBarrel.hModel = cg_buildables[ es->modelindex ].models[ 1 ];
+
+    CG_PositionEntityOnTag( &turretBarrel, &ent, ent.hModel, "tag_turret" );
+    VectorCopy( cent->lerpOrigin, turretBarrel.lightingOrigin );
+    AnglesToAxis( es->angles2, flatAxis );
+
+    RotatePointAroundVector( turretBarrel.axis[ 0 ], xNormal, flatAxis[ 0 ], -rotAngle );
+    RotatePointAroundVector( turretBarrel.axis[ 1 ], xNormal, flatAxis[ 1 ], -rotAngle );
+    RotatePointAroundVector( turretBarrel.axis[ 2 ], xNormal, flatAxis[ 2 ], -rotAngle );
+
+    turretBarrel.oldframe = ent.oldframe;
+    turretBarrel.frame    = ent.frame;
+    turretBarrel.backlerp = ent.backlerp;
+
+    turretBarrel.customShader = ent.customShader;
+
+    if( scale != 1.0f )
+    {
+      VectorScale( turretBarrel.axis[ 0 ], scale, turretBarrel.axis[ 0 ] );
+      VectorScale( turretBarrel.axis[ 1 ], scale, turretBarrel.axis[ 1 ] );
+      VectorScale( turretBarrel.axis[ 2 ], scale, turretBarrel.axis[ 2 ] );
+
+      turretBarrel.nonNormalizedAxes = qtrue;
+    }
+    else
+      turretBarrel.nonNormalizedAxes = qfalse;
+
+    if( CG_PlayerIsBuilder( es->modelindex ) && CG_BuildableRemovalPending( es->number ) )
+      turretBarrel.customShader = cgs.media.redBuildShader;
+
+    trap_R_AddRefEntityToScene( &turretBarrel );
+  }
+
+  //turret barrel bit
+  if( cg_buildables[ es->modelindex ].models[ 2 ] )
+  {
+    refEntity_t turretTop;
+    vec3_t      flatAxis[ 3 ];
+    vec3_t      swivelAngles;
+
+    memset( &turretTop, 0, sizeof( turretTop ) );
+
+    VectorCopy( es->angles2, swivelAngles );
+    swivelAngles[ PITCH ] = 0.0f;
+
+    turretTop.hModel = cg_buildables[ es->modelindex ].models[ 2 ];
+
+    CG_PositionRotatedEntityOnTag( &turretTop, &ent, ent.hModel, "tag_turret" );
+    VectorCopy( cent->lerpOrigin, turretTop.lightingOrigin );
+    AnglesToAxis( swivelAngles, flatAxis );
+
+    RotatePointAroundVector( turretTop.axis[ 0 ], xNormal, flatAxis[ 0 ], -rotAngle );
+    RotatePointAroundVector( turretTop.axis[ 1 ], xNormal, flatAxis[ 1 ], -rotAngle );
+    RotatePointAroundVector( turretTop.axis[ 2 ], xNormal, flatAxis[ 2 ], -rotAngle );
+
+    turretTop.oldframe = ent.oldframe;
+    turretTop.frame    = ent.frame;
+    turretTop.backlerp = ent.backlerp;
+
+    turretTop.customShader = ent.customShader;
+
+    if( scale != 1.0f )
+    {
+      VectorScale( turretTop.axis[ 0 ], scale, turretTop.axis[ 0 ] );
+      VectorScale( turretTop.axis[ 1 ], scale, turretTop.axis[ 1 ] );
+      VectorScale( turretTop.axis[ 2 ], scale, turretTop.axis[ 2 ] );
+
+      turretTop.nonNormalizedAxes = qtrue;
+    }
+    else
+      turretTop.nonNormalizedAxes = qfalse;
+
+    if( CG_PlayerIsBuilder( es->modelindex ) && CG_BuildableRemovalPending( es->number ) )
+      turretTop.customShader = cgs.media.redBuildShader;
+
+    trap_R_AddRefEntityToScene( &turretTop );
+  }
+
+  //weapon effects for turrets
+  if( es->eFlags & EF_FIRING )
+  {
+    weaponInfo_t  *weapon = &cg_weapons[ es->weapon ];
+
+    if( cg.time - cent->muzzleFlashTime > MUZZLE_FLASH_TIME ||
+        BG_Buildable( es->modelindex )->turretProjType == WP_TESLAGEN )
+    {
+      if( weapon->wim[ WPM_PRIMARY ].flashDlightColor[ 0 ] ||
+          weapon->wim[ WPM_PRIMARY ].flashDlightColor[ 1 ] ||
+          weapon->wim[ WPM_PRIMARY ].flashDlightColor[ 2 ] )
+      {
+        trap_R_AddLightToScene( cent->lerpOrigin, 300 + ( rand( ) & 31 ),
+            weapon->wim[ WPM_PRIMARY ].flashDlightColor[ 0 ],
+            weapon->wim[ WPM_PRIMARY ].flashDlightColor[ 1 ],
+            weapon->wim[ WPM_PRIMARY ].flashDlightColor[ 2 ] );
+      }
+    }
+
+    if( weapon->wim[ WPM_PRIMARY ].firingSound )
+    {
+      trap_S_AddLoopingSound( es->number, cent->lerpOrigin, vec3_origin,
+          weapon->wim[ WPM_PRIMARY ].firingSound );
+    }
+    else if( weapon->readySound )
+      trap_S_AddLoopingSound( es->number, cent->lerpOrigin, vec3_origin, weapon->readySound );
+  }
+
+  health = es->generic1;
+
+  if( health < cent->lastBuildableHealth &&
+      ( es->eFlags & EF_B_SPAWNED ) )
+  {
+    if( cent->lastBuildableDamageSoundTime + BUILDABLE_SOUND_PERIOD < cg.time )
+    {
+      if( team == TEAM_HUMANS )
+      {
+        int i = rand( ) % 4;
+        trap_S_StartSound( NULL, es->number, CHAN_BODY, cgs.media.humanBuildableDamage[ i ] );
+      }
+      else if( team == TEAM_ALIENS )
+        trap_S_StartSound( NULL, es->number, CHAN_BODY, cgs.media.alienBuildableDamage );
+
+      cent->lastBuildableDamageSoundTime = cg.time;
+    }
+  }
+
+  cent->lastBuildableHealth = health;
+
+  //smoke etc for damaged buildables
+  CG_BuildableParticleEffects( cent );
+}
diff -uNr tremulous-ggp1-src.p/src/cgame/cg_buildable.c.rej tremulous-ggp1-src/src/cgame/cg_buildable.c.rej
--- tremulous-ggp1-src.p/src/cgame/cg_buildable.c.rej	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/cgame/cg_buildable.c.rej	2012-07-19 04:25:52.041556450 +0200
@@ -0,0 +1,26 @@
+--- src/cgame/cg_buildable.c	(Revision 2062)
++++ src/cgame/cg_buildable.c	(Arbeitskopie)
+@@ -551,7 +551,8 @@
+                                               const vec3_t mins, const vec3_t maxs,
+                                               vec3_t outAxis[ 3 ], vec3_t outOrigin )
+ {
+-  vec3_t  forward, start, end;
++  vec3_t  forward, start, end, newMaxs;
++  vec_t   w, h;
+   trace_t tr;
+ 
+   AngleVectors( angles, forward, NULL, NULL );
+@@ -572,7 +573,12 @@
+ 
+   VectorMA( inOrigin, -TRACE_DEPTH, normal, end );
+   VectorMA( inOrigin, 1.0f, normal, start );
+-  CG_CapTrace( &tr, start, mins, maxs, end, skipNumber,
++  VectorCopy( maxs, newMaxs );
++  w = maxs[0] - mins[0];
++  h = maxs[2] - mins[2];
++  if( h < w )
++    newMaxs[2] += w - h;
++  CG_CapTrace( &tr, start, mins, newMaxs, end, skipNumber,
+                CONTENTS_SOLID | CONTENTS_PLAYERCLIP );
+ 
+   if( tr.fraction == 1.0f )
diff -uNr tremulous-ggp1-src.p/src/client/cl_scrn.c tremulous-ggp1-src/src/client/cl_scrn.c
--- tremulous-ggp1-src.p/src/client/cl_scrn.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/client/cl_scrn.c	2012-07-19 04:25:52.041556450 +0200
@@ -560,9 +560,9 @@
 		}
 
 		if ( com_speeds->integer ) {
-			re.EndFrame( &time_frontend, &time_backend );
+			re.EndFrame( &time_frontend, &time_backend, &time_GL );
 		} else {
-			re.EndFrame( NULL, NULL );
+			re.EndFrame( NULL, NULL, NULL );
 		}
 	}
 	
diff -uNr tremulous-ggp1-src.p/src/client/cl_scrn.c.orig tremulous-ggp1-src/src/client/cl_scrn.c.orig
--- tremulous-ggp1-src.p/src/client/cl_scrn.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/client/cl_scrn.c.orig	2012-07-19 04:25:20.221556050 +0200
@@ -0,0 +1,571 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+// cl_scrn.c -- master for refresh, status bar, console, chat, notify, etc
+
+#include "client.h"
+
+qboolean	scr_initialized;		// ready to draw
+
+cvar_t		*cl_timegraph;
+cvar_t		*cl_debuggraph;
+cvar_t		*cl_graphheight;
+cvar_t		*cl_graphscale;
+cvar_t		*cl_graphshift;
+
+/*
+================
+SCR_DrawNamedPic
+
+Coordinates are 640*480 virtual values
+=================
+*/
+void SCR_DrawNamedPic( float x, float y, float width, float height, const char *picname ) {
+	qhandle_t	hShader;
+
+	assert( width != 0 );
+
+	hShader = re.RegisterShader( picname );
+	SCR_AdjustFrom640( &x, &y, &width, &height );
+	re.DrawStretchPic( x, y, width, height, 0, 0, 1, 1, hShader );
+}
+
+
+/*
+================
+SCR_AdjustFrom640
+
+Adjusted for resolution and screen aspect ratio
+================
+*/
+void SCR_AdjustFrom640( float *x, float *y, float *w, float *h ) {
+	float	xscale;
+	float	yscale;
+
+#if 0
+		// adjust for wide screens
+		if ( cls.glconfig.vidWidth * 480 > cls.glconfig.vidHeight * 640 ) {
+			*x += 0.5 * ( cls.glconfig.vidWidth - ( cls.glconfig.vidHeight * 640 / 480 ) );
+		}
+#endif
+
+	// scale for screen sizes
+	xscale = cls.glconfig.vidWidth / 640.0;
+	yscale = cls.glconfig.vidHeight / 480.0;
+	if ( x ) {
+		*x *= xscale;
+	}
+	if ( y ) {
+		*y *= yscale;
+	}
+	if ( w ) {
+		*w *= xscale;
+	}
+	if ( h ) {
+		*h *= yscale;
+	}
+}
+
+/*
+================
+SCR_FillRect
+
+Coordinates are 640*480 virtual values
+=================
+*/
+void SCR_FillRect( float x, float y, float width, float height, const float *color ) {
+	re.SetColor( color );
+
+	SCR_AdjustFrom640( &x, &y, &width, &height );
+	re.DrawStretchPic( x, y, width, height, 0, 0, 0, 0, cls.whiteShader );
+
+	re.SetColor( NULL );
+}
+
+
+/*
+================
+SCR_DrawPic
+
+Coordinates are 640*480 virtual values
+=================
+*/
+void SCR_DrawPic( float x, float y, float width, float height, qhandle_t hShader ) {
+	SCR_AdjustFrom640( &x, &y, &width, &height );
+	re.DrawStretchPic( x, y, width, height, 0, 0, 1, 1, hShader );
+}
+
+
+
+/*
+** SCR_DrawChar
+** chars are drawn at 640*480 virtual screen size
+*/
+static void SCR_DrawChar( int x, int y, float size, int ch ) {
+	int row, col;
+	float frow, fcol;
+	float	ax, ay, aw, ah;
+
+	ch &= 255;
+
+	if ( ch == ' ' ) {
+		return;
+	}
+
+	if ( y < -size ) {
+		return;
+	}
+
+	ax = x;
+	ay = y;
+	aw = size;
+	ah = size;
+	SCR_AdjustFrom640( &ax, &ay, &aw, &ah );
+
+	row = ch>>4;
+	col = ch&15;
+
+	frow = row*0.0625;
+	fcol = col*0.0625;
+	size = 0.0625;
+
+	re.DrawStretchPic( ax, ay, aw, ah,
+					   fcol, frow, 
+					   fcol + size, frow + size, 
+					   cls.charSetShader );
+}
+
+/*
+** SCR_DrawSmallChar
+** small chars are drawn at native screen resolution
+*/
+void SCR_DrawSmallChar( int x, int y, int ch ) {
+	int row, col;
+	float frow, fcol;
+	float size;
+
+	ch &= 255;
+
+	if ( ch == ' ' ) {
+		return;
+	}
+
+	if ( y < -SMALLCHAR_HEIGHT ) {
+		return;
+	}
+
+	row = ch>>4;
+	col = ch&15;
+
+	frow = row*0.0625;
+	fcol = col*0.0625;
+	size = 0.0625;
+
+	re.DrawStretchPic( x, y, SMALLCHAR_WIDTH, SMALLCHAR_HEIGHT,
+					   fcol, frow, 
+					   fcol + size, frow + size, 
+					   cls.charSetShader );
+}
+
+
+/*
+==================
+SCR_DrawBigString[Color]
+
+Draws a multi-colored string with a drop shadow, optionally forcing
+to a fixed color.
+
+Coordinates are at 640 by 480 virtual resolution
+==================
+*/
+void SCR_DrawStringExt( int x, int y, float size, const char *string, float *setColor, qboolean forceColor,
+		qboolean noColorEscape ) {
+	vec4_t		color;
+	const char	*s;
+	int			xx;
+
+	// draw the drop shadow
+	color[0] = color[1] = color[2] = 0;
+	color[3] = setColor[3];
+	re.SetColor( color );
+	s = string;
+	xx = x;
+	while ( *s ) {
+		if ( !noColorEscape && Q_IsColorString( s ) ) {
+			s += 2;
+			continue;
+		}
+		SCR_DrawChar( xx+2, y+2, size, *s );
+		xx += size;
+		s++;
+	}
+
+
+	// draw the colored text
+	s = string;
+	xx = x;
+	re.SetColor( setColor );
+	while ( *s ) {
+		if ( !noColorEscape && Q_IsColorString( s ) ) {
+			if ( !forceColor ) {
+				Com_Memcpy( color, g_color_table[ColorIndex(*(s+1))], sizeof( color ) );
+				color[3] = setColor[3];
+				re.SetColor( color );
+			}
+			s += 2;
+			continue;
+		}
+		SCR_DrawChar( xx, y, size, *s );
+		xx += size;
+		s++;
+	}
+	re.SetColor( NULL );
+}
+
+
+void SCR_DrawBigString( int x, int y, const char *s, float alpha, qboolean noColorEscape ) {
+	float	color[4];
+
+	color[0] = color[1] = color[2] = 1.0;
+	color[3] = alpha;
+	SCR_DrawStringExt( x, y, BIGCHAR_WIDTH, s, color, qfalse, noColorEscape );
+}
+
+void SCR_DrawBigStringColor( int x, int y, const char *s, vec4_t color, qboolean noColorEscape ) {
+	SCR_DrawStringExt( x, y, BIGCHAR_WIDTH, s, color, qtrue, noColorEscape );
+}
+
+
+/*
+==================
+SCR_DrawSmallString[Color]
+
+Draws a multi-colored string with a drop shadow, optionally forcing
+to a fixed color.
+==================
+*/
+void SCR_DrawSmallStringExt( int x, int y, const char *string, float *setColor, qboolean forceColor,
+		qboolean noColorEscape ) {
+	vec4_t		color;
+	const char	*s;
+	int			xx;
+
+	// draw the colored text
+	s = string;
+	xx = x;
+	re.SetColor( setColor );
+	while ( *s ) {
+		if ( Q_IsColorString( s ) ) {
+			if ( !forceColor ) {
+				Com_Memcpy( color, g_color_table[ColorIndex(*(s+1))], sizeof( color ) );
+				color[3] = setColor[3];
+				re.SetColor( color );
+			}
+			if ( !noColorEscape ) {
+				s += 2;
+				continue;
+			}
+		}
+		SCR_DrawSmallChar( xx, y, *s );
+		xx += SMALLCHAR_WIDTH;
+		s++;
+	}
+	re.SetColor( NULL );
+}
+
+
+
+/*
+** SCR_Strlen -- skips color escape codes
+*/
+static int SCR_Strlen( const char *str ) {
+	const char *s = str;
+	int count = 0;
+
+	while ( *s ) {
+		if ( Q_IsColorString( s ) ) {
+			s += 2;
+		} else {
+			count++;
+			s++;
+		}
+	}
+
+	return count;
+}
+
+/*
+** SCR_GetBigStringWidth
+*/ 
+int	SCR_GetBigStringWidth( const char *str ) {
+	return SCR_Strlen( str ) * 16;
+}
+
+
+//===============================================================================
+
+
+#ifdef USE_VOIP
+/*
+=================
+SCR_DrawVoipMeter
+
+FIXME: inherited from ioq3, move to cgame/ui
+=================
+*/
+void SCR_DrawVoipMeter( void ) {
+	char	buffer[16];
+	char	string[256];
+	int limit, i;
+
+	if (!cl_voipShowMeter->integer)
+		return;  // player doesn't want to show meter at all.
+	else if (!cl_voipSend->integer)
+		return;  // not recording at the moment.
+	else if (cls.state != CA_ACTIVE)
+		return;  // not connected to a server.
+	else if (!cl_connectedToVoipServer)
+		return;  // server doesn't support VoIP.
+	else if (clc.demoplaying)
+		return;  // playing back a demo.
+	else if (!cl_voip->integer)
+		return;  // client has VoIP support disabled.
+
+	limit = (int) (clc.voipPower * 10.0f);
+	if (limit > 10)
+		limit = 10;
+
+	for (i = 0; i < limit; i++)
+		buffer[i] = '*';
+	while (i < 10)
+		buffer[i++] = ' ';
+	buffer[i] = '\0';
+
+	sprintf( string, "VoIP: [%s]", buffer );
+	SCR_DrawStringExt( 320 - strlen( string ) * 4, 10, 8, string, g_color_table[7], qtrue, qfalse );
+}
+#endif
+
+
+
+
+/*
+===============================================================================
+
+DEBUG GRAPH
+
+===============================================================================
+*/
+
+typedef struct
+{
+	float	value;
+	int		color;
+} graphsamp_t;
+
+static	int			current;
+static	graphsamp_t	values[1024];
+
+/*
+==============
+SCR_DebugGraph
+==============
+*/
+void SCR_DebugGraph (float value, int color)
+{
+	values[current&1023].value = value;
+	values[current&1023].color = color;
+	current++;
+}
+
+/*
+==============
+SCR_DrawDebugGraph
+==============
+*/
+void SCR_DrawDebugGraph (void)
+{
+	int		a, x, y, w, i, h;
+	float	v;
+	int		color;
+
+	//
+	// draw the graph
+	//
+	w = cls.glconfig.vidWidth;
+	x = 0;
+	y = cls.glconfig.vidHeight;
+	re.SetColor( g_color_table[0] );
+	re.DrawStretchPic(x, y - cl_graphheight->integer, 
+		w, cl_graphheight->integer, 0, 0, 0, 0, cls.whiteShader );
+	re.SetColor( NULL );
+
+	for (a=0 ; a<w ; a++)
+	{
+		i = (current-1-a+1024) & 1023;
+		v = values[i].value;
+		color = values[i].color;
+		v = v * cl_graphscale->integer + cl_graphshift->integer;
+		
+		if (v < 0)
+			v += cl_graphheight->integer * (1+(int)(-v / cl_graphheight->integer));
+		h = (int)v % cl_graphheight->integer;
+		re.DrawStretchPic( x+w-1-a, y - h, 1, h, 0, 0, 0, 0, cls.whiteShader );
+	}
+}
+
+//=============================================================================
+
+/*
+==================
+SCR_Init
+==================
+*/
+void SCR_Init( void ) {
+	cl_timegraph = Cvar_Get ("timegraph", "0", CVAR_CHEAT);
+	cl_debuggraph = Cvar_Get ("debuggraph", "0", CVAR_CHEAT);
+	cl_graphheight = Cvar_Get ("graphheight", "32", CVAR_CHEAT);
+	cl_graphscale = Cvar_Get ("graphscale", "1", CVAR_CHEAT);
+	cl_graphshift = Cvar_Get ("graphshift", "0", CVAR_CHEAT);
+
+	scr_initialized = qtrue;
+}
+
+
+//=======================================================
+
+/*
+==================
+SCR_DrawScreenField
+
+This will be called twice if rendering in stereo mode
+==================
+*/
+void SCR_DrawScreenField( stereoFrame_t stereoFrame ) {
+	re.BeginFrame( stereoFrame );
+
+	// wide aspect ratio screens need to have the sides cleared
+	// unless they are displaying game renderings
+	if ( cls.state != CA_ACTIVE && cls.state != CA_CINEMATIC ) {
+		if ( cls.glconfig.vidWidth * 480 > cls.glconfig.vidHeight * 640 ) {
+			re.SetColor( g_color_table[0] );
+			re.DrawStretchPic( 0, 0, cls.glconfig.vidWidth, cls.glconfig.vidHeight, 0, 0, 0, 0, cls.whiteShader );
+			re.SetColor( NULL );
+		}
+	}
+
+	// if the menu is going to cover the entire screen, we
+	// don't need to render anything under it
+	if ( uivm && !VM_Call( uivm, UI_IS_FULLSCREEN )) {
+		switch( cls.state ) {
+		default:
+			Com_Error( ERR_FATAL, "SCR_DrawScreenField: bad cls.state" );
+			break;
+		case CA_CINEMATIC:
+			SCR_DrawCinematic();
+			break;
+		case CA_DISCONNECTED:
+			// force menu up
+			S_StopAllSounds();
+			VM_Call( uivm, UI_SET_ACTIVE_MENU, UIMENU_MAIN );
+			break;
+		case CA_CONNECTING:
+		case CA_CHALLENGING:
+		case CA_CONNECTED:
+			// connecting clients will only show the connection dialog
+			// refresh to update the time
+			VM_Call( uivm, UI_REFRESH, cls.realtime );
+			VM_Call( uivm, UI_DRAW_CONNECT_SCREEN, qfalse );
+			break;
+		case CA_LOADING:
+		case CA_PRIMED:
+			// draw the game information screen and loading progress
+			CL_CGameRendering(stereoFrame);
+			break;
+		case CA_ACTIVE:
+			// always supply STEREO_CENTER as vieworg offset is now done by the engine.
+			CL_CGameRendering(stereoFrame);
+#ifdef USE_VOIP
+			SCR_DrawVoipMeter();
+#endif
+			break;
+		}
+	}
+
+	// the menu draws next
+	if ( Key_GetCatcher( ) & KEYCATCH_UI && uivm ) {
+		VM_Call( uivm, UI_REFRESH, cls.realtime );
+	}
+
+	// console draws next
+	Con_DrawConsole ();
+
+	// debug graph can be drawn on top of anything
+	if ( cl_debuggraph->integer || cl_timegraph->integer || cl_debugMove->integer ) {
+		SCR_DrawDebugGraph ();
+	}
+}
+
+/*
+==================
+SCR_UpdateScreen
+
+This is called every frame, and can also be called explicitly to flush
+text to the screen.
+==================
+*/
+void SCR_UpdateScreen( void ) {
+	static int	recursive;
+
+	if ( !scr_initialized ) {
+		return;				// not initialized yet
+	}
+
+	if ( ++recursive > 2 ) {
+		Com_Error( ERR_FATAL, "SCR_UpdateScreen: recursively called" );
+	}
+	recursive = 1;
+
+	// If there is no VM, there are also no rendering commands issued. Stop the renderer in
+	// that case.
+	if( uivm || com_dedicated->integer )
+	{
+		// XXX
+		extern cvar_t* r_anaglyphMode;
+		// if running in stereo, we need to draw the frame twice
+		if ( cls.glconfig.stereoEnabled || r_anaglyphMode->integer) {
+			SCR_DrawScreenField( STEREO_LEFT );
+			SCR_DrawScreenField( STEREO_RIGHT );
+		} else {
+			SCR_DrawScreenField( STEREO_CENTER );
+		}
+
+		if ( com_speeds->integer ) {
+			re.EndFrame( &time_frontend, &time_backend );
+		} else {
+			re.EndFrame( NULL, NULL );
+		}
+	}
+	
+	recursive = 0;
+}
+
diff -uNr tremulous-ggp1-src.p/src/qcommon/common.c tremulous-ggp1-src/src/qcommon/common.c
--- tremulous-ggp1-src.p/src/qcommon/common.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/qcommon/common.c	2012-07-19 04:25:52.041556450 +0200
@@ -91,6 +91,7 @@
 int		time_game;
 int		time_frontend;		// renderer frontend time
 int		time_backend;		// renderer backend time
+int		time_GL;		// time to render reported by GL_EXT_timer_query
 
 int			com_frameTime;
 int			com_frameNumber;
@@ -2955,8 +2956,8 @@
 		sv -= time_game;
 		cl -= time_frontend + time_backend;
 
-		Com_Printf ("frame:%i all:%3i sv:%3i ev:%3i cl:%3i gm:%3i rf:%3i bk:%3i\n", 
-					 com_frameNumber, all, sv, ev, cl, time_game, time_frontend, time_backend );
+		Com_Printf ("frame:%i all:%3i sv:%3i ev:%3i cl:%3i gm:%3i rf:%3i bk:%3i gl:%3i\n", 
+			    com_frameNumber, all, sv, ev, cl, time_game, time_frontend, time_backend, time_GL );
 	}	
 
 	//
diff -uNr tremulous-ggp1-src.p/src/qcommon/common.c.orig tremulous-ggp1-src/src/qcommon/common.c.orig
--- tremulous-ggp1-src.p/src/qcommon/common.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/qcommon/common.c.orig	2012-07-19 04:25:20.301556050 +0200
@@ -0,0 +1,3326 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+// common.c -- misc functions used in client and server
+
+#include "q_shared.h"
+#include "qcommon.h"
+#include <setjmp.h>
+#ifndef _WIN32
+#include <netinet/in.h>
+#include <sys/stat.h> // umask
+#else
+#include <winsock.h>
+#endif
+
+int demo_protocols[] =
+{ PROTOCOL_VERSION, 0 };
+
+#define MAX_NUM_ARGVS	50
+
+#define MIN_DEDICATED_COMHUNKMEGS 1
+#define MIN_COMHUNKMEGS		128
+#define DEF_COMHUNKMEGS		128
+#define DEF_COMZONEMEGS		24
+#define DEF_COMHUNKMEGS_S	XSTRING(DEF_COMHUNKMEGS)
+#define DEF_COMZONEMEGS_S	XSTRING(DEF_COMZONEMEGS)
+
+int		com_argc;
+char	*com_argv[MAX_NUM_ARGVS+1];
+
+jmp_buf abortframe;		// an ERR_DROP occured, exit the entire frame
+
+
+FILE *debuglogfile;
+static fileHandle_t pipefile;
+static fileHandle_t logfile;
+fileHandle_t	com_journalFile;			// events are written here
+fileHandle_t	com_journalDataFile;		// config files are written here
+
+cvar_t	*com_speeds;
+cvar_t	*com_developer;
+cvar_t	*com_dedicated;
+cvar_t	*com_timescale;
+cvar_t	*com_fixedtime;
+cvar_t	*com_journal;
+cvar_t	*com_maxfps;
+cvar_t	*com_altivec;
+cvar_t	*com_timedemo;
+cvar_t	*com_sv_running;
+cvar_t	*com_cl_running;
+cvar_t	*com_logfile;		// 1 = buffer log, 2 = flush after each print
+cvar_t	*com_pipefile;
+cvar_t	*com_showtrace;
+cvar_t	*com_version;
+cvar_t	*com_blood;
+cvar_t	*com_buildScript;	// for automated data building scripts
+cvar_t	*cl_paused;
+cvar_t	*sv_paused;
+cvar_t  *cl_packetdelay;
+cvar_t  *sv_packetdelay;
+cvar_t	*com_cameraMode;
+cvar_t	*com_ansiColor;
+cvar_t	*com_unfocused;
+cvar_t	*com_maxfpsUnfocused;
+cvar_t	*com_minimized;
+cvar_t	*com_maxfpsMinimized;
+cvar_t	*com_abnormalExit;
+cvar_t  *com_homepath;
+cvar_t	*com_busyWait;
+
+// com_speeds times
+int		time_game;
+int		time_frontend;		// renderer frontend time
+int		time_backend;		// renderer backend time
+
+int			com_frameTime;
+int			com_frameNumber;
+
+qboolean	com_errorEntered = qfalse;
+qboolean	com_fullyInitialized = qfalse;
+qboolean	com_gameRestarting = qfalse;
+
+char	com_errorMessage[MAXPRINTMSG];
+
+void Com_WriteConfig_f( void );
+void CIN_CloseAllVideos( void );
+
+//============================================================================
+
+static char	*rd_buffer;
+static int	rd_buffersize;
+static void	(*rd_flush)( char *buffer );
+
+void Com_BeginRedirect (char *buffer, int buffersize, void (*flush)( char *) )
+{
+	if (!buffer || !buffersize || !flush)
+		return;
+	rd_buffer = buffer;
+	rd_buffersize = buffersize;
+	rd_flush = flush;
+
+	*rd_buffer = 0;
+}
+
+void Com_EndRedirect (void)
+{
+	if ( rd_flush ) {
+		rd_flush(rd_buffer);
+	}
+
+	rd_buffer = NULL;
+	rd_buffersize = 0;
+	rd_flush = NULL;
+}
+
+/*
+=============
+Com_Printf
+
+Both client and server can use this, and it will output
+to the apropriate place.
+
+A raw string should NEVER be passed as fmt, because of "%f" type crashers.
+=============
+*/
+void QDECL Com_Printf( const char *fmt, ... ) {
+	va_list		argptr;
+	char		msg[MAXPRINTMSG];
+  static qboolean opening_qconsole = qfalse;
+
+
+	va_start (argptr,fmt);
+	Q_vsnprintf (msg, sizeof(msg), fmt, argptr);
+	va_end (argptr);
+
+	if ( rd_buffer ) {
+		if ((strlen (msg) + strlen(rd_buffer)) > (rd_buffersize - 1)) {
+			rd_flush(rd_buffer);
+			*rd_buffer = 0;
+		}
+		Q_strcat(rd_buffer, rd_buffersize, msg);
+    // TTimo nooo .. that would defeat the purpose
+		//rd_flush(rd_buffer);			
+		//*rd_buffer = 0;
+		return;
+	}
+
+#ifndef DEDICATED
+	CL_ConsolePrint( msg );
+#endif
+
+	Q_StripIndentMarker( msg );
+
+	// echo to dedicated console and early console
+	Sys_Print( msg );
+
+	// logfile
+	if ( com_logfile && com_logfile->integer ) {
+    // TTimo: only open the qconsole.log if the filesystem is in an initialized state
+    //   also, avoid recursing in the qconsole.log opening (i.e. if fs_debug is on)
+		if ( !logfile && FS_Initialized() && !opening_qconsole) {
+			struct tm *newtime;
+			time_t aclock;
+
+      opening_qconsole = qtrue;
+
+			time( &aclock );
+			newtime = localtime( &aclock );
+
+			logfile = FS_FOpenFileWrite( "qconsole.log" );
+			
+			if(logfile)
+			{
+				Com_Printf( "logfile opened on %s\n", asctime( newtime ) );
+			
+				if ( com_logfile->integer > 1 )
+				{
+					// force it to not buffer so we get valid
+					// data even if we are crashing
+					FS_ForceFlush(logfile);
+				}
+			}
+			else
+			{
+				Com_Printf("Opening qconsole.log failed!\n");
+				Cvar_SetValue("logfile", 0);
+			}
+
+      opening_qconsole = qfalse;
+		}
+		if ( logfile && FS_Initialized()) {
+			FS_Write(msg, strlen(msg), logfile);
+		}
+	}
+}
+
+
+/*
+================
+Com_DPrintf
+
+A Com_Printf that only shows up if the "developer" cvar is set
+================
+*/
+void QDECL Com_DPrintf( const char *fmt, ...) {
+	va_list		argptr;
+	char		msg[MAXPRINTMSG];
+		
+	if ( !com_developer || !com_developer->integer ) {
+		return;			// don't confuse non-developers with techie stuff...
+	}
+
+	va_start (argptr,fmt);	
+	Q_vsnprintf (msg, sizeof(msg), fmt, argptr);
+	va_end (argptr);
+	
+	Com_Printf ("%s", msg);
+}
+
+/*
+=============
+Com_Error
+
+Both client and server can use this, and it will
+do the appropriate thing.
+=============
+*/
+void QDECL Com_Error( int code, const char *fmt, ... ) {
+	va_list		argptr;
+	static int	lastErrorTime;
+	static int	errorCount;
+	static qboolean	calledSysError = qfalse;
+	int			currentTime;
+
+	if(com_errorEntered)
+	{
+		if(!calledSysError)
+		{
+			calledSysError = qtrue;
+			Sys_Error("recursive error after: %s", com_errorMessage);
+		}
+		
+		return;
+	}
+
+	com_errorEntered = qtrue;
+
+	Cvar_Set("com_errorCode", va("%i", code));
+
+	// when we are running automated scripts, make sure we
+	// know if anything failed
+	if ( com_buildScript && com_buildScript->integer ) {
+		code = ERR_FATAL;
+	}
+
+	// if we are getting a solid stream of ERR_DROP, do an ERR_FATAL
+	currentTime = Sys_Milliseconds();
+	if ( currentTime - lastErrorTime < 100 ) {
+		if ( ++errorCount > 3 ) {
+			code = ERR_FATAL;
+		}
+	} else {
+		errorCount = 0;
+	}
+	lastErrorTime = currentTime;
+
+	va_start (argptr,fmt);
+	Q_vsnprintf (com_errorMessage, sizeof(com_errorMessage),fmt,argptr);
+	va_end (argptr);
+
+	if (code != ERR_DISCONNECT && code != ERR_NEED_CD)
+		Cvar_Set("com_errorMessage", com_errorMessage);
+
+	if (code == ERR_DISCONNECT || code == ERR_SERVERDISCONNECT) {
+		VM_Forced_Unload_Start();
+		SV_Shutdown( "Server disconnected" );
+		CL_Disconnect( qtrue );
+		CL_FlushMemory( );
+		VM_Forced_Unload_Done();
+		// make sure we can get at our local stuff
+		FS_PureServerSetLoadedPaks("", "");
+		com_errorEntered = qfalse;
+		longjmp (abortframe, -1);
+	} else if (code == ERR_DROP) {
+		Com_Printf ("********************\nERROR: %s\n********************\n", com_errorMessage);
+		VM_Forced_Unload_Start();
+		SV_Shutdown (va("Server crashed: %s",  com_errorMessage));
+		CL_Disconnect( qtrue );
+		CL_FlushMemory( );
+		VM_Forced_Unload_Done();
+		FS_PureServerSetLoadedPaks("", "");
+		com_errorEntered = qfalse;
+		longjmp (abortframe, -1);
+	} else if ( code == ERR_NEED_CD ) {
+		VM_Forced_Unload_Start();
+		SV_Shutdown( "Server didn't have CD" );
+		if ( com_cl_running && com_cl_running->integer ) {
+			CL_Disconnect( qtrue );
+			CL_FlushMemory( );
+			VM_Forced_Unload_Done();
+			CL_CDDialog();
+		} else {
+			Com_Printf("Server didn't have CD\n" );
+			VM_Forced_Unload_Done();
+		}
+
+		FS_PureServerSetLoadedPaks("", "");
+
+		com_errorEntered = qfalse;
+		longjmp (abortframe, -1);
+	} else {
+		VM_Forced_Unload_Start();
+		CL_Shutdown (va("Client fatal crashed: %s", com_errorMessage));
+		SV_Shutdown (va("Server fatal crashed: %s", com_errorMessage));
+		VM_Forced_Unload_Done();
+	}
+
+	Com_Shutdown ();
+
+	calledSysError = qtrue;
+	Sys_Error ("%s", com_errorMessage);
+}
+
+
+/*
+=============
+Com_Quit_f
+
+Both client and server can use this, and it will
+do the apropriate things.
+=============
+*/
+void Com_Quit_f( void ) {
+	// don't try to shutdown if we are in a recursive error
+	char *p = Cmd_Args( );
+	if ( !com_errorEntered ) {
+		SV_Shutdown (p[0] ? p : "Server quit");
+		CL_Shutdown (p[0] ? p : "Client quit");
+		Com_Shutdown ();
+		FS_Shutdown(qtrue);
+	}
+	Sys_Quit ();
+}
+
+
+
+/*
+============================================================================
+
+COMMAND LINE FUNCTIONS
+
++ characters seperate the commandLine string into multiple console
+command lines.
+
+All of these are valid:
+
+tremulous +set test blah +map test
+tremulous set test blah+map test
+tremulous set test blah + map test
+
+============================================================================
+*/
+
+#define	MAX_CONSOLE_LINES	32
+int		com_numConsoleLines;
+char	*com_consoleLines[MAX_CONSOLE_LINES];
+
+/*
+==================
+Com_ParseCommandLine
+
+Break it up into multiple console lines
+==================
+*/
+void Com_ParseCommandLine( char *commandLine ) {
+    int inq = 0;
+    com_consoleLines[0] = commandLine;
+    com_numConsoleLines = 1;
+
+    while ( *commandLine ) {
+        if (*commandLine == '"') {
+            inq = !inq;
+        }
+        // look for a + seperating character
+        // if commandLine came from a file, we might have real line seperators
+        if ( (*commandLine == '+' && !inq) || *commandLine == '\n'  || *commandLine == '\r' ) {
+            if ( com_numConsoleLines == MAX_CONSOLE_LINES ) {
+                return;
+            }
+            com_consoleLines[com_numConsoleLines] = commandLine + 1;
+            com_numConsoleLines++;
+            *commandLine = 0;
+        }
+        commandLine++;
+    }
+}
+
+
+/*
+===================
+Com_SafeMode
+
+Check for "safe" on the command line, which will
+skip loading of autogen.cfg
+===================
+*/
+qboolean Com_SafeMode( void ) {
+	int		i;
+
+	for ( i = 0 ; i < com_numConsoleLines ; i++ ) {
+		Cmd_TokenizeString( com_consoleLines[i] );
+		if ( !Q_stricmp( Cmd_Argv(0), "safe" )
+			|| !Q_stricmp( Cmd_Argv(0), "cvar_restart" ) ) {
+			com_consoleLines[i][0] = 0;
+			return qtrue;
+		}
+	}
+	return qfalse;
+}
+
+
+/*
+===============
+Com_StartupVariable
+
+Searches for command line parameters that are set commands.
+If match is not NULL, only that cvar will be looked for.
+That is necessary because cddir and basedir need to be set
+before the filesystem is started, but all other sets should
+be after execing the config and default.
+===============
+*/
+void Com_StartupVariable( const char *match ) {
+	int		i;
+	char	*s;
+
+	for (i=0 ; i < com_numConsoleLines ; i++) {
+		Cmd_TokenizeString( com_consoleLines[i] );
+		if ( strcmp( Cmd_Argv(0), "set" ) ) {
+			continue;
+		}
+
+		s = Cmd_Argv(1);
+		
+		if(!match || !strcmp(s, match))
+		{
+			if(Cvar_Flags(s) == CVAR_NONEXISTENT)
+				Cvar_Get(s, Cmd_Argv(2), CVAR_USER_CREATED);
+			else
+				Cvar_Set(s, Cmd_Argv(2));
+		}
+	}
+}
+
+
+/*
+=================
+Com_AddStartupCommands
+
+Adds command line parameters as script statements
+Commands are seperated by + signs
+
+Returns qtrue if any late commands were added, which
+will keep the demoloop from immediately starting
+=================
+*/
+qboolean Com_AddStartupCommands( void ) {
+	int		i;
+	qboolean	added;
+
+	added = qfalse;
+	// quote every token, so args with semicolons can work
+	for (i=0 ; i < com_numConsoleLines ; i++) {
+		if ( !com_consoleLines[i] || !com_consoleLines[i][0] ) {
+			continue;
+		}
+
+		// set commands already added with Com_StartupVariable
+		if ( !Q_stricmpn( com_consoleLines[i], "set", 3 ) ) {
+			continue;
+		}
+
+		added = qtrue;
+		Cbuf_AddText( com_consoleLines[i] );
+		Cbuf_AddText( "\n" );
+	}
+
+	return added;
+}
+
+
+//============================================================================
+
+void Info_Print( const char *s ) {
+	char	key[BIG_INFO_KEY];
+	char	value[BIG_INFO_VALUE];
+	char	*o;
+	int		l;
+
+	if (*s == '\\')
+		s++;
+	while (*s)
+	{
+		o = key;
+		while (*s && *s != '\\')
+			*o++ = *s++;
+
+		l = o - key;
+		if (l < 20)
+		{
+			Com_Memset (o, ' ', 20-l);
+			key[20] = 0;
+		}
+		else
+			*o = 0;
+		Com_Printf ("%s ", key);
+
+		if (!*s)
+		{
+			Com_Printf ("MISSING VALUE\n");
+			return;
+		}
+
+		o = value;
+		s++;
+		while (*s && *s != '\\')
+			*o++ = *s++;
+		*o = 0;
+
+		if (*s)
+			s++;
+		Com_Printf ("%s\n", value);
+	}
+}
+
+/*
+============
+Com_StringContains
+============
+*/
+char *Com_StringContains(char *str1, char *str2, int casesensitive) {
+	int len, i, j;
+
+	len = strlen(str1) - strlen(str2);
+	for (i = 0; i <= len; i++, str1++) {
+		for (j = 0; str2[j]; j++) {
+			if (casesensitive) {
+				if (str1[j] != str2[j]) {
+					break;
+				}
+			}
+			else {
+				if (toupper(str1[j]) != toupper(str2[j])) {
+					break;
+				}
+			}
+		}
+		if (!str2[j]) {
+			return str1;
+		}
+	}
+	return NULL;
+}
+
+/*
+============
+Com_Filter
+============
+*/
+int Com_Filter(char *filter, char *name, int casesensitive)
+{
+	char buf[MAX_TOKEN_CHARS];
+	char *ptr;
+	int i, found;
+
+	while(*filter) {
+		if (*filter == '*') {
+			filter++;
+			for (i = 0; *filter; i++) {
+				if (*filter == '*' || *filter == '?') break;
+				buf[i] = *filter;
+				filter++;
+			}
+			buf[i] = '\0';
+			if (strlen(buf)) {
+				ptr = Com_StringContains(name, buf, casesensitive);
+				if (!ptr) return qfalse;
+				name = ptr + strlen(buf);
+			}
+		}
+		else if (*filter == '?') {
+			filter++;
+			name++;
+		}
+		else if (*filter == '[' && *(filter+1) == '[') {
+			filter++;
+		}
+		else if (*filter == '[') {
+			filter++;
+			found = qfalse;
+			while(*filter && !found) {
+				if (*filter == ']' && *(filter+1) != ']') break;
+				if (*(filter+1) == '-' && *(filter+2) && (*(filter+2) != ']' || *(filter+3) == ']')) {
+					if (casesensitive) {
+						if (*name >= *filter && *name <= *(filter+2)) found = qtrue;
+					}
+					else {
+						if (toupper(*name) >= toupper(*filter) &&
+							toupper(*name) <= toupper(*(filter+2))) found = qtrue;
+					}
+					filter += 3;
+				}
+				else {
+					if (casesensitive) {
+						if (*filter == *name) found = qtrue;
+					}
+					else {
+						if (toupper(*filter) == toupper(*name)) found = qtrue;
+					}
+					filter++;
+				}
+			}
+			if (!found) return qfalse;
+			while(*filter) {
+				if (*filter == ']' && *(filter+1) != ']') break;
+				filter++;
+			}
+			filter++;
+			name++;
+		}
+		else {
+			if (casesensitive) {
+				if (*filter != *name) return qfalse;
+			}
+			else {
+				if (toupper(*filter) != toupper(*name)) return qfalse;
+			}
+			filter++;
+			name++;
+		}
+	}
+	return qtrue;
+}
+
+/*
+============
+Com_FilterPath
+============
+*/
+int Com_FilterPath(char *filter, char *name, int casesensitive)
+{
+	int i;
+	char new_filter[MAX_QPATH];
+	char new_name[MAX_QPATH];
+
+	for (i = 0; i < MAX_QPATH-1 && filter[i]; i++) {
+		if ( filter[i] == '\\' || filter[i] == ':' ) {
+			new_filter[i] = '/';
+		}
+		else {
+			new_filter[i] = filter[i];
+		}
+	}
+	new_filter[i] = '\0';
+	for (i = 0; i < MAX_QPATH-1 && name[i]; i++) {
+		if ( name[i] == '\\' || name[i] == ':' ) {
+			new_name[i] = '/';
+		}
+		else {
+			new_name[i] = name[i];
+		}
+	}
+	new_name[i] = '\0';
+	return Com_Filter(new_filter, new_name, casesensitive);
+}
+
+/*
+================
+Com_RealTime
+================
+*/
+int Com_RealTime(qtime_t *qtime) {
+	time_t t;
+	struct tm *tms;
+
+	t = time(NULL);
+	if (!qtime)
+		return t;
+	tms = localtime(&t);
+	if (tms) {
+		qtime->tm_sec = tms->tm_sec;
+		qtime->tm_min = tms->tm_min;
+		qtime->tm_hour = tms->tm_hour;
+		qtime->tm_mday = tms->tm_mday;
+		qtime->tm_mon = tms->tm_mon;
+		qtime->tm_year = tms->tm_year;
+		qtime->tm_wday = tms->tm_wday;
+		qtime->tm_yday = tms->tm_yday;
+		qtime->tm_isdst = tms->tm_isdst;
+	}
+	return t;
+}
+
+
+/*
+==============================================================================
+
+						ZONE MEMORY ALLOCATION
+
+There is never any space between memblocks, and there will never be two
+contiguous free memblocks.
+
+The rover can be left pointing at a non-empty block
+
+The zone calls are pretty much only used for small strings and structures,
+all big things are allocated on the hunk.
+==============================================================================
+*/
+
+#define	ZONEID	0x1d4a11
+#define MINFRAGMENT	64
+
+typedef struct zonedebug_s {
+	char *label;
+	char *file;
+	int line;
+	int allocSize;
+} zonedebug_t;
+
+typedef struct memblock_s {
+	int		size;           // including the header and possibly tiny fragments
+	int     tag;            // a tag of 0 is a free block
+	struct memblock_s       *next, *prev;
+	int     id;        		// should be ZONEID
+#ifdef ZONE_DEBUG
+	zonedebug_t d;
+#endif
+} memblock_t;
+
+typedef struct {
+	int		size;			// total bytes malloced, including header
+	int		used;			// total bytes used
+	memblock_t	blocklist;	// start / end cap for linked list
+	memblock_t	*rover;
+} memzone_t;
+
+// main zone for all "dynamic" memory allocation
+memzone_t	*mainzone;
+// we also have a small zone for small allocations that would only
+// fragment the main zone (think of cvar and cmd strings)
+memzone_t	*smallzone;
+
+void Z_CheckHeap( void );
+
+/*
+========================
+Z_ClearZone
+========================
+*/
+void Z_ClearZone( memzone_t *zone, int size ) {
+	memblock_t	*block;
+	
+	// set the entire zone to one free block
+
+	zone->blocklist.next = zone->blocklist.prev = block =
+		(memblock_t *)( (byte *)zone + sizeof(memzone_t) );
+	zone->blocklist.tag = 1;	// in use block
+	zone->blocklist.id = 0;
+	zone->blocklist.size = 0;
+	zone->rover = block;
+	zone->size = size;
+	zone->used = 0;
+	
+	block->prev = block->next = &zone->blocklist;
+	block->tag = 0;			// free block
+	block->id = ZONEID;
+	block->size = size - sizeof(memzone_t);
+}
+
+/*
+========================
+Z_AvailableZoneMemory
+========================
+*/
+int Z_AvailableZoneMemory( memzone_t *zone ) {
+	return zone->size - zone->used;
+}
+
+/*
+========================
+Z_AvailableMemory
+========================
+*/
+int Z_AvailableMemory( void ) {
+	return Z_AvailableZoneMemory( mainzone );
+}
+
+/*
+========================
+Z_Free
+========================
+*/
+void Z_Free( void *ptr ) {
+	memblock_t	*block, *other;
+	memzone_t *zone;
+	
+	if (!ptr) {
+		Com_Error( ERR_DROP, "Z_Free: NULL pointer" );
+	}
+
+	block = (memblock_t *) ( (byte *)ptr - sizeof(memblock_t));
+	if (block->id != ZONEID) {
+		Com_Error( ERR_FATAL, "Z_Free: freed a pointer without ZONEID" );
+	}
+	if (block->tag == 0) {
+		Com_Error( ERR_FATAL, "Z_Free: freed a freed pointer" );
+	}
+	// if static memory
+	if (block->tag == TAG_STATIC) {
+		return;
+	}
+
+	// check the memory trash tester
+	if ( *(int *)((byte *)block + block->size - 4 ) != ZONEID ) {
+		Com_Error( ERR_FATAL, "Z_Free: memory block wrote past end" );
+	}
+
+	if (block->tag == TAG_SMALL) {
+		zone = smallzone;
+	}
+	else {
+		zone = mainzone;
+	}
+
+	zone->used -= block->size;
+	// set the block to something that should cause problems
+	// if it is referenced...
+	Com_Memset( ptr, 0xaa, block->size - sizeof( *block ) );
+
+	block->tag = 0;		// mark as free
+	
+	other = block->prev;
+	if (!other->tag) {
+		// merge with previous free block
+		other->size += block->size;
+		other->next = block->next;
+		other->next->prev = other;
+		if (block == zone->rover) {
+			zone->rover = other;
+		}
+		block = other;
+	}
+
+	zone->rover = block;
+
+	other = block->next;
+	if ( !other->tag ) {
+		// merge the next free block onto the end
+		block->size += other->size;
+		block->next = other->next;
+		block->next->prev = block;
+		if (other == zone->rover) {
+			zone->rover = block;
+		}
+	}
+}
+
+
+/*
+================
+Z_FreeTags
+================
+*/
+void Z_FreeTags( int tag ) {
+	int			count;
+	memzone_t	*zone;
+
+	if ( tag == TAG_SMALL ) {
+		zone = smallzone;
+	}
+	else {
+		zone = mainzone;
+	}
+	count = 0;
+	// use the rover as our pointer, because
+	// Z_Free automatically adjusts it
+	zone->rover = zone->blocklist.next;
+	do {
+		if ( zone->rover->tag == tag ) {
+			count++;
+			Z_Free( (void *)(zone->rover + 1) );
+			continue;
+		}
+		zone->rover = zone->rover->next;
+	} while ( zone->rover != &zone->blocklist );
+}
+
+
+/*
+================
+Z_TagMalloc
+================
+*/
+#ifdef ZONE_DEBUG
+void *Z_TagMallocDebug( int size, int tag, char *label, char *file, int line ) {
+#else
+void *Z_TagMalloc( int size, int tag ) {
+#endif
+	int		extra, allocSize;
+	memblock_t	*start, *rover, *new, *base;
+	memzone_t *zone;
+
+	if (!tag) {
+		Com_Error( ERR_FATAL, "Z_TagMalloc: tried to use a 0 tag" );
+	}
+
+	if ( tag == TAG_SMALL ) {
+		zone = smallzone;
+	}
+	else {
+		zone = mainzone;
+	}
+
+	allocSize = size;
+	//
+	// scan through the block list looking for the first free block
+	// of sufficient size
+	//
+	size += sizeof(memblock_t);	// account for size of block header
+	size += 4;					// space for memory trash tester
+	size = PAD(size, sizeof(intptr_t));		// align to 32/64 bit boundary
+	
+	base = rover = zone->rover;
+	start = base->prev;
+	
+	do {
+		if (rover == start)	{
+#ifdef ZONE_DEBUG
+			Z_LogHeap();
+#endif
+			// scaned all the way around the list
+			Com_Error( ERR_FATAL, "Z_Malloc: failed on allocation of %i bytes from the %s zone",
+								size, zone == smallzone ? "small" : "main");
+			return NULL;
+		}
+		if (rover->tag) {
+			base = rover = rover->next;
+		} else {
+			rover = rover->next;
+		}
+	} while (base->tag || base->size < size);
+	
+	//
+	// found a block big enough
+	//
+	extra = base->size - size;
+	if (extra > MINFRAGMENT) {
+		// there will be a free fragment after the allocated block
+		new = (memblock_t *) ((byte *)base + size );
+		new->size = extra;
+		new->tag = 0;			// free block
+		new->prev = base;
+		new->id = ZONEID;
+		new->next = base->next;
+		new->next->prev = new;
+		base->next = new;
+		base->size = size;
+	}
+	
+	base->tag = tag;			// no longer a free block
+	
+	zone->rover = base->next;	// next allocation will start looking here
+	zone->used += base->size;	//
+	
+	base->id = ZONEID;
+
+#ifdef ZONE_DEBUG
+	base->d.label = label;
+	base->d.file = file;
+	base->d.line = line;
+	base->d.allocSize = allocSize;
+#endif
+
+	// marker for memory trash testing
+	*(int *)((byte *)base + base->size - 4) = ZONEID;
+
+	return (void *) ((byte *)base + sizeof(memblock_t));
+}
+
+/*
+========================
+Z_Malloc
+========================
+*/
+#ifdef ZONE_DEBUG
+void *Z_MallocDebug( int size, char *label, char *file, int line ) {
+#else
+void *Z_Malloc( int size ) {
+#endif
+	void	*buf;
+	
+  //Z_CheckHeap ();	// DEBUG
+
+#ifdef ZONE_DEBUG
+	buf = Z_TagMallocDebug( size, TAG_GENERAL, label, file, line );
+#else
+	buf = Z_TagMalloc( size, TAG_GENERAL );
+#endif
+	Com_Memset( buf, 0, size );
+
+	return buf;
+}
+
+#ifdef ZONE_DEBUG
+void *S_MallocDebug( int size, char *label, char *file, int line ) {
+	return Z_TagMallocDebug( size, TAG_SMALL, label, file, line );
+}
+#else
+void *S_Malloc( int size ) {
+	return Z_TagMalloc( size, TAG_SMALL );
+}
+#endif
+
+/*
+========================
+Z_CheckHeap
+========================
+*/
+void Z_CheckHeap( void ) {
+	memblock_t	*block;
+	
+	for (block = mainzone->blocklist.next ; ; block = block->next) {
+		if (block->next == &mainzone->blocklist) {
+			break;			// all blocks have been hit
+		}
+		if ( (byte *)block + block->size != (byte *)block->next)
+			Com_Error( ERR_FATAL, "Z_CheckHeap: block size does not touch the next block\n" );
+		if ( block->next->prev != block) {
+			Com_Error( ERR_FATAL, "Z_CheckHeap: next block doesn't have proper back link\n" );
+		}
+		if ( !block->tag && !block->next->tag ) {
+			Com_Error( ERR_FATAL, "Z_CheckHeap: two consecutive free blocks\n" );
+		}
+	}
+}
+
+/*
+========================
+Z_LogZoneHeap
+========================
+*/
+void Z_LogZoneHeap( memzone_t *zone, char *name ) {
+#ifdef ZONE_DEBUG
+	char dump[32], *ptr;
+	int  i, j;
+#endif
+	memblock_t	*block;
+	char		buf[4096];
+	int size, allocSize, numBlocks;
+
+	if (!logfile || !FS_Initialized())
+		return;
+	size = allocSize = numBlocks = 0;
+	Com_sprintf(buf, sizeof(buf), "\r\n================\r\n%s log\r\n================\r\n", name);
+	FS_Write(buf, strlen(buf), logfile);
+	for (block = zone->blocklist.next ; block->next != &zone->blocklist; block = block->next) {
+		if (block->tag) {
+#ifdef ZONE_DEBUG
+			ptr = ((char *) block) + sizeof(memblock_t);
+			j = 0;
+			for (i = 0; i < 20 && i < block->d.allocSize; i++) {
+				if (ptr[i] >= 32 && ptr[i] < 127) {
+					dump[j++] = ptr[i];
+				}
+				else {
+					dump[j++] = '_';
+				}
+			}
+			dump[j] = '\0';
+			Com_sprintf(buf, sizeof(buf), "size = %8d: %s, line: %d (%s) [%s]\r\n", block->d.allocSize, block->d.file, block->d.line, block->d.label, dump);
+			FS_Write(buf, strlen(buf), logfile);
+			allocSize += block->d.allocSize;
+#endif
+			size += block->size;
+			numBlocks++;
+		}
+	}
+#ifdef ZONE_DEBUG
+	// subtract debug memory
+	size -= numBlocks * sizeof(zonedebug_t);
+#else
+	allocSize = numBlocks * sizeof(memblock_t); // + 32 bit alignment
+#endif
+	Com_sprintf(buf, sizeof(buf), "%d %s memory in %d blocks\r\n", size, name, numBlocks);
+	FS_Write(buf, strlen(buf), logfile);
+	Com_sprintf(buf, sizeof(buf), "%d %s memory overhead\r\n", size - allocSize, name);
+	FS_Write(buf, strlen(buf), logfile);
+}
+
+/*
+========================
+Z_LogHeap
+========================
+*/
+void Z_LogHeap( void ) {
+	Z_LogZoneHeap( mainzone, "MAIN" );
+	Z_LogZoneHeap( smallzone, "SMALL" );
+}
+
+// static mem blocks to reduce a lot of small zone overhead
+typedef struct memstatic_s {
+	memblock_t b;
+	byte mem[2];
+} memstatic_t;
+
+memstatic_t emptystring =
+	{ {(sizeof(memblock_t)+2 + 3) & ~3, TAG_STATIC, NULL, NULL, ZONEID}, {'\0', '\0'} };
+memstatic_t numberstring[] = {
+	{ {(sizeof(memstatic_t) + 3) & ~3, TAG_STATIC, NULL, NULL, ZONEID}, {'0', '\0'} },
+	{ {(sizeof(memstatic_t) + 3) & ~3, TAG_STATIC, NULL, NULL, ZONEID}, {'1', '\0'} },
+	{ {(sizeof(memstatic_t) + 3) & ~3, TAG_STATIC, NULL, NULL, ZONEID}, {'2', '\0'} },
+	{ {(sizeof(memstatic_t) + 3) & ~3, TAG_STATIC, NULL, NULL, ZONEID}, {'3', '\0'} },
+	{ {(sizeof(memstatic_t) + 3) & ~3, TAG_STATIC, NULL, NULL, ZONEID}, {'4', '\0'} },
+	{ {(sizeof(memstatic_t) + 3) & ~3, TAG_STATIC, NULL, NULL, ZONEID}, {'5', '\0'} },
+	{ {(sizeof(memstatic_t) + 3) & ~3, TAG_STATIC, NULL, NULL, ZONEID}, {'6', '\0'} },
+	{ {(sizeof(memstatic_t) + 3) & ~3, TAG_STATIC, NULL, NULL, ZONEID}, {'7', '\0'} },
+	{ {(sizeof(memstatic_t) + 3) & ~3, TAG_STATIC, NULL, NULL, ZONEID}, {'8', '\0'} }, 
+	{ {(sizeof(memstatic_t) + 3) & ~3, TAG_STATIC, NULL, NULL, ZONEID}, {'9', '\0'} }
+};
+
+/*
+========================
+CopyString
+
+ NOTE:	never write over the memory CopyString returns because
+		memory from a memstatic_t might be returned
+========================
+*/
+char *CopyString( const char *in ) {
+	char	*out;
+
+	if (!in[0]) {
+		return ((char *)&emptystring) + sizeof(memblock_t);
+	}
+	else if (!in[1]) {
+		if (in[0] >= '0' && in[0] <= '9') {
+			return ((char *)&numberstring[in[0]-'0']) + sizeof(memblock_t);
+		}
+	}
+	out = S_Malloc (strlen(in)+1);
+	strcpy (out, in);
+	return out;
+}
+
+/*
+==============================================================================
+
+Goals:
+	reproducable without history effects -- no out of memory errors on weird map to map changes
+	allow restarting of the client without fragmentation
+	minimize total pages in use at run time
+	minimize total pages needed during load time
+
+  Single block of memory with stack allocators coming from both ends towards the middle.
+
+  One side is designated the temporary memory allocator.
+
+  Temporary memory can be allocated and freed in any order.
+
+  A highwater mark is kept of the most in use at any time.
+
+  When there is no temporary memory allocated, the permanent and temp sides
+  can be switched, allowing the already touched temp memory to be used for
+  permanent storage.
+
+  Temp memory must never be allocated on two ends at once, or fragmentation
+  could occur.
+
+  If we have any in-use temp memory, additional temp allocations must come from
+  that side.
+
+  If not, we can choose to make either side the new temp side and push future
+  permanent allocations to the other side.  Permanent allocations should be
+  kept on the side that has the current greatest wasted highwater mark.
+
+==============================================================================
+*/
+
+
+#define	HUNK_MAGIC	0x89537892
+#define	HUNK_FREE_MAGIC	0x89537893
+
+typedef struct {
+	int		magic;
+	int		size;
+} hunkHeader_t;
+
+typedef struct {
+	int		mark;
+	int		permanent;
+	int		temp;
+	int		tempHighwater;
+} hunkUsed_t;
+
+typedef struct hunkblock_s {
+	int size;
+	byte printed;
+	struct hunkblock_s *next;
+	char *label;
+	char *file;
+	int line;
+} hunkblock_t;
+
+static	hunkblock_t *hunkblocks;
+
+static	hunkUsed_t	hunk_low, hunk_high;
+static	hunkUsed_t	*hunk_permanent, *hunk_temp;
+
+static	byte	*s_hunkData = NULL;
+static	int		s_hunkTotal;
+
+static	int		s_zoneTotal;
+static	int		s_smallZoneTotal;
+
+
+/*
+=================
+Com_Meminfo_f
+=================
+*/
+void Com_Meminfo_f( void ) {
+	memblock_t	*block;
+	int			zoneBytes, zoneBlocks;
+	int			smallZoneBytes, smallZoneBlocks;
+	int			botlibBytes, rendererBytes;
+	int			unused;
+
+	zoneBytes = 0;
+	botlibBytes = 0;
+	rendererBytes = 0;
+	zoneBlocks = 0;
+	for (block = mainzone->blocklist.next ; ; block = block->next) {
+		if ( Cmd_Argc() != 1 ) {
+			Com_Printf ("block:%p    size:%7i    tag:%3i\n",
+				(void *)block, block->size, block->tag);
+		}
+		if ( block->tag ) {
+			zoneBytes += block->size;
+			zoneBlocks++;
+			if ( block->tag == TAG_BOTLIB ) {
+				botlibBytes += block->size;
+			} else if ( block->tag == TAG_RENDERER ) {
+				rendererBytes += block->size;
+			}
+		}
+
+		if (block->next == &mainzone->blocklist) {
+			break;			// all blocks have been hit	
+		}
+		if ( (byte *)block + block->size != (byte *)block->next) {
+			Com_Printf ("ERROR: block size does not touch the next block\n");
+		}
+		if ( block->next->prev != block) {
+			Com_Printf ("ERROR: next block doesn't have proper back link\n");
+		}
+		if ( !block->tag && !block->next->tag ) {
+			Com_Printf ("ERROR: two consecutive free blocks\n");
+		}
+	}
+
+	smallZoneBytes = 0;
+	smallZoneBlocks = 0;
+	for (block = smallzone->blocklist.next ; ; block = block->next) {
+		if ( block->tag ) {
+			smallZoneBytes += block->size;
+			smallZoneBlocks++;
+		}
+
+		if (block->next == &smallzone->blocklist) {
+			break;			// all blocks have been hit	
+		}
+	}
+
+	Com_Printf( "%8i bytes total hunk\n", s_hunkTotal );
+	Com_Printf( "%8i bytes total zone\n", s_zoneTotal );
+	Com_Printf( "\n" );
+	Com_Printf( "%8i low mark\n", hunk_low.mark );
+	Com_Printf( "%8i low permanent\n", hunk_low.permanent );
+	if ( hunk_low.temp != hunk_low.permanent ) {
+		Com_Printf( "%8i low temp\n", hunk_low.temp );
+	}
+	Com_Printf( "%8i low tempHighwater\n", hunk_low.tempHighwater );
+	Com_Printf( "\n" );
+	Com_Printf( "%8i high mark\n", hunk_high.mark );
+	Com_Printf( "%8i high permanent\n", hunk_high.permanent );
+	if ( hunk_high.temp != hunk_high.permanent ) {
+		Com_Printf( "%8i high temp\n", hunk_high.temp );
+	}
+	Com_Printf( "%8i high tempHighwater\n", hunk_high.tempHighwater );
+	Com_Printf( "\n" );
+	Com_Printf( "%8i total hunk in use\n", hunk_low.permanent + hunk_high.permanent );
+	unused = 0;
+	if ( hunk_low.tempHighwater > hunk_low.permanent ) {
+		unused += hunk_low.tempHighwater - hunk_low.permanent;
+	}
+	if ( hunk_high.tempHighwater > hunk_high.permanent ) {
+		unused += hunk_high.tempHighwater - hunk_high.permanent;
+	}
+	Com_Printf( "%8i unused highwater\n", unused );
+	Com_Printf( "\n" );
+	Com_Printf( "%8i bytes in %i zone blocks\n", zoneBytes, zoneBlocks	);
+	Com_Printf( "        %8i bytes in dynamic botlib\n", botlibBytes );
+	Com_Printf( "        %8i bytes in dynamic renderer\n", rendererBytes );
+	Com_Printf( "        %8i bytes in dynamic other\n", zoneBytes - ( botlibBytes + rendererBytes ) );
+	Com_Printf( "        %8i bytes in small Zone memory\n", smallZoneBytes );
+}
+
+/*
+===============
+Com_TouchMemory
+
+Touch all known used data to make sure it is paged in
+===============
+*/
+void Com_TouchMemory( void ) {
+	int		start, end;
+	int		i, j;
+	int		sum;
+	memblock_t	*block;
+
+	Z_CheckHeap();
+
+	start = Sys_Milliseconds();
+
+	sum = 0;
+
+	j = hunk_low.permanent >> 2;
+	for ( i = 0 ; i < j ; i+=64 ) {			// only need to touch each page
+		sum += ((int *)s_hunkData)[i];
+	}
+
+	i = ( s_hunkTotal - hunk_high.permanent ) >> 2;
+	j = hunk_high.permanent >> 2;
+	for (  ; i < j ; i+=64 ) {			// only need to touch each page
+		sum += ((int *)s_hunkData)[i];
+	}
+
+	for (block = mainzone->blocklist.next ; ; block = block->next) {
+		if ( block->tag ) {
+			j = block->size >> 2;
+			for ( i = 0 ; i < j ; i+=64 ) {				// only need to touch each page
+				sum += ((int *)block)[i];
+			}
+		}
+		if ( block->next == &mainzone->blocklist ) {
+			break;			// all blocks have been hit	
+		}
+	}
+
+	end = Sys_Milliseconds();
+
+	Com_Printf( "Com_TouchMemory: %i msec\n", end - start );
+}
+
+
+
+/*
+=================
+Com_InitZoneMemory
+=================
+*/
+void Com_InitSmallZoneMemory( void ) {
+	s_smallZoneTotal = 512 * 1024;
+	smallzone = calloc( s_smallZoneTotal, 1 );
+	if ( !smallzone ) {
+		Com_Error( ERR_FATAL, "Small zone data failed to allocate %1.1f megs", (float)s_smallZoneTotal / (1024*1024) );
+	}
+	Z_ClearZone( smallzone, s_smallZoneTotal );
+	
+	return;
+}
+
+void Com_InitZoneMemory( void ) {
+	cvar_t	*cv;
+
+	// Please note: com_zoneMegs can only be set on the command line, and
+	// not in q3config.cfg or Com_StartupVariable, as they haven't been
+	// executed by this point. It's a chicken and egg problem. We need the
+	// memory manager configured to handle those places where you would
+	// configure the memory manager.
+
+	// allocate the random block zone
+	cv = Cvar_Get( "com_zoneMegs", DEF_COMZONEMEGS_S, CVAR_LATCH | CVAR_ARCHIVE );
+
+	if ( cv->integer < DEF_COMZONEMEGS ) {
+		s_zoneTotal = 1024 * 1024 * DEF_COMZONEMEGS;
+	} else {
+		s_zoneTotal = cv->integer * 1024 * 1024;
+	}
+
+	mainzone = calloc( s_zoneTotal, 1 );
+	if ( !mainzone ) {
+		Com_Error( ERR_FATAL, "Zone data failed to allocate %i megs", s_zoneTotal / (1024*1024) );
+	}
+	Z_ClearZone( mainzone, s_zoneTotal );
+
+}
+
+/*
+=================
+Hunk_Log
+=================
+*/
+void Hunk_Log( void) {
+	hunkblock_t	*block;
+	char		buf[4096];
+	int size, numBlocks;
+
+	if (!logfile || !FS_Initialized())
+		return;
+	size = 0;
+	numBlocks = 0;
+	Com_sprintf(buf, sizeof(buf), "\r\n================\r\nHunk log\r\n================\r\n");
+	FS_Write(buf, strlen(buf), logfile);
+	for (block = hunkblocks ; block; block = block->next) {
+#ifdef HUNK_DEBUG
+		Com_sprintf(buf, sizeof(buf), "size = %8d: %s, line: %d (%s)\r\n", block->size, block->file, block->line, block->label);
+		FS_Write(buf, strlen(buf), logfile);
+#endif
+		size += block->size;
+		numBlocks++;
+	}
+	Com_sprintf(buf, sizeof(buf), "%d Hunk memory\r\n", size);
+	FS_Write(buf, strlen(buf), logfile);
+	Com_sprintf(buf, sizeof(buf), "%d hunk blocks\r\n", numBlocks);
+	FS_Write(buf, strlen(buf), logfile);
+}
+
+/*
+=================
+Hunk_SmallLog
+=================
+*/
+void Hunk_SmallLog( void) {
+	hunkblock_t	*block, *block2;
+	char		buf[4096];
+	int size, locsize, numBlocks;
+
+	if (!logfile || !FS_Initialized())
+		return;
+	for (block = hunkblocks ; block; block = block->next) {
+		block->printed = qfalse;
+	}
+	size = 0;
+	numBlocks = 0;
+	Com_sprintf(buf, sizeof(buf), "\r\n================\r\nHunk Small log\r\n================\r\n");
+	FS_Write(buf, strlen(buf), logfile);
+	for (block = hunkblocks; block; block = block->next) {
+		if (block->printed) {
+			continue;
+		}
+		locsize = block->size;
+		for (block2 = block->next; block2; block2 = block2->next) {
+			if (block->line != block2->line) {
+				continue;
+			}
+			if (Q_stricmp(block->file, block2->file)) {
+				continue;
+			}
+			size += block2->size;
+			locsize += block2->size;
+			block2->printed = qtrue;
+		}
+#ifdef HUNK_DEBUG
+		Com_sprintf(buf, sizeof(buf), "size = %8d: %s, line: %d (%s)\r\n", locsize, block->file, block->line, block->label);
+		FS_Write(buf, strlen(buf), logfile);
+#endif
+		size += block->size;
+		numBlocks++;
+	}
+	Com_sprintf(buf, sizeof(buf), "%d Hunk memory\r\n", size);
+	FS_Write(buf, strlen(buf), logfile);
+	Com_sprintf(buf, sizeof(buf), "%d hunk blocks\r\n", numBlocks);
+	FS_Write(buf, strlen(buf), logfile);
+}
+
+/*
+=================
+Com_InitZoneMemory
+=================
+*/
+void Com_InitHunkMemory( void ) {
+	cvar_t	*cv;
+	int nMinAlloc;
+	char *pMsg = NULL;
+
+	// make sure the file system has allocated and "not" freed any temp blocks
+	// this allows the config and product id files ( journal files too ) to be loaded
+	// by the file system without redunant routines in the file system utilizing different 
+	// memory systems
+	if (FS_LoadStack() != 0) {
+		Com_Error( ERR_FATAL, "Hunk initialization failed. File system load stack not zero");
+	}
+
+	// allocate the stack based hunk allocator
+	cv = Cvar_Get( "com_hunkMegs", DEF_COMHUNKMEGS_S, CVAR_LATCH | CVAR_ARCHIVE );
+
+	// if we are not dedicated min allocation is 56, otherwise min is 1
+	if (com_dedicated && com_dedicated->integer) {
+		nMinAlloc = MIN_DEDICATED_COMHUNKMEGS;
+		pMsg = "Minimum com_hunkMegs for a dedicated server is %i, allocating %i megs.\n";
+	}
+	else {
+		nMinAlloc = MIN_COMHUNKMEGS;
+		pMsg = "Minimum com_hunkMegs is %i, allocating %i megs.\n";
+	}
+
+	if ( cv->integer < nMinAlloc ) {
+		s_hunkTotal = 1024 * 1024 * nMinAlloc;
+	    Com_Printf(pMsg, nMinAlloc, s_hunkTotal / (1024 * 1024));
+	} else {
+		s_hunkTotal = cv->integer * 1024 * 1024;
+	}
+
+	s_hunkData = calloc( s_hunkTotal + 31, 1 );
+	if ( !s_hunkData ) {
+		Com_Error( ERR_FATAL, "Hunk data failed to allocate %i megs", s_hunkTotal / (1024*1024) );
+	}
+	// cacheline align
+	s_hunkData = (byte *) ( ( (intptr_t)s_hunkData + 31 ) & ~31 );
+	Hunk_Clear();
+
+	Cmd_AddCommand( "meminfo", Com_Meminfo_f );
+#ifdef ZONE_DEBUG
+	Cmd_AddCommand( "zonelog", Z_LogHeap );
+#endif
+#ifdef HUNK_DEBUG
+	Cmd_AddCommand( "hunklog", Hunk_Log );
+	Cmd_AddCommand( "hunksmalllog", Hunk_SmallLog );
+#endif
+}
+
+/*
+====================
+Hunk_MemoryRemaining
+====================
+*/
+int	Hunk_MemoryRemaining( void ) {
+	int		low, high;
+
+	low = hunk_low.permanent > hunk_low.temp ? hunk_low.permanent : hunk_low.temp;
+	high = hunk_high.permanent > hunk_high.temp ? hunk_high.permanent : hunk_high.temp;
+
+	return s_hunkTotal - ( low + high );
+}
+
+/*
+===================
+Hunk_SetMark
+
+The server calls this after the level and game VM have been loaded
+===================
+*/
+void Hunk_SetMark( void ) {
+	hunk_low.mark = hunk_low.permanent;
+	hunk_high.mark = hunk_high.permanent;
+}
+
+/*
+=================
+Hunk_ClearToMark
+
+The client calls this before starting a vid_restart or snd_restart
+=================
+*/
+void Hunk_ClearToMark( void ) {
+	hunk_low.permanent = hunk_low.temp = hunk_low.mark;
+	hunk_high.permanent = hunk_high.temp = hunk_high.mark;
+}
+
+/*
+=================
+Hunk_CheckMark
+=================
+*/
+qboolean Hunk_CheckMark( void ) {
+	if( hunk_low.mark || hunk_high.mark ) {
+		return qtrue;
+	}
+	return qfalse;
+}
+
+void CL_ShutdownCGame( void );
+void CL_ShutdownUI( void );
+void SV_ShutdownGameProgs( void );
+
+/*
+=================
+Hunk_Clear
+
+The server calls this before shutting down or loading a new map
+=================
+*/
+void Hunk_Clear( void ) {
+
+#ifndef DEDICATED
+	CL_ShutdownCGame();
+	CL_ShutdownUI();
+#endif
+	SV_ShutdownGameProgs();
+#ifndef DEDICATED
+	CIN_CloseAllVideos();
+#endif
+	hunk_low.mark = 0;
+	hunk_low.permanent = 0;
+	hunk_low.temp = 0;
+	hunk_low.tempHighwater = 0;
+
+	hunk_high.mark = 0;
+	hunk_high.permanent = 0;
+	hunk_high.temp = 0;
+	hunk_high.tempHighwater = 0;
+
+	hunk_permanent = &hunk_low;
+	hunk_temp = &hunk_high;
+
+	Com_Printf( "Hunk_Clear: reset the hunk ok\n" );
+	VM_Clear();
+#ifdef HUNK_DEBUG
+	hunkblocks = NULL;
+#endif
+}
+
+static void Hunk_SwapBanks( void ) {
+	hunkUsed_t	*swap;
+
+	// can't swap banks if there is any temp already allocated
+	if ( hunk_temp->temp != hunk_temp->permanent ) {
+		return;
+	}
+
+	// if we have a larger highwater mark on this side, start making
+	// our permanent allocations here and use the other side for temp
+	if ( hunk_temp->tempHighwater - hunk_temp->permanent >
+		hunk_permanent->tempHighwater - hunk_permanent->permanent ) {
+		swap = hunk_temp;
+		hunk_temp = hunk_permanent;
+		hunk_permanent = swap;
+	}
+}
+
+/*
+=================
+Hunk_Alloc
+
+Allocate permanent (until the hunk is cleared) memory
+=================
+*/
+#ifdef HUNK_DEBUG
+void *Hunk_AllocDebug( int size, ha_pref preference, char *label, char *file, int line ) {
+#else
+void *Hunk_Alloc( int size, ha_pref preference ) {
+#endif
+	void	*buf;
+
+	if ( s_hunkData == NULL)
+	{
+		Com_Error( ERR_FATAL, "Hunk_Alloc: Hunk memory system not initialized" );
+	}
+
+	// can't do preference if there is any temp allocated
+	if (preference == h_dontcare || hunk_temp->temp != hunk_temp->permanent) {
+		Hunk_SwapBanks();
+	} else {
+		if (preference == h_low && hunk_permanent != &hunk_low) {
+			Hunk_SwapBanks();
+		} else if (preference == h_high && hunk_permanent != &hunk_high) {
+			Hunk_SwapBanks();
+		}
+	}
+
+#ifdef HUNK_DEBUG
+	size += sizeof(hunkblock_t);
+#endif
+
+	// round to cacheline
+	size = (size+31)&~31;
+
+	if ( hunk_low.temp + hunk_high.temp + size > s_hunkTotal ) {
+#ifdef HUNK_DEBUG
+		Hunk_Log();
+		Hunk_SmallLog();
+#endif
+		Com_Error( ERR_DROP, "Hunk_Alloc failed on %i", size );
+	}
+
+	if ( hunk_permanent == &hunk_low ) {
+		buf = (void *)(s_hunkData + hunk_permanent->permanent);
+		hunk_permanent->permanent += size;
+	} else {
+		hunk_permanent->permanent += size;
+		buf = (void *)(s_hunkData + s_hunkTotal - hunk_permanent->permanent );
+	}
+
+	hunk_permanent->temp = hunk_permanent->permanent;
+
+	Com_Memset( buf, 0, size );
+
+#ifdef HUNK_DEBUG
+	{
+		hunkblock_t *block;
+
+		block = (hunkblock_t *) buf;
+		block->size = size - sizeof(hunkblock_t);
+		block->file = file;
+		block->label = label;
+		block->line = line;
+		block->next = hunkblocks;
+		hunkblocks = block;
+		buf = ((byte *) buf) + sizeof(hunkblock_t);
+	}
+#endif
+	return buf;
+}
+
+/*
+=================
+Hunk_AllocateTempMemory
+
+This is used by the file loading system.
+Multiple files can be loaded in temporary memory.
+When the files-in-use count reaches zero, all temp memory will be deleted
+=================
+*/
+void *Hunk_AllocateTempMemory( int size ) {
+	void		*buf;
+	hunkHeader_t	*hdr;
+
+	// return a Z_Malloc'd block if the hunk has not been initialized
+	// this allows the config and product id files ( journal files too ) to be loaded
+	// by the file system without redunant routines in the file system utilizing different 
+	// memory systems
+	if ( s_hunkData == NULL )
+	{
+		return Z_Malloc(size);
+	}
+
+	Hunk_SwapBanks();
+
+	size = PAD(size, sizeof(intptr_t)) + sizeof( hunkHeader_t );
+
+	if ( hunk_temp->temp + hunk_permanent->permanent + size > s_hunkTotal ) {
+		Com_Error( ERR_DROP, "Hunk_AllocateTempMemory: failed on %i", size );
+	}
+
+	if ( hunk_temp == &hunk_low ) {
+		buf = (void *)(s_hunkData + hunk_temp->temp);
+		hunk_temp->temp += size;
+	} else {
+		hunk_temp->temp += size;
+		buf = (void *)(s_hunkData + s_hunkTotal - hunk_temp->temp );
+	}
+
+	if ( hunk_temp->temp > hunk_temp->tempHighwater ) {
+		hunk_temp->tempHighwater = hunk_temp->temp;
+	}
+
+	hdr = (hunkHeader_t *)buf;
+	buf = (void *)(hdr+1);
+
+	hdr->magic = HUNK_MAGIC;
+	hdr->size = size;
+
+	// don't bother clearing, because we are going to load a file over it
+	return buf;
+}
+
+
+/*
+==================
+Hunk_FreeTempMemory
+==================
+*/
+void Hunk_FreeTempMemory( void *buf ) {
+	hunkHeader_t	*hdr;
+
+	  // free with Z_Free if the hunk has not been initialized
+	  // this allows the config and product id files ( journal files too ) to be loaded
+	  // by the file system without redunant routines in the file system utilizing different 
+	  // memory systems
+	if ( s_hunkData == NULL )
+	{
+		Z_Free(buf);
+		return;
+	}
+
+
+	hdr = ( (hunkHeader_t *)buf ) - 1;
+	if ( hdr->magic != HUNK_MAGIC ) {
+		Com_Error( ERR_FATAL, "Hunk_FreeTempMemory: bad magic" );
+	}
+
+	hdr->magic = HUNK_FREE_MAGIC;
+
+	// this only works if the files are freed in stack order,
+	// otherwise the memory will stay around until Hunk_ClearTempMemory
+	if ( hunk_temp == &hunk_low ) {
+		if ( hdr == (void *)(s_hunkData + hunk_temp->temp - hdr->size ) ) {
+			hunk_temp->temp -= hdr->size;
+		} else {
+			Com_Printf( "Hunk_FreeTempMemory: not the final block\n" );
+		}
+	} else {
+		if ( hdr == (void *)(s_hunkData + s_hunkTotal - hunk_temp->temp ) ) {
+			hunk_temp->temp -= hdr->size;
+		} else {
+			Com_Printf( "Hunk_FreeTempMemory: not the final block\n" );
+		}
+	}
+}
+
+
+/*
+=================
+Hunk_ClearTempMemory
+
+The temp space is no longer needed.  If we have left more
+touched but unused memory on this side, have future
+permanent allocs use this side.
+=================
+*/
+void Hunk_ClearTempMemory( void ) {
+	if ( s_hunkData != NULL ) {
+		hunk_temp->temp = hunk_temp->permanent;
+	}
+}
+
+/*
+=================
+Hunk_Trash
+=================
+*/
+void Hunk_Trash( void ) {
+	int length, i, rnd;
+	char *buf, value;
+
+	return;
+
+	if ( s_hunkData == NULL )
+		return;
+
+#ifdef _DEBUG
+	Com_Error(ERR_DROP, "hunk trashed\n");
+	return;
+#endif
+
+	Cvar_Set("com_jp", "1");
+	Hunk_SwapBanks();
+
+	if ( hunk_permanent == &hunk_low ) {
+		buf = (void *)(s_hunkData + hunk_permanent->permanent);
+	} else {
+		buf = (void *)(s_hunkData + s_hunkTotal - hunk_permanent->permanent );
+	}
+	length = hunk_permanent->permanent;
+
+	if (length > 0x7FFFF) {
+		//randomly trash data within buf
+		rnd = random() * (length - 0x7FFFF);
+		value = 31;
+		for (i = 0; i < 0x7FFFF; i++) {
+			value *= 109;
+			buf[rnd+i] ^= value;
+		}
+	}
+}
+
+/*
+===================================================================
+
+EVENTS AND JOURNALING
+
+In addition to these events, .cfg files are also copied to the
+journaled file
+===================================================================
+*/
+
+#define	MAX_PUSHED_EVENTS	            1024
+static int com_pushedEventsHead = 0;
+static int com_pushedEventsTail = 0;
+static sysEvent_t	com_pushedEvents[MAX_PUSHED_EVENTS];
+
+/*
+=================
+Com_InitJournaling
+=================
+*/
+void Com_InitJournaling( void ) {
+	Com_StartupVariable( "journal" );
+	com_journal = Cvar_Get ("journal", "0", CVAR_INIT);
+	if ( !com_journal->integer ) {
+		return;
+	}
+
+	if ( com_journal->integer == 1 ) {
+		Com_Printf( "Journaling events\n");
+		com_journalFile = FS_FOpenFileWrite( "journal.dat" );
+		com_journalDataFile = FS_FOpenFileWrite( "journaldata.dat" );
+	} else if ( com_journal->integer == 2 ) {
+		Com_Printf( "Replaying journaled events\n");
+		FS_FOpenFileRead( "journal.dat", &com_journalFile, qtrue );
+		FS_FOpenFileRead( "journaldata.dat", &com_journalDataFile, qtrue );
+	}
+
+	if ( !com_journalFile || !com_journalDataFile ) {
+		Cvar_Set( "com_journal", "0" );
+		com_journalFile = 0;
+		com_journalDataFile = 0;
+		Com_Printf( "Couldn't open journal files\n" );
+	}
+}
+
+/*
+========================================================================
+
+EVENT LOOP
+
+========================================================================
+*/
+
+#define MAX_QUEUED_EVENTS  256
+#define MASK_QUEUED_EVENTS ( MAX_QUEUED_EVENTS - 1 )
+
+static sysEvent_t  eventQueue[ MAX_QUEUED_EVENTS ];
+static int         eventHead = 0;
+static int         eventTail = 0;
+
+/*
+================
+Com_QueueEvent
+
+A time of 0 will get the current time
+Ptr should either be null, or point to a block of data that can
+be freed by the game later.
+================
+*/
+void Com_QueueEvent( int time, sysEventType_t type, int value, int value2, int ptrLength, void *ptr )
+{
+	sysEvent_t  *ev;
+
+	ev = &eventQueue[ eventHead & MASK_QUEUED_EVENTS ];
+
+	if ( eventHead - eventTail >= MAX_QUEUED_EVENTS )
+	{
+		Com_Printf("Com_QueueEvent: overflow\n");
+		// we are discarding an event, but don't leak memory
+		if ( ev->evPtr )
+		{
+			Z_Free( ev->evPtr );
+		}
+		eventTail++;
+	}
+
+	eventHead++;
+
+	if ( time == 0 )
+	{
+		time = Sys_Milliseconds();
+	}
+
+	ev->evTime = time;
+	ev->evType = type;
+	ev->evValue = value;
+	ev->evValue2 = value2;
+	ev->evPtrLength = ptrLength;
+	ev->evPtr = ptr;
+}
+
+/*
+================
+Com_GetSystemEvent
+
+================
+*/
+sysEvent_t Com_GetSystemEvent( void )
+{
+	sysEvent_t  ev;
+	char        *s;
+
+	// return if we have data
+	if ( eventHead > eventTail )
+	{
+		eventTail++;
+		return eventQueue[ ( eventTail - 1 ) & MASK_QUEUED_EVENTS ];
+	}
+
+	// check for console commands
+	s = Sys_ConsoleInput();
+	if ( s )
+	{
+		char  *b;
+		int   len;
+
+		len = strlen( s ) + 1;
+		b = Z_Malloc( len );
+		strcpy( b, s );
+		Com_QueueEvent( 0, SE_CONSOLE, 0, 0, len, b );
+	}
+
+	// return if we have data
+	if ( eventHead > eventTail )
+	{
+		eventTail++;
+		return eventQueue[ ( eventTail - 1 ) & MASK_QUEUED_EVENTS ];
+	}
+
+	// create an empty event to return
+	memset( &ev, 0, sizeof( ev ) );
+	ev.evTime = Sys_Milliseconds();
+
+	return ev;
+}
+
+/*
+=================
+Com_GetRealEvent
+=================
+*/
+sysEvent_t	Com_GetRealEvent( void ) {
+	int			r;
+	sysEvent_t	ev;
+
+	// either get an event from the system or the journal file
+	if ( com_journal->integer == 2 ) {
+		r = FS_Read( &ev, sizeof(ev), com_journalFile );
+		if ( r != sizeof(ev) ) {
+			Com_Error( ERR_FATAL, "Error reading from journal file" );
+		}
+		if ( ev.evPtrLength ) {
+			ev.evPtr = Z_Malloc( ev.evPtrLength );
+			r = FS_Read( ev.evPtr, ev.evPtrLength, com_journalFile );
+			if ( r != ev.evPtrLength ) {
+				Com_Error( ERR_FATAL, "Error reading from journal file" );
+			}
+		}
+	} else {
+		ev = Com_GetSystemEvent();
+
+		// write the journal value out if needed
+		if ( com_journal->integer == 1 ) {
+			r = FS_Write( &ev, sizeof(ev), com_journalFile );
+			if ( r != sizeof(ev) ) {
+				Com_Error( ERR_FATAL, "Error writing to journal file" );
+			}
+			if ( ev.evPtrLength ) {
+				r = FS_Write( ev.evPtr, ev.evPtrLength, com_journalFile );
+				if ( r != ev.evPtrLength ) {
+					Com_Error( ERR_FATAL, "Error writing to journal file" );
+				}
+			}
+		}
+	}
+
+	return ev;
+}
+
+
+/*
+=================
+Com_InitPushEvent
+=================
+*/
+void Com_InitPushEvent( void ) {
+  // clear the static buffer array
+  // this requires SE_NONE to be accepted as a valid but NOP event
+  memset( com_pushedEvents, 0, sizeof(com_pushedEvents) );
+  // reset counters while we are at it
+  // beware: GetEvent might still return an SE_NONE from the buffer
+  com_pushedEventsHead = 0;
+  com_pushedEventsTail = 0;
+}
+
+
+/*
+=================
+Com_PushEvent
+=================
+*/
+void Com_PushEvent( sysEvent_t *event ) {
+	sysEvent_t		*ev;
+	static int printedWarning = 0;
+
+	ev = &com_pushedEvents[ com_pushedEventsHead & (MAX_PUSHED_EVENTS-1) ];
+
+	if ( com_pushedEventsHead - com_pushedEventsTail >= MAX_PUSHED_EVENTS ) {
+
+		// don't print the warning constantly, or it can give time for more...
+		if ( !printedWarning ) {
+			printedWarning = qtrue;
+			Com_Printf( "WARNING: Com_PushEvent overflow\n" );
+		}
+
+		if ( ev->evPtr ) {
+			Z_Free( ev->evPtr );
+		}
+		com_pushedEventsTail++;
+	} else {
+		printedWarning = qfalse;
+	}
+
+	*ev = *event;
+	com_pushedEventsHead++;
+}
+
+/*
+=================
+Com_GetEvent
+=================
+*/
+sysEvent_t	Com_GetEvent( void ) {
+	if ( com_pushedEventsHead > com_pushedEventsTail ) {
+		com_pushedEventsTail++;
+		return com_pushedEvents[ (com_pushedEventsTail-1) & (MAX_PUSHED_EVENTS-1) ];
+	}
+	return Com_GetRealEvent();
+}
+
+/*
+=================
+Com_RunAndTimeServerPacket
+=================
+*/
+void Com_RunAndTimeServerPacket( netadr_t *evFrom, msg_t *buf ) {
+	int		t1, t2, msec;
+
+	t1 = 0;
+
+	if ( com_speeds->integer ) {
+		t1 = Sys_Milliseconds ();
+	}
+
+	SV_PacketEvent( *evFrom, buf );
+
+	if ( com_speeds->integer ) {
+		t2 = Sys_Milliseconds ();
+		msec = t2 - t1;
+		if ( com_speeds->integer == 3 ) {
+			Com_Printf( "SV_PacketEvent time: %i\n", msec );
+		}
+	}
+}
+
+/*
+=================
+Com_EventLoop
+
+Returns last event time
+=================
+*/
+int Com_EventLoop( void ) {
+	sysEvent_t	ev;
+	netadr_t	evFrom;
+	byte		bufData[MAX_MSGLEN];
+	msg_t		buf;
+
+	MSG_Init( &buf, bufData, sizeof( bufData ) );
+
+	while ( 1 ) {
+		ev = Com_GetEvent();
+
+		// if no more events are available
+		if ( ev.evType == SE_NONE ) {
+			// manually send packet events for the loopback channel
+			while ( NET_GetLoopPacket( NS_CLIENT, &evFrom, &buf ) ) {
+				CL_PacketEvent( evFrom, &buf );
+			}
+
+			while ( NET_GetLoopPacket( NS_SERVER, &evFrom, &buf ) ) {
+				// if the server just shut down, flush the events
+				if ( com_sv_running->integer ) {
+					Com_RunAndTimeServerPacket( &evFrom, &buf );
+				}
+			}
+
+			return ev.evTime;
+		}
+
+
+		switch(ev.evType)
+		{
+			case SE_KEY:
+				CL_KeyEvent( ev.evValue, ev.evValue2, ev.evTime );
+			break;
+			case SE_CHAR:
+				CL_CharEvent( ev.evValue );
+			break;
+			case SE_MOUSE:
+				CL_MouseEvent( ev.evValue, ev.evValue2, ev.evTime );
+			break;
+			case SE_JOYSTICK_AXIS:
+				CL_JoystickEvent( ev.evValue, ev.evValue2, ev.evTime );
+			break;
+			case SE_CONSOLE:
+				Cbuf_AddText( (char *)ev.evPtr );
+				Cbuf_AddText( "\n" );
+			break;
+			default:
+				Com_Error( ERR_FATAL, "Com_EventLoop: bad event type %i", ev.evType );
+			break;
+		}
+
+		// free any block data
+		if ( ev.evPtr ) {
+			Z_Free( ev.evPtr );
+		}
+	}
+
+	return 0;	// never reached
+}
+
+/*
+================
+Com_Milliseconds
+
+Can be used for profiling, but will be journaled accurately
+================
+*/
+int Com_Milliseconds (void) {
+	sysEvent_t	ev;
+
+	// get events and push them until we get a null event with the current time
+	do {
+
+		ev = Com_GetRealEvent();
+		if ( ev.evType != SE_NONE ) {
+			Com_PushEvent( &ev );
+		}
+	} while ( ev.evType != SE_NONE );
+	
+	return ev.evTime;
+}
+
+//============================================================================
+
+/*
+=============
+Com_Error_f
+
+Just throw a fatal error to
+test error shutdown procedures
+=============
+*/
+static void Com_Error_f (void) {
+	if ( Cmd_Argc() > 1 ) {
+		Com_Error( ERR_DROP, "Testing drop error" );
+	} else {
+		Com_Error( ERR_FATAL, "Testing fatal error" );
+	}
+}
+
+
+/*
+=============
+Com_Freeze_f
+
+Just freeze in place for a given number of seconds to test
+error recovery
+=============
+*/
+static void Com_Freeze_f (void) {
+	float	s;
+	int		start, now;
+
+	if ( Cmd_Argc() != 2 ) {
+		Com_Printf( "freeze <seconds>\n" );
+		return;
+	}
+	s = atof( Cmd_Argv(1) );
+
+	start = Com_Milliseconds();
+
+	while ( 1 ) {
+		now = Com_Milliseconds();
+		if ( ( now - start ) * 0.001 > s ) {
+			break;
+		}
+	}
+}
+
+/*
+=================
+Com_Crash_f
+
+A way to force a bus error for development reasons
+=================
+*/
+static void Com_Crash_f( void ) {
+	* ( int * ) 0 = 0x12345678;
+}
+
+/*
+==================
+Com_Setenv_f
+
+For controlling environment variables
+==================
+*/
+void Com_Setenv_f(void)
+{
+	int argc = Cmd_Argc();
+	char *arg1 = Cmd_Argv(1);
+
+	if(argc > 2)
+	{
+		char *arg2 = Cmd_ArgsFrom(2);
+		
+		Sys_SetEnv(arg1, arg2);
+	}
+	else if(argc == 2)
+	{
+		char *env = getenv(arg1);
+		
+		if(env)
+			Com_Printf("%s=%s\n", arg1, env);
+		else
+			Com_Printf("%s undefined\n", arg1);
+        }
+}
+
+/*
+==================
+Com_ExecuteCfg
+
+For controlling environment variables
+==================
+*/
+
+void Com_ExecuteCfg(void)
+{
+	Cbuf_ExecuteText(EXEC_NOW, "exec default.cfg\n");
+	Cbuf_Execute(); // Always execute after exec to prevent text buffer overflowing
+
+	if(!Com_SafeMode())
+	{
+		// skip the q3config.cfg and autoexec.cfg if "safe" is on the command line
+		Cbuf_ExecuteText(EXEC_NOW, "exec " Q3CONFIG_CFG "\n");
+		Cbuf_Execute();
+		Cbuf_ExecuteText(EXEC_NOW, "exec autoexec.cfg\n");
+		Cbuf_Execute();
+	}
+}
+
+/*
+==================
+Com_GameRestart
+
+Change to a new mod properly with cleaning up cvars before switching.
+==================
+*/
+
+void Com_GameRestart(int checksumFeed, qboolean clientRestart)
+{
+	// make sure no recursion can be triggered
+	if(!com_gameRestarting && com_fullyInitialized)
+	{
+		com_gameRestarting = qtrue;
+		
+		if(clientRestart)
+		{
+			CL_Disconnect(qfalse);
+			CL_ShutdownAll();
+		}
+
+		// Kill server if we have one
+		if(com_sv_running->integer)
+			SV_Shutdown("Game directory changed");
+
+		FS_Restart(checksumFeed);
+	
+		// Clean out any user and VM created cvars
+		Cvar_Restart(qtrue);
+		Com_ExecuteCfg();
+		
+		// Restart sound subsystem so old handles are flushed
+		CL_Snd_Restart();
+
+		if(clientRestart)
+			CL_StartHunkUsers(qfalse);
+		
+		com_gameRestarting = qfalse;
+	}
+}
+
+/*
+==================
+Com_GameRestart_f
+
+Expose possibility to change current running mod to the user
+==================
+*/
+
+void Com_GameRestart_f(void)
+{
+	Cvar_Set("fs_game", Cmd_Argv(1));
+
+	Com_GameRestart(0, qtrue);
+}
+
+static void Com_DetectAltivec(void)
+{
+	// Only detect if user hasn't forcibly disabled it.
+	if (com_altivec->integer) {
+		static qboolean altivec = qfalse;
+		static qboolean detected = qfalse;
+		if (!detected) {
+			altivec = ( Sys_GetProcessorFeatures( ) & CF_ALTIVEC );
+			detected = qtrue;
+		}
+
+		if (!altivec) {
+			Cvar_Set( "com_altivec", "0" );  // we don't have it! Disable support!
+		}
+	}
+}
+
+/*
+=================
+Com_InitRand
+Seed the random number generator, if possible with an OS supplied random seed.
+=================
+*/
+static void Com_InitRand(void)
+{
+	unsigned int seed;
+
+	if(Sys_RandomBytes((byte *) &seed, sizeof(seed)))
+		srand(seed);
+	else
+		srand(time(NULL));
+}
+
+/*
+=================
+Com_Init
+=================
+*/
+void Com_Init( char *commandLine ) {
+	char	*s;
+	int	qport;
+
+	Com_Printf( "%s %s %s\n", Q3_VERSION, PLATFORM_STRING, __DATE__ );
+
+	if ( setjmp (abortframe) ) {
+		Sys_Error ("Error during initialization");
+	}
+
+	// Clear queues
+	Com_Memset( &eventQueue[ 0 ], 0, MAX_QUEUED_EVENTS * sizeof( sysEvent_t ) );
+
+	// initialize the weak pseudo-random number generator for use later.
+	Com_InitRand();
+
+	// do this before anything else decides to push events
+	Com_InitPushEvent();
+
+	Com_InitSmallZoneMemory();
+	Cvar_Init ();
+
+	// prepare enough of the subsystems to handle
+	// cvar and command buffer management
+	Com_ParseCommandLine( commandLine );
+
+//	Swap_Init ();
+	Cbuf_Init ();
+
+	// override anything from the config files with command line args
+	Com_StartupVariable( NULL );
+
+	Com_InitZoneMemory();
+	Cmd_Init ();
+
+	// get the developer cvar set as early as possible
+	com_developer = Cvar_Get("developer", "0", CVAR_TEMP);
+
+	// done early so bind command exists
+	CL_InitKeyCommands();
+
+	com_homepath = Cvar_Get("com_homepath", "", CVAR_INIT);
+	
+	// Com_StartupVariable(
+	FS_InitFilesystem ();
+
+	Com_InitJournaling();
+
+	// Add some commands here already so users can use them from config files
+	Cmd_AddCommand ("setenv", Com_Setenv_f);
+	if (com_developer && com_developer->integer)
+	{
+		Cmd_AddCommand ("error", Com_Error_f);
+		Cmd_AddCommand ("crash", Com_Crash_f);
+		Cmd_AddCommand ("freeze", Com_Freeze_f);
+	}
+	Cmd_AddCommand ("quit", Com_Quit_f);
+	Cmd_AddCommand ("changeVectors", MSG_ReportChangeVectors_f );
+	Cmd_AddCommand ("writeconfig", Com_WriteConfig_f );
+	Cmd_SetCommandCompletionFunc( "writeconfig", Cmd_CompleteCfgName );
+	Cmd_AddCommand("game_restart", Com_GameRestart_f);
+
+	Com_ExecuteCfg();
+
+	// override anything from the config files with command line args
+	Com_StartupVariable( NULL );
+
+  // get dedicated here for proper hunk megs initialization
+#ifdef DEDICATED
+	com_dedicated = Cvar_Get ("dedicated", "1", CVAR_INIT);
+	Cvar_CheckRange( com_dedicated, 1, 2, qtrue );
+#else
+	com_dedicated = Cvar_Get ("dedicated", "0", CVAR_LATCH);
+	Cvar_CheckRange( com_dedicated, 0, 2, qtrue );
+#endif
+	// allocate the stack based hunk allocator
+	Com_InitHunkMemory();
+
+	// if any archived cvars are modified after this, we will trigger a writing
+	// of the config file
+	cvar_modifiedFlags &= ~CVAR_ARCHIVE;
+
+	//
+	// init commands and vars
+	//
+	com_altivec = Cvar_Get ("com_altivec", "1", CVAR_ARCHIVE);
+	com_maxfps = Cvar_Get ("com_maxfps", "85", CVAR_ARCHIVE);
+	com_blood = Cvar_Get ("com_blood", "1", CVAR_ARCHIVE);
+
+	com_logfile = Cvar_Get ("logfile", "0", CVAR_TEMP );
+
+	com_timescale = Cvar_Get ("timescale", "1", CVAR_CHEAT | CVAR_SYSTEMINFO );
+	com_fixedtime = Cvar_Get ("fixedtime", "0", CVAR_CHEAT);
+	com_showtrace = Cvar_Get ("com_showtrace", "0", CVAR_CHEAT);
+	com_speeds = Cvar_Get ("com_speeds", "0", 0);
+	com_timedemo = Cvar_Get ("timedemo", "0", CVAR_CHEAT);
+	com_cameraMode = Cvar_Get ("com_cameraMode", "0", CVAR_CHEAT);
+
+	cl_paused = Cvar_Get ("cl_paused", "0", CVAR_ROM);
+	sv_paused = Cvar_Get ("sv_paused", "0", CVAR_ROM);
+	cl_packetdelay = Cvar_Get ("cl_packetdelay", "0", CVAR_CHEAT);
+	sv_packetdelay = Cvar_Get ("sv_packetdelay", "0", CVAR_CHEAT);
+	com_sv_running = Cvar_Get ("sv_running", "0", CVAR_ROM);
+	com_cl_running = Cvar_Get ("cl_running", "0", CVAR_ROM);
+	com_buildScript = Cvar_Get( "com_buildScript", "0", 0 );
+	com_ansiColor = Cvar_Get( "com_ansiColor", "0", CVAR_ARCHIVE );
+
+	com_unfocused = Cvar_Get( "com_unfocused", "0", CVAR_ROM );
+	com_maxfpsUnfocused = Cvar_Get( "com_maxfpsUnfocused", "0", CVAR_ARCHIVE );
+	com_minimized = Cvar_Get( "com_minimized", "0", CVAR_ROM );
+	com_maxfpsMinimized = Cvar_Get( "com_maxfpsMinimized", "0", CVAR_ARCHIVE );
+	com_abnormalExit = Cvar_Get( "com_abnormalExit", "0", CVAR_ROM );
+	com_busyWait = Cvar_Get("com_busyWait", "0", CVAR_ARCHIVE);
+
+	s = va("%s %s %s", Q3_VERSION, PLATFORM_STRING, __DATE__ );
+	com_version = Cvar_Get ("version", s, CVAR_ROM | CVAR_SERVERINFO );
+	Cvar_Get ("protocol", va("%i", PROTOCOL_VERSION), CVAR_SERVERINFO | CVAR_ROM);
+
+	Sys_Init();
+
+	if( Sys_WritePIDFile( ) ) {
+#ifndef DEDICATED
+		const char *message = "The last time " CLIENT_WINDOW_TITLE " ran, "
+			"it didn't exit properly. This may be due to inappropriate video "
+			"settings. Would you like to start with \"safe\" video settings?";
+
+		if( Sys_Dialog( DT_YES_NO, message, "Abnormal Exit" ) == DR_YES ) {
+			Cvar_Set( "com_abnormalExit", "1" );
+		}
+#endif
+	}
+
+	// Pick a random port value
+	Com_RandomBytes( (byte*)&qport, sizeof(int) );
+	Netchan_Init( qport & 0xffff );
+
+	VM_Init();
+	SV_Init();
+
+	com_dedicated->modified = qfalse;
+#ifndef DEDICATED
+	CL_Init();
+#endif
+
+	// set com_frameTime so that if a map is started on the
+	// command line it will still be able to count on com_frameTime
+	// being random enough for a serverid
+	com_frameTime = Com_Milliseconds();
+
+	// add + commands from command line
+	if ( !Com_AddStartupCommands() ) {
+		// if the user didn't give any commands, run default action
+		if ( !com_dedicated->integer ) {
+			Cbuf_AddText ("cinematic splash.RoQ\n");
+		}
+	}
+
+	// start in full screen ui mode
+	Cvar_Set("r_uiFullScreen", "1");
+
+	CL_StartHunkUsers( qfalse );
+
+	// make sure single player is off by default
+	Cvar_Set("ui_singlePlayerActive", "0");
+
+	com_fullyInitialized = qtrue;
+
+	// always set the cvar, but only print the info if it makes sense.
+	Com_DetectAltivec();
+#if idppc
+	Com_Printf ("Altivec support is %s\n", com_altivec->integer ? "enabled" : "disabled");
+#endif
+
+	com_pipefile = Cvar_Get( "com_pipefile", "", CVAR_ARCHIVE|CVAR_LATCH );
+	if( com_pipefile->string[0] )
+	{
+		pipefile = FS_FCreateOpenPipeFile( com_pipefile->string );
+	}
+
+	Com_Printf ("--- Common Initialization Complete ---\n");
+}
+
+/*
+===============
+Com_ReadFromPipe
+
+Read whatever is in com_pipefile, if anything, and execute it
+===============
+*/
+void Com_ReadFromPipe( void )
+{
+	char buffer[MAX_STRING_CHARS] = {""};
+	qboolean read;
+
+	if( !pipefile )
+		return;
+
+	read = FS_Read( buffer, sizeof( buffer ), pipefile );
+	if( read )
+		Cbuf_ExecuteText( EXEC_APPEND, buffer );
+}
+
+
+//==================================================================
+
+void Com_WriteConfigToFile( const char *filename ) {
+	fileHandle_t	f;
+
+	f = FS_FOpenFileWrite( filename );
+	if ( !f ) {
+		Com_Printf ("Couldn't write %s.\n", filename );
+		return;
+	}
+
+	FS_Printf (f, "// generated by tremulous, do not modify\n");
+	Key_WriteBindings (f);
+	Cvar_WriteVariables (f);
+	FS_FCloseFile( f );
+}
+
+
+/*
+===============
+Com_WriteConfiguration
+
+Writes key bindings and archived cvars to config file if modified
+===============
+*/
+void Com_WriteConfiguration( void ) {
+	// if we are quiting without fully initializing, make sure
+	// we don't write out anything
+	if ( !com_fullyInitialized ) {
+		return;
+	}
+
+	if ( !(cvar_modifiedFlags & CVAR_ARCHIVE ) ) {
+		return;
+	}
+	cvar_modifiedFlags &= ~CVAR_ARCHIVE;
+
+	Com_WriteConfigToFile( Q3CONFIG_CFG );
+}
+
+
+/*
+===============
+Com_WriteConfig_f
+
+Write the config file to a specific name
+===============
+*/
+void Com_WriteConfig_f( void ) {
+	char	filename[MAX_QPATH];
+
+	if ( Cmd_Argc() != 2 ) {
+		Com_Printf( "Usage: writeconfig <filename>\n" );
+		return;
+	}
+
+	Q_strncpyz( filename, Cmd_Argv(1), sizeof( filename ) );
+	COM_DefaultExtension( filename, sizeof( filename ), ".cfg" );
+	Com_Printf( "Writing %s.\n", filename );
+	Com_WriteConfigToFile( filename );
+}
+
+/*
+================
+Com_ModifyMsec
+================
+*/
+int Com_ModifyMsec( int msec ) {
+	int		clampTime;
+
+	//
+	// modify time for debugging values
+	//
+	if ( com_fixedtime->integer ) {
+		msec = com_fixedtime->integer;
+	} else if ( com_timescale->value ) {
+		msec *= com_timescale->value;
+	} else if (com_cameraMode->integer) {
+		msec *= com_timescale->value;
+	}
+	
+	// don't let it scale below 1 msec
+	if ( msec < 1 && com_timescale->value) {
+		msec = 1;
+	}
+
+	if ( com_dedicated->integer ) {
+		// dedicated servers don't want to clamp for a much longer
+		// period, because it would mess up all the client's views
+		// of time.
+		if (com_sv_running->integer && msec > 500)
+			Com_Printf( "Hitch warning: %i msec frame time\n", msec );
+
+		clampTime = 5000;
+	} else 
+	if ( !com_sv_running->integer ) {
+		// clients of remote servers do not want to clamp time, because
+		// it would skew their view of the server's time temporarily
+		clampTime = 5000;
+	} else {
+		// for local single player gaming
+		// we may want to clamp the time to prevent players from
+		// flying off edges when something hitches.
+		clampTime = 200;
+	}
+
+	if ( msec > clampTime ) {
+		msec = clampTime;
+	}
+
+	return msec;
+}
+
+/*
+=================
+Com_Frame
+=================
+*/
+void Com_Frame( void ) {
+
+	int		msec, minMsec;
+	int		timeVal;
+	static int	lastTime = 0, bias = 0;
+ 
+	int		timeBeforeFirstEvents;
+	int		timeBeforeServer;
+	int		timeBeforeEvents;
+	int		timeBeforeClient;
+	int		timeAfter;
+  
+
+	if ( setjmp (abortframe) ) {
+		return;			// an ERR_DROP was thrown
+	}
+
+	timeBeforeFirstEvents =0;
+	timeBeforeServer =0;
+	timeBeforeEvents =0;
+	timeBeforeClient = 0;
+	timeAfter = 0;
+
+	// write config file if anything changed
+	Com_WriteConfiguration(); 
+
+	//
+	// main event loop
+	//
+	if ( com_speeds->integer ) {
+		timeBeforeFirstEvents = Sys_Milliseconds ();
+	}
+
+	// Figure out how much time we have
+	if(!com_timedemo->integer)
+	{
+		if(com_dedicated->integer)
+			minMsec = SV_FrameMsec();
+		else
+		{
+			if(com_minimized->integer && com_maxfpsMinimized->integer > 0)
+				minMsec = 1000 / com_maxfpsMinimized->integer;
+			else if(com_unfocused->integer && com_maxfpsUnfocused->integer > 0)
+				minMsec = 1000 / com_maxfpsUnfocused->integer;
+			else if(com_maxfps->integer > 0)
+				minMsec = 1000 / com_maxfps->integer;
+			else
+				minMsec = 1;
+			
+			timeVal = com_frameTime - lastTime;
+			bias += timeVal - minMsec;
+			
+			if(bias > minMsec)
+				bias = minMsec;
+			
+			// Adjust minMsec if previous frame took too long to render so
+			// that framerate is stable at the requested value.
+			minMsec -= bias;
+		}
+	}
+	else
+		minMsec = 1;
+
+	timeVal = 0;
+	do
+	{
+		// Busy sleep the last millisecond for better timeout precision
+		if(com_busyWait->integer || timeVal < 2)
+			NET_Sleep(0);
+		else
+			NET_Sleep(timeVal - 1);
+
+		msec = Sys_Milliseconds() - com_frameTime;
+		
+		if(msec >= minMsec)
+			timeVal = 0;
+		else
+			timeVal = minMsec - msec;
+
+	} while(timeVal > 0);
+	
+	lastTime = com_frameTime;
+	com_frameTime = Com_EventLoop();
+	
+	msec = com_frameTime - lastTime;
+
+	Cbuf_Execute ();
+
+	if (com_altivec->modified)
+	{
+		Com_DetectAltivec();
+		com_altivec->modified = qfalse;
+	}
+
+	// mess with msec if needed
+	msec = Com_ModifyMsec(msec);
+
+	//
+	// server side
+	//
+	if ( com_speeds->integer ) {
+		timeBeforeServer = Sys_Milliseconds ();
+	}
+
+	SV_Frame( msec );
+
+	// if "dedicated" has been modified, start up
+	// or shut down the client system.
+	// Do this after the server may have started,
+	// but before the client tries to auto-connect
+	if ( com_dedicated->modified ) {
+		// get the latched value
+		Cvar_Get( "dedicated", "0", 0 );
+		com_dedicated->modified = qfalse;
+		if ( !com_dedicated->integer ) {
+			SV_Shutdown( "dedicated set to 0" );
+			CL_FlushMemory();
+		}
+	}
+
+#ifndef DEDICATED
+	//
+	// client system
+	//
+	//
+	// run event loop a second time to get server to client packets
+	// without a frame of latency
+	//
+	if ( com_speeds->integer ) {
+		timeBeforeEvents = Sys_Milliseconds ();
+	}
+	Com_EventLoop();
+	Cbuf_Execute ();
+
+
+	//
+	// client side
+	//
+	if ( com_speeds->integer ) {
+		timeBeforeClient = Sys_Milliseconds ();
+	}
+
+	CL_Frame( msec );
+
+	if ( com_speeds->integer ) {
+		timeAfter = Sys_Milliseconds ();
+	}
+#else
+	if ( com_speeds->integer ) {
+		timeAfter = Sys_Milliseconds ();
+		timeBeforeEvents = timeAfter;
+		timeBeforeClient = timeAfter;
+	}
+#endif
+
+
+	NET_FlushPacketQueue();
+
+	//
+	// report timing information
+	//
+	if ( com_speeds->integer ) {
+		int			all, sv, ev, cl;
+
+		all = timeAfter - timeBeforeServer;
+		sv = timeBeforeEvents - timeBeforeServer;
+		ev = timeBeforeServer - timeBeforeFirstEvents + timeBeforeClient - timeBeforeEvents;
+		cl = timeAfter - timeBeforeClient;
+		sv -= time_game;
+		cl -= time_frontend + time_backend;
+
+		Com_Printf ("frame:%i all:%3i sv:%3i ev:%3i cl:%3i gm:%3i rf:%3i bk:%3i\n", 
+					 com_frameNumber, all, sv, ev, cl, time_game, time_frontend, time_backend );
+	}	
+
+	//
+	// trace optimization tracking
+	//
+	if ( com_showtrace->integer ) {
+	
+		extern	int c_traces, c_brush_traces, c_patch_traces;
+		extern	int	c_pointcontents;
+
+		Com_Printf ("%4i traces  (%ib %ip) %4i points\n", c_traces,
+			c_brush_traces, c_patch_traces, c_pointcontents);
+		c_traces = 0;
+		c_brush_traces = 0;
+		c_patch_traces = 0;
+		c_pointcontents = 0;
+	}
+
+	Com_ReadFromPipe( );
+
+	com_frameNumber++;
+}
+
+/*
+=================
+Com_Shutdown
+=================
+*/
+void Com_Shutdown (void) {
+	if (logfile) {
+		FS_FCloseFile (logfile);
+		logfile = 0;
+	}
+
+	if ( com_journalFile ) {
+		FS_FCloseFile( com_journalFile );
+		com_journalFile = 0;
+	}
+
+	if( pipefile ) {
+		FS_FCloseFile( pipefile );
+		FS_HomeRemove( com_pipefile->string );
+	}
+
+}
+
+//------------------------------------------------------------------------
+
+
+/*
+=====================
+Q_acos
+
+the msvc acos doesn't always return a value between -PI and PI:
+
+int i;
+i = 1065353246;
+acos(*(float*) &i) == -1.#IND0
+
+	This should go in q_math but it is too late to add new traps
+	to game and ui
+=====================
+*/
+float Q_acos(float c) {
+	float angle;
+
+	angle = acos(c);
+
+	if (angle > M_PI) {
+		return (float)M_PI;
+	}
+	if (angle < -M_PI) {
+		return (float)M_PI;
+	}
+	return angle;
+}
+
+/*
+===========================================
+command line completion
+===========================================
+*/
+
+/*
+==================
+Field_Clear
+==================
+*/
+void Field_Clear( field_t *edit ) {
+  memset(edit->buffer, 0, MAX_EDIT_LINE);
+	edit->cursor = 0;
+	edit->scroll = 0;
+}
+
+static const char *completionString;
+static char shortestMatch[MAX_TOKEN_CHARS];
+static int	matchCount;
+// field we are working on, passed to Field_AutoComplete(&g_consoleCommand for instance)
+static field_t *completionField;
+
+/*
+===============
+FindMatches
+
+===============
+*/
+static void FindMatches( const char *s ) {
+	int		i;
+
+	if ( Q_stricmpn( s, completionString, strlen( completionString ) ) ) {
+		return;
+	}
+	matchCount++;
+	if ( matchCount == 1 ) {
+		Q_strncpyz( shortestMatch, s, sizeof( shortestMatch ) );
+		return;
+	}
+
+	// cut shortestMatch to the amount common with s
+	for ( i = 0 ; shortestMatch[i] ; i++ ) {
+		if ( i >= strlen( s ) ) {
+			shortestMatch[i] = 0;
+			break;
+		}
+
+		if ( tolower(shortestMatch[i]) != tolower(s[i]) ) {
+			shortestMatch[i] = 0;
+		}
+	}
+}
+
+/*
+===============
+PrintMatches
+
+===============
+*/
+static void PrintMatches( const char *s ) {
+	if ( !Q_stricmpn( s, shortestMatch, strlen( shortestMatch ) ) ) {
+		Com_Printf( "    %s\n", s );
+	}
+}
+
+/*
+===============
+PrintCvarMatches
+
+===============
+*/
+static void PrintCvarMatches( const char *s ) {
+	char value[ TRUNCATE_LENGTH ];
+
+	if ( !Q_stricmpn( s, shortestMatch, strlen( shortestMatch ) ) ) {
+		Com_TruncateLongString( value, Cvar_VariableString( s ) );
+		Com_Printf( "    %s = \"%s\"\n", s, value );
+	}
+}
+
+/*
+===============
+Field_FindFirstSeparator
+===============
+*/
+static char *Field_FindFirstSeparator( char *s )
+{
+	int i;
+
+	for( i = 0; i < strlen( s ); i++ )
+	{
+		if( s[ i ] == ';' )
+			return &s[ i ];
+	}
+
+	return NULL;
+}
+
+/*
+===============
+Field_Complete
+===============
+*/
+static qboolean Field_Complete( void )
+{
+	int completionOffset;
+
+	if( matchCount == 0 )
+		return qtrue;
+
+	completionOffset = strlen( completionField->buffer ) - strlen( completionString );
+
+	Q_strncpyz( &completionField->buffer[ completionOffset ], shortestMatch,
+		sizeof( completionField->buffer ) - completionOffset );
+
+	completionField->cursor = strlen( completionField->buffer );
+
+	if( matchCount == 1 )
+	{
+		Q_strcat( completionField->buffer, sizeof( completionField->buffer ), " " );
+		completionField->cursor++;
+		return qtrue;
+	}
+
+	Com_Printf( "]%s\n", completionField->buffer );
+
+	return qfalse;
+}
+
+#ifndef DEDICATED
+/*
+===============
+Field_CompleteKeyname
+===============
+*/
+void Field_CompleteKeyname( void )
+{
+	matchCount = 0;
+	shortestMatch[ 0 ] = 0;
+
+	Key_KeynameCompletion( FindMatches );
+
+	if( !Field_Complete( ) )
+		Key_KeynameCompletion( PrintMatches );
+}
+#endif
+
+/*
+===============
+Field_CompleteFilename
+===============
+*/
+void Field_CompleteFilename( const char *dir,
+		const char *ext, qboolean stripExt, qboolean allowNonPureFilesOnDisk )
+{
+	matchCount = 0;
+	shortestMatch[ 0 ] = 0;
+
+	FS_FilenameCompletion( dir, ext, stripExt, FindMatches, allowNonPureFilesOnDisk );
+
+	if( !Field_Complete( ) )
+		FS_FilenameCompletion( dir, ext, stripExt, PrintMatches, allowNonPureFilesOnDisk );
+}
+
+/*
+===============
+Field_CompleteCommand
+===============
+*/
+void Field_CompleteCommand( char *cmd,
+		qboolean doCommands, qboolean doCvars )
+{
+	int		completionArgument = 0;
+
+	// Skip leading whitespace and quotes
+	cmd = Com_SkipCharset( cmd, " \"" );
+
+	Cmd_TokenizeStringIgnoreQuotes( cmd );
+	completionArgument = Cmd_Argc( );
+
+	// If there is trailing whitespace on the cmd
+	if( *( cmd + strlen( cmd ) - 1 ) == ' ' )
+	{
+		completionString = "";
+		completionArgument++;
+	}
+	else
+		completionString = Cmd_Argv( completionArgument - 1 );
+
+#ifndef DEDICATED
+	// Unconditionally add a '\' to the start of the buffer
+	if( completionField->buffer[ 0 ] &&
+			completionField->buffer[ 0 ] != '\\' )
+	{
+		if( completionField->buffer[ 0 ] != '/' )
+		{
+			// Buffer is full, refuse to complete
+			if( strlen( completionField->buffer ) + 1 >=
+				sizeof( completionField->buffer ) )
+				return;
+
+			memmove( &completionField->buffer[ 1 ],
+				&completionField->buffer[ 0 ],
+				strlen( completionField->buffer ) + 1 );
+			completionField->cursor++;
+		}
+
+		completionField->buffer[ 0 ] = '\\';
+	}
+#endif
+
+	if( completionArgument > 1 )
+	{
+		const char *baseCmd = Cmd_Argv( 0 );
+		char *p;
+
+#ifndef DEDICATED
+		// This should always be true
+		if( baseCmd[ 0 ] == '\\' || baseCmd[ 0 ] == '/' )
+			baseCmd++;
+#endif
+
+		if( ( p = Field_FindFirstSeparator( cmd ) ) )
+			Field_CompleteCommand( p + 1, qtrue, qtrue ); // Compound command
+		else
+			Cmd_CompleteArgument( baseCmd, cmd, completionArgument ); 
+	}
+	else
+	{
+		if( completionString[0] == '\\' || completionString[0] == '/' )
+			completionString++;
+
+		matchCount = 0;
+		shortestMatch[ 0 ] = 0;
+
+		if( strlen( completionString ) == 0 )
+			return;
+
+		if( doCommands )
+			Cmd_CommandCompletion( FindMatches );
+
+		if( doCvars )
+			Cvar_CommandCompletion( FindMatches );
+
+		if( !Field_Complete( ) )
+		{
+			// run through again, printing matches
+			if( doCommands )
+				Cmd_CommandCompletion( PrintMatches );
+
+			if( doCvars )
+				Cvar_CommandCompletion( PrintCvarMatches );
+		}
+	}
+}
+
+/*
+===============
+Field_AutoComplete
+
+Perform Tab expansion
+===============
+*/
+void Field_AutoComplete( field_t *field )
+{
+	completionField = field;
+
+	Field_CompleteCommand( completionField->buffer, qtrue, qtrue );
+}
+
+/*
+==================
+Com_RandomBytes
+
+fills string array with len radom bytes, peferably from the OS randomizer
+==================
+*/
+void Com_RandomBytes( byte *string, int len )
+{
+	int i;
+
+	if( Sys_RandomBytes( string, len ) )
+		return;
+
+	Com_Printf( "Com_RandomBytes: using weak randomization\n" );
+	for( i = 0; i < len; i++ )
+		string[i] = (unsigned char)( rand() % 255 );
+}
+
diff -uNr tremulous-ggp1-src.p/src/qcommon/qcommon.h tremulous-ggp1-src/src/qcommon/qcommon.h
--- tremulous-ggp1-src.p/src/qcommon/qcommon.h	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/qcommon/qcommon.h	2012-07-19 04:25:52.041556450 +0200
@@ -841,6 +841,7 @@
 extern	int		time_game;
 extern	int		time_frontend;
 extern	int		time_backend;		// renderer backend time
+extern	int		time_GL;
 
 extern	int		com_frameTime;
 
diff -uNr tremulous-ggp1-src.p/src/qcommon/qcommon.h.orig tremulous-ggp1-src/src/qcommon/qcommon.h.orig
--- tremulous-ggp1-src.p/src/qcommon/qcommon.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/qcommon/qcommon.h.orig	2012-07-19 04:25:20.311556052 +0200
@@ -0,0 +1,1194 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+// qcommon.h -- definitions common between client and server, but not game.or ref modules
+#ifndef _QCOMMON_H_
+#define _QCOMMON_H_
+
+#include "../qcommon/cm_public.h"
+
+//Ignore __attribute__ on non-gcc platforms
+#ifndef __GNUC__
+#ifndef __attribute__
+#define __attribute__(x)
+#endif
+#endif
+
+//============================================================================
+
+//
+// msg.c
+//
+typedef struct {
+	qboolean	allowoverflow;	// if false, do a Com_Error
+	qboolean	overflowed;		// set to true if the buffer size failed (with allowoverflow set)
+	qboolean	oob;			// set to true if the buffer size failed (with allowoverflow set)
+	byte	*data;
+	int		maxsize;
+	int		cursize;
+	int		readcount;
+	int		bit;				// for bitwise reads and writes
+} msg_t;
+
+void MSG_Init (msg_t *buf, byte *data, int length);
+void MSG_InitOOB( msg_t *buf, byte *data, int length );
+void MSG_Clear (msg_t *buf);
+void MSG_WriteData (msg_t *buf, const void *data, int length);
+void MSG_Bitstream( msg_t *buf );
+
+// TTimo
+// copy a msg_t in case we need to store it as is for a bit
+// (as I needed this to keep an msg_t from a static var for later use)
+// sets data buffer as MSG_Init does prior to do the copy
+void MSG_Copy(msg_t *buf, byte *data, int length, msg_t *src);
+
+struct usercmd_s;
+struct entityState_s;
+struct playerState_s;
+
+void MSG_WriteBits( msg_t *msg, int value, int bits );
+
+void MSG_WriteChar (msg_t *sb, int c);
+void MSG_WriteByte (msg_t *sb, int c);
+void MSG_WriteShort (msg_t *sb, int c);
+void MSG_WriteLong (msg_t *sb, int c);
+void MSG_WriteFloat (msg_t *sb, float f);
+void MSG_WriteString (msg_t *sb, const char *s);
+void MSG_WriteBigString (msg_t *sb, const char *s);
+void MSG_WriteAngle16 (msg_t *sb, float f);
+int MSG_HashKey(const char *string, int maxlen);
+
+void	MSG_BeginReading (msg_t *sb);
+void	MSG_BeginReadingOOB(msg_t *sb);
+
+int		MSG_ReadBits( msg_t *msg, int bits );
+
+int		MSG_ReadChar (msg_t *sb);
+int		MSG_ReadByte (msg_t *sb);
+int		MSG_ReadShort (msg_t *sb);
+int		MSG_ReadLong (msg_t *sb);
+float	MSG_ReadFloat (msg_t *sb);
+char	*MSG_ReadString (msg_t *sb);
+char	*MSG_ReadBigString (msg_t *sb);
+char	*MSG_ReadStringLine (msg_t *sb);
+float	MSG_ReadAngle16 (msg_t *sb);
+void	MSG_ReadData (msg_t *sb, void *buffer, int size);
+int		MSG_LookaheadByte (msg_t *msg);
+
+void MSG_WriteDeltaUsercmd( msg_t *msg, struct usercmd_s *from, struct usercmd_s *to );
+void MSG_ReadDeltaUsercmd( msg_t *msg, struct usercmd_s *from, struct usercmd_s *to );
+
+void MSG_WriteDeltaUsercmdKey( msg_t *msg, int key, usercmd_t *from, usercmd_t *to );
+void MSG_ReadDeltaUsercmdKey( msg_t *msg, int key, usercmd_t *from, usercmd_t *to );
+
+void MSG_WriteDeltaEntity( msg_t *msg, struct entityState_s *from, struct entityState_s *to
+						   , qboolean force );
+void MSG_ReadDeltaEntity( msg_t *msg, entityState_t *from, entityState_t *to, 
+						 int number );
+
+void MSG_WriteDeltaPlayerstate( msg_t *msg, struct playerState_s *from, struct playerState_s *to );
+void MSG_ReadDeltaPlayerstate( msg_t *msg, struct playerState_s *from, struct playerState_s *to );
+
+
+void MSG_ReportChangeVectors_f( void );
+
+//============================================================================
+
+/*
+==============================================================
+
+NET
+
+==============================================================
+*/
+
+#define NET_ENABLEV4            0x01
+#define NET_ENABLEV6            0x02
+// if this flag is set, always attempt ipv6 connections instead of ipv4 if a v6 address is found.
+#define NET_PRIOV6              0x04
+// disables ipv6 multicast support if set.
+#define NET_DISABLEMCAST        0x08
+
+
+#define	PACKET_BACKUP	32	// number of old messages that must be kept on client and
+							// server for delta comrpession and ping estimation
+#define	PACKET_MASK		(PACKET_BACKUP-1)
+
+#define	MAX_PACKET_USERCMDS		32		// max number of usercmd_t in a packet
+
+#define	PORT_ANY			-1
+
+#define	MAX_RELIABLE_COMMANDS	128			// max string commands buffered for restransmit
+
+typedef enum {
+	NA_BAD = 0,					// an address lookup failed
+	NA_LOOPBACK,
+	NA_BROADCAST,
+	NA_IP,
+	NA_IP6,
+	NA_MULTICAST6,
+	NA_UNSPEC
+} netadrtype_t;
+
+typedef enum {
+	NS_CLIENT,
+	NS_SERVER
+} netsrc_t;
+
+#define NET_ADDRSTRMAXLEN 48	// maximum length of an IPv6 address string including trailing '\0'
+typedef struct {
+	netadrtype_t	type;
+
+	byte	ip[4];
+	byte	ip6[16];
+
+	unsigned short	port;
+	unsigned long	scope_id;	// Needed for IPv6 link-local addresses
+} netadr_t;
+
+void		NET_Init( void );
+void		NET_Shutdown( void );
+void		NET_Restart_f( void );
+void		NET_Config( qboolean enableNetworking );
+void		NET_FlushPacketQueue(void);
+void		NET_SendPacket (netsrc_t sock, int length, const void *data, netadr_t to);
+void		QDECL NET_OutOfBandPrint( netsrc_t net_socket, netadr_t adr, const char *format, ...) __attribute__ ((format (printf, 3, 4)));
+void		QDECL NET_OutOfBandData( netsrc_t sock, netadr_t adr, byte *format, int len );
+
+qboolean	NET_CompareAdr (netadr_t a, netadr_t b);
+qboolean	NET_CompareBaseAdrMask(netadr_t a, netadr_t b, int netmask);
+qboolean	NET_CompareBaseAdr (netadr_t a, netadr_t b);
+qboolean	NET_IsLocalAddress (netadr_t adr);
+const char	*NET_AdrToString (netadr_t a);
+const char	*NET_AdrToStringwPort (netadr_t a);
+int		NET_StringToAdr ( const char *s, netadr_t *a, netadrtype_t family);
+qboolean	NET_GetLoopPacket (netsrc_t sock, netadr_t *net_from, msg_t *net_message);
+void		NET_JoinMulticast6(void);
+void		NET_LeaveMulticast6(void);
+void		NET_Sleep(int msec);
+
+
+#define	MAX_MSGLEN				16384		// max length of a message, which may
+											// be fragmented into multiple packets
+
+#define MAX_DOWNLOAD_WINDOW			8		// max of eight download frames
+#define MAX_DOWNLOAD_BLKSIZE		2048	// 2048 byte block chunks
+ 
+
+/*
+Netchan handles packet fragmentation and out of order / duplicate suppression
+*/
+
+typedef struct {
+	netsrc_t	sock;
+
+	int			dropped;			// between last packet and previous
+
+	netadr_t	remoteAddress;
+	int			qport;				// qport value to write when transmitting
+
+	// sequencing variables
+	int			incomingSequence;
+	int			outgoingSequence;
+
+	// incoming fragment assembly buffer
+	int			fragmentSequence;
+	int			fragmentLength;	
+	byte		fragmentBuffer[MAX_MSGLEN];
+
+	// outgoing fragment buffer
+	// we need to space out the sending of large fragmented messages
+	qboolean	unsentFragments;
+	int			unsentFragmentStart;
+	int			unsentLength;
+	byte		unsentBuffer[MAX_MSGLEN];
+} netchan_t;
+
+void Netchan_Init( int qport );
+void Netchan_Setup( netsrc_t sock, netchan_t *chan, netadr_t adr, int qport );
+
+void Netchan_Transmit( netchan_t *chan, int length, const byte *data );
+void Netchan_TransmitNextFragment( netchan_t *chan );
+
+qboolean Netchan_Process( netchan_t *chan, msg_t *msg );
+
+
+/*
+==============================================================
+
+PROTOCOL
+
+==============================================================
+*/
+
+#define	PROTOCOL_VERSION	70
+
+// maintain a list of compatible protocols for demo playing
+// NOTE: that stuff only works with two digits protocols
+extern int demo_protocols[];
+
+// override on command line, config files etc.
+#ifndef MASTER_SERVER_NAME
+#define MASTER_SERVER_NAME	"master.tremulous.net"
+#endif
+
+#define	PORT_MASTER			30700
+#define	PORT_SERVER			30720
+#define	NUM_SERVER_PORTS	4		// broadcast scan this many ports after
+									// PORT_SERVER so a single machine can
+									// run multiple servers
+
+
+// the svc_strings[] array in cl_parse.c should mirror this
+//
+// server to client
+//
+enum svc_ops_e {
+	svc_bad,
+	svc_nop,
+	svc_gamestate,
+	svc_configstring,			// [short] [string] only in gamestate messages
+	svc_baseline,				// only in gamestate messages
+	svc_serverCommand,			// [string] to be executed by client game module
+	svc_download,				// [short] size [size bytes]
+	svc_snapshot,
+	svc_EOF,
+
+	// svc_extension follows a svc_EOF, followed by another svc_* ...
+	//  this keeps legacy clients compatible.
+	svc_extension,
+	svc_voip,     // not wrapped in USE_VOIP, so this value is reserved.
+};
+
+
+//
+// client to server
+//
+enum clc_ops_e {
+	clc_bad,
+	clc_nop, 		
+	clc_move,				// [[usercmd_t]
+	clc_moveNoDelta,		// [[usercmd_t]
+	clc_clientCommand,		// [string] message
+	clc_EOF,
+
+	// clc_extension follows a clc_EOF, followed by another clc_* ...
+	//  this keeps legacy servers compatible.
+	clc_extension,
+	clc_voip,   // not wrapped in USE_VOIP, so this value is reserved.
+};
+
+/*
+==============================================================
+
+VIRTUAL MACHINE
+
+==============================================================
+*/
+
+typedef struct vm_s vm_t;
+
+typedef enum {
+	VMI_NATIVE,
+	VMI_BYTECODE,
+	VMI_COMPILED
+} vmInterpret_t;
+
+typedef enum {
+	TRAP_MEMSET = 100,
+	TRAP_MEMCPY,
+	TRAP_STRNCPY,
+	TRAP_SIN,
+	TRAP_COS,
+	TRAP_ATAN2,
+	TRAP_SQRT,
+	TRAP_MATRIXMULTIPLY,
+	TRAP_ANGLEVECTORS,
+	TRAP_PERPENDICULARVECTOR,
+	TRAP_FLOOR,
+	TRAP_CEIL,
+
+	TRAP_TESTPRINTINT,
+	TRAP_TESTPRINTFLOAT
+} sharedTraps_t;
+
+void	VM_Init( void );
+vm_t	*VM_Create( const char *module, intptr_t (*systemCalls)(intptr_t *), 
+				   vmInterpret_t interpret );
+// module should be bare: "cgame", not "cgame.dll" or "vm/cgame.qvm"
+
+void	VM_Free( vm_t *vm );
+void	VM_Clear(void);
+void	VM_Forced_Unload_Start(void);
+void	VM_Forced_Unload_Done(void);
+vm_t	*VM_Restart( vm_t *vm );
+
+intptr_t		QDECL VM_Call( vm_t *vm, int callNum, ... );
+
+void	VM_Debug( int level );
+
+void	*VM_ArgPtr( intptr_t intValue );
+void	*VM_ExplicitArgPtr( vm_t *vm, intptr_t intValue );
+
+#define	VMA(x) VM_ArgPtr(args[x])
+static ID_INLINE float _vmf(intptr_t x)
+{
+	floatint_t fi;
+	fi.i = (int) x;
+	return fi.f;
+}
+#define	VMF(x)	_vmf(args[x])
+
+
+/*
+==============================================================
+
+CMD
+
+Command text buffering and command execution
+
+==============================================================
+*/
+
+/*
+
+Any number of commands can be added in a frame, from several different sources.
+Most commands come from either keybindings or console line input, but entire text
+files can be execed.
+
+*/
+
+void Cbuf_Init (void);
+// allocates an initial text buffer that will grow as needed
+
+void Cbuf_AddText( const char *text );
+// Adds command text at the end of the buffer, does NOT add a final \n
+
+void Cbuf_ExecuteText( int exec_when, const char *text );
+// this can be used in place of either Cbuf_AddText or Cbuf_InsertText
+
+void Cbuf_Execute (void);
+// Pulls off \n terminated lines of text from the command buffer and sends
+// them through Cmd_ExecuteString.  Stops when the buffer is empty.
+// Normally called once per frame, but may be explicitly invoked.
+// Do not call inside a command function, or current args will be destroyed.
+
+//===========================================================================
+
+/*
+
+Command execution takes a null terminated string, breaks it into tokens,
+then searches for a command or variable that matches the first token.
+
+*/
+
+typedef void (*xcommand_t) (void);
+
+void	Cmd_Init (void);
+
+void	Cmd_AddCommand( const char *cmd_name, xcommand_t function );
+// called by the init functions of other parts of the program to
+// register commands and functions to call for them.
+// The cmd_name is referenced later, so it should not be in temp memory
+// if function is NULL, the command will be forwarded to the server
+// as a clc_clientCommand instead of executed locally
+
+void	Cmd_RemoveCommand( const char *cmd_name );
+
+typedef void (*completionFunc_t)( char *args, int argNum );
+
+// don't allow VMs to remove system commands
+void	Cmd_RemoveCommandSafe( const char *cmd_name );
+
+void	Cmd_CommandCompletion( void(*callback)(const char *s) );
+// callback with each valid string
+void Cmd_SetCommandCompletionFunc( const char *command,
+	completionFunc_t complete );
+void Cmd_CompleteArgument( const char *command, char *args, int argNum );
+void Cmd_CompleteCfgName( char *args, int argNum );
+
+int		Cmd_Argc (void);
+char	*Cmd_Argv (int arg);
+void	Cmd_ArgvBuffer( int arg, char *buffer, int bufferLength );
+char	*Cmd_Args (void);
+char	*Cmd_ArgsFrom( int arg );
+void	Cmd_ArgsBuffer( char *buffer, int bufferLength );
+void	Cmd_LiteralArgsBuffer( char *buffer, int bufferLength );
+char	*Cmd_Cmd (void);
+void	Cmd_Args_Sanitize( void );
+// The functions that execute commands get their parameters with these
+// functions. Cmd_Argv () will return an empty string, not a NULL
+// if arg > argc, so string operations are allways safe.
+
+void	Cmd_TokenizeString( const char *text );
+void	Cmd_TokenizeStringIgnoreQuotes( const char *text_in );
+// Takes a null terminated string.  Does not need to be /n terminated.
+// breaks the string up into arg tokens.
+
+void	Cmd_ExecuteString( const char *text );
+// Parses a single line of text into arguments and tries to execute it
+// as if it was typed at the console
+
+void Cmd_SaveCmdContext( void );
+void Cmd_RestoreCmdContext( void );
+
+/*
+==============================================================
+
+CVAR
+
+==============================================================
+*/
+
+/*
+
+cvar_t variables are used to hold scalar or string variables that can be changed
+or displayed at the console or prog code as well as accessed directly
+in C code.
+
+The user can access cvars from the console in three ways:
+r_draworder			prints the current value
+r_draworder 0		sets the current value to 0
+set r_draworder 0	as above, but creates the cvar if not present
+
+Cvars are restricted from having the same names as commands to keep this
+interface from being ambiguous.
+
+The are also occasionally used to communicated information between different
+modules of the program.
+
+*/
+
+cvar_t *Cvar_Get( const char *var_name, const char *value, int flags );
+// creates the variable if it doesn't exist, or returns the existing one
+// if it exists, the value will not be changed, but flags will be ORed in
+// that allows variables to be unarchived without needing bitflags
+// if value is "", the value will not override a previously set value.
+
+void	Cvar_Register( vmCvar_t *vmCvar, const char *varName, const char *defaultValue, int flags );
+// basically a slightly modified Cvar_Get for the interpreted modules
+
+void	Cvar_Update( vmCvar_t *vmCvar );
+// updates an interpreted modules' version of a cvar
+
+void 	Cvar_Set( const char *var_name, const char *value );
+// will create the variable with no flags if it doesn't exist
+
+void	Cvar_SetSafe( const char *var_name, const char *value );
+// sometimes we set variables from an untrusted source: fail if flags & CVAR_PROTECTED
+
+void Cvar_SetLatched( const char *var_name, const char *value);
+// don't set the cvar immediately
+
+void	Cvar_SetValue( const char *var_name, float value );
+void	Cvar_SetValueSafe( const char *var_name, float value );
+// expands value to a string and calls Cvar_Set/Cvar_SetSafe
+
+float	Cvar_VariableValue( const char *var_name );
+int		Cvar_VariableIntegerValue( const char *var_name );
+// returns 0 if not defined or non numeric
+
+char	*Cvar_VariableString( const char *var_name );
+void	Cvar_VariableStringBuffer( const char *var_name, char *buffer, int bufsize );
+// returns an empty string if not defined
+
+int	Cvar_Flags(const char *var_name);
+// returns CVAR_NONEXISTENT if cvar doesn't exist or the flags of that particular CVAR.
+
+void	Cvar_CommandCompletion( void(*callback)(const char *s) );
+// callback with each valid string
+
+void 	Cvar_Reset( const char *var_name );
+void 	Cvar_ForceReset(const char *var_name);
+
+void	Cvar_SetCheatState( void );
+// reset all testing vars to a safe value
+
+qboolean Cvar_Command( void );
+// called by Cmd_ExecuteString when Cmd_Argv(0) doesn't match a known
+// command.  Returns true if the command was a variable reference that
+// was handled. (print or change)
+
+void 	Cvar_WriteVariables( fileHandle_t f );
+// writes lines containing "set variable value" for all variables
+// with the archive flag set to true.
+
+void	Cvar_Init( void );
+
+char	*Cvar_InfoString( int bit );
+char	*Cvar_InfoString_Big( int bit );
+// returns an info string containing all the cvars that have the given bit set
+// in their flags ( CVAR_USERINFO, CVAR_SERVERINFO, CVAR_SYSTEMINFO, etc )
+void	Cvar_InfoStringBuffer( int bit, char *buff, int buffsize );
+void Cvar_CheckRange( cvar_t *cv, float minVal, float maxVal, qboolean shouldBeIntegral );
+
+void	Cvar_Restart(qboolean unsetVM);
+void	Cvar_Restart_f( void );
+
+void Cvar_CompleteCvarName( char *args, int argNum );
+
+extern	int			cvar_modifiedFlags;
+// whenever a cvar is modifed, its flags will be OR'd into this, so
+// a single check can determine if any CVAR_USERINFO, CVAR_SERVERINFO,
+// etc, variables have been modified since the last check.  The bit
+// can then be cleared to allow another change detection.
+
+/*
+==============================================================
+
+FILESYSTEM
+
+No stdio calls should be used by any part of the game, because
+we need to deal with all sorts of directory and seperator char
+issues.
+==============================================================
+*/
+
+// referenced flags
+// these are in loop specific order so don't change the order
+#define FS_GENERAL_REF	0x01
+#define FS_UI_REF		0x02
+#define FS_CGAME_REF	0x04
+#define FS_QAGAME_REF	0x08
+
+#define	MAX_FILE_HANDLES	64
+
+#define BASEGAME "base"
+
+#ifdef DEDICATED
+#	define Q3CONFIG_CFG "autogen_server.cfg"
+#else
+#	define Q3CONFIG_CFG "autogen.cfg"
+#endif
+
+qboolean FS_Initialized( void );
+
+void	FS_InitFilesystem ( void );
+void	FS_Shutdown( qboolean closemfp );
+
+qboolean	FS_ConditionalRestart( int checksumFeed );
+void	FS_Restart( int checksumFeed );
+// shutdown and restart the filesystem so changes to fs_gamedir can take effect
+
+void FS_AddGameDirectory( const char *path, const char *dir );
+
+char	**FS_ListFiles( const char *directory, const char *extension, int *numfiles );
+// directory should not have either a leading or trailing /
+// if extension is "/", only subdirectories will be returned
+// the returned files will not include any directories or /
+
+void	FS_FreeFileList( char **list );
+
+qboolean FS_FileExists( const char *file );
+
+qboolean FS_CreatePath (char *OSPath);
+
+char *FS_FindDll( const char *filename );
+
+char   *FS_BuildOSPath( const char *base, const char *game, const char *qpath );
+qboolean FS_CompareZipChecksum(const char *zipfile);
+
+int		FS_LoadStack( void );
+
+int		FS_GetFileList(  const char *path, const char *extension, char *listbuf, int bufsize );
+int		FS_GetModList(  char *listbuf, int bufsize );
+
+fileHandle_t	FS_FOpenFileWrite( const char *qpath );
+fileHandle_t	FS_FOpenFileAppend( const char *filename );
+fileHandle_t	FS_FCreateOpenPipeFile( const char *filename );
+// will properly create any needed paths and deal with seperater character issues
+
+fileHandle_t FS_SV_FOpenFileWrite( const char *filename );
+int		FS_SV_FOpenFileRead( const char *filename, fileHandle_t *fp );
+void	FS_SV_Rename( const char *from, const char *to );
+int		FS_FOpenFileRead( const char *qpath, fileHandle_t *file, qboolean uniqueFILE );
+// if uniqueFILE is true, then a new FILE will be fopened even if the file
+// is found in an already open pak file.  If uniqueFILE is false, you must call
+// FS_FCloseFile instead of fclose, otherwise the pak FILE would be improperly closed
+// It is generally safe to always set uniqueFILE to true, because the majority of
+// file IO goes through FS_ReadFile, which Does The Right Thing already.
+
+int		FS_FileIsInPAK(const char *filename, int *pChecksum );
+// returns 1 if a file is in the PAK file, otherwise -1
+
+int		FS_Write( const void *buffer, int len, fileHandle_t f );
+
+int		FS_Read2( void *buffer, int len, fileHandle_t f );
+int		FS_Read( void *buffer, int len, fileHandle_t f );
+// properly handles partial reads and reads from other dlls
+
+void	FS_FCloseFile( fileHandle_t f );
+// note: you can't just fclose from another DLL, due to MS libc issues
+
+int		FS_ReadFile( const char *qpath, void **buffer );
+// returns the length of the file
+// a null buffer will just return the file length without loading
+// as a quick check for existance. -1 length == not present
+// A 0 byte will always be appended at the end, so string ops are safe.
+// the buffer should be considered read-only, because it may be cached
+// for other uses.
+
+void	FS_ForceFlush( fileHandle_t f );
+// forces flush on files we're writing to.
+
+void	FS_FreeFile( void *buffer );
+// frees the memory returned by FS_ReadFile
+
+void	FS_WriteFile( const char *qpath, const void *buffer, int size );
+// writes a complete file, creating any subdirectories needed
+
+int		FS_filelength( fileHandle_t f );
+// doesn't work for files that are opened from a pack file
+
+int		FS_FTell( fileHandle_t f );
+// where are we?
+
+void	FS_Flush( fileHandle_t f );
+
+void 	QDECL FS_Printf( fileHandle_t f, const char *fmt, ... ) __attribute__ ((format (printf, 2, 3)));
+// like fprintf
+
+int		FS_FOpenFileByMode( const char *qpath, fileHandle_t *f, fsMode_t mode );
+// opens a file for reading, writing, or appending depending on the value of mode
+
+int		FS_Seek( fileHandle_t f, long offset, int origin );
+// seek on a file (doesn't work for zip files!!!!!!!!)
+
+qboolean FS_FilenameCompare( const char *s1, const char *s2 );
+
+const char *FS_GamePureChecksum( void );
+// Returns the checksum of the pk3 from which the server loaded the qagame.qvm
+
+const char *FS_LoadedPakNames( void );
+const char *FS_LoadedPakChecksums( void );
+const char *FS_LoadedPakPureChecksums( void );
+// Returns a space separated string containing the checksums of all loaded pk3 files.
+// Servers with sv_pure set will get this string and pass it to clients.
+
+const char *FS_ReferencedPakNames( void );
+const char *FS_ReferencedPakChecksums( void );
+const char *FS_ReferencedPakPureChecksums( void );
+// Returns a space separated string containing the checksums of all loaded 
+// AND referenced pk3 files. Servers with sv_pure set will get this string 
+// back from clients for pure validation 
+
+void FS_ClearPakReferences( int flags );
+// clears referenced booleans on loaded pk3s
+
+void FS_PureServerSetReferencedPaks( const char *pakSums, const char *pakNames );
+void FS_PureServerSetLoadedPaks( const char *pakSums, const char *pakNames );
+// If the string is empty, all data sources will be allowed.
+// If not empty, only pk3 files that match one of the space
+// separated checksums will be checked for files, with the
+// sole exception of .cfg files.
+
+qboolean FS_CheckDirTraversal(const char *checkdir);
+qboolean FS_ComparePaks( char *neededpaks, int len, qboolean dlstring );
+
+void FS_Rename( const char *from, const char *to );
+
+void FS_Remove( const char *osPath );
+void FS_HomeRemove( const char *homePath );
+
+void	FS_FilenameCompletion( const char *dir, const char *ext,
+		qboolean stripExt, void(*callback)(const char *s), qboolean allowNonPureFilesOnDisk );
+
+const char *FS_GetCurrentGameDir(void);
+
+/*
+==============================================================
+
+Edit fields and command line history/completion
+
+==============================================================
+*/
+
+#define	MAX_EDIT_LINE	256
+typedef struct {
+	int		cursor;
+	int		scroll;
+	int		widthInChars;
+	char	buffer[MAX_EDIT_LINE];
+} field_t;
+
+void Field_Clear( field_t *edit );
+void Field_AutoComplete( field_t *edit );
+void Field_CompleteKeyname( void );
+void Field_CompleteFilename( const char *dir,
+		const char *ext, qboolean stripExt, qboolean allowNonPureFilesOnDisk );
+void Field_CompleteCommand( char *cmd,
+		qboolean doCommands, qboolean doCvars );
+
+/*
+==============================================================
+
+MISC
+
+==============================================================
+*/
+
+// returned by Sys_GetProcessorFeatures
+typedef enum
+{
+  CF_RDTSC      = 1 << 0,
+  CF_MMX        = 1 << 1,
+  CF_MMX_EXT    = 1 << 2,
+  CF_3DNOW      = 1 << 3,
+  CF_3DNOW_EXT  = 1 << 4,
+  CF_SSE        = 1 << 5,
+  CF_SSE2       = 1 << 6,
+  CF_ALTIVEC    = 1 << 7
+} cpuFeatures_t;
+
+// centralized and cleaned, that's the max string you can send to a Com_Printf / Com_DPrintf (above gets truncated)
+#define	MAXPRINTMSG	4096
+
+
+typedef enum {
+	// SE_NONE must be zero
+	SE_NONE = 0,		// evTime is still valid
+	SE_KEY,			// evValue is a key code, evValue2 is the down flag
+	SE_CHAR,		// evValue is an ascii char
+	SE_MOUSE,		// evValue and evValue2 are reletive signed x / y moves
+	SE_JOYSTICK_AXIS,	// evValue is an axis number and evValue2 is the current state (-127 to 127)
+	SE_CONSOLE		// evPtr is a char*
+} sysEventType_t;
+
+typedef struct {
+	int				evTime;
+	sysEventType_t	evType;
+	int				evValue, evValue2;
+	int				evPtrLength;	// bytes of data pointed to by evPtr, for journaling
+	void			*evPtr;			// this must be manually freed if not NULL
+} sysEvent_t;
+
+void		Com_QueueEvent( int time, sysEventType_t type, int value, int value2, int ptrLength, void *ptr );
+int			Com_EventLoop( void );
+sysEvent_t	Com_GetSystemEvent( void );
+
+char		*CopyString( const char *in );
+void		Info_Print( const char *s );
+
+void		Com_BeginRedirect (char *buffer, int buffersize, void (*flush)(char *));
+void		Com_EndRedirect( void );
+void 		QDECL Com_Printf( const char *fmt, ... ) __attribute__ ((format (printf, 1, 2)));
+void 		QDECL Com_DPrintf( const char *fmt, ... ) __attribute__ ((format (printf, 1, 2)));
+void 		QDECL Com_Error( int code, const char *fmt, ... ) __attribute__ ((format (printf, 2, 3)));
+void 		Com_Quit_f( void );
+void		Com_GameRestart(int checksumFeed, qboolean clientRestart);
+
+int			Com_Milliseconds( void );	// will be journaled properly
+unsigned	Com_BlockChecksum( const void *buffer, int length );
+char		*Com_MD5File(const char *filename, int length, const char *prefix, int prefix_len);
+int			Com_Filter(char *filter, char *name, int casesensitive);
+int			Com_FilterPath(char *filter, char *name, int casesensitive);
+int			Com_RealTime(qtime_t *qtime);
+qboolean	Com_SafeMode( void );
+void		Com_RunAndTimeServerPacket(netadr_t *evFrom, msg_t *buf);
+
+void		Com_StartupVariable( const char *match );
+// checks for and removes command line "+set var arg" constructs
+// if match is NULL, all set commands will be executed, otherwise
+// only a set with the exact name.  Only used during startup.
+
+
+extern	cvar_t	*com_developer;
+extern	cvar_t	*com_dedicated;
+extern	cvar_t	*com_speeds;
+extern	cvar_t	*com_timescale;
+extern	cvar_t	*com_sv_running;
+extern	cvar_t	*com_cl_running;
+extern	cvar_t	*com_version;
+extern	cvar_t	*com_blood;
+extern	cvar_t	*com_buildScript;		// for building release pak files
+extern	cvar_t	*com_journal;
+extern	cvar_t	*com_cameraMode;
+extern	cvar_t	*com_ansiColor;
+extern	cvar_t	*com_unfocused;
+extern	cvar_t	*com_maxfpsUnfocused;
+extern	cvar_t	*com_minimized;
+extern	cvar_t	*com_maxfpsMinimized;
+extern	cvar_t	*com_altivec;
+extern	cvar_t	*com_homepath;
+
+// both client and server must agree to pause
+extern	cvar_t	*cl_paused;
+extern	cvar_t	*sv_paused;
+
+extern	cvar_t	*cl_packetdelay;
+extern	cvar_t	*sv_packetdelay;
+
+// com_speeds times
+extern	int		time_game;
+extern	int		time_frontend;
+extern	int		time_backend;		// renderer backend time
+
+extern	int		com_frameTime;
+
+extern	qboolean	com_errorEntered;
+
+extern	fileHandle_t	com_journalFile;
+extern	fileHandle_t	com_journalDataFile;
+
+typedef enum {
+	TAG_FREE,
+	TAG_GENERAL,
+	TAG_BOTLIB,
+	TAG_RENDERER,
+	TAG_SMALL,
+	TAG_STATIC
+} memtag_t;
+
+/*
+
+--- low memory ----
+server vm
+server clipmap
+---mark---
+renderer initialization (shaders, etc)
+UI vm
+cgame vm
+renderer map
+renderer models
+
+---free---
+
+temp file loading
+--- high memory ---
+
+*/
+
+#if defined(_DEBUG) && !defined(BSPC)
+	#define ZONE_DEBUG
+#endif
+
+#ifdef ZONE_DEBUG
+#define Z_TagMalloc(size, tag)			Z_TagMallocDebug(size, tag, #size, __FILE__, __LINE__)
+#define Z_Malloc(size)					Z_MallocDebug(size, #size, __FILE__, __LINE__)
+#define S_Malloc(size)					S_MallocDebug(size, #size, __FILE__, __LINE__)
+void *Z_TagMallocDebug( int size, int tag, char *label, char *file, int line );	// NOT 0 filled memory
+void *Z_MallocDebug( int size, char *label, char *file, int line );			// returns 0 filled memory
+void *S_MallocDebug( int size, char *label, char *file, int line );			// returns 0 filled memory
+#else
+void *Z_TagMalloc( int size, int tag );	// NOT 0 filled memory
+void *Z_Malloc( int size );			// returns 0 filled memory
+void *S_Malloc( int size );			// NOT 0 filled memory only for small allocations
+#endif
+void Z_Free( void *ptr );
+void Z_FreeTags( int tag );
+int Z_AvailableMemory( void );
+void Z_LogHeap( void );
+
+void Hunk_Clear( void );
+void Hunk_ClearToMark( void );
+void Hunk_SetMark( void );
+qboolean Hunk_CheckMark( void );
+void Hunk_ClearTempMemory( void );
+void *Hunk_AllocateTempMemory( int size );
+void Hunk_FreeTempMemory( void *buf );
+int	Hunk_MemoryRemaining( void );
+void Hunk_Log( void);
+void Hunk_Trash( void );
+
+void Com_TouchMemory( void );
+
+// commandLine should not include the executable name (argv[0])
+void Com_Init( char *commandLine );
+void Com_Frame( void );
+void Com_Shutdown( void );
+
+
+/*
+==============================================================
+
+CLIENT / SERVER SYSTEMS
+
+==============================================================
+*/
+
+//
+// client interface
+//
+void CL_InitKeyCommands( void );
+// the keyboard binding interface must be setup before execing
+// config files, but the rest of client startup will happen later
+
+void CL_Init( void );
+void CL_Disconnect( qboolean showMainMenu );
+void CL_Shutdown( char *finalmsg );
+void CL_Frame( int msec );
+qboolean CL_GameCommand( void );
+void CL_KeyEvent (int key, qboolean down, unsigned time);
+
+void CL_CharEvent( int key );
+// char events are for field typing, not game control
+
+void CL_MouseEvent( int dx, int dy, int time );
+
+void CL_JoystickEvent( int axis, int value, int time );
+
+void CL_PacketEvent( netadr_t from, msg_t *msg );
+
+void CL_ConsolePrint( char *text );
+
+void CL_MapLoading( void );
+// do a screen update before starting to load a map
+// when the server is going to load a new map, the entire hunk
+// will be cleared, so the client must shutdown cgame, ui, and
+// the renderer
+
+void	CL_ForwardCommandToServer( const char *string );
+// adds the current command line as a clc_clientCommand to the client message.
+// things like godmode, noclip, etc, are commands directed to the server,
+// so when they are typed in at the console, they will need to be forwarded.
+
+void CL_CDDialog( void );
+// bring up the "need a cd to play" dialog
+
+void CL_ShutdownAll( void );
+// shutdown all the client stuff
+
+void CL_FlushMemory( void );
+// dump all memory on an error
+
+void CL_StartHunkUsers( qboolean rendererOnly );
+// start all the client stuff using the hunk
+
+void CL_Snd_Restart(void);
+// Restart sound subsystem
+
+void Key_KeynameCompletion( void(*callback)(const char *s) );
+// for keyname autocompletion
+
+void Key_WriteBindings( fileHandle_t f );
+// for writing the config files
+
+void S_ClearSoundBuffer( void );
+// call before filesystem access
+
+void SCR_DebugGraph (float value, int color);	// FIXME: move logging to common?
+
+// AVI files have the start of pixel lines 4 byte-aligned
+#define AVI_LINE_PADDING 4
+
+//
+// server interface
+//
+void SV_Init( void );
+void SV_Shutdown( char *finalmsg );
+void SV_Frame( int msec );
+void SV_PacketEvent( netadr_t from, msg_t *msg );
+int SV_FrameMsec(void);
+qboolean SV_GameCommand( void );
+
+
+//
+// UI interface
+//
+qboolean UI_GameCommand( void );
+
+/*
+==============================================================
+
+NON-PORTABLE SYSTEM SERVICES
+
+==============================================================
+*/
+
+typedef enum {
+	AXIS_SIDE,
+	AXIS_FORWARD,
+	AXIS_UP,
+	AXIS_ROLL,
+	AXIS_YAW,
+	AXIS_PITCH,
+	MAX_JOYSTICK_AXIS
+} joystickAxis_t;
+
+void	Sys_Init (void);
+
+// general development dll loading for virtual machine testing
+void	* QDECL Sys_LoadDll( const char *name, intptr_t (QDECL **entryPoint)(int, ...),
+				  intptr_t (QDECL *systemcalls)(intptr_t, ...) );
+void	Sys_UnloadDll( void *dllHandle );
+
+void	Sys_UnloadGame( void );
+void	*Sys_GetGameAPI( void *parms );
+
+void	Sys_UnloadCGame( void );
+void	*Sys_GetCGameAPI( void );
+
+void	Sys_UnloadUI( void );
+void	*Sys_GetUIAPI( void );
+
+//bot libraries
+void	Sys_UnloadBotLib( void );
+void	*Sys_GetBotLibAPI( void *parms );
+
+char	*Sys_GetCurrentUser( void );
+
+void	QDECL Sys_Error( const char *error, ...) __attribute__ ((format (printf, 1, 2)));
+void	Sys_Quit (void);
+char	*Sys_GetClipboardData( void );	// note that this isn't journaled...
+
+void	Sys_Print( const char *msg );
+
+// Sys_Milliseconds should only be used for profiling purposes,
+// any game related timing information should come from event timestamps
+int		Sys_Milliseconds (void);
+
+void	Sys_SnapVector( float *v );
+
+qboolean Sys_RandomBytes( byte *string, int len );
+
+// the system console is shown when a dedicated server is running
+void	Sys_DisplaySystemConsole( qboolean show );
+
+cpuFeatures_t Sys_GetProcessorFeatures( void );
+
+void	Sys_SetErrorText( const char *text );
+
+void	Sys_SendPacket( int length, const void *data, netadr_t to );
+
+qboolean	Sys_StringToAdr( const char *s, netadr_t *a, netadrtype_t family );
+//Does NOT parse port numbers, only base addresses.
+
+qboolean	Sys_IsLANAddress (netadr_t adr);
+void		Sys_ShowIP(void);
+
+qboolean Sys_Mkdir( const char *path );
+FILE	*Sys_Mkfifo( const char *ospath );
+char	*Sys_Cwd( void );
+void	Sys_SetDefaultInstallPath(const char *path);
+char	*Sys_DefaultInstallPath(void);
+
+#ifdef MACOS_X
+char    *Sys_DefaultAppPath(void);
+#endif
+
+void  Sys_SetDefaultHomePath(const char *path);
+char	*Sys_DefaultHomePath(void);
+const char	*Sys_TempPath(void);
+const char *Sys_Dirname( char *path );
+const char *Sys_Basename( char *path );
+char *Sys_ConsoleInput(void);
+
+char **Sys_ListFiles( const char *directory, const char *extension, char *filter, int *numfiles, qboolean wantsubs );
+void	Sys_FreeFileList( char **list );
+void	Sys_Sleep(int msec);
+
+qboolean Sys_LowPhysicalMemory( void );
+
+void Sys_SetEnv(const char *name, const char *value);
+
+typedef enum
+{
+	DR_YES = 0,
+	DR_NO = 1,
+	DR_OK = 0,
+	DR_CANCEL = 1
+} dialogResult_t;
+
+typedef enum
+{
+	DT_INFO,
+	DT_WARNING,
+	DT_ERROR,
+	DT_YES_NO,
+	DT_OK_CANCEL
+} dialogType_t;
+
+dialogResult_t Sys_Dialog( dialogType_t type, const char *message, const char *title );
+
+qboolean Sys_WritePIDFile( void );
+
+/* This is based on the Adaptive Huffman algorithm described in Sayood's Data
+ * Compression book.  The ranks are not actually stored, but implicitly defined
+ * by the location of a node within a doubly-linked list */
+
+#define NYT HMAX					/* NYT = Not Yet Transmitted */
+#define INTERNAL_NODE (HMAX+1)
+
+typedef struct nodetype {
+	struct	nodetype *left, *right, *parent; /* tree structure */ 
+	struct	nodetype *next, *prev; /* doubly-linked list */
+	struct	nodetype **head; /* highest ranked node in block */
+	int		weight;
+	int		symbol;
+} node_t;
+
+#define HMAX 256 /* Maximum symbol */
+
+typedef struct {
+	int			blocNode;
+	int			blocPtrs;
+
+	node_t*		tree;
+	node_t*		lhead;
+	node_t*		ltail;
+	node_t*		loc[HMAX+1];
+	node_t**	freelist;
+
+	node_t		nodeList[768];
+	node_t*		nodePtrs[768];
+} huff_t;
+
+typedef struct {
+	huff_t		compressor;
+	huff_t		decompressor;
+} huffman_t;
+
+void	Huff_Compress(msg_t *buf, int offset);
+void	Huff_Decompress(msg_t *buf, int offset);
+void	Huff_Init(huffman_t *huff);
+void	Huff_addRef(huff_t* huff, byte ch);
+int		Huff_Receive (node_t *node, int *ch, byte *fin);
+void	Huff_transmit (huff_t *huff, int ch, byte *fout);
+void	Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset);
+void	Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset);
+void	Huff_putBit( int bit, byte *fout, int *offset);
+int		Huff_getBit( byte *fout, int *offset);
+
+// don't use if you don't know what you're doing.
+int		Huff_getBloc(void);
+void	Huff_setBloc(int _bloc);
+
+extern huffman_t clientHuffTables;
+
+int		Parse_AddGlobalDefine(char *string);
+int		Parse_LoadSourceHandle(const char *filename);
+int		Parse_FreeSourceHandle(int handle);
+int		Parse_ReadTokenHandle(int handle, pc_token_t *pc_token);
+int		Parse_SourceFileAndLine(int handle, char *filename, int *line);
+
+#define	SV_ENCODE_START		4
+#define SV_DECODE_START		12
+#define	CL_ENCODE_START		12
+#define CL_DECODE_START		4
+
+// flags for sv_allowDownload and cl_allowDownload
+#define DLF_ENABLE 1
+#define DLF_NO_REDIRECT 2
+#define DLF_NO_UDP 4
+#define DLF_NO_DISCONNECT 8
+
+#endif // _QCOMMON_H_
diff -uNr tremulous-ggp1-src.p/src/qcommon/qfiles.h tremulous-ggp1-src/src/qcommon/qfiles.h
--- tremulous-ggp1-src.p/src/qcommon/qfiles.h	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/qcommon/qfiles.h	2012-07-19 04:25:52.041556450 +0200
@@ -36,8 +36,8 @@
 #endif
 
 // surface geometry should not exceed these limits
-#define	SHADER_MAX_VERTEXES	1000
-#define	SHADER_MAX_INDEXES	(6*SHADER_MAX_VERTEXES)
+//#define	SHADER_MAX_VERTEXES	1000
+//#define	SHADER_MAX_INDEXES	(6*SHADER_MAX_VERTEXES)
 
 
 // the maximum size of game relative pathnames
diff -uNr tremulous-ggp1-src.p/src/qcommon/q_shared.h tremulous-ggp1-src/src/qcommon/q_shared.h
--- tremulous-ggp1-src.p/src/qcommon/q_shared.h	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/qcommon/q_shared.h	2012-07-19 04:25:52.041556450 +0200
@@ -490,6 +490,7 @@
 #define VectorClear(a)			((a)[0]=(a)[1]=(a)[2]=0)
 #define VectorNegate(a,b)		((b)[0]=-(a)[0],(b)[1]=-(a)[1],(b)[2]=-(a)[2])
 #define VectorSet(v, x, y, z)	((v)[0]=(x), (v)[1]=(y), (v)[2]=(z))
+#define Vector2Copy(a,b)		((b)[0]=(a)[0],(b)[1]=(a)[1])
 #define Vector4Copy(a,b)		((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2],(b)[3]=(a)[3])
 #define Vector4Add(a,b,c)    ((c)[0]=(a)[0]+(b)[0],(c)[1]=(a)[1]+(b)[1],(c)[2]=(a)[2]+(b)[2],(c)[3]=(a)[3]+(b)[3])
 #define Vector4Lerp( f, s, e, r ) ((r)[0]=(s)[0]+(f)*((e)[0]-(s)[0]),\
diff -uNr tremulous-ggp1-src.p/src/qcommon/q_shared.h.orig tremulous-ggp1-src/src/qcommon/q_shared.h.orig
--- tremulous-ggp1-src.p/src/qcommon/q_shared.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/qcommon/q_shared.h.orig	2012-07-19 04:25:20.311556052 +0200
@@ -0,0 +1,1424 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+//
+#ifndef __Q_SHARED_H
+#define __Q_SHARED_H
+
+// q_shared.h -- included first by ALL program modules.
+// A user mod should never modify this file
+
+#define PRODUCT_NAME              "tremulous"
+
+#ifdef _MSC_VER
+# define PRODUCT_VERSION          "gpp1"
+#endif
+
+#define CLIENT_WINDOW_TITLE       "Tremulous " PRODUCT_VERSION
+#define CLIENT_WINDOW_MIN_TITLE   "Tremulous"
+#define Q3_VERSION                 PRODUCT_NAME " " PRODUCT_VERSION
+
+#define GAMENAME_FOR_MASTER       "Tremulous"
+#define HEARTBEAT_FOR_MASTER      GAMENAME_FOR_MASTER
+#define FLATLINE_FOR_MASTER       GAMENAME_FOR_MASTER "dead"
+
+#define MAX_TEAMNAME 32
+#define MAX_MASTER_SERVERS      5 // number of supported master servers
+
+#define DEMOEXT	"dm_"			// standard demo extension
+
+#ifdef _MSC_VER
+
+#pragma warning(disable : 4018)     // signed/unsigned mismatch
+#pragma warning(disable : 4032)
+#pragma warning(disable : 4051)
+#pragma warning(disable : 4057)		// slightly different base types
+#pragma warning(disable : 4100)		// unreferenced formal parameter
+#pragma warning(disable : 4115)
+#pragma warning(disable : 4125)		// decimal digit terminates octal escape sequence
+#pragma warning(disable : 4127)		// conditional expression is constant
+#pragma warning(disable : 4136)
+#pragma warning(disable : 4152)		// nonstandard extension, function/data pointer conversion in expression
+//#pragma warning(disable : 4201)
+//#pragma warning(disable : 4214)
+#pragma warning(disable : 4244)
+#pragma warning(disable : 4142)		// benign redefinition
+//#pragma warning(disable : 4305)		// truncation from const double to float
+//#pragma warning(disable : 4310)		// cast truncates constant value
+//#pragma warning(disable:  4505) 	// unreferenced local function has been removed
+#pragma warning(disable : 4514)
+#pragma warning(disable : 4702)		// unreachable code
+#pragma warning(disable : 4711)		// selected for automatic inline expansion
+#pragma warning(disable : 4220)		// varargs matches remaining parameters
+//#pragma intrinsic( memset, memcpy )
+#endif
+
+//Ignore __attribute__ on non-gcc platforms
+#ifndef __GNUC__
+#ifndef __attribute__
+#define __attribute__(x)
+#endif
+#endif
+
+#if (defined _MSC_VER)
+#define Q_EXPORT __declspec(dllexport)
+#elif (defined __SUNPRO_C)
+#define Q_EXPORT __global
+#elif ((__GNUC__ >= 3) && (!__EMX__) && (!sun))
+#define Q_EXPORT __attribute__((visibility("default")))
+#else
+#define Q_EXPORT
+#endif
+
+/**********************************************************************
+  VM Considerations
+
+  The VM can not use the standard system headers because we aren't really
+  using the compiler they were meant for.  We use bg_lib.h which contains
+  prototypes for the functions we define for our own use in bg_lib.c.
+
+  When writing mods, please add needed headers HERE, do not start including
+  stuff like <stdio.h> in the various .c files that make up each of the VMs
+  since you will be including system headers files can will have issues.
+
+  Remember, if you use a C library function that is not defined in bg_lib.c,
+  you will have to add your own version for support in the VM.
+
+ **********************************************************************/
+
+#ifdef Q3_VM
+
+#include "../game/bg_lib.h"
+
+typedef int intptr_t;
+
+#else
+
+#include <assert.h>
+#include <math.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdlib.h>
+#include <time.h>
+#include <ctype.h>
+#include <limits.h>
+
+#ifdef _MSC_VER
+  #include <io.h>
+
+  typedef __int64 int64_t;
+  typedef __int32 int32_t;
+  typedef __int16 int16_t;
+  typedef __int8 int8_t;
+  typedef unsigned __int64 uint64_t;
+  typedef unsigned __int32 uint32_t;
+  typedef unsigned __int16 uint16_t;
+  typedef unsigned __int8 uint8_t;
+
+  // vsnprintf is ISO/IEC 9899:1999
+  // abstracting this to make it portable
+  int Q_vsnprintf(char *str, size_t size, const char *format, va_list ap);
+#else
+  #include <stdint.h>
+
+  #define Q_vsnprintf vsnprintf
+  #define Q_snprintf snprintf
+#endif
+
+#endif
+
+
+#include "q_platform.h"
+
+//=============================================================
+
+typedef unsigned char 		byte;
+
+typedef enum {qfalse, qtrue}	qboolean;
+
+typedef union {
+	float f;
+	int i;
+	unsigned int ui;
+} floatint_t;
+
+typedef int		qhandle_t;
+typedef int		sfxHandle_t;
+typedef int		fileHandle_t;
+typedef int		clipHandle_t;
+
+#define PAD(x,y)	(((x)+(y)-1) & ~((y)-1))
+#define PADLEN(x,y)	(PAD((x), (y)) - (x))
+
+#ifdef __GNUC__
+#define QALIGN(x) __attribute__((aligned(x)))
+#else
+#define QALIGN(x)
+#endif
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+#define STRING(s)			#s
+// expand constants before stringifying them
+#define XSTRING(s)			STRING(s)
+
+#define	MAX_QINT			0x7fffffff
+#define	MIN_QINT			(-MAX_QINT-1)
+
+#define ARRAY_LEN(x)			(sizeof(x) / sizeof(*(x)))
+
+
+// angle indexes
+#define	PITCH				0		// up / down
+#define	YAW					1		// left / right
+#define	ROLL				2		// fall over
+
+// the game guarantees that no string from the network will ever
+// exceed MAX_STRING_CHARS
+#define	MAX_STRING_CHARS	1024	// max length of a string passed to Cmd_TokenizeString
+#define	MAX_STRING_TOKENS	1024	// max tokens resulting from Cmd_TokenizeString
+#define	MAX_TOKEN_CHARS		1024	// max length of an individual token
+
+#define	MAX_INFO_STRING		1024
+#define	MAX_INFO_KEY		  1024
+#define	MAX_INFO_VALUE		1024
+
+#define	BIG_INFO_STRING		8192  // used for system info key only
+#define	BIG_INFO_KEY		  8192
+#define	BIG_INFO_VALUE		8192
+
+#define	MAX_NEWS_STRING		10000
+
+#define	MAX_QPATH			64		// max length of a quake game pathname
+#ifdef PATH_MAX
+#define MAX_OSPATH			PATH_MAX
+#else
+#define	MAX_OSPATH			256		// max length of a filesystem pathname
+#endif
+
+#define	MAX_NAME_LENGTH			32		// max length of a client name
+#define	MAX_HOSTNAME_LENGTH	80		// max length of a host name
+
+#define	MAX_SAY_TEXT	150
+
+// paramters for command buffer stuffing
+typedef enum {
+	EXEC_NOW,			// don't return until completed, a VM should NEVER use this,
+						// because some commands might cause the VM to be unloaded...
+	EXEC_INSERT,		// insert at current position, but don't run yet
+	EXEC_APPEND			// add to end of the command buffer (normal case)
+} cbufExec_t;
+
+
+//
+// these aren't needed by any of the VMs.  put in another header?
+//
+#define	MAX_MAP_AREA_BYTES		32		// bit vector of area visibility
+
+
+// print levels from renderer (FIXME: set up for game / cgame?)
+typedef enum {
+	PRINT_ALL,
+	PRINT_DEVELOPER,		// only print when "developer 1"
+	PRINT_WARNING,
+	PRINT_ERROR
+} printParm_t;
+
+
+#ifdef ERR_FATAL
+#undef ERR_FATAL			// this is be defined in malloc.h
+#endif
+
+// parameters to the main Error routine
+typedef enum {
+	ERR_FATAL,					// exit the entire game with a popup window
+	ERR_DROP,					// print to console and disconnect from game
+	ERR_SERVERDISCONNECT,		// don't kill server
+	ERR_DISCONNECT,				// client disconnected from the server
+	ERR_NEED_CD					// pop up the need-cd dialog
+} errorParm_t;
+
+
+// font rendering values used by ui and cgame
+
+#define PROP_GAP_WIDTH			3
+#define PROP_SPACE_WIDTH		8
+#define PROP_HEIGHT				27
+#define PROP_SMALL_SIZE_SCALE	0.75
+
+#define BLINK_DIVISOR			200
+#define PULSE_DIVISOR			75
+
+#define UI_LEFT			0x00000000	// default
+#define UI_CENTER		0x00000001
+#define UI_RIGHT		0x00000002
+#define UI_FORMATMASK	0x00000007
+#define UI_SMALLFONT	0x00000010
+#define UI_BIGFONT		0x00000020	// default
+#define UI_GIANTFONT	0x00000040
+#define UI_DROPSHADOW	0x00000800
+#define UI_BLINK		0x00001000
+#define UI_INVERSE		0x00002000
+#define UI_PULSE		0x00004000
+
+#if defined(_DEBUG) && !defined(BSPC)
+	#define HUNK_DEBUG
+#endif
+
+typedef enum {
+	h_high,
+	h_low,
+	h_dontcare
+} ha_pref;
+
+#ifdef HUNK_DEBUG
+#define Hunk_Alloc( size, preference )				Hunk_AllocDebug(size, preference, #size, __FILE__, __LINE__)
+void *Hunk_AllocDebug( int size, ha_pref preference, char *label, char *file, int line );
+#else
+void *Hunk_Alloc( int size, ha_pref preference );
+#endif
+
+#define Com_Memset memset
+#define Com_Memcpy memcpy
+
+#define CIN_system	1
+#define CIN_loop	2
+#define	CIN_hold	4
+#define CIN_silent	8
+#define CIN_shader	16
+
+/*
+==============================================================
+
+MATHLIB
+
+==============================================================
+*/
+
+
+typedef float vec_t;
+typedef vec_t vec2_t[2];
+typedef vec_t vec3_t[3];
+typedef vec_t vec4_t[4];
+typedef vec_t vec5_t[5];
+
+typedef	int	fixed4_t;
+typedef	int	fixed8_t;
+typedef	int	fixed16_t;
+
+#ifndef M_PI
+#define M_PI		3.14159265358979323846f	// matches value in gcc v2 math.h
+#endif
+
+#ifndef M_SQRT2
+#define M_SQRT2 1.414213562f
+#endif
+
+#ifndef M_ROOT3
+#define M_ROOT3 1.732050808f
+#endif
+
+#define NUMVERTEXNORMALS	162
+extern	vec3_t	bytedirs[NUMVERTEXNORMALS];
+
+// all drawing is done to a 640*480 virtual screen size
+// and will be automatically scaled to the real resolution
+#define	SCREEN_WIDTH		640
+#define	SCREEN_HEIGHT		480
+
+#define TINYCHAR_WIDTH		(SMALLCHAR_WIDTH)
+#define TINYCHAR_HEIGHT		(SMALLCHAR_HEIGHT/2)
+
+#define SMALLCHAR_WIDTH		8
+#define SMALLCHAR_HEIGHT	16
+
+#define BIGCHAR_WIDTH		16
+#define BIGCHAR_HEIGHT		16
+
+#define	GIANTCHAR_WIDTH		32
+#define	GIANTCHAR_HEIGHT	48
+
+extern	vec4_t		colorBlack;
+extern	vec4_t		colorRed;
+extern	vec4_t		colorGreen;
+extern	vec4_t		colorBlue;
+extern	vec4_t		colorYellow;
+extern	vec4_t		colorMagenta;
+extern	vec4_t		colorCyan;
+extern	vec4_t		colorWhite;
+extern	vec4_t		colorLtGrey;
+extern	vec4_t		colorMdGrey;
+extern	vec4_t		colorDkGrey;
+
+#define Q_COLOR_ESCAPE	'^'
+#define Q_IsColorString(p)	((p) && *(p) == Q_COLOR_ESCAPE && *((p)+1) && isalnum(*((p)+1))) // ^[0-9a-zA-Z]
+
+#define COLOR_BLACK	'0'
+#define COLOR_RED	'1'
+#define COLOR_GREEN	'2'
+#define COLOR_YELLOW	'3'
+#define COLOR_BLUE	'4'
+#define COLOR_CYAN	'5'
+#define COLOR_MAGENTA	'6'
+#define COLOR_WHITE	'7'
+#define ColorIndex(c)	(((c) - '0') & 0x07)
+
+#define S_COLOR_BLACK	"^0"
+#define S_COLOR_RED	"^1"
+#define S_COLOR_GREEN	"^2"
+#define S_COLOR_YELLOW	"^3"
+#define S_COLOR_BLUE	"^4"
+#define S_COLOR_CYAN	"^5"
+#define S_COLOR_MAGENTA	"^6"
+#define S_COLOR_WHITE	"^7"
+
+#define INDENT_MARKER '\v'
+void Q_StripIndentMarker(char *string);
+
+extern vec4_t	g_color_table[8];
+
+#define	MAKERGB( v, r, g, b ) v[0]=r;v[1]=g;v[2]=b
+#define	MAKERGBA( v, r, g, b, a ) v[0]=r;v[1]=g;v[2]=b;v[3]=a
+
+#define DEG2RAD( a ) ( ( (a) * M_PI ) / 180.0F )
+#define RAD2DEG( a ) ( ( (a) * 180.0f ) / M_PI )
+
+struct cplane_s;
+
+extern	vec3_t	vec3_origin;
+extern	vec3_t	axisDefault[3];
+
+#define	nanmask (255<<23)
+
+#define	IS_NAN(x) (((*(int *)&x)&nanmask)==nanmask)
+
+#if idppc
+
+static ID_INLINE float Q_rsqrt( float number ) {
+		float x = 0.5f * number;
+                float y;
+#ifdef __GNUC__            
+                asm("frsqrte %0,%1" : "=f" (y) : "f" (number));
+#else
+		y = __frsqrte( number );
+#endif
+		return y * (1.5f - (x * y * y));
+	}
+
+#ifdef __GNUC__            
+static ID_INLINE float Q_fabs(float x) {
+    float abs_x;
+    
+    asm("fabs %0,%1" : "=f" (abs_x) : "f" (x));
+    return abs_x;
+}
+#else
+#define Q_fabs __fabsf
+#endif
+
+#else
+float Q_fabs( float f );
+float Q_rsqrt( float f );		// reciprocal square root
+#endif
+
+#define SQRTFAST( x ) ( (x) * Q_rsqrt( x ) )
+
+signed char ClampChar( int i );
+signed short ClampShort( int i );
+
+// this isn't a real cheap function to call!
+int DirToByte( vec3_t dir );
+void ByteToDir( int b, vec3_t dir );
+
+#if	1
+
+#define DotProduct(x,y)			((x)[0]*(y)[0]+(x)[1]*(y)[1]+(x)[2]*(y)[2])
+#define VectorSubtract(a,b,c)	((c)[0]=(a)[0]-(b)[0],(c)[1]=(a)[1]-(b)[1],(c)[2]=(a)[2]-(b)[2])
+#define VectorAdd(a,b,c)		((c)[0]=(a)[0]+(b)[0],(c)[1]=(a)[1]+(b)[1],(c)[2]=(a)[2]+(b)[2])
+#define VectorCopy(a,b)			((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2])
+#define	VectorScale(v, s, o)	((o)[0]=(v)[0]*(s),(o)[1]=(v)[1]*(s),(o)[2]=(v)[2]*(s))
+#define	VectorMA(v, s, b, o)	((o)[0]=(v)[0]+(b)[0]*(s),(o)[1]=(v)[1]+(b)[1]*(s),(o)[2]=(v)[2]+(b)[2]*(s))
+#define VectorLerp( f, s, e, r ) ((r)[0]=(s)[0]+(f)*((e)[0]-(s)[0]),\
+  (r)[1]=(s)[1]+(f)*((e)[1]-(s)[1]),\
+  (r)[2]=(s)[2]+(f)*((e)[2]-(s)[2])) 
+
+#else
+
+#define DotProduct(x,y)			_DotProduct(x,y)
+#define VectorSubtract(a,b,c)	_VectorSubtract(a,b,c)
+#define VectorAdd(a,b,c)		_VectorAdd(a,b,c)
+#define VectorCopy(a,b)			_VectorCopy(a,b)
+#define	VectorScale(v, s, o)	_VectorScale(v,s,o)
+#define	VectorMA(v, s, b, o)	_VectorMA(v,s,b,o)
+
+#endif
+
+#ifdef Q3_VM
+#ifdef VectorCopy
+#undef VectorCopy
+// this is a little hack to get more efficient copies in our interpreter
+typedef struct {
+	float	v[3];
+} vec3struct_t;
+#define VectorCopy(a,b)	(*(vec3struct_t *)b=*(vec3struct_t *)a)
+#endif
+#endif
+
+#define Vector2Set(v, x, y) ((v)[0]=(x), (v)[1]=(y))
+#define VectorClear(a)			((a)[0]=(a)[1]=(a)[2]=0)
+#define VectorNegate(a,b)		((b)[0]=-(a)[0],(b)[1]=-(a)[1],(b)[2]=-(a)[2])
+#define VectorSet(v, x, y, z)	((v)[0]=(x), (v)[1]=(y), (v)[2]=(z))
+#define Vector4Copy(a,b)		((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2],(b)[3]=(a)[3])
+#define Vector4Add(a,b,c)    ((c)[0]=(a)[0]+(b)[0],(c)[1]=(a)[1]+(b)[1],(c)[2]=(a)[2]+(b)[2],(c)[3]=(a)[3]+(b)[3])
+#define Vector4Lerp( f, s, e, r ) ((r)[0]=(s)[0]+(f)*((e)[0]-(s)[0]),\
+  (r)[1]=(s)[1]+(f)*((e)[1]-(s)[1]),\
+  (r)[2]=(s)[2]+(f)*((e)[2]-(s)[2]),\
+  (r)[3]=(s)[3]+(f)*((e)[3]-(s)[3]))
+
+#define SnapVector(v) ( (v)[0] = (int)(v)[0],\
+                        (v)[1] = (int)(v)[1],\
+                        (v)[2] = (int)(v)[2] )
+
+// just in case you do't want to use the macros
+vec_t _DotProduct( const vec3_t v1, const vec3_t v2 );
+void _VectorSubtract( const vec3_t veca, const vec3_t vecb, vec3_t out );
+void _VectorAdd( const vec3_t veca, const vec3_t vecb, vec3_t out );
+void _VectorCopy( const vec3_t in, vec3_t out );
+void _VectorScale( const vec3_t in, float scale, vec3_t out );
+void _VectorMA( const vec3_t veca, float scale, const vec3_t vecb, vec3_t vecc );
+
+unsigned ColorBytes3 (float r, float g, float b);
+unsigned ColorBytes4 (float r, float g, float b, float a);
+
+float NormalizeColor( const vec3_t in, vec3_t out );
+
+float RadiusFromBounds( const vec3_t mins, const vec3_t maxs );
+void ClearBounds( vec3_t mins, vec3_t maxs );
+void AddPointToBounds( const vec3_t v, vec3_t mins, vec3_t maxs );
+
+#if !defined( Q3_VM ) || ( defined( Q3_VM ) && defined( __Q3_VM_MATH ) )
+static ID_INLINE int VectorCompare( const vec3_t v1, const vec3_t v2 ) {
+	if (v1[0] != v2[0] || v1[1] != v2[1] || v1[2] != v2[2]) {
+		return 0;
+	}			
+	return 1;
+}
+
+static ID_INLINE int VectorCompareEpsilon(
+		const vec3_t v1, const vec3_t v2, float epsilon )
+{
+	vec3_t d;
+
+	VectorSubtract( v1, v2, d );
+	d[ 0 ] = fabs( d[ 0 ] );
+	d[ 1 ] = fabs( d[ 1 ] );
+	d[ 2 ] = fabs( d[ 2 ] );
+
+	if( d[ 0 ] > epsilon || d[ 1 ] > epsilon || d[ 2 ] > epsilon )
+		return 0;
+
+	return 1;
+}
+
+static ID_INLINE vec_t VectorLength( const vec3_t v ) {
+	return (vec_t)sqrt (v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
+}
+
+static ID_INLINE vec_t VectorLengthSquared( const vec3_t v ) {
+	return (v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
+}
+
+static ID_INLINE vec_t Distance( const vec3_t p1, const vec3_t p2 ) {
+	vec3_t	v;
+
+	VectorSubtract (p2, p1, v);
+	return VectorLength( v );
+}
+
+static ID_INLINE vec_t DistanceSquared( const vec3_t p1, const vec3_t p2 ) {
+	vec3_t	v;
+
+	VectorSubtract (p2, p1, v);
+	return v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
+}
+
+// fast vector normalize routine that does not check to make sure
+// that length != 0, nor does it return length, uses rsqrt approximation
+static ID_INLINE void VectorNormalizeFast( vec3_t v )
+{
+	float ilength;
+
+	ilength = Q_rsqrt( DotProduct( v, v ) );
+
+	v[0] *= ilength;
+	v[1] *= ilength;
+	v[2] *= ilength;
+}
+
+static ID_INLINE void VectorInverse( vec3_t v ){
+	v[0] = -v[0];
+	v[1] = -v[1];
+	v[2] = -v[2];
+}
+
+static ID_INLINE void CrossProduct( const vec3_t v1, const vec3_t v2, vec3_t cross ) {
+	cross[0] = v1[1]*v2[2] - v1[2]*v2[1];
+	cross[1] = v1[2]*v2[0] - v1[0]*v2[2];
+	cross[2] = v1[0]*v2[1] - v1[1]*v2[0];
+}
+
+#else
+int VectorCompare( const vec3_t v1, const vec3_t v2 );
+
+vec_t VectorLength( const vec3_t v );
+
+vec_t VectorLengthSquared( const vec3_t v );
+
+vec_t Distance( const vec3_t p1, const vec3_t p2 );
+
+vec_t DistanceSquared( const vec3_t p1, const vec3_t p2 );
+
+void VectorNormalizeFast( vec3_t v );
+
+void VectorInverse( vec3_t v );
+
+void CrossProduct( const vec3_t v1, const vec3_t v2, vec3_t cross );
+
+#endif
+
+vec_t VectorNormalize (vec3_t v);		// returns vector length
+vec_t VectorNormalize2( const vec3_t v, vec3_t out );
+void Vector4Scale( const vec4_t in, vec_t scale, vec4_t out );
+void VectorRotate( vec3_t in, vec3_t matrix[3], vec3_t out );
+int Q_log2(int val);
+
+float Q_acos(float c);
+
+int		Q_rand( int *seed );
+float	Q_random( int *seed );
+float	Q_crandom( int *seed );
+
+#define random()	((rand () & 0x7fff) / ((float)0x7fff))
+#define crandom()	(2.0 * (random() - 0.5))
+
+void vectoangles( const vec3_t value1, vec3_t angles);
+void AnglesToAxis( const vec3_t angles, vec3_t axis[3] );
+void AxisToAngles( vec3_t axis[3], vec3_t angles );
+
+void AxisClear( vec3_t axis[3] );
+void AxisCopy( vec3_t in[3], vec3_t out[3] );
+
+void SetPlaneSignbits( struct cplane_s *out );
+int BoxOnPlaneSide (vec3_t emins, vec3_t emaxs, struct cplane_s *plane);
+
+qboolean BoundsIntersect(const vec3_t mins, const vec3_t maxs,
+		const vec3_t mins2, const vec3_t maxs2);
+qboolean BoundsIntersectSphere(const vec3_t mins, const vec3_t maxs,
+		const vec3_t origin, vec_t radius);
+qboolean BoundsIntersectPoint(const vec3_t mins, const vec3_t maxs,
+		const vec3_t origin);
+
+float	AngleMod(float a);
+float	LerpAngle (float from, float to, float frac);
+float	AngleSubtract( float a1, float a2 );
+void	AnglesSubtract( vec3_t v1, vec3_t v2, vec3_t v3 );
+
+float AngleNormalize360 ( float angle );
+float AngleNormalize180 ( float angle );
+float AngleDelta ( float angle1, float angle2 );
+
+qboolean PlaneFromPoints( vec4_t plane, const vec3_t a, const vec3_t b, const vec3_t c );
+void ProjectPointOnPlane( vec3_t dst, const vec3_t p, const vec3_t normal );
+void RotatePointAroundVector( vec3_t dst, const vec3_t dir, const vec3_t point, float degrees );
+void RotateAroundDirection( vec3_t axis[3], vec_t angle );
+void MakeNormalVectors( const vec3_t forward, vec3_t right, vec3_t up );
+// perpendicular vector could be replaced by this
+
+//int	PlaneTypeForNormal (vec3_t normal);
+
+void MatrixMultiply(float in1[3][3], float in2[3][3], float out[3][3]);
+void VectorMatrixMultiply( const vec3_t p, vec3_t m[ 3 ], vec3_t out );
+void AngleVectors( const vec3_t angles, vec3_t forward, vec3_t right, vec3_t up);
+void PerpendicularVector( vec3_t dst, const vec3_t src );
+int Q_isnan( float x );
+
+void GetPerpendicularViewVector( const vec3_t point, const vec3_t p1,
+		const vec3_t p2, vec3_t up );
+void ProjectPointOntoVector( vec3_t point, vec3_t vStart,
+		vec3_t vEnd, vec3_t vProj );
+float VectorDistance( vec3_t v1, vec3_t v2 );
+
+float pointToLineDistance( const vec3_t point, const vec3_t p1, const vec3_t p2 );
+float VectorMinComponent( vec3_t v );
+float VectorMaxComponent( vec3_t v );
+
+vec_t DistanceBetweenLineSegmentsSquared(
+    const vec3_t sP0, const vec3_t sP1,
+    const vec3_t tP0, const vec3_t tP1,
+    float *s, float *t );
+vec_t DistanceBetweenLineSegments(
+    const vec3_t sP0, const vec3_t sP1,
+    const vec3_t tP0, const vec3_t tP1,
+    float *s, float *t );
+
+#ifndef MAX
+#define MAX(x,y) ((x)>(y)?(x):(y))
+#endif
+
+#ifndef MIN
+#define MIN(x,y) ((x)<(y)?(x):(y))
+#endif
+
+//=============================================
+
+float Com_Clamp( float min, float max, float value );
+
+char	*COM_SkipPath( char *pathname );
+const char	*COM_GetExtension( const char *name );
+void	COM_StripExtension(const char *in, char *out, int destsize);
+void	COM_DefaultExtension( char *path, int maxSize, const char *extension );
+
+void	COM_BeginParseSession( const char *name );
+int		COM_GetCurrentParseLine( void );
+char	*COM_Parse( char **data_p );
+char	*COM_ParseExt( char **data_p, qboolean allowLineBreak );
+int		COM_Compress( char *data_p );
+void	COM_ParseError( char *format, ... ) __attribute__ ((format (printf, 1, 2)));
+void	COM_ParseWarning( char *format, ... ) __attribute__ ((format (printf, 1, 2)));
+//int		COM_ParseInfos( char *buf, int max, char infos[][MAX_INFO_STRING] );
+
+#define MAX_TOKENLENGTH		1024
+
+#ifndef TT_STRING
+//token types
+#define TT_STRING					1			// string
+#define TT_LITERAL					2			// literal
+#define TT_NUMBER					3			// number
+#define TT_NAME						4			// name
+#define TT_PUNCTUATION				5			// punctuation
+#endif
+
+typedef struct pc_token_s
+{
+	int type;
+	int subtype;
+	int intvalue;
+	float floatvalue;
+	char string[MAX_TOKENLENGTH];
+} pc_token_t;
+
+// data is an in/out parm, returns a parsed out token
+
+void	COM_MatchToken( char**buf_p, char *match );
+
+void SkipBracedSection (char **program);
+void SkipRestOfLine ( char **data );
+
+void Parse1DMatrix (char **buf_p, int x, float *m);
+void Parse2DMatrix (char **buf_p, int y, int x, float *m);
+void Parse3DMatrix (char **buf_p, int z, int y, int x, float *m);
+int Com_HexStrToInt( const char *str );
+
+void	QDECL Com_sprintf (char *dest, int size, const char *fmt, ...) __attribute__ ((format (printf, 3, 4)));
+
+char *Com_SkipTokens( char *s, int numTokens, char *sep );
+char *Com_SkipCharset( char *s, char *sep );
+
+void Com_RandomBytes( byte *string, int len );
+
+typedef struct 
+{
+  unsigned int hi;
+  unsigned int lo;
+} clientList_t;
+
+qboolean Com_ClientListContains( const clientList_t *list, int clientNum );
+void Com_ClientListAdd( clientList_t *list, int clientNum );
+void Com_ClientListRemove( clientList_t *list, int clientNum );
+char *Com_ClientListString( const clientList_t *list );
+void Com_ClientListParse( clientList_t *list, const char *s );
+
+// mode parm for FS_FOpenFile
+typedef enum {
+	FS_READ,
+	FS_WRITE,
+	FS_APPEND,
+	FS_APPEND_SYNC
+} fsMode_t;
+
+typedef enum {
+	FS_SEEK_CUR,
+	FS_SEEK_END,
+	FS_SEEK_SET
+} fsOrigin_t;
+
+//=============================================
+
+int Q_isprint( int c );
+int Q_islower( int c );
+int Q_isupper( int c );
+int Q_isalpha( int c );
+qboolean Q_isanumber( const char *s );
+qboolean Q_isintegral( float f );
+
+// portable case insensitive compare
+int		Q_stricmp (const char *s1, const char *s2);
+int		Q_strncmp (const char *s1, const char *s2, int n);
+int		Q_stricmpn (const char *s1, const char *s2, int n);
+char	*Q_strlwr( char *s1 );
+char	*Q_strupr( char *s1 );
+char	*Q_strrchr( const char* string, int c );
+const char	*Q_stristr( const char *s, const char *find);
+
+// buffer size safe library replacements
+void	Q_strncpyz( char *dest, const char *src, int destsize );
+void	Q_strcat( char *dest, int size, const char *src );
+
+// strlen that discounts Quake color sequences
+int Q_PrintStrlen( const char *string );
+// removes color sequences from string
+char *Q_CleanStr( char *string );
+// parse "\n" into '\n'
+void Q_ParseNewlines( char *dest, const char *src, int destsize );
+// Count the number of char tocount encountered in string
+int Q_CountChar(const char *string, char tocount);
+
+//=============================================
+
+// 64-bit integers for global rankings interface
+// implemented as a struct for qvm compatibility
+typedef struct
+{
+	byte	b0;
+	byte	b1;
+	byte	b2;
+	byte	b3;
+	byte	b4;
+	byte	b5;
+	byte	b6;
+	byte	b7;
+} qint64;
+
+//=============================================
+/*
+short	BigShort(short l);
+short	LittleShort(short l);
+int		BigLong (int l);
+int		LittleLong (int l);
+qint64  BigLong64 (qint64 l);
+qint64  LittleLong64 (qint64 l);
+float	BigFloat (const float *l);
+float	LittleFloat (const float *l);
+
+void	Swap_Init (void);
+*/
+char	* QDECL va(char *format, ...) __attribute__ ((format (printf, 1, 2)));
+
+#define TRUNCATE_LENGTH	64
+void Com_TruncateLongString( char *buffer, const char *s );
+
+//=============================================
+
+//
+// key / value info strings
+//
+char *Info_ValueForKey( const char *s, const char *key );
+void Info_RemoveKey( char *s, const char *key );
+void Info_RemoveKey_big( char *s, const char *key );
+void Info_SetValueForKey( char *s, const char *key, const char *value );
+void Info_SetValueForKey_Big( char *s, const char *key, const char *value );
+qboolean Info_Validate( const char *s );
+void Info_NextPair( const char **s, char *key, char *value );
+
+// this is only here so the functions in q_shared.c and bg_*.c can link
+void	QDECL Com_Error( int level, const char *error, ... ) __attribute__ ((format (printf, 2, 3)));
+void	QDECL Com_Printf( const char *msg, ... ) __attribute__ ((format (printf, 1, 2)));
+
+
+/*
+==========================================================
+
+CVARS (console variables)
+
+Many variables can be used for cheating purposes, so when
+cheats is zero, force all unspecified variables to their
+default values.
+==========================================================
+*/
+
+#define	CVAR_ARCHIVE		0x0001	// set to cause it to be saved to vars.rc
+					// used for system variables, not for player
+					// specific configurations
+#define	CVAR_USERINFO		0x0002	// sent to server on connect or change
+#define	CVAR_SERVERINFO		0x0004	// sent in response to front end requests
+#define	CVAR_SYSTEMINFO		0x0008	// these cvars will be duplicated on all clients
+#define	CVAR_INIT		0x0010	// don't allow change from console at all,
+					// but can be set from the command line
+#define	CVAR_LATCH		0x0020	// will only change when C code next does
+					// a Cvar_Get(), so it can't be changed
+					// without proper initialization.  modified
+					// will be set, even though the value hasn't
+					// changed yet
+#define	CVAR_ROM		0x0040	// display only, cannot be set by user at all
+#define	CVAR_USER_CREATED	0x0080	// created by a set command
+#define	CVAR_TEMP		0x0100	// can be set even when cheats are disabled, but is not archived
+#define CVAR_CHEAT		0x0200	// can not be changed if cheats are disabled
+#define CVAR_NORESTART		0x0400	// do not clear when a cvar_restart is issued
+
+#define CVAR_SERVER_CREATED	0x0800	// cvar was created by a server the client connected to.
+#define CVAR_VM_CREATED		0x1000	// cvar was created exclusively in one of the VMs.
+#define CVAR_PROTECTED		0x2000	// prevent modifying this var from VMs or the server
+#define CVAR_NONEXISTENT	0xFFFFFFFF	// Cvar doesn't exist.
+
+// nothing outside the Cvar_*() functions should modify these fields!
+typedef struct cvar_s cvar_t;
+
+struct cvar_s {
+	char			*name;
+	char			*string;
+	char			*resetString;		// cvar_restart will reset to this value
+	char			*latchedString;		// for CVAR_LATCH vars
+	int				flags;
+	qboolean	modified;			// set each time the cvar is changed
+	int				modificationCount;	// incremented each time the cvar is changed
+	float			value;				// atof( string )
+	int				integer;			// atoi( string )
+	qboolean	validate;
+	qboolean	integral;
+	float			min;
+	float			max;
+
+	cvar_t *next;
+	cvar_t *prev;
+	cvar_t *hashNext;
+	cvar_t *hashPrev;
+	int			hashIndex;
+};
+
+#define	MAX_CVAR_VALUE_STRING	256
+
+typedef int	cvarHandle_t;
+
+// the modules that run in the virtual machine can't access the cvar_t directly,
+// so they must ask for structured updates
+typedef struct {
+	cvarHandle_t	handle;
+	int			modificationCount;
+	float		value;
+	int			integer;
+	char		string[MAX_CVAR_VALUE_STRING];
+} vmCvar_t;
+
+/*
+==============================================================
+
+COLLISION DETECTION
+
+==============================================================
+*/
+
+#include "surfaceflags.h"			// shared with the q3map utility
+
+// plane types are used to speed some tests
+// 0-2 are axial planes
+#define	PLANE_X			0
+#define	PLANE_Y			1
+#define	PLANE_Z			2
+#define	PLANE_NON_AXIAL	3
+
+
+/*
+=================
+PlaneTypeForNormal
+=================
+*/
+
+#define PlaneTypeForNormal(x) (x[0] == 1.0 ? PLANE_X : (x[1] == 1.0 ? PLANE_Y : (x[2] == 1.0 ? PLANE_Z : PLANE_NON_AXIAL) ) )
+
+// plane_t structure
+// !!! if this is changed, it must be changed in asm code too !!!
+typedef struct cplane_s {
+	vec3_t	normal;
+	float	dist;
+	byte	type;			// for fast side tests: 0,1,2 = axial, 3 = nonaxial
+	byte	signbits;		// signx + (signy<<1) + (signz<<2), used as lookup during collision
+	byte	pad[2];
+} cplane_t;
+
+typedef enum {
+	TT_NONE,
+
+	TT_AABB,
+	TT_CAPSULE,
+	TT_BISPHERE,
+
+	TT_NUM_TRACE_TYPES
+} traceType_t;
+
+// a trace is returned when a box is swept through the world
+typedef struct {
+	qboolean	allsolid;	// if true, plane is not valid
+	qboolean	startsolid;	// if true, the initial point was in a solid area
+	float		fraction;	// time completed, 1.0 = didn't hit anything
+	vec3_t		endpos;		// final position
+	cplane_t	plane;		// surface normal at impact, transformed to world space
+	int			surfaceFlags;	// surface hit
+	int			contents;	// contents on other side of surface hit
+	int			entityNum;	// entity the contacted sirface is a part of
+	float		lateralFraction; // fraction of collision tangetially to the trace direction
+} trace_t;
+
+// trace->entityNum can also be 0 to (MAX_GENTITIES-1)
+// or ENTITYNUM_NONE, ENTITYNUM_WORLD
+
+
+// markfragments are returned by CM_MarkFragments()
+typedef struct {
+	int		firstPoint;
+	int		numPoints;
+} markFragment_t;
+
+
+
+typedef struct {
+	vec3_t		origin;
+	vec3_t		axis[3];
+} orientation_t;
+
+//=====================================================================
+
+
+// in order from highest priority to lowest
+// if none of the catchers are active, bound key strings will be executed
+#define KEYCATCH_CONSOLE		0x0001
+#define	KEYCATCH_UI					0x0002
+#define	KEYCATCH_CGAME			0x0008
+
+
+// sound channels
+// channel 0 never willingly overrides
+// other channels will allways override a playing sound on that channel
+typedef enum {
+	CHAN_AUTO,
+	CHAN_LOCAL,		// menu sounds, etc
+	CHAN_WEAPON,
+	CHAN_VOICE,
+	CHAN_ITEM,
+	CHAN_BODY,
+	CHAN_LOCAL_SOUND,	// chat messages, etc
+	CHAN_ANNOUNCER		// announcer voices, etc
+} soundChannel_t;
+
+
+/*
+========================================================================
+
+  ELEMENTS COMMUNICATED ACROSS THE NET
+
+========================================================================
+*/
+
+#define	ANGLE2SHORT(x)	((int)((x)*65536/360) & 65535)
+#define	SHORT2ANGLE(x)	((x)*(360.0/65536))
+
+#define	SNAPFLAG_RATE_DELAYED	1
+#define	SNAPFLAG_NOT_ACTIVE		2	// snapshot used during connection and for zombies
+#define SNAPFLAG_SERVERCOUNT	4	// toggled every map_restart so transitions can be detected
+
+//
+// per-level limits
+//
+#define	MAX_CLIENTS			64		// absolute limit
+#define MAX_LOCATIONS		64
+
+#define	GENTITYNUM_BITS		10		// don't need to send any more
+#define	MAX_GENTITIES		(1<<GENTITYNUM_BITS)
+#define GENTITYNUM_MASK		(MAX_GENTITIES - 1)
+
+// entitynums are communicated with GENTITY_BITS, so any reserved
+// values that are going to be communcated over the net need to
+// also be in this range
+#define	ENTITYNUM_NONE		(MAX_GENTITIES-1)
+#define	ENTITYNUM_WORLD		(MAX_GENTITIES-2)
+#define	ENTITYNUM_MAX_NORMAL	(MAX_GENTITIES-2)
+
+
+#define	MAX_MODELS									256		// these are sent over the net as 8 bits
+#define	MAX_SOUNDS									256		// so they cannot be blindly increased
+#define	MAX_GAME_SHADERS						64
+#define	MAX_GAME_PARTICLE_SYSTEMS		64
+
+
+#define	MAX_CONFIGSTRINGS	1024
+
+// these are the only configstrings that the system reserves, all the
+// other ones are strictly for servergame to clientgame communication
+#define	CS_SERVERINFO		0		// an info string with all the serverinfo cvars
+#define	CS_SYSTEMINFO		1		// an info string for server system to client system configuration (timescale, etc)
+
+#define	RESERVED_CONFIGSTRINGS	2	// game can't modify below this, only the system can
+
+#define	MAX_GAMESTATE_CHARS	16000
+typedef struct {
+	int			stringOffsets[MAX_CONFIGSTRINGS];
+	char		stringData[MAX_GAMESTATE_CHARS];
+	int			dataCount;
+} gameState_t;
+
+//=========================================================
+
+// bit field limits
+#define	MAX_STATS				16
+#define	MAX_PERSISTANT			16
+#define	MAX_MISC    			16
+#define	MAX_WEAPONS				16		
+
+#define	MAX_PS_EVENTS			2
+
+#define PS_PMOVEFRAMECOUNTBITS	6
+
+// playerState_t is the information needed by both the client and server
+// to predict player motion and actions
+// nothing outside of pmove should modify these, or some degree of prediction error
+// will occur
+
+// you can't add anything to this without modifying the code in msg.c
+
+// playerState_t is a full superset of entityState_t as it is used by players,
+// so if a playerState_t is transmitted, the entityState_t can be fully derived
+// from it.
+typedef struct playerState_s {
+	int			commandTime;	// cmd->serverTime of last executed command
+	int			pm_type;
+	int			bobCycle;		// for view bobbing and footstep generation
+	int			pm_flags;		// ducked, jump_held, etc
+	int			pm_time;
+
+	vec3_t		origin;
+	vec3_t		velocity;
+	int			weaponTime;
+	int			gravity;
+	int			speed;
+	int			delta_angles[3];	// add to command angles to get view direction
+									// changed by spawns, rotating objects, and teleporters
+
+	int			groundEntityNum;// ENTITYNUM_NONE = in air
+
+	int			legsTimer;		// don't change low priority animations until this runs out
+	int			legsAnim;		// mask off ANIM_TOGGLEBIT
+
+	int			torsoTimer;		// don't change low priority animations until this runs out
+	int			torsoAnim;		// mask off ANIM_TOGGLEBIT
+
+	int			tauntTimer;		// don't allow another taunt until this runs out
+
+	int			weaponAnim;		// mask off ANIM_TOGGLEBIT
+
+	int			movementDir;	// a number 0 to 7 that represents the reletive angle
+								// of movement to the view angle (axial and diagonals)
+								// when at rest, the value will remain unchanged
+								// used to twist the legs during strafing
+
+	vec3_t		grapplePoint;	// location of grapple to pull towards if PMF_GRAPPLE_PULL
+
+	int			eFlags;			// copied to entityState_t->eFlags
+
+	int			eventSequence;	// pmove generated events
+	int			events[MAX_PS_EVENTS];
+	int			eventParms[MAX_PS_EVENTS];
+
+	int			externalEvent;	// events set on player from another source
+	int			externalEventParm;
+	int			externalEventTime;
+
+	int			clientNum;		// ranges from 0 to MAX_CLIENTS-1
+	int			weapon;			// copied to entityState_t->weapon
+	int			weaponstate;
+
+	vec3_t		viewangles;		// for fixed views
+	int			viewheight;
+
+	// damage feedback
+	int			damageEvent;	// when it changes, latch the other parms
+	int			damageYaw;
+	int			damagePitch;
+	int			damageCount;
+
+	int			stats[MAX_STATS];
+	int			persistant[MAX_PERSISTANT];	// stats that aren't cleared on death
+	int			misc[MAX_MISC];	// misc data
+	int			ammo;			// ammo held
+	int			clips;			// clips held
+
+	int			generic1;
+	int			loopSound;
+	int			otherEntityNum;
+
+	// not communicated over the net at all
+	int			ping;			// server to game info for scoreboard
+	int			pmove_framecount;	// FIXME: don't transmit over the network
+	int			jumppad_frame;
+	int			entityEventSequence;
+} playerState_t;
+
+
+//====================================================================
+
+
+//
+// usercmd_t->button bits, many of which are generated by the client system,
+// so they aren't game/cgame only definitions
+//
+#define	BUTTON_ATTACK		1
+#define	BUTTON_TALK			2			// displays talk balloon and disables actions
+#define BUTTON_USE_HOLDABLE 4           // activate upgrade
+#define	BUTTON_GESTURE		8
+#define	BUTTON_WALKING		16			// walking can't just be infered from MOVE_RUN
+										// because a key pressed late in the frame will
+										// only generate a small move value for that frame
+										// walking will use different animations and
+										// won't generate footsteps
+#define BUTTON_ATTACK2	32
+#define BUTTON_DODGE        64          // start a dodge or sprint motion
+#define BUTTON_USE_EVOLVE   128         // use target or open evolve menu
+#define BUTTON_SPRINT	256
+
+#define	BUTTON_ANY			2048			// any key whatsoever
+
+#define	MOVE_RUN			120			// if forwardmove or rightmove are >= MOVE_RUN,
+										// then BUTTON_WALKING should be set
+
+// usercmd_t is sent to the server each client frame
+typedef struct usercmd_s {
+	int				serverTime;
+	int				angles[3];
+	int 			buttons;
+	byte			weapon;           // weapon 
+	signed char	forwardmove, rightmove, upmove;
+} usercmd_t;
+
+//===================================================================
+
+// if entityState->solid == SOLID_BMODEL, modelindex is an inline model number
+#define	SOLID_BMODEL	0xffffff
+
+typedef enum {
+	TR_STATIONARY,
+	TR_INTERPOLATE,				// non-parametric, but interpolate between snapshots
+	TR_LINEAR,
+	TR_LINEAR_STOP,
+	TR_SINE,					// value = base + sin( time / duration ) * delta
+	TR_GRAVITY,
+	TR_BUOYANCY
+} trType_t;
+
+typedef struct {
+	trType_t	trType;
+	int		trTime;
+	int		trDuration;			// if non 0, trTime + trDuration = stop time
+	vec3_t	trBase;
+	vec3_t	trDelta;			// velocity, etc
+} trajectory_t;
+
+// entityState_t is the information conveyed from the server
+// in an update message about entities that the client will
+// need to render in some way
+// Different eTypes may use the information in different ways
+// The messages are delta compressed, so it doesn't really matter if
+// the structure size is fairly large
+
+typedef struct entityState_s {
+	int		number;			// entity index
+	int		eType;			// entityType_t
+	int		eFlags;
+
+	trajectory_t	pos;	// for calculating position
+	trajectory_t	apos;	// for calculating angles
+
+	int		time;
+	int		time2;
+
+	vec3_t	origin;
+	vec3_t	origin2;
+
+	vec3_t	angles;
+	vec3_t	angles2;
+
+	int		otherEntityNum;	// shotgun sources, etc
+	int		otherEntityNum2;
+
+	int		groundEntityNum;	// -1 = in air
+
+	int		constantLight;	// r + (g<<8) + (b<<16) + (intensity<<24)
+	int		loopSound;		// constantly loop this sound
+
+	int		modelindex;
+	int		modelindex2;
+	int		clientNum;		// 0 to (MAX_CLIENTS - 1), for players and corpses
+	int		frame;
+
+	int		solid;			// for client side prediction, trap_linkentity sets this properly
+
+	int		event;			// impulse events -- muzzle flashes, footsteps, etc
+	int		eventParm;
+
+	// for players
+	int		misc;			// bit flags
+	int		weapon;			// determines weapon and flash model, etc
+	int		legsAnim;		// mask off ANIM_TOGGLEBIT
+	int		torsoAnim;		// mask off ANIM_TOGGLEBIT
+	int		weaponAnim;		// mask off ANIM_TOGGLEBIT
+
+	int		generic1;
+} entityState_t;
+
+typedef enum {
+	CA_UNINITIALIZED,
+	CA_DISCONNECTED, 	// not talking to a server
+	CA_AUTHORIZING,		// not used any more, was checking cd key 
+	CA_CONNECTING,		// sending request packets to the server
+	CA_CHALLENGING,		// sending challenge packets to the server
+	CA_CONNECTED,		// netchan_t established, getting gamestate
+	CA_LOADING,			// only during cgame initialization, never during main loop
+	CA_PRIMED,			// got gamestate, waiting for first frame
+	CA_ACTIVE,			// game views should be displayed
+	CA_CINEMATIC		// playing a cinematic or a static pic, not connected to a server
+} connstate_t;
+
+// font support 
+
+#define GLYPH_START 0
+#define GLYPH_END 255
+#define GLYPH_CHARSTART 32
+#define GLYPH_CHAREND 127
+#define GLYPHS_PER_FONT GLYPH_END - GLYPH_START + 1
+typedef struct {
+  int height;       // number of scan lines
+  int top;          // top of glyph in buffer
+  int bottom;       // bottom of glyph in buffer
+  int pitch;        // width for copying
+  int xSkip;        // x adjustment
+  int imageWidth;   // width of actual image
+  int imageHeight;  // height of actual image
+  float s;          // x offset in image where glyph starts
+  float t;          // y offset in image where glyph starts
+  float s2;
+  float t2;
+  qhandle_t glyph;  // handle to the shader with the glyph
+  char shaderName[32];
+} glyphInfo_t;
+
+typedef struct {
+  glyphInfo_t glyphs [GLYPHS_PER_FONT];
+  float glyphScale;
+  char name[MAX_QPATH];
+} fontInfo_t;
+
+#define Square(x) ((x)*(x))
+
+// real time
+//=============================================
+
+
+typedef struct qtime_s {
+	int tm_sec;     /* seconds after the minute - [0,59] */
+	int tm_min;     /* minutes after the hour - [0,59] */
+	int tm_hour;    /* hours since midnight - [0,23] */
+	int tm_mday;    /* day of the month - [1,31] */
+	int tm_mon;     /* months since January - [0,11] */
+	int tm_year;    /* years since 1900 */
+	int tm_wday;    /* days since Sunday - [0,6] */
+	int tm_yday;    /* days since January 1 - [0,365] */
+	int tm_isdst;   /* daylight savings time flag */
+} qtime_t;
+
+
+// server browser sources
+// AS_MPLAYER is no longer used
+#define AS_GLOBAL			0
+#define AS_MPLAYER		1
+#define AS_LOCAL			2
+#define AS_FAVORITES	3
+
+
+// cinematic states
+typedef enum {
+	FMV_IDLE,
+	FMV_PLAY,		// play
+	FMV_EOF,		// all other conditions, i.e. stop/EOF/abort
+	FMV_ID_BLT,
+	FMV_ID_IDLE,
+	FMV_LOOPED,
+	FMV_ID_WAIT
+} e_status;
+
+typedef enum _flag_status {
+	FLAG_ATBASE = 0,
+	FLAG_TAKEN,			// CTF
+	FLAG_TAKEN_RED,		// One Flag CTF
+	FLAG_TAKEN_BLUE,	// One Flag CTF
+	FLAG_DROPPED
+} flagStatus_t;
+
+typedef enum {
+	DS_NONE,
+
+	DS_PLAYBACK,
+	DS_RECORDING,
+
+	DS_NUM_DEMO_STATES
+} demoState_t;
+
+
+#define	MAX_GLOBAL_SERVERS				4096
+#define	MAX_OTHER_SERVERS					128
+#define MAX_PINGREQUESTS					32
+#define MAX_SERVERSTATUSREQUESTS	16
+
+#define MAX_EMOTICON_NAME_LEN 16
+#define MAX_EMOTICONS 64
+
+typedef struct
+{
+  char      name[ MAX_EMOTICON_NAME_LEN ];
+#ifndef GAME
+  int       width;
+  qhandle_t shader;
+#endif
+} emoticon_t;
+
+// flags for com_downloadPrompt
+#define DLP_TYPE_MASK 0x0f
+#define DLP_IGNORE    0x01 // don't download anything
+#define DLP_CURL      0x02 // download via HTTP redirect
+#define DLP_UDP       0x04 // download from server
+#define DLP_SHOW      0x10 // prompt needs to be shown
+#define DLP_PROMPTED  0x20 // prompt has been processed by client
+#define DLP_STALE     0x40 // prompt is not being shown by UI VM
+
+#define LERP( a, b, w ) ( ( a ) * ( 1.0f - ( w ) ) + ( b ) * ( w ) )
+#define LUMA( red, green, blue ) ( 0.2126f * ( red ) + 0.7152f * ( green ) + 0.0722f * ( blue ) )
+
+#endif	// __Q_SHARED_H
diff -uNr tremulous-ggp1-src.p/src/renderer/iqm.h tremulous-ggp1-src/src/renderer/iqm.h
--- tremulous-ggp1-src.p/src/renderer/iqm.h	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/iqm.h	2012-07-19 04:25:52.041556450 +0200
@@ -0,0 +1,107 @@
+#ifndef __IQM_H__
+#define __IQM_H__
+
+#define IQM_MAGIC "INTERQUAKEMODEL"
+#define IQM_VERSION 1
+
+typedef struct iqmheader
+{
+    char magic[16];
+    unsigned int version;
+    unsigned int filesize;
+    unsigned int flags;
+    unsigned int num_text, ofs_text;
+    unsigned int num_meshes, ofs_meshes;
+    unsigned int num_vertexarrays, num_vertexes, ofs_vertexarrays;
+    unsigned int num_triangles, ofs_triangles, ofs_adjacency;
+    unsigned int num_joints, ofs_joints;
+    unsigned int num_poses, ofs_poses;
+    unsigned int num_anims, ofs_anims;
+    unsigned int num_frames, num_framechannels, ofs_frames, ofs_bounds;
+    unsigned int num_comment, ofs_comment;
+    unsigned int num_extensions, ofs_extensions;
+} iqmHeader_t;
+
+typedef struct iqmmesh
+{
+    unsigned int name;
+    unsigned int material;
+    unsigned int first_vertex, num_vertexes;
+    unsigned int first_triangle, num_triangles;
+} iqmMesh_t;
+
+enum
+{
+    IQM_POSITION     = 0,
+    IQM_TEXCOORD     = 1,
+    IQM_NORMAL       = 2,
+    IQM_TANGENT      = 3,
+    IQM_BLENDINDEXES = 4,
+    IQM_BLENDWEIGHTS = 5,
+    IQM_COLOR        = 6,
+    IQM_CUSTOM       = 0x10
+};
+
+enum
+{
+    IQM_BYTE   = 0,
+    IQM_UBYTE  = 1,
+    IQM_SHORT  = 2,
+    IQM_USHORT = 3,
+    IQM_INT    = 4,
+    IQM_UINT   = 5,
+    IQM_HALF   = 6,
+    IQM_FLOAT  = 7,
+    IQM_DOUBLE = 8,
+};
+
+typedef struct iqmtriangle
+{
+    unsigned int vertex[3];
+} iqmTriangle_t;
+
+typedef struct iqmjoint
+{
+    unsigned int name;
+    int parent;
+    float translate[3], rotate[3], scale[3];
+} iqmJoint_t;
+
+typedef struct iqmpose
+{
+    int parent;
+    unsigned int mask;
+    float channeloffset[9];
+    float channelscale[9];
+} iqmPose_t;
+
+typedef struct iqmanim
+{
+    unsigned int name;
+    unsigned int first_frame, num_frames;
+    float framerate;
+    unsigned int flags;
+} iqmAnim_t;
+
+enum
+{
+    IQM_LOOP = 1<<0
+};
+
+typedef struct iqmvertexarray
+{
+    unsigned int type;
+    unsigned int flags;
+    unsigned int format;
+    unsigned int size;
+    unsigned int offset;
+} iqmVertexArray_t;
+
+typedef struct iqmbounds
+{
+    float bbmin[3], bbmax[3];
+    float xyradius, radius;
+} iqmBounds_t;
+
+#endif
+
diff -uNr tremulous-ggp1-src.p/src/renderer/qgl.h tremulous-ggp1-src/src/renderer/qgl.h
--- tremulous-ggp1-src.p/src/renderer/qgl.h	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/qgl.h	2012-07-19 04:25:52.031556446 +0200
@@ -27,19 +27,329 @@
 #ifndef __QGL_H__
 #define __QGL_H__
 
+#ifndef _WIN32
+#define NO_SDL_GLEXT
+#include <SDL_opengl.h>
+#else
+#include <SDL_opengl.h>
+
+// hack alarm !
+#ifndef GL_EXT_timer_query
+#define GL_TIME_ELAPSED_EXT 0x88BF
+typedef int64_t GLint64EXT;
+typedef uint64_t GLuint64EXT;
+#endif
+
+#ifndef GL_EXT_geometry_shader4
+#define GL_GEOMETRY_SHADER_EXT 0x8DD9
+#define GL_GEOMETRY_VERTICES_OUT_EXT 0x8DDA
+#define GL_GEOMETRY_INPUT_TYPE_EXT 0x8DDB
+#define GL_GEOMETRY_OUTPUT_TYPE_EXT 0x8DDC
+#endif
+
+#ifndef GL_EXT_texture_compression_latc
+#define GL_COMPRESSED_LUMINANCE_LATC1_EXT 0x8C70
+#define GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT 0x8C72
+#endif
+
+#ifndef GL_ARB_debug_output
+typedef void (APIENTRYP *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,GLvoid *userParam);
+#define GL_DEBUG_LOGGED_MESSAGES_ARB 0x9145
+#define GL_DEBUG_SEVERITY_HIGH_ARB 0x9146
+#define GL_DEBUG_SEVERITY_MEDIUM_ARB 0x9147
+#define GL_DEBUG_SEVERITY_LOW_ARB 0x9148
+#define GL_DEBUG_SOURCE_APPLICATION_ARB 0x824A
+#define GL_DEBUG_TYPE_OTHER_ARB 0x8251
+#endif
+
+#ifndef GL_AMD_debug_output
+typedef void (APIENTRYP *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,GLvoid *userParam);
+#define GL_DEBUG_LOGGED_MESSAGES_AMD 0x9145
+#define GL_DEBUG_SEVERITY_HIGH_AMD 0x9146
+#define GL_DEBUG_SEVERITY_MEDIUM_AMD 0x9147
+#define GL_DEBUG_SEVERITY_LOW_AMD 0x9148
+#define GL_DEBUG_CATEGORY_APPLICATION_AMD 0x914f
+#endif
+
+#ifndef WGL_ARB_create_context_profile
+#define WGL_CONTEXT_FLAGS_ARB 0x2094
+#define WGL_CONTEXT_DEBUG_BIT_ARB 0x0001
+#endif
+#endif
+
 #ifdef USE_LOCAL_HEADERS
 #	include "SDL_opengl.h"
 #else
 #	include <SDL_opengl.h>
 #endif
 
+// GL_EXT_draw_range_elements
+extern void (APIENTRYP qglDrawRangeElementsEXT) (GLenum mode, GLsizei count, GLuint start, GLuint end, GLenum type, const GLvoid *indices);
+
 extern void (APIENTRYP qglActiveTextureARB) (GLenum texture);
 extern void (APIENTRYP qglClientActiveTextureARB) (GLenum texture);
 extern void (APIENTRYP qglMultiTexCoord2fARB) (GLenum target, GLfloat s, GLfloat t);
+extern void (APIENTRYP qglMultiTexCoord4fvARB) (GLenum target, GLfloat *v);
 
 extern void (APIENTRYP qglLockArraysEXT) (GLint first, GLsizei count);
 extern void (APIENTRYP qglUnlockArraysEXT) (void);
 
+// GL_ARB_texture_compression
+extern void (APIENTRYP qglCompressedTexImage3DARB) (GLenum target, GLint level,
+						    GLenum internalformat, GLsizei width,
+						    GLsizei height, GLsizei depth,
+						    GLint border, GLsizei imageSize,
+						    const GLvoid *data);
+extern void (APIENTRYP qglCompressedTexImage2DARB) (GLenum target, GLint level,
+						    GLenum internalformat, GLsizei width,
+						    GLsizei height, GLint border, 
+						    GLsizei imageSize, const GLvoid *data);
+extern void (APIENTRYP qglCompressedTexImage1DARB) (GLenum target, GLint level,
+						    GLenum internalformat, GLsizei width,
+						    GLint border, GLsizei imageSize,
+						    const GLvoid *data);
+extern void (APIENTRYP qglCompressedTexSubImage3DARB) (GLenum target, GLint level, 
+						       GLint xoffset, GLint yoffset,
+						       GLint zoffset, GLsizei width,
+						       GLsizei height, GLsizei depth,
+						       GLenum format, GLsizei imageSize,
+						       const GLvoid *data);
+extern void (APIENTRYP qglCompressedTexSubImage2DARB) (GLenum target, GLint level, 
+						       GLint xoffset, GLint yoffset,
+						       GLsizei width, GLsizei height,
+						       GLenum format, GLsizei imageSize,
+						       const GLvoid *data);
+extern void (APIENTRYP qglCompressedTexSubImage1DARB) (GLenum target, GLint level, 
+						       GLint xoffset, GLsizei width,
+						       GLenum format, GLsizei imageSize,
+						       const GLvoid *data);
+extern void (APIENTRYP qglGetCompressedTexImageARB) (GLenum target, GLint lod,
+						     GLvoid *img);
+
+// GL_ARB_vertex_buffer_object
+extern void (APIENTRYP qglBindBufferARB) (GLenum target, GLuint buffer);
+extern void (APIENTRYP qglDeleteBuffersARB) (GLsizei n, const GLuint *buffers);
+extern void (APIENTRYP qglGenBuffersARB) (GLsizei n, GLuint *buffers);
+extern GLboolean (APIENTRYP qglIsBufferARB) (GLuint buffer);
+extern void (APIENTRYP qglBufferDataARB) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
+extern void (APIENTRYP qglBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
+extern void (APIENTRYP qglGetBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
+extern GLvoid *(APIENTRYP qglMapBufferARB) (GLenum target, GLenum access);
+extern GLboolean (APIENTRYP qglUnmapBufferARB) (GLenum target);
+extern void (APIENTRYP qglGetBufferParameterivARB) (GLenum target, GLenum pname, GLint *params);
+extern void (APIENTRYP qglGetBufferPointervARB) (GLenum target, GLenum pname, GLvoid **params);
+
+// GL_ARB_shader_objects
+extern GLvoid (APIENTRYP qglDeleteShader) (GLuint shader);
+extern GLvoid (APIENTRYP qglDeleteProgram) (GLuint program);
+extern GLvoid (APIENTRYP qglDetachShader) (GLuint program, GLuint shader);
+extern GLuint (APIENTRYP qglCreateShader) (GLenum type);
+extern GLvoid (APIENTRYP qglShaderSource) (GLuint shader, GLsizei count, const char **string,
+					   const GLint *length);
+extern GLvoid (APIENTRYP qglCompileShader) (GLuint shader);
+extern GLuint (APIENTRYP qglCreateProgram) (void);
+extern GLvoid (APIENTRYP qglAttachShader) (GLuint program, GLuint shader);
+extern GLvoid (APIENTRYP qglLinkProgram) (GLuint program);
+extern GLvoid (APIENTRYP qglUseProgram) (GLuint program);
+extern GLvoid (APIENTRYP qglValidateProgram) (GLuint program);
+extern GLvoid (APIENTRYP qglUniform1f) (GLint location, GLfloat v0);
+extern GLvoid (APIENTRYP qglUniform2f) (GLint location, GLfloat v0, GLfloat v1);
+extern GLvoid (APIENTRYP qglUniform3f) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+extern GLvoid (APIENTRYP qglUniform4f) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+extern GLvoid (APIENTRYP qglUniform1i) (GLint location, GLint v0);
+extern GLvoid (APIENTRYP qglUniform2i) (GLint location, GLint v0, GLint v1);
+extern GLvoid (APIENTRYP qglUniform3i) (GLint location, GLint v0, GLint v1, GLint v2);
+extern GLvoid (APIENTRYP qglUniform4i) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+extern GLvoid (APIENTRYP qglUniform1fv) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniform2fv) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniform3fv) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniform4fv) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniform1iv) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRYP qglUniform2iv) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRYP qglUniform3iv) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRYP qglUniform4iv) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRYP qglUniformMatrix2fv) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniformMatrix3fv) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniformMatrix4fv) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+extern GLvoid (APIENTRYP qglGetShaderiv) (GLuint shader, GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglGetProgramiv) (GLuint program, GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglGetShaderInfoLog) (GLuint shader, GLsizei maxLength, GLsizei *length, char *infoLog);
+extern GLvoid (APIENTRYP qglGetProgramInfoLog) (GLuint program, GLsizei maxLength, GLsizei *length, char *infoLog);
+extern GLvoid (APIENTRYP qglGetAttachedShaders) (GLuint program, GLsizei maxCount, GLsizei *count,
+						 GLuint *shaders);
+extern GLint (APIENTRYP qglGetUniformLocation) (GLuint program, const char *name);
+extern GLvoid (APIENTRYP qglGetActiveUniform) (GLuint program, GLuint index, GLsizei maxLength,
+					       GLsizei *length, GLint *size, GLenum *type, char *name);
+extern GLvoid (APIENTRYP qglGetUniformfv) (GLuint program, GLint location, GLfloat *params);
+extern GLvoid (APIENTRYP qglGetUniformiv) (GLuint program, GLint location, GLint *params);
+extern GLvoid (APIENTRYP qglGetShaderSource) (GLuint shader, GLsizei maxLength, GLsizei *length,
+					      char *source);
+
+// GL_ARB_vertex_shader
+extern GLvoid (APIENTRYP qglVertexAttrib1fARB) (GLuint index, GLfloat v0);
+extern GLvoid (APIENTRYP qglVertexAttrib1sARB) (GLuint index, GLshort v0);
+extern GLvoid (APIENTRYP qglVertexAttrib1dARB) (GLuint index, GLdouble v0);
+extern GLvoid (APIENTRYP qglVertexAttrib2fARB) (GLuint index, GLfloat v0, GLfloat v1);
+extern GLvoid (APIENTRYP qglVertexAttrib2sARB) (GLuint index, GLshort v0, GLshort v1);
+extern GLvoid (APIENTRYP qglVertexAttrib2dARB) (GLuint index, GLdouble v0, GLdouble v1);
+extern GLvoid (APIENTRYP qglVertexAttrib3fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);
+extern GLvoid (APIENTRYP qglVertexAttrib3sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2);
+extern GLvoid (APIENTRYP qglVertexAttrib3dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
+extern GLvoid (APIENTRYP qglVertexAttrib4fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+extern GLvoid (APIENTRYP qglVertexAttrib4sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);
+extern GLvoid (APIENTRYP qglVertexAttrib4dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
+extern GLvoid (APIENTRYP qglVertexAttrib4NubARB) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+extern GLvoid (APIENTRYP qglVertexAttrib1fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRYP qglVertexAttrib1svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib1dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRYP qglVertexAttrib2fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRYP qglVertexAttrib2svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib2dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRYP qglVertexAttrib3fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRYP qglVertexAttrib3svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib3dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4ivARB) (GLuint index, GLint *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4bvARB) (GLuint index, GLbyte *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4ubvARB) (GLuint index, GLubyte *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4usvARB) (GLuint index, GLushort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4uivARB) (GLuint index, GLuint *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NbvARB) (GLuint index, const GLbyte *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NsvARB) (GLuint index, const GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NivARB) (GLuint index, const GLint *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NubvARB) (GLuint index, const GLubyte *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NusvARB) (GLuint index, const GLushort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NuivARB) (GLuint index, const GLuint *v);
+extern GLvoid (APIENTRYP qglVertexAttribPointerARB) (GLuint index, GLint size, GLenum type, GLboolean normalized,
+						     GLsizei stride, const GLvoid *pointer);
+extern GLvoid (APIENTRYP qglEnableVertexAttribArrayARB) (GLuint index);
+extern GLvoid (APIENTRYP qglDisableVertexAttribArrayARB) (GLuint index);
+extern GLvoid (APIENTRYP qglBindAttribLocationARB) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
+extern GLvoid (APIENTRYP qglGetActiveAttribARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
+						 GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+extern GLint (APIENTRYP qglGetAttribLocationARB) (GLhandleARB programObj, const GLcharARB *name);
+extern GLvoid (APIENTRYP qglGetVertexAttribdvARB) (GLuint index, GLenum pname, GLdouble *params);
+extern GLvoid (APIENTRYP qglGetVertexAttribfvARB) (GLuint index, GLenum pname, GLfloat *params);
+extern GLvoid (APIENTRYP qglGetVertexAttribivARB) (GLuint index, GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglGetVertexAttribPointervARB) (GLuint index, GLenum pname, GLvoid **pointer);
+
+// GL_EXT_geometry_shader4
+extern GLvoid (APIENTRYP qglProgramParameteriEXT) (GLuint program, GLenum pname, GLint value);
+extern GLvoid (APIENTRYP qglFramebufferTextureEXT) (GLenum target, GLenum attachment,
+						    GLuint texture, GLint level);
+extern GLvoid (APIENTRYP qglFramebufferTextureLayerEXT) (GLenum target, GLenum attachment,
+							 GLuint texture, GLint level, GLint layer);
+extern GLvoid (APIENTRYP qglFramebufferTextureFaceEXT) (GLenum target, GLenum attachment,
+							GLuint texture, GLint level, GLenum face);
+
+// GL_EXT_texture3D
+extern GLvoid (APIENTRYP qglTexImage3DEXT) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+
+// GL_ARB_framebuffer_object
+extern GLboolean (APIENTRYP qglIsRenderbuffer) (GLuint renderbuffer);
+extern GLvoid (APIENTRYP qglBindRenderbuffer) (GLenum target, GLuint renderbuffer);
+extern GLvoid (APIENTRYP qglDeleteRenderbuffers) (GLsizei n, const GLuint *renderbuffers);
+extern GLvoid (APIENTRYP qglGenRenderbuffers) (GLsizei n, GLuint *renderbuffers);
+extern GLvoid (APIENTRYP qglRenderbufferStorage) (GLenum target, GLenum internalformat,
+						  GLsizei width, GLsizei height);
+extern GLvoid (APIENTRYP qglRenderbufferStorageMultisample) (GLenum target, GLsizei samples,
+							     GLenum internalformat,
+							     GLsizei width, GLsizei height);
+extern GLvoid (APIENTRYP qglGetRenderbufferParameteriv) (GLenum target, GLenum pname, GLint *params);
+extern GLboolean (APIENTRYP qglIsFramebuffer) (GLuint framebuffer);
+extern GLvoid (APIENTRYP qglBindFramebuffer) (GLenum target, GLuint framebuffer);
+extern GLvoid (APIENTRYP qglDeleteFramebuffers) (GLsizei n, const GLuint *framebuffers);
+extern GLvoid (APIENTRYP qglGenFramebuffers) (GLsizei n, GLuint *framebuffers);
+extern GLenum (APIENTRYP qglCheckFramebufferStatus) (GLenum target);
+extern GLvoid (APIENTRYP qglFramebufferTexture1D) (GLenum target, GLenum attachment,
+						   GLenum textarget, GLuint texture, GLint level);
+extern GLvoid (APIENTRYP qglFramebufferTexture2D) (GLenum target, GLenum attachment,
+						   GLenum textarget, GLuint texture, GLint level);
+extern GLvoid (APIENTRYP qglFramebufferTexture3D) (GLenum target, GLenum attachment,
+						   GLenum textarget, GLuint texture,
+						   GLint level, GLint layer);
+extern GLvoid (APIENTRYP qglFramebufferTextureLayer) (GLenum target, GLenum attachment,
+						      GLuint texture, GLint level, GLint layer);
+extern GLvoid (APIENTRYP qglFramebufferRenderbuffer) (GLenum target, GLenum attachment,
+						      GLenum renderbuffertarget, GLuint renderbuffer);
+extern GLvoid (APIENTRYP qglGetFramebufferAttachmentParameteriv) (GLenum target, GLenum attachment,
+								  GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglBlitFramebuffer) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
+					      GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
+					      GLbitfield mask, GLenum filter);
+extern GLvoid (APIENTRYP qglGenerateMipmap) (GLenum target);
+
+// GL_EXT_timer_query
+extern GLvoid (APIENTRYP qglGenQueriesARB) (GLsizei n, GLuint *ids);
+extern GLvoid (APIENTRYP qglDeleteQueriesARB) (GLsizei n, const GLuint *ids);
+extern GLboolean (APIENTRYP qglIsQueryARB) (GLuint id);
+extern GLvoid (APIENTRYP qglBeginQueryARB) (GLenum target, GLuint id);
+extern GLvoid (APIENTRYP qglEndQueryARB) (GLenum target);
+extern GLvoid (APIENTRYP qglGetQueryivARB) (GLenum target, GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglGetQueryObjectivARB) (GLuint id, GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglGetQueryObjectuivARB) (GLuint id, GLenum pname, GLuint *params);
+extern GLvoid (APIENTRYP qglGetQueryObjecti64vEXT) (GLuint id, GLenum pname, GLint64EXT *params);
+extern GLvoid (APIENTRYP qglGetQueryObjectui64vEXT) (GLuint id, GLenum pname, GLuint64EXT *params);
+
+// GL_ARB_instanced_arrays
+extern GLvoid (APIENTRYP qglVertexAttribDivisorARB) (GLuint index, GLuint divisor);
+extern GLvoid (APIENTRYP qglDrawArraysInstancedARB) (GLenum mode, GLint first, GLsizei count,
+						     GLsizei primcount);
+extern GLvoid (APIENTRYP qglDrawElementsInstancedARB) (GLenum mode, GLsizei count, GLenum type,
+						       const GLvoid *indices, GLsizei primcount);
+
+// GL_ARB_separate_stencil, does not really exists, part of 2.0
+extern GLvoid (APIENTRYP qglStencilOpSeparate) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
+extern GLvoid (APIENTRYP qglStencilFuncSeparate) (GLenum face, GLenum func, GLint ref, GLuint mask);
+extern GLvoid (APIENTRYP qglStencilMaskSeparate) (GLenum face, GLuint mask);
+
+// GL_ARB_debug_output, not part of core
+extern GLvoid (APIENTRYP qglDebugMessageControlARB) (GLenum source,
+						     GLenum type,
+						     GLenum severity,
+						     GLsizei count,
+						     const GLuint* ids,
+						     GLboolean enabled);
+extern GLvoid (APIENTRYP qglDebugMessageInsertARB) (GLenum source,
+						    GLenum type,
+						    GLuint id,
+						    GLenum severity,
+						    GLsizei length, 
+						    const GLchar* buf);
+extern GLvoid (APIENTRYP qglDebugMessageCallbackARB) (GLDEBUGPROCARB callback,
+						      GLvoid *userParam);
+extern GLuint (APIENTRYP qglGetDebugMessageLogARB) (GLuint count,
+						    GLsizei bufsize,
+						    GLenum *sources,
+						    GLenum *types,
+						    GLuint *ids,
+						    GLenum *severities,
+						    GLsizei *lengths, 
+						    GLchar *messageLog);
+// GL_AMD_debug_output, predecessor to GL_ARB_debug_output, but has only
+// a category parameter instead of source and type
+extern GLvoid (APIENTRYP qglDebugMessageEnableAMD) (GLenum category,
+						    GLenum severity,
+						    GLsizei count,
+						    const GLuint* ids,
+						    GLboolean enabled);
+extern GLvoid (APIENTRYP qglDebugMessageInsertAMD) (GLenum category,
+						    GLuint id,
+						    GLenum severity,
+						    GLsizei length, 
+						    const GLchar* buf);
+extern GLvoid (APIENTRYP qglDebugMessageCallbackAMD) (GLDEBUGPROCAMD callback,
+						      GLvoid *userParam);
+extern GLuint (APIENTRYP qglGetDebugMessageLogAMD) (GLuint count,
+						    GLsizei bufsize,
+						    GLenum *categories,
+						    GLuint *ids,
+						    GLenum *severities,
+						    GLsizei *lengths, 
+						    GLchar *messageLog);
+
 
 //===========================================================================
 
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_animation.c tremulous-ggp1-src/src/renderer/tr_animation.c
--- tremulous-ggp1-src.p/src/renderer/tr_animation.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_animation.c	2012-07-19 04:25:52.031556446 +0200
@@ -46,13 +46,13 @@
 	shader_t		*shader;
 	int				i;
 
-	header = (md4Header_t *) tr.currentModel->md4;
+	header = (md4Header_t *) tr.currentModel->modelData.md4.md4;
 	lod = (md4LOD_t *)( (byte *)header + header->ofsLODs );
 
 	surface = (md4Surface_t *)( (byte *)lod + lod->ofsSurfaces );
 	for ( i = 0 ; i < lod->numSurfaces ; i++ ) {
 		shader = R_GetShaderByHandle( surface->shaderIndex );
-		R_AddDrawSurf( (void *)surface, shader, 0 /*fogNum*/, qfalse );
+		R_AddDrawSurf( (void *)surface, shader, 0 /*fogNum*/, 0, qfalse );
 		surface = (md4Surface_t *)( (byte *)surface + surface->ofsEnd );
 	}
 }
@@ -62,12 +62,13 @@
 RB_SurfaceAnim
 ==============
 */
-void RB_SurfaceAnim( md4Surface_t *surface ) {
+void RB_SurfaceAnim( surfaceType_t *surf ) {
+	md4Surface_t		*surface = (md4Surface_t *)surf;
 	int				i, j, k;
 	float			frontlerp, backlerp;
 	int				*triangles;
 	int				indexes;
-	int				baseIndex, baseVertex;
+	int				baseVertex;
 	int				numVerts;
 	md4Vertex_t		*v;
 	md4Bone_t		bones[MD4_MAX_BONES];
@@ -76,7 +77,9 @@
 	md4Frame_t		*frame;
 	md4Frame_t		*oldFrame;
 	int				frameSize;
-
+	vaWord1_t		*vertexPtr1;
+	vaWord2_t		*vertexPtr2;
+	vaWord3_t		*vertexPtr3;
 
 	if (  backEnd.currentEntity->e.oldframe == backEnd.currentEntity->e.frame ) {
 		backlerp = 0;
@@ -94,77 +97,92 @@
 	oldFrame = (md4Frame_t *)((byte *)header + header->ofsFrames + 
 			backEnd.currentEntity->e.oldframe * frameSize );
 
-	RB_CheckOverflow( surface->numVerts, surface->numTriangles * 3 );
-
-	triangles = (int *) ((byte *)surface + surface->ofsTriangles);
-	indexes = surface->numTriangles * 3;
-	baseIndex = tess.numIndexes;
-	baseVertex = tess.numVertexes;
-	for (j = 0 ; j < indexes ; j++) {
-		tess.indexes[baseIndex + j] = baseIndex + triangles[j];
-	}
-	tess.numIndexes += indexes;
-
-	//
-	// lerp all the needed bones
-	//
-	if ( !backlerp ) {
-		// no lerping needed
-		bonePtr = frame->bones;
-	} else {
-		bonePtr = bones;
-		for ( i = 0 ; i < header->numBones*12 ; i++ ) {
-			((float *)bonePtr)[i] = frontlerp * ((float *)frame->bones)[i]
+	if ( tess.vertexPtr1 ) {
+		baseVertex = tess.numVertexes;
+		vertexPtr1 = tess.vertexPtr1 + baseVertex;
+		vertexPtr2 = tess.vertexPtr2 + baseVertex;
+		vertexPtr3 = tess.vertexPtr3 + baseVertex;
+
+		//
+		// lerp all the needed bones
+		//
+		if ( !backlerp ) {
+			// no lerping needed
+			bonePtr = frame->bones;
+		} else {
+			bonePtr = bones;
+			for ( i = 0 ; i < header->numBones*12 ; i++ ) {
+				((float *)bonePtr)[i] = frontlerp * ((float *)frame->bones)[i]
 					+ backlerp * ((float *)oldFrame->bones)[i];
+			}
 		}
-	}
-
-	//
-	// deform the vertexes by the lerped bones
-	//
-	numVerts = surface->numVerts;
-	// FIXME
-	// This makes TFC's skeletons work.  Shouldn't be necessary anymore, but left
-	// in for reference.
-	//v = (md4Vertex_t *) ((byte *)surface + surface->ofsVerts + 12);
-	v = (md4Vertex_t *) ((byte *)surface + surface->ofsVerts);
-	for ( j = 0; j < numVerts; j++ ) {
-		vec3_t	tempVert, tempNormal;
-		md4Weight_t	*w;
-
-		VectorClear( tempVert );
-		VectorClear( tempNormal );
-		w = v->weights;
-		for ( k = 0 ; k < v->numWeights ; k++, w++ ) {
-			bone = bonePtr + w->boneIndex;
-
-			tempVert[0] += w->boneWeight * ( DotProduct( bone->matrix[0], w->offset ) + bone->matrix[0][3] );
-			tempVert[1] += w->boneWeight * ( DotProduct( bone->matrix[1], w->offset ) + bone->matrix[1][3] );
-			tempVert[2] += w->boneWeight * ( DotProduct( bone->matrix[2], w->offset ) + bone->matrix[2][3] );
-
-			tempNormal[0] += w->boneWeight * DotProduct( bone->matrix[0], v->normal );
-			tempNormal[1] += w->boneWeight * DotProduct( bone->matrix[1], v->normal );
-			tempNormal[2] += w->boneWeight * DotProduct( bone->matrix[2], v->normal );
-		}
-
-		tess.xyz[baseVertex + j][0] = tempVert[0];
-		tess.xyz[baseVertex + j][1] = tempVert[1];
-		tess.xyz[baseVertex + j][2] = tempVert[2];
-
-		tess.normal[baseVertex + j][0] = tempNormal[0];
-		tess.normal[baseVertex + j][1] = tempNormal[1];
-		tess.normal[baseVertex + j][2] = tempNormal[2];
-
-		tess.texCoords[baseVertex + j][0][0] = v->texCoords[0];
-		tess.texCoords[baseVertex + j][0][1] = v->texCoords[1];
-
+		
+		//
+		// deform the vertexes by the lerped bones
+		//
+		numVerts = surface->numVerts;
 		// FIXME
 		// This makes TFC's skeletons work.  Shouldn't be necessary anymore, but left
 		// in for reference.
-		//v = (md4Vertex_t *)( ( byte * )&v->weights[v->numWeights] + 12 );
-		v = (md4Vertex_t *)&v->weights[v->numWeights];
+		//v = (md4Vertex_t *) ((byte *)surface + surface->ofsVerts + 12);
+		v = (md4Vertex_t *) ((byte *)surface + surface->ofsVerts);
+		for ( j = 0; j < numVerts; j++ ) {
+			vec4_t	tempVert, tempNormal;
+			md4Weight_t	*w;
+			
+			VectorClear( tempVert ); tempVert[3] = 0.0;
+			VectorClear( tempNormal ); tempNormal[3] = 0.0;
+			w = v->weights;
+			for ( k = 0 ; k < v->numWeights ; k++, w++ ) {
+				bone = bonePtr + w->boneIndex;
+				
+				tempVert[0] += w->boneWeight * ( DotProduct( bone->matrix[0], w->offset ) + bone->matrix[0][3] );
+				tempVert[1] += w->boneWeight * ( DotProduct( bone->matrix[1], w->offset ) + bone->matrix[1][3] );
+				tempVert[2] += w->boneWeight * ( DotProduct( bone->matrix[2], w->offset ) + bone->matrix[2][3] );
+				
+				tempNormal[0] += w->boneWeight * DotProduct( bone->matrix[0], v->normal );
+				tempNormal[1] += w->boneWeight * DotProduct( bone->matrix[1], v->normal );
+				tempNormal[2] += w->boneWeight * DotProduct( bone->matrix[2], v->normal );
+			}
+			
+			VectorCopy( tempVert, vertexPtr2->xyz );
+			VectorCopy( tempNormal, vertexPtr3->normal );
+			Vector2Copy( v->texCoords, vertexPtr1->tc1 );
+			Vector2Copy( v->texCoords, vertexPtr1->tc2 );
+			vertexPtr2->fogNum = (float)tess.fogNum;
+
+			vertexPtr1++;
+			vertexPtr2++;
+			vertexPtr3++;
+			
+			// FIXME
+			// This makes TFC's skeletons work.  Shouldn't be necessary anymore, but left
+			// in for reference.
+			//v = (md4Vertex_t *)( ( byte * )&v->weights[v->numWeights] + 12 );
+			v = (md4Vertex_t *)&v->weights[v->numWeights];
+		}
+	} else {
+		baseVertex = 0; // ERROR
 	}
-
+	
+	if ( tess.indexPtr.p16 ) {
+		triangles = (int *) ((byte *)surface + surface->ofsTriangles);
+		indexes = surface->numTriangles * 3;
+
+		if ( tess.indexInc == sizeof(GLushort) ) {
+			GLushort *indexPtr = tess.indexPtr.p16 + tess.numIndexes;
+			for (j = 0 ; j < indexes ; j++) {
+				*indexPtr++ = (GLushort)(baseVertex + triangles[j]);
+			}
+		} else {
+			GLuint *indexPtr32 = tess.indexPtr.p32 + tess.numIndexes;
+			for (j = 0 ; j < indexes ; j++) {
+				*indexPtr32++ = baseVertex + triangles[j];
+			}
+		}
+	}
+	
+	tess.numIndexes += surface->numTriangles * 3;
 	tess.numVertexes += surface->numVerts;
 }
 
@@ -445,8 +463,9 @@
 RB_MDRSurfaceAnim
 ==============
 */
-void RB_MDRSurfaceAnim( md4Surface_t *surface )
+void RB_MDRSurfaceAnim( surfaceType_t *surf )
 {
+	md4Surface_t *surface = (md4Surface_t *) surf;
 	int				i, j, k;
 	float			frontlerp, backlerp;
 	int				*triangles;
@@ -483,8 +502,6 @@
 	oldFrame = (mdrFrame_t *)((byte *)header + header->ofsFrames +
 		backEnd.currentEntity->e.oldframe * frameSize );
 
-	RB_CheckOverflow( surface->numVerts, surface->numTriangles );
-
 	triangles	= (int *) ((byte *)surface + surface->ofsTriangles);
 	indexes		= surface->numTriangles * 3;
 	baseIndex	= tess.numIndexes;
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_backend.c tremulous-ggp1-src/src/renderer/tr_backend.c
--- tremulous-ggp1-src.p/src/renderer/tr_backend.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_backend.c	2012-07-19 04:25:52.041556450 +0200
@@ -25,217 +25,146 @@
 backEndData_t	*backEndData[SMP_FRAMES];
 backEndState_t	backEnd;
 
-
-static float	s_flipMatrix[16] = {
-	// convert from our coordinate system (looking down X)
-	// to OpenGL's coordinate system (looking down -Z)
-	0, 0, -1, 0,
-	-1, 0, 0, 0,
-	0, 1, 0, 0,
-	0, 0, 0, 1
-};
-
-
 /*
-** GL_Bind
+** GL_BindTexture
+** 
+** binds a texture to texture unit 0 for texture manipulation.
+** This is called by the frontend, so it may use a separate context for SMP,
+** in which case the glState must not be changed !
 */
-void GL_Bind( image_t *image ) {
-	int texnum;
-
-	if ( !image ) {
-		ri.Printf( PRINT_WARNING, "GL_Bind: NULL image\n" );
-		texnum = tr.defaultImage->texnum;
-	} else {
-		texnum = image->texnum;
-	}
-
-	if ( r_nobind->integer && tr.dlightImage ) {		// performance evaluation option
-		texnum = tr.dlightImage->texnum;
-	}
-
-	if ( glState.currenttextures[glState.currenttmu] != texnum ) {
-		image->frameUsed = tr.frameCount;
-		glState.currenttextures[glState.currenttmu] = texnum;
-		qglBindTexture (GL_TEXTURE_2D, texnum);
+void GL_BindTexture( int texnum ) {
+	if( GLimp_IsSMPActive() ) {
+		if( qglActiveTextureARB )
+			qglActiveTextureARB( GL_TEXTURE0_ARB );
+		qglBindTexture( GL_TEXTURE_2D, texnum );
+	} else if ( glState.currenttextures[0] != texnum ) {
+		glState.currenttextures[0] = texnum;
+		qglBindTexture( GL_TEXTURE_2D, texnum );
 	}
 }
 
 /*
-** GL_SelectTexture
-*/
-void GL_SelectTexture( int unit )
-{
-	if ( glState.currenttmu == unit )
-	{
-		return;
-	}
-
-	if ( unit == 0 )
-	{
-		qglActiveTextureARB( GL_TEXTURE0_ARB );
-		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE0_ARB )\n" );
-		qglClientActiveTextureARB( GL_TEXTURE0_ARB );
-		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE0_ARB )\n" );
-	}
-	else if ( unit == 1 )
-	{
-		qglActiveTextureARB( GL_TEXTURE1_ARB );
-		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE1_ARB )\n" );
-		qglClientActiveTextureARB( GL_TEXTURE1_ARB );
-		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE1_ARB )\n" );
-	} else {
-		ri.Error( ERR_DROP, "GL_SelectTexture: unit = %i", unit );
-	}
-
-	glState.currenttmu = unit;
-}
-
-
-/*
-** GL_BindMultitexture
+** GL_UnbindAllTextures
+**
+** unbind all texture units for renderer cleanup.
 */
-void GL_BindMultitexture( image_t *image0, GLuint env0, image_t *image1, GLuint env1 ) {
-	int		texnum0, texnum1;
-
-	texnum0 = image0->texnum;
-	texnum1 = image1->texnum;
+void GL_UnbindAllTextures( void ) {
+	int	i;
 
-	if ( r_nobind->integer && tr.dlightImage ) {		// performance evaluation option
-		texnum0 = texnum1 = tr.dlightImage->texnum;
-	}
+	for( i = 0; i < NUM_TEXTURE_BUNDLES; i++ ) {
+		if( i >= glGlobals.maxTextureImageUnits )
+			break;
 
-	if ( glState.currenttextures[1] != texnum1 ) {
-		GL_SelectTexture( 1 );
-		image1->frameUsed = tr.frameCount;
-		glState.currenttextures[1] = texnum1;
-		qglBindTexture( GL_TEXTURE_2D, texnum1 );
-	}
-	if ( glState.currenttextures[0] != texnum0 ) {
-		GL_SelectTexture( 0 );
-		image0->frameUsed = tr.frameCount;
-		glState.currenttextures[0] = texnum0;
-		qglBindTexture( GL_TEXTURE_2D, texnum0 );
+		if( glState.currenttextures[i] ) {
+			glState.currenttextures[i] = 0;
+			glState.texEnabled[i] = qfalse;
+			if( qglActiveTextureARB )
+				qglActiveTextureARB( GL_TEXTURE0_ARB + i );
+			qglBindTexture( GL_TEXTURE_2D, 0 );
+			qglDisable( GL_TEXTURE_2D );
+		}
 	}
 }
 
-
 /*
-** GL_Cull
+** GL_Bind
+**
+** bind a list of images to the texture units. For GLSL shader it's not
+** required to glEnable them and we may keep unused textures bound, so
+** we can avoid to rebind them later.
 */
-void GL_Cull( int cullType ) {
-	if ( glState.faceCulling == cullType ) {
-		return;
+static void GL_BindImages( int count, image_t **images, qboolean isGLSL ) {
+	int i, texnum;
+	
+	if( !qglActiveTextureARB && count > 1 ) {
+		ri.Printf( PRINT_WARNING, "GL_BindImages: Multitexturing not enabled\n" );
+		count = 1;
+	}
+	
+	for( i = 0; i < count; i++ ) {
+		if ( !images[i] ) {
+			ri.Printf( PRINT_WARNING, "GL_BindImages: NULL image\n" );
+			texnum = tr.defaultImage->texnum;
+		} else {
+			texnum = images[i]->texnum;
+		}
+		
+		if ( r_nobind->integer && tr.dlightImage ) {		// performance evaluation option
+			texnum = tr.dlightImage->texnum;
+		}
+		
+		if ( glState.currenttextures[i] != texnum ) {
+			images[i]->frameUsed = tr.frameCount;
+			glState.currenttextures[i] = texnum;
+			if( qglActiveTextureARB )
+				qglActiveTextureARB( GL_TEXTURE0_ARB + i );
+			qglBindTexture( GL_TEXTURE_2D, texnum );
+		}
+		if( !isGLSL /*&& !glState.texEnabled[i]*/ ) {
+			qglEnable( GL_TEXTURE_2D );
+			glState.texEnabled[i] = qtrue;
+		}
 	}
 
-	glState.faceCulling = cullType;
-
-	if ( cullType == CT_TWO_SIDED ) 
-	{
-		qglDisable( GL_CULL_FACE );
-	} 
-	else 
-	{
-		qglEnable( GL_CULL_FACE );
+	// have to disable further textures for non-GLSL shaders
+	for( ; i < MAX_SHADER_STAGES; i++ ) {
+		if( i >= glGlobals.maxTextureImageUnits )
+			break;
 
-		if ( cullType == CT_BACK_SIDED )
-		{
-			if ( backEnd.viewParms.isMirror )
-			{
-				qglCullFace( GL_FRONT );
-			}
-			else
-			{
-				qglCullFace( GL_BACK );
-			}
-		}
-		else
-		{
-			if ( backEnd.viewParms.isMirror )
-			{
-				qglCullFace( GL_BACK );
-			}
-			else
-			{
-				qglCullFace( GL_FRONT );
+		if( glState.currenttextures[i] ) {
+			if( qglActiveTextureARB )
+				qglActiveTextureARB( GL_TEXTURE0_ARB + i );
+			qglBindTexture( GL_TEXTURE_2D, 0 );
+			glState.currenttextures[i] = 0;
+
+			if( !isGLSL && glState.texEnabled[i] ) {
+				qglDisable( GL_TEXTURE_2D );
+				glState.texEnabled[i] = qfalse;
 			}
 		}
 	}
 }
 
 /*
-** GL_TexEnv
-*/
-void GL_TexEnv( int env )
-{
-	if ( env == glState.texEnv[glState.currenttmu] )
-	{
-		return;
-	}
-
-	glState.texEnv[glState.currenttmu] = env;
-
-
-	switch ( env )
-	{
-	case GL_MODULATE:
-		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
-		break;
-	case GL_REPLACE:
-		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );
-		break;
-	case GL_DECAL:
-		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL );
-		break;
-	case GL_ADD:
-		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_ADD );
-		break;
-	default:
-		ri.Error( ERR_DROP, "GL_TexEnv: invalid env '%d' passed\n", env );
-		break;
-	}
-}
+==================
+SetRenderState
 
-/*
-** GL_State
-**
-** This routine is responsible for setting the most commonly changed state
-** in Q3.
+set all OpenGL state to the values passed in state, avoid calling gl functions
+if the state doesn't actually change
+==================
 */
-void GL_State( unsigned long stateBits )
-{
+static void GL_State( unsigned long stateBits ) {
 	unsigned long diff = stateBits ^ glState.glStateBits;
 
-	if ( !diff )
-	{
+	if ( !diff ) {
 		return;
 	}
 
 	//
 	// check depthFunc bits
 	//
-	if ( diff & GLS_DEPTHFUNC_EQUAL )
-	{
-		if ( stateBits & GLS_DEPTHFUNC_EQUAL )
-		{
+	if ( diff & GLS_DEPTHFUNC_BITS ) {
+		switch( stateBits & GLS_DEPTHFUNC_BITS ) {
+		case GLS_DEPTHFUNC_EQUAL:
 			qglDepthFunc( GL_EQUAL );
-		}
-		else
-		{
+			break;
+		case GLS_DEPTHFUNC_ALWAYS:
+			qglDepthFunc( GL_ALWAYS );
+			break;
+		default:
 			qglDepthFunc( GL_LEQUAL );
+			break;
 		}
 	}
 
 	//
 	// check blend bits
 	//
-	if ( diff & ( GLS_SRCBLEND_BITS | GLS_DSTBLEND_BITS ) )
-	{
+	if ( diff & ( GLS_SRCBLEND_BITS | GLS_DSTBLEND_BITS ) ) {
 		GLenum srcFactor, dstFactor;
 
-		if ( stateBits & ( GLS_SRCBLEND_BITS | GLS_DSTBLEND_BITS ) )
-		{
-			switch ( stateBits & GLS_SRCBLEND_BITS )
-			{
+		if ( stateBits & ( GLS_SRCBLEND_BITS | GLS_DSTBLEND_BITS ) ) {
+			switch ( stateBits & GLS_SRCBLEND_BITS ) {
 			case GLS_SRCBLEND_ZERO:
 				srcFactor = GL_ZERO;
 				break;
@@ -269,8 +198,7 @@
 				break;
 			}
 
-			switch ( stateBits & GLS_DSTBLEND_BITS )
-			{
+			switch ( stateBits & GLS_DSTBLEND_BITS ) {
 			case GLS_DSTBLEND_ZERO:
 				dstFactor = GL_ZERO;
 				break;
@@ -313,79 +241,685 @@
 	//
 	// check depthmask
 	//
-	if ( diff & GLS_DEPTHMASK_TRUE )
-	{
-		if ( stateBits & GLS_DEPTHMASK_TRUE )
-		{
+	if ( diff & GLS_DEPTHMASK_TRUE ) {
+		if ( stateBits & GLS_DEPTHMASK_TRUE ) {
 			qglDepthMask( GL_TRUE );
-		}
-		else
-		{
+		} else {
 			qglDepthMask( GL_FALSE );
 		}
 	}
 
 	//
+	// check colormask
+	//
+	if ( diff & GLS_COLORMASK_FALSE ) {
+		if ( stateBits & GLS_COLORMASK_FALSE ) {
+			qglColorMask( GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE );
+		} else {
+			qglColorMask( GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE );
+		}
+	}
+
+	// check polygon offset
+	if ( diff & GLS_POLYGON_OFFSET ) {
+		if ( stateBits & GLS_POLYGON_OFFSET ) {
+			qglEnable( GL_POLYGON_OFFSET_FILL );
+			qglPolygonOffset( r_offsetFactor->value, r_offsetUnits->value );
+		} else {
+			qglDisable( GL_POLYGON_OFFSET_FILL );
+		}
+	}
+	//
 	// fill/line mode
 	//
-	if ( diff & GLS_POLYMODE_LINE )
+	if ( diff & GLS_POLYMODE_LINE ) {
+		if ( stateBits & GLS_POLYMODE_LINE ) {
+			qglPolygonMode( GL_FRONT_AND_BACK, GL_LINE );
+		} else {
+			qglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
+		}
+	}
+
+	//
+	// depthtest
+	//
+	if ( diff & GLS_DEPTHTEST_DISABLE ) {
+		if ( stateBits & GLS_DEPTHTEST_DISABLE ) {
+			qglDisable( GL_DEPTH_TEST );
+		} else {
+			qglEnable( GL_DEPTH_TEST );
+		}
+	}
+
+	//
+	// depth range
+	//
+	if ( diff & GLS_DEPTHRANGE_BITS ) {
+		switch ( stateBits & GLS_DEPTHRANGE_BITS ) {
+		case GLS_DEPTHRANGE_0_TO_1:
+			qglDepthRange( 0.0f, 1.0f );
+			break;
+		case GLS_DEPTHRANGE_0_TO_0:
+			qglDepthRange( 0.0f, 0.0f );
+			break;
+		case GLS_DEPTHRANGE_1_TO_1:
+			qglDepthRange( 1.0f, 1.0f );
+			break;
+		case GLS_DEPTHRANGE_0_TO_03:
+			qglDepthRange( 0.0f, 0.3f );
+			break;
+		}
+	}
+
+	//
+	// alpha test
+	//
+	if ( diff & GLS_ATEST_BITS ) {
+		switch ( stateBits & GLS_ATEST_BITS ) {
+		case 0:
+			qglDisable( GL_ALPHA_TEST );
+			break;
+		case GLS_ATEST_GT_0:
+			qglEnable( GL_ALPHA_TEST );
+			qglAlphaFunc( GL_GREATER, 0.0f );
+			break;
+		case GLS_ATEST_LT_80:
+			qglEnable( GL_ALPHA_TEST );
+			qglAlphaFunc( GL_LESS, 0.5f );
+			break;
+		case GLS_ATEST_GE_80:
+			qglEnable( GL_ALPHA_TEST );
+			qglAlphaFunc( GL_GEQUAL, 0.5f );
+			break;
+		default:
+			assert( 0 );
+			break;
+		}
+	}
+
+	glState.glStateBits = stateBits;
+}
+static void GL_Cull( int cullType ) {
+	if ( glState.faceCulling == cullType ) {
+		return;
+	}
+
+	glState.faceCulling = cullType;
+
+	if ( cullType == CT_TWO_SIDED ) 
+	{
+		qglDisable( GL_CULL_FACE );
+	} 
+	else 
 	{
-		if ( stateBits & GLS_POLYMODE_LINE )
+		qglEnable( GL_CULL_FACE );
+
+		if ( cullType == CT_BACK_SIDED )
 		{
-			qglPolygonMode( GL_FRONT_AND_BACK, GL_LINE );
+			if ( backEnd.viewParms.isMirror )
+			{
+				qglCullFace( GL_FRONT );
+			}
+			else
+			{
+				qglCullFace( GL_BACK );
+			}
 		}
 		else
 		{
-			qglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
+			if ( backEnd.viewParms.isMirror )
+			{
+				qglCullFace( GL_BACK );
+			}
+			else
+			{
+				qglCullFace( GL_FRONT );
+			}
+		}
+	}
+}
+void GL_Program( GLSLprogram_t *program )
+{
+	if ( glState.currentProgram != program ) {
+		glState.currentProgram = program;
+		qglUseProgram( program ? program->handle : 0 );
+	}
+}
+static void DisableAttributePointer( int attr ) {
+	switch( attr ) {
+	case AL_VERTEX:
+		qglDisableClientState( GL_VERTEX_ARRAY );
+		break;
+	case AL_NORMAL:
+		qglDisableClientState( GL_NORMAL_ARRAY );
+		break;
+	case AL_COLOR:
+		qglDisableClientState( GL_COLOR_ARRAY );
+		break;
+	case AL_TEXCOORD:
+	case AL_TEXCOORD2:
+	case AL_TEXCOORD3:
+	case AL_TEXCOORD4:
+		if( qglClientActiveTextureARB )
+			qglClientActiveTextureARB( attr - AL_TEXCOORD + GL_TEXTURE0_ARB );
+		qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
+		break;
+	default:
+		qglDisableVertexAttribArrayARB( attr );
+		break;
+	}
+}
+static void EnableAttributePointer( int attr ) {
+	switch( attr ) {
+	case AL_VERTEX:
+		qglEnableClientState( GL_VERTEX_ARRAY );
+		break;
+	case AL_NORMAL:
+		qglEnableClientState( GL_NORMAL_ARRAY );
+		break;
+	case AL_COLOR:
+		qglEnableClientState( GL_COLOR_ARRAY );
+		break;
+	case AL_TEXCOORD:
+	case AL_TEXCOORD2:
+	case AL_TEXCOORD3:
+	case AL_TEXCOORD4:
+		if( qglClientActiveTextureARB )
+			qglClientActiveTextureARB( attr - AL_TEXCOORD + GL_TEXTURE0_ARB );
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+		break;
+	default:
+		qglEnableVertexAttribArrayARB( attr );
+		break;
+	}
+}
+static void SetAttribute4f( int attr, vec_t *values ) {
+	switch( attr ) {
+	case AL_VERTEX:
+		qglVertex4fv( values );
+		break;
+	case AL_NORMAL:
+		qglNormal3fv( values );
+		break;
+	case AL_COLOR:
+		qglColor4fv( values );
+		break;
+	case AL_TEXCOORD:
+		qglTexCoord4fv( values );
+		break;
+	case AL_TEXCOORD2:
+	case AL_TEXCOORD3:
+	case AL_TEXCOORD4:
+		if( qglMultiTexCoord4fvARB )
+			qglMultiTexCoord4fvARB( attr - AL_TEXCOORD + GL_TEXTURE0_ARB, values );
+		break;
+	default:
+		qglVertexAttrib4fvARB( attr, values );
+		break;
+	}
+	glState.glAttribute[attr].attrStatus = attrIsValue;
+	glState.glAttribute[attr].currentValues[0] = values[0];
+	glState.glAttribute[attr].currentValues[1] = values[1];
+	glState.glAttribute[attr].currentValues[2] = values[2];
+	glState.glAttribute[attr].currentValues[3] = values[3];
+}
+static void SetAttributePointer( int attr, GLuint VBO, GLint size,
+				 GLenum type, GLsizei stride, void *ptr ) {
+	GL_VBO( VBO );
+	switch( attr ) {
+	case AL_VERTEX:
+		qglVertexPointer( size, type, stride, ptr );
+		break;
+	case AL_NORMAL:
+		qglNormalPointer( type, stride, ptr );
+		break;
+	case AL_COLOR:
+		qglColorPointer( size, type, stride, ptr );
+		break;
+	case AL_TEXCOORD:
+	case AL_TEXCOORD2:
+	case AL_TEXCOORD3:
+	case AL_TEXCOORD4:
+		if( qglClientActiveTextureARB )
+			qglClientActiveTextureARB( attr - AL_TEXCOORD + GL_TEXTURE0_ARB );
+		qglTexCoordPointer( size, type, stride, ptr );
+		break;
+	default:
+		qglVertexAttribPointerARB( attr, size, type, GL_FALSE, stride, ptr );
+		break;
+	}
+	glState.glAttribute[attr].attrStatus = attrIsPointer;
+	glState.glAttribute[attr].vbo = VBO;
+	glState.glAttribute[attr].ptr = ptr;
+}
+static void SetRenderState( glRenderState_t *state, qboolean *doLock ) {
+	int i;
+	unsigned int attributes;
+
+	if(backEnd.currentEntity &&
+	   (backEnd.currentEntity->e.renderfx & RF_DEPTHHACK) ) {
+		if( (state->stateBits & GLS_DEPTHRANGE_BITS) == GLS_DEPTHRANGE_0_TO_1 )
+			state->stateBits |= GLS_DEPTHRANGE_0_TO_03;
+	}
+
+	GL_State( state->stateBits );
+	GL_Cull( state->faceCulling );
+	GL_Program( state->program );
+	GL_BindImages( state->numImages, state->image, state->program != NULL );
+
+	if( state->program )
+		attributes = state->program->attributes;
+	else
+		attributes = (1 << AL_VERTEX) | (1 << AL_NORMAL) |
+			(1 << AL_COLOR) | (1 << AL_TEXCOORD) |
+			(1 << AL_TEXCOORD2) | (1 << AL_TEXCOORD3) |
+			(1 << AL_TEXCOORD4);
+
+	*doLock = qfalse;
+	for( i = 0; i < AL_NUMATTRIBUTES; i++ ) {
+		if( state->attrib[i].attrType == RA_UNSPEC ||
+		    !(attributes & (1 << i)) ) {
+			if( glState.glAttribute[i].attrStatus == attrIsPointer ) {
+				// diable pointer for unspecified attrs,
+				// otherwise OpenGL may segfault
+				DisableAttributePointer( i );
+				glState.glAttribute[i].attrStatus = attrIsUndefined;
+			}
+		} else if( state->attrib[i].attrType == RA_VEC ) {
+			if( glState.glAttribute[i].attrStatus == attrIsPointer ) {
+				DisableAttributePointer( i );
+				SetAttribute4f( i, state->attrib[i].vec );
+			} else if( glState.glAttribute[i].attrStatus == attrIsValue &&
+				   glState.glAttribute[i].currentValues[0] == state->attrib[i].vec[0] &&
+				   glState.glAttribute[i].currentValues[1] == state->attrib[i].vec[1] &&
+				   glState.glAttribute[i].currentValues[2] == state->attrib[i].vec[2] &&
+				   glState.glAttribute[i].currentValues[3] == state->attrib[i].vec[3] ) {
+				// do nothing, unchanged attribute
+			} else {
+				SetAttribute4f( i, state->attrib[i].vec );
+			}
+		} else {
+			if( state->attrib[i].VBO == 0 )
+				*doLock = qtrue;
+
+			if( glState.glAttribute[i].attrStatus == attrIsPointer ) {
+				if( state->attrib[i].VBO == 0 ||
+				    state->attrib[i].VBO == backEnd.streamVBO.ibo ||
+				    glState.glAttribute[i].vbo != state->attrib[i].VBO ||
+				    glState.glAttribute[i].ptr != state->attrib[i].ptr ) {
+					// pointer or VBO changed
+					// for VBO 0/streamVBO the pointer is always updated
+					// because the engine may reuse buffers
+					SetAttributePointer( i, state->attrib[i].VBO,
+							     state->attrib[i].size,
+							     state->attrib[i].type,
+							     state->attrib[i].stride,
+							     state->attrib[i].ptr );
+				}
+			} else {
+				EnableAttributePointer( i );
+				SetAttributePointer( i, state->attrib[i].VBO,
+						     state->attrib[i].size,
+						     state->attrib[i].type,
+						     state->attrib[i].stride,
+						     state->attrib[i].ptr );
+			}
+		}
+	}
+}
+
+void GL_StartQuery( GLuint query, GLuint *result ) {
+	if( !(*result & QUERY_RUNNING_BIT) )
+		qglBeginQueryARB( GL_SAMPLES_PASSED_ARB, query );
+}
+void GL_EndQuery( GLuint query, GLuint *result ) {
+	if( !(*result & QUERY_RUNNING_BIT) )
+		qglEndQueryARB( GL_SAMPLES_PASSED_ARB );
+	*result |= QUERY_RUNNING_BIT;
+}
+void GL_GetQuery( GLuint query, GLuint *result ) {
+	GLuint available;
+
+	if( *result & QUERY_RUNNING_BIT ) {
+		qglGetQueryObjectuivARB( query,
+					 GL_QUERY_RESULT_AVAILABLE_ARB,
+					 &available);
+		if ( available ) {
+			qglGetQueryObjectuivARB( query,
+						 GL_QUERY_RESULT_ARB,
+						 result);
+
+			if( *result & QUERY_RUNNING_BIT )
+				*result = QUERY_MASK;		// overflow
+		}
+	}
+}
+
+void GL_DrawElements( glRenderState_t *state,
+		      int numIndexes, GLuint IBO, const void *indexes,
+		      GLuint start, GLuint end, GLuint max ) {
+	GLenum  type = max > 65535 ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT;
+	qboolean doLock;
+
+	if( numIndexes <= 0 )
+		return;
+
+	SetRenderState( state, &doLock );
+	GL_IBO( IBO );
+	
+	if( doLock && qglLockArraysEXT ) {
+		qglLockArraysEXT( start, end - start + 1 );
+	}
+	if ( qglDrawRangeElementsEXT )
+		qglDrawRangeElementsEXT( GL_TRIANGLES, 
+					 start, end,
+					 numIndexes,
+					 type,
+					 indexes );
+	else
+		qglDrawElements( GL_TRIANGLES,
+				 numIndexes,
+				 type,
+				 indexes );
+	if( doLock && qglLockArraysEXT ) {
+		qglUnlockArraysEXT( );
+	}
+}
+void GL_DrawArrays( glRenderState_t *state,
+		    GLenum mode, GLint first, GLuint count ) {
+	qboolean doLock;
+
+	SetRenderState( state, &doLock );
+	
+	if( doLock && qglLockArraysEXT ) {
+		qglLockArraysEXT( first, count );
+	}
+	qglDrawArrays( mode, first, count );
+	if( doLock && qglLockArraysEXT ) {
+		qglUnlockArraysEXT( );
+	}
+}
+
+
+/*
+** GL_TexEnv
+*/
+void GL_TexEnv( int tmu, int env )
+{
+	if ( env == glState.texEnv[tmu] )
+	{
+		return;
+	}
+
+	if( qglActiveTextureARB ) {
+		glState.texEnv[tmu] = env;
+		qglActiveTextureARB( GL_TEXTURE0_ARB + tmu );
+	}
+
+	switch ( env )
+	{
+	case GL_MODULATE:
+		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
+		break;
+	case GL_REPLACE:
+		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );
+		break;
+	case GL_DECAL:
+		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL );
+		break;
+	case GL_ADD:
+		qglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_ADD );
+		break;
+	default:
+		ri.Error( ERR_DROP, "GL_TexEnv: invalid env '%d' passed\n", env );
+		break;
+	}
+}
+
+/*
+** GL_State
+**
+** This routine is responsible for setting the most commonly changed state
+** in Q3.
+*/
+void GL_VBO( GLuint vbo )
+{
+	if ( glState.currentVBO != vbo ) {
+		glState.currentVBO = vbo;
+		qglBindBufferARB (GL_ARRAY_BUFFER_ARB, vbo );
+	}
+}
+void GL_IBO( GLuint ibo )
+{
+	if ( glState.currentIBO != ibo ) {
+		glState.currentIBO = ibo;
+		qglBindBufferARB (GL_ELEMENT_ARRAY_BUFFER_ARB, ibo );
+	}
+}
+
+// simple, fast allocator for the backend thread
+// memory must be freed in LIFO order
+static byte	*scratchStart, *scratchPtr;
+static size_t	freeScratch;
+void RB_InitScratchMemory( void ) {
+	freeScratch = r_scratchmegs->integer;
+	if( freeScratch <= SMP_SCRATCHMEGS )
+		freeScratch = SMP_SCRATCHMEGS;
+	freeScratch *= 1024 * 1024;
+
+	scratchStart = scratchPtr = ri.Hunk_Alloc( freeScratch, h_low );
+}
+void *RB_AllocScratch( size_t amount ) {
+	byte *mem = scratchPtr;
+
+	amount = (amount + 31) & -32;
+	if( amount > freeScratch ) {
+		ri.Error( ERR_DROP, "RB_AllocScratch: out of scratch memory, try to increase /r_scratchmegs\n" );
+	}
+	scratchPtr += amount;
+	freeScratch -= amount;
+	return mem;
+}
+void RB_FreeScratch( void *ptr ) {
+	if( (byte *)ptr < scratchStart || (byte *)ptr > scratchPtr ) {
+		ri.Error( ERR_DROP, "RB_FreeScratch: bad pointer\n" );
+	}
+	freeScratch += (scratchPtr - (byte *)ptr);
+	scratchPtr = ptr;
+}
+
+GLSLshader_t *RB_CompileShader( GLenum type, const char **code, int parts ) {
+	GLSLshader_t	*shader;
+	GLint 		status;
+	GLint		i, j;
+	unsigned int	hash;
+	const char	*ptr;
+	
+	// try to reuse existing shader
+	for( i = 0, hash = 0; i < parts; i++ ) {
+		for( ptr = code[i]; *ptr; ptr++ ) {
+			hash = *ptr + hash * 65599;
 		}
 	}
+	
+	for( i = 0; i < tr.numGLSLshaders; i++ ) {
+		if( tr.GLSLshaders[i]->hash == hash ) {
+			GLint   length;
+			char    *source, *sourcePtr;
+			qboolean same = qtrue;
+
+			qglGetShaderiv( tr.GLSLshaders[i]->handle,
+					GL_SHADER_SOURCE_LENGTH,
+					&length );
+			sourcePtr = source = ri.Hunk_AllocateTempMemory( length + 1 );
+			qglGetShaderSource( tr.GLSLshaders[i]->handle, length + 1,
+					    NULL, source );
+			
+			for( j = 0; j < parts; j++ ) {
+				for( ptr = code[j]; *ptr; ptr++, sourcePtr++ ) {
+					if( *ptr != *sourcePtr )
+						break;
+				}
+			}
+			same = *sourcePtr == '\0';
+			ri.Hunk_FreeTempMemory( source );
 
-	//
-	// depthtest
-	//
-	if ( diff & GLS_DEPTHTEST_DISABLE )
-	{
-		if ( stateBits & GLS_DEPTHTEST_DISABLE )
-		{
-			qglDisable( GL_DEPTH_TEST );
-		}
-		else
-		{
-			qglEnable( GL_DEPTH_TEST );
+			if( same )
+				return tr.GLSLshaders[i];
 		}
 	}
 
-	//
-	// alpha test
-	//
-	if ( diff & GLS_ATEST_BITS )
-	{
-		switch ( stateBits & GLS_ATEST_BITS )
-		{
-		case 0:
-			qglDisable( GL_ALPHA_TEST );
-			break;
-		case GLS_ATEST_GT_0:
-			qglEnable( GL_ALPHA_TEST );
-			qglAlphaFunc( GL_GREATER, 0.0f );
-			break;
-		case GLS_ATEST_LT_80:
-			qglEnable( GL_ALPHA_TEST );
-			qglAlphaFunc( GL_LESS, 0.5f );
-			break;
-		case GLS_ATEST_GE_80:
-			qglEnable( GL_ALPHA_TEST );
-			qglAlphaFunc( GL_GEQUAL, 0.5f );
-			break;
-		default:
-			assert( 0 );
-			break;
-		}
+	shader = ri.Hunk_Alloc( sizeof(GLSLprogram_t), h_low );
+	shader->handle = qglCreateShader( type );
+	shader->hash = hash;
+	qglShaderSource( shader->handle, parts, code, NULL );
+	qglCompileShader( shader->handle );
+	qglGetShaderiv( shader->handle, GL_OBJECT_COMPILE_STATUS_ARB, &status );
+	if( !status ) {
+		char *log;
+		GLint len;
+		qglGetShaderiv( shader->handle, GL_OBJECT_INFO_LOG_LENGTH_ARB, &len );
+		log = ri.Hunk_AllocateTempMemory( len + 1 );
+		qglGetShaderInfoLog( shader->handle, len + 1, &len, log );
+		
+		ri.Printf( PRINT_WARNING, "compile shader error: %s\n", log );
+		while( parts > 0 ) {
+			ri.Printf( PRINT_WARNING, "%s", *(code++) );
+			parts--;
+		}
+		
+		ri.Hunk_FreeTempMemory( log );
+		qglDeleteShader( shader->handle );
+		return NULL;
+	}
+	tr.GLSLshaders[tr.numGLSLshaders++] = shader;
+	return shader;
+}
+
+GLSLprogram_t *RB_CompileGSProgram( const char *name,
+				    const char **VScode, int VSparts,
+				    const char **GScode, int GSparts,
+				    int nVerticesOut, int inType, int outType,
+				    const char **FScode, int FSparts,
+				    unsigned int attributes ) {
+	GLSLshader_t	*VertexShader = NULL;
+	GLSLshader_t	*GeometryShader = NULL;
+	GLSLshader_t	*FragmentShader = NULL;
+	GLint		Program;
+	GLint		i;
+	GLSLprogram_t	*newProgram;
+
+	// find shaders
+	if( VSparts > 0 ) {
+		VertexShader = RB_CompileShader( GL_VERTEX_SHADER_ARB, VScode, VSparts );
+		if( !VertexShader )
+			return NULL;  // compilation error
+	}
+	if( GSparts > 0 ) {
+		GeometryShader = RB_CompileShader( GL_GEOMETRY_SHADER_EXT, GScode, GSparts );
+		if( !GeometryShader )
+			return NULL;  // compilation error
+	}
+	if( FSparts > 0 ) {
+		FragmentShader = RB_CompileShader( GL_FRAGMENT_SHADER_ARB, FScode, FSparts );
+		if( !FragmentShader )
+			return NULL;  // compilation error
+	}
+
+	// try to reuse existing program
+	for( i = 0; i < tr.numGLSLprograms; i++ ) {
+		if( tr.GLSLprograms[i]->vertex == VertexShader &&
+		    tr.GLSLprograms[i]->geometry == GeometryShader &&
+		    tr.GLSLprograms[i]->fragment == FragmentShader ) {
+			return tr.GLSLprograms[i];
+		}
+	}
+
+	Program = qglCreateProgram();
+	if( VertexShader )
+		qglAttachShader( Program, VertexShader->handle );
+	if( GeometryShader ) {
+		qglAttachShader( Program, GeometryShader->handle );
+
+		qglProgramParameteriEXT( Program, GL_GEOMETRY_VERTICES_OUT_EXT, nVerticesOut );
+		qglProgramParameteriEXT( Program, GL_GEOMETRY_INPUT_TYPE_EXT, inType );
+		qglProgramParameteriEXT( Program, GL_GEOMETRY_OUTPUT_TYPE_EXT, outType );
+	}
+	if( FragmentShader )
+		qglAttachShader( Program, FragmentShader->handle );
+	
+	if( attributes & (1 << AL_CAMERAPOS) )
+		qglBindAttribLocationARB( Program, AL_CAMERAPOS,     "aCameraPos" );
+	if( attributes & (1 << AL_TIMES) )
+		qglBindAttribLocationARB( Program, AL_TIMES,         "aTimes" );
+	if( attributes & (1 << AL_TRANSX) )
+		qglBindAttribLocationARB( Program, AL_TRANSX,        "aTransX" );
+	if( attributes & (1 << AL_TRANSY) )
+		qglBindAttribLocationARB( Program, AL_TRANSY,        "aTransY" );
+	if( attributes & (1 << AL_TRANSZ) )
+		qglBindAttribLocationARB( Program, AL_TRANSZ,        "aTransZ" );
+	if( attributes & (1 << AL_AMBIENTLIGHT) )
+		qglBindAttribLocationARB( Program, AL_AMBIENTLIGHT,  "aAmbientLight" );
+	if( attributes & (1 << AL_DIRECTEDLIGHT) )
+		qglBindAttribLocationARB( Program, AL_DIRECTEDLIGHT, "aDirectedLight" );
+	if( attributes & (1 << AL_LIGHTDIR) )
+		qglBindAttribLocationARB( Program, AL_LIGHTDIR,      "aLightDir" );
+	
+	qglLinkProgram( Program );
+	qglGetProgramiv( Program, GL_OBJECT_LINK_STATUS_ARB, &i );
+	if ( !i ) {
+		char *log;
+		qglGetProgramiv( Program, GL_OBJECT_INFO_LOG_LENGTH_ARB, &i );
+		log = ri.Hunk_AllocateTempMemory( i + 1 );
+		qglGetProgramInfoLog( Program, i + 1, &i, log );
+		
+		ri.Printf( PRINT_WARNING, "link shader %s error: %s\n", name, log );
+		while( VSparts > 0 ) {
+			ri.Printf( PRINT_WARNING, "%s", *(VScode++) );
+			VSparts--;
+		}
+		while( GSparts > 0 ) {
+			ri.Printf( PRINT_WARNING, "%s", *(GScode++) );
+			GSparts--;
+		}
+		while( FSparts > 0 ) {
+			ri.Printf( PRINT_WARNING, "%s", *(FScode++) );
+			FSparts--;
+		}
+
+		ri.Hunk_FreeTempMemory( log );
+		qglDeleteProgram( Program );
+		if( FragmentShader )
+			qglDeleteShader( FragmentShader->handle );
+		if( GeometryShader )
+			qglDeleteShader( GeometryShader->handle );
+		if( VertexShader )
+			qglDeleteShader( VertexShader->handle );
+		return NULL;
 	}
 
-	glState.glStateBits = stateBits;
-}
+	newProgram = ri.Hunk_Alloc( sizeof(GLSLprogram_t), h_low );
+	tr.GLSLprograms[tr.numGLSLprograms++] = newProgram;
+	
+	newProgram->handle = Program;
 
+	newProgram->vertex = VertexShader;
+	newProgram->geometry = GeometryShader;
+	newProgram->fragment = FragmentShader;
+	newProgram->attributes = attributes;
+
+	return newProgram;
+}
+GLSLprogram_t *RB_CompileProgram( const char *name,
+				  const char **VScode, int VSparts,
+				  const char **FScode, int FSparts,
+				  unsigned int attributes ) {
+	return RB_CompileGSProgram( name, VScode, VSparts,
+				    NULL, 0,
+				    0, 0, 0,
+				    FScode, FSparts,
+				    attributes );
+}
 
 
 /*
@@ -411,8 +945,29 @@
 
 
 static void SetViewportAndScissor( void ) {
+	float	mat[16], scale;
+	vec4_t	q, c;
+	
+	Com_Memcpy( mat, backEnd.viewParms.projectionMatrix, sizeof(mat) );
+	if( backEnd.viewParms.portalLevel ) {
+		c[0] = -DotProduct( backEnd.viewParms.portalPlane.normal, backEnd.viewParms.or.axis[1] );
+		c[1] = DotProduct( backEnd.viewParms.portalPlane.normal, backEnd.viewParms.or.axis[2] );
+		c[2] = -DotProduct( backEnd.viewParms.portalPlane.normal, backEnd.viewParms.or.axis[0] );
+		c[3] = DotProduct( backEnd.viewParms.portalPlane.normal, backEnd.viewParms.or.origin ) - backEnd.viewParms.portalPlane.dist;
+		
+		q[0] = (c[0] < 0.0f ? -1.0f : 1.0f) / mat[0];
+		q[1] = (c[1] < 0.0f ? -1.0f : 1.0f) / mat[5];
+		q[2] = -1.0f;
+		q[3] = (1.0f + mat[10]) / mat[14];
+		
+		scale = 2.0f / (DotProduct( c, q ) + c[3] * q[3]);
+		mat[2]  = c[0] * scale;
+		mat[6]  = c[1] * scale;
+		mat[10] = c[2] * scale + 1.0f;
+		mat[14] = c[3] * scale;
+	}
 	qglMatrixMode(GL_PROJECTION);
-	qglLoadMatrixf( backEnd.viewParms.projectionMatrix );
+	qglLoadMatrixf( mat );
 	qglMatrixMode(GL_MODELVIEW);
 
 	// set the window clipping
@@ -454,22 +1009,25 @@
 	// ensures that depth writes are enabled for the depth clear
 	GL_State( GLS_DEFAULT );
 	// clear relevant buffers
-	clearBits = GL_DEPTH_BUFFER_BIT;
-
-	if ( r_measureOverdraw->integer || r_shadows->integer == 2 )
-	{
-		clearBits |= GL_STENCIL_BUFFER_BIT;
-	}
-	if ( r_fastsky->integer && !( backEnd.refdef.rdflags & RDF_NOWORLDMODEL ) )
-	{
-		clearBits |= GL_COLOR_BUFFER_BIT;	// FIXME: only if sky shaders have been used
+	if ( backEnd.viewParms.isFirst ) {
+		clearBits = GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT;
+		
+		if ( r_clear->integer ) {
+			clearBits |= GL_COLOR_BUFFER_BIT;
+			qglClearColor( 1.0f, 0.0f, 0.5f, 1.0f );
+		}
+		if ( r_fastsky->integer && !( backEnd.refdef.rdflags & RDF_NOWORLDMODEL ) )
+		{
+			clearBits |= GL_COLOR_BUFFER_BIT;	// FIXME: only if sky shaders have been used
 #ifdef _DEBUG
-		qglClearColor( 0.8f, 0.7f, 0.4f, 1.0f );	// FIXME: get color of sky
+			qglClearColor( 0.8f, 0.7f, 0.4f, 1.0f );	// FIXME: get color of sky
 #else
-		qglClearColor( 0.0f, 0.0f, 0.0f, 1.0f );	// FIXME: get color of sky
+			qglClearColor( 0.0f, 0.0f, 0.0f, 1.0f );	// FIXME: get color of sky
 #endif
+		}
+		qglStencilMask( glGlobals.portalMask | glGlobals.shadowMask );
+		qglClear( clearBits );
 	}
-	qglClear( clearBits );
 
 	if ( ( backEnd.refdef.rdflags & RDF_HYPERSPACE ) )
 	{
@@ -485,33 +1043,309 @@
 
 	// we will only draw a sun if there was sky rendered in this view
 	backEnd.skyRenderedThisView = qfalse;
+}
+
+
+/*
+==================
+RB_FindShaderVBO
+==================
+*/
+static int
+findShaderVBO( vboInfo_t **root, int VBOkey ) {
+	vboInfo_t node, *left, *right, *tmp;
+	qboolean  found = qfalse;
+
+	if ( !*root )
+		return qfalse;
+
+	node.left = node.right = NULL;
+	left = right = &node;
+	
+	while( 1 ) {
+		if( VBOkey < (*root)->key ) {
+			tmp = (*root)->left;
+			if( !tmp )
+				break;
+			if( VBOkey < tmp->key ) {
+				(*root)->left = tmp->right;
+				tmp->right = *root;
+				*root = tmp;
+				if( !(*root)->left )
+					break;
+			}
+			right->left = *root;
+			right = *root;
+			*root = (*root)->left;
+		} else if( VBOkey > (*root)->key ) {
+			tmp = (*root)->right;
+			if( !tmp )
+				break;
+			if( VBOkey > tmp->key ) {
+				(*root)->right = tmp->left;
+				tmp->left = *root;
+				*root = tmp;
+				if( !(*root)->right )
+					break;
+			}
+			left->right = *root;
+			left = *root;
+			*root = (*root)->right;
+		} else {
+			found = qtrue;
+			break;
+		}
+	}
+        left->right = (*root)->left;
+	right->left = (*root)->right;
+        (*root)->left = node.right;
+        (*root)->right = node.left;
+	return found;
+}
+
+static void newShaderVBO( vboInfo_t **root, int VBOkey )
+{
+	vboInfo_t *new;
 
-	// clip to the plane of the portal
-	if ( backEnd.viewParms.isPortal ) {
-		float	plane[4];
-		double	plane2[4];
-
-		plane[0] = backEnd.viewParms.portalPlane.normal[0];
-		plane[1] = backEnd.viewParms.portalPlane.normal[1];
-		plane[2] = backEnd.viewParms.portalPlane.normal[2];
-		plane[3] = backEnd.viewParms.portalPlane.dist;
-
-		plane2[0] = DotProduct (backEnd.viewParms.or.axis[0], plane);
-		plane2[1] = DotProduct (backEnd.viewParms.or.axis[1], plane);
-		plane2[2] = DotProduct (backEnd.viewParms.or.axis[2], plane);
-		plane2[3] = DotProduct (plane, backEnd.viewParms.or.origin) - plane[3];
-
-		qglLoadMatrixf( s_flipMatrix );
-		qglClipPlane (GL_CLIP_PLANE0, plane2);
-		qglEnable (GL_CLIP_PLANE0);
+	if ( !backEnd.vboReserveCount ) {
+		backEnd.vboReserve = ri.Hunk_Alloc( sizeof(vboInfo_t) *
+						    (backEnd.vboReserveCount = 1000),
+						    h_dontcare );
+	}
+	
+	new = backEnd.vboReserve++;
+	backEnd.vboReserveCount--;
+	
+	// requires that the tree has been splayed with findShaderVBO
+	// before
+	if( !*root ) {
+		new->left = new->right = NULL;
 	} else {
-		qglDisable (GL_CLIP_PLANE0);
+		if( VBOkey < (*root)->key ) {
+			new->left = (*root)->left;
+			(*root)->left = NULL;
+			new->right = *root;
+		} else if ( VBOkey > (*root)->key ) {
+			new->right = (*root)->right;
+			(*root)->right = NULL;
+			new->left = *root;
+		} else
+			return; // should not happen
+	}
+	*root = new;
+}
+
+vboInfo_t *RB_CreateShaderVBO( vboInfo_t **root, int VBOkey ) {
+	if( !findShaderVBO( root, VBOkey ) ) {
+		newShaderVBO( root, VBOkey );
+		(*root)->vbo = 0;
+		(*root)->ibo = 0;
 	}
+	(*root)->key = VBOkey;
+	
+	return *root;
 }
+void RB_CopyVBO( vboInfo_t **root, int VBOkeyNew, int VBOkeyOld ) {
+	vboInfo_t *oldVBO;
+	if( !findShaderVBO( root, VBOkeyOld ) )
+		return;
 
+	oldVBO = *root;
+	
+	if( !findShaderVBO( root, VBOkeyNew ) ) {
+		newShaderVBO( root, VBOkeyNew );
+		(*root)->vbo = oldVBO->vbo;
+		(*root)->ibo = oldVBO->ibo;
+		(*root)->numIndexes = oldVBO->numIndexes;
+		(*root)->minIndex = oldVBO->minIndex;
+		(*root)->maxIndex = oldVBO->maxIndex;
+		(*root)->offs1 = oldVBO->offs1;
+		(*root)->offs2 = oldVBO->offs2;
+		(*root)->offs3 = oldVBO->offs3;
+		(*root)->offs4 = oldVBO->offs4;
+		(*root)->offsIdx = oldVBO->offsIdx;
+	}
+	(*root)->key = VBOkeyNew;
+}
 
 #define	MAC_EVENT_PUMP_MSEC		5
 
+
+void RB_ClearVertexBuffer( void ) {
+	tess.indexPtr.p16 = NULL;
+	tess.indexInc = 0;
+	tess.vertexPtr1 = NULL;
+	tess.vertexPtr2 = NULL;
+	tess.vertexPtr3 = NULL;
+	tess.vertexPtr4 = NULL;
+
+	tess.numVertexes = tess.numIndexes = tess.maxIndex = 0;
+}
+void RB_SetupVertexBuffer(shader_t *shader, vboInfo_t *vbo) {
+	const size_t	vertexSize = sizeof(vaWord1_t) + sizeof(vaWord2_t)
+		+ sizeof(vaWord3_t) + sizeof(vaWord4_t);
+	size_t		requiredSizeVBO;
+	size_t		requiredSizeRAM;
+	byte		*vboPtr, *ramPtr;
+
+	if ( shader == tr.shadowShader ) {
+		// need more room for stencil shadows
+		tess.numVertexes *= 2;
+		tess.numIndexes *= 6;
+	}
+
+	if ( tess.numVertexes > 65536 ) {
+		tess.indexInc = sizeof(GLuint);
+	} else {
+		tess.indexInc = sizeof(GLushort);
+	}
+
+	// round to next multiple of 4 vertexes for alignment
+	tess.numVertexes = (tess.numVertexes + 3) & -4;
+
+	if( vbo && vbo->ibo ) {
+		if( vbo->vbo ) {
+			// VBO for vertex and index data
+			requiredSizeVBO = vertexSize * tess.numVertexes;
+		} else {
+			// VBO for indexes only (use worldVBO for data)
+			if( backEnd.worldVBO.maxIndex >= 65536 ) {
+				tess.indexInc = sizeof(GLuint);
+			} else {
+				tess.indexInc = sizeof(GLushort);
+			}
+			requiredSizeVBO = 0;
+		}
+		requiredSizeVBO += tess.indexInc * tess.numIndexes;
+		requiredSizeRAM = 0;
+	} else {
+		if( vbo && vbo->vbo ) {
+			// VBO for vertex data only (building worldVBO)
+			requiredSizeVBO = vertexSize * tess.numVertexes;
+			requiredSizeRAM = tess.indexInc * tess.numIndexes;
+		} else {
+			// all in RAM
+			requiredSizeRAM = vertexSize * tess.numVertexes;
+			requiredSizeRAM += tess.indexInc * tess.numIndexes;
+			requiredSizeVBO = 0;
+		}
+	}
+
+	if( requiredSizeVBO > 0 ) {
+		tess.streaming = vbo;
+
+		if( vbo->ibo ) {
+			GLenum	usage;
+			GL_IBO( vbo->ibo );
+
+			if( vbo->ibo == backEnd.streamVBO.ibo )
+				usage = GL_STREAM_DRAW_ARB;
+			else
+				usage = GL_STATIC_DRAW_ARB;
+			qglBufferDataARB(GL_ELEMENT_ARRAY_BUFFER_ARB,
+					 requiredSizeVBO, NULL, usage );
+			vboPtr = qglMapBufferARB( GL_ELEMENT_ARRAY_BUFFER,
+						  GL_WRITE_ONLY_ARB );
+		} else {
+			GL_IBO( vbo->vbo );
+			qglBufferDataARB(GL_ELEMENT_ARRAY_BUFFER_ARB,
+					 requiredSizeVBO, NULL, GL_STATIC_DRAW_ARB );
+			vboPtr = qglMapBufferARB( GL_ELEMENT_ARRAY_BUFFER,
+						  GL_WRITE_ONLY_ARB );
+		}
+	} else {
+		vboPtr = NULL;
+	}
+
+	if( requiredSizeRAM > 0 ) {
+		requiredSizeRAM += 16 + sizeof(int);
+
+		if ( tess.vertexBuffer ) {
+			if ( *(int *)tess.vertexBufferEnd != 0xDEADBEEF) {
+				ri.Error( ERR_DROP, "VertexBuffer overflow" );
+			}
+			if ( tess.vertexBufferEnd - tess.vertexBuffer < requiredSizeRAM - sizeof(int) ) {
+				ri.Free( tess.vertexBuffer );
+				tess.vertexBuffer = tess.vertexBufferEnd = NULL;
+			}
+		}
+		
+		if ( !tess.vertexBuffer ) {
+			tess.vertexBuffer = ri.Malloc( requiredSizeRAM );
+			tess.vertexBufferEnd = tess.vertexBuffer + requiredSizeRAM - sizeof(int);
+			*(int *)tess.vertexBufferEnd = 0xDEADBEEF;
+		}
+
+		ramPtr = (byte *)(((intptr_t)tess.vertexBuffer + 15) & -16);
+	} else {
+		ramPtr = NULL;
+	}
+
+	if( vbo && vbo->vbo ) {
+		tess.vertexPtr1 = (vaWord1_t *)vboPtr;
+		vboPtr += tess.numVertexes * sizeof(vaWord1_t);
+		vbo->offs1 = (vaWord1_t *)NULL;
+
+		tess.vertexPtr2 = (vaWord2_t *)vboPtr;
+		vboPtr += tess.numVertexes * sizeof(vaWord2_t);
+		vbo->offs2 = (vaWord2_t *)(tess.numVertexes + vbo->offs1);
+
+		tess.vertexPtr3 = (vaWord3_t *)vboPtr;
+		vboPtr += tess.numVertexes * sizeof(vaWord3_t);
+		vbo->offs3 = (vaWord3_t *)(tess.numVertexes + vbo->offs2);
+
+		tess.vertexPtr4 = (vaWord4_t *)vboPtr;
+		vboPtr += tess.numVertexes * sizeof(vaWord4_t);
+		vbo->offs4 = (vaWord4_t *)(tess.numVertexes + vbo->offs3);
+	} else if( !vbo || !vbo->ibo ) {
+		tess.vertexPtr1 = (vaWord1_t *)ramPtr;
+		ramPtr += tess.numVertexes * sizeof(vaWord1_t);
+
+		tess.vertexPtr2 = (vaWord2_t *)ramPtr;
+		ramPtr += tess.numVertexes * sizeof(vaWord2_t);
+
+		tess.vertexPtr3 = (vaWord3_t *)ramPtr;
+		ramPtr += tess.numVertexes * sizeof(vaWord3_t);
+
+		tess.vertexPtr4 = (vaWord4_t *)ramPtr;
+		ramPtr += tess.numVertexes * sizeof(vaWord4_t);
+	} else {
+		tess.vertexPtr1 = NULL;
+		tess.vertexPtr2 = NULL;
+		tess.vertexPtr3 = NULL;
+		tess.vertexPtr4 = NULL;
+	}
+
+	if( vbo && vbo->ibo ) {
+		tess.indexPtr.p16 = (GLushort *)vboPtr;
+		if( vbo->vbo )
+			vbo->offsIdx = (GLushort *)(tess.numVertexes + vbo->offs4);
+		else
+			vbo->offsIdx = (GLushort *)NULL;
+	} else {
+		tess.indexPtr.p16 = (GLushort *)ramPtr;
+	}
+
+	tess.numVertexes = tess.numIndexes = tess.maxIndex = 0;
+}
+void RB_FlushVertexBuffer( void ) {
+	if( tess.streaming ) {
+		qglUnmapBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB );
+
+		// the data is already in the stream VBO
+		tess.streaming->numIndexes = tess.numIndexes;
+		tess.streaming->minIndex = tess.minIndex;
+		tess.streaming->maxIndex = tess.maxIndex;
+
+		tess.streaming->next = tess.firstVBO;
+		tess.firstVBO = tess.streaming;
+
+		tess.streaming = NULL;
+		tess.numIndexes = tess.numVertexes = 0;
+	}
+}
+
+
 /*
 ==================
 RB_RenderDrawSurfList
@@ -522,12 +1356,13 @@
 	int				fogNum, oldFogNum;
 	int				entityNum, oldEntityNum;
 	int				dlighted, oldDlighted;
-	qboolean		depthRange, oldDepthRange, isCrosshair, wasCrosshair;
-	int				i;
-	drawSurf_t		*drawSurf;
-	int				oldSort;
+	qboolean		culled;
+	qboolean		depthRange, oldDepthRange, isCrosshair, wasCrosshair, worldMatrix;
+	int				i, j, k;
+	int				oldSort, endSort, sortMask;
 	float			originalTime;
-
+	qboolean		isGLSL = qfalse;
+	
 	// save original time for entity shader offsets
 	originalTime = backEnd.refdef.floatTime;
 
@@ -547,29 +1382,50 @@
 
 	backEnd.pc.c_surfaces += numDrawSurfs;
 
-	for (i = 0, drawSurf = drawSurfs ; i < numDrawSurfs ; i++, drawSurf++) {
-		if ( drawSurf->sort == oldSort ) {
-			// fast path, same as previous sort
-			rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
-			continue;
-		}
-		oldSort = drawSurf->sort;
-		R_DecomposeSort( drawSurf->sort, &entityNum, &shader, &fogNum, &dlighted );
+	RB_ClearVertexBuffer ();
+	
+	qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
+	worldMatrix = qtrue;
+	
+	for( i = 0; i < numDrawSurfs ; ) {
+		entityNum = QSORT_ENTITYNUM( drawSurfs[i].sort );
+		shader = tr.shaders[ drawSurfs[i].shaderIndex ];
+		fogNum = QSORT_FOGNUM( drawSurfs[i].sort );
+		dlighted = QSORT_DLIGHT( drawSurfs[i].sort );
+		culled = QSORT_CULLED( drawSurfs[i].sort );
 
 		//
 		// change the tess parameters if needed
 		// a "entityMergable" shader is a shader that can have surfaces from seperate
 		// entities merged into a single batch, like smoke and blood puff sprites
-		if (shader != oldShader || fogNum != oldFogNum || dlighted != oldDlighted 
-			|| ( entityNum != oldEntityNum && !shader->entityMergable ) ) {
-			if (oldShader != NULL) {
-				RB_EndSurface();
-			}
+		if( shader->entityMergable ) {
+			sortMask = QSORT_SHADERNUM_MASK
+				| QSORT_FOGNUM_MASK
+				| QSORT_DLIGHT_MASK;
+		} else {
+			sortMask = QSORT_SHADERNUM_MASK
+				| QSORT_ENTITYNUM_MASK
+				| QSORT_FOGNUM_MASK
+				| QSORT_DLIGHT_MASK;
+		}
+		if( (drawSurfs[i].sort & sortMask) != (oldSort & sortMask) ) {
 			RB_BeginSurface( shader, fogNum );
 			oldShader = shader;
 			oldFogNum = fogNum;
 			oldDlighted = dlighted;
+			
+			// combine sprite entities if possible, they don't use
+			// VBOs anyway
+			if (//shader->entityMergable &&
+			    backEnd.refdef.entities[entityNum].e.reType == RT_SPRITE) {
+				sortMask = QSORT_SHADERNUM_MASK;
+			} else {
+				sortMask = QSORT_SHADERNUM_MASK | QSORT_ENTITYNUM_MASK;
+			}
+			isGLSL = (shader->optimalStageIteratorFunc == RB_StageIteratorGLSL);
+			oldEntityNum = -1;
 		}
+		oldSort = drawSurfs[i].sort;
 
 		//
 		// change the modelview matrix if needed
@@ -583,13 +1439,21 @@
 				// we have to reset the shaderTime as well otherwise image animations start
 				// from the wrong frame
 				tess.shaderTime = backEnd.refdef.floatTime - tess.shader->timeOffset;
-
+				
 				// set up the transformation matrix
 				R_RotateForEntity( backEnd.currentEntity, &backEnd.viewParms, &backEnd.or );
-
+				
 				// set up the dynamic lighting if needed
 				if ( backEnd.currentEntity->needDlights ) {
-					R_TransformDlights( backEnd.refdef.num_dlights, backEnd.refdef.dlights, &backEnd.or );
+				  R_TransformDlights( backEnd.refdef.num_dlights, backEnd.refdef.dlights, &backEnd.or );
+				}
+				if( !isGLSL ) {
+					qglLoadMatrixf( backEnd.or.modelMatrix );
+					worldMatrix = qfalse;
+					
+				} else if( !worldMatrix ) {
+					qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
+					worldMatrix = qtrue;
 				}
 
 				if(backEnd.currentEntity->e.renderfx & RF_DEPTHHACK)
@@ -607,13 +1471,15 @@
 				// we have to reset the shaderTime as well otherwise image animations on
 				// the world (like water) continue with the wrong frame
 				tess.shaderTime = backEnd.refdef.floatTime - tess.shader->timeOffset;
-				R_TransformDlights( backEnd.refdef.num_dlights, backEnd.refdef.dlights, &backEnd.or );
+				if( !worldMatrix ) {
+					qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
+					worldMatrix = qtrue;
+					R_TransformDlights( backEnd.refdef.num_dlights, backEnd.refdef.dlights, &backEnd.or );
+				}
 			}
 
-			qglLoadMatrixf( backEnd.or.modelMatrix );
-
 			//
-			// change depthrange. Also change projection matrix so first person weapon does not look like coming
+			// change projection matrix so first person weapon does not look like coming
 			// out of the screen.
 			//
 			if (oldDepthRange != depthRange || wasCrosshair != isCrosshair)
@@ -643,9 +1509,6 @@
 							qglMatrixMode(GL_MODELVIEW);
 						}
 					}
-
-					if(!oldDepthRange)
-						qglDepthRange (0, 0.3);
 				}
 				else
 				{
@@ -655,8 +1518,6 @@
 						qglLoadMatrixf(backEnd.viewParms.projectionMatrix);
 						qglMatrixMode(GL_MODELVIEW);
 					}
-
-					qglDepthRange (0, 1);
 				}
 
 				oldDepthRange = depthRange;
@@ -666,31 +1527,211 @@
 			oldEntityNum = entityNum;
 		}
 
-		// add the triangles for this surface
-		rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
-	}
+		// look if we can use a VBO for this shader/entity
+		int VBOkey = 0;
+		vboInfo_t **VBOtree = &shader->VBOs;
+		
+		if ( shader->useVBO ) {
+			if (entityNum == ENTITYNUM_WORLD) {
+				if ( backEnd.viewParms.viewCluster >= 0 ) {
+					VBOkey = VBOKEY_VIS | ((backEnd.viewParms.frustType << 24 | backEnd.viewParms.viewCluster) & VBOKEY_IDXMASK);
+				}
+			} else {
+				trRefEntity_t	*ent = backEnd.currentEntity;
+				if ( ent->e.reType == RT_MODEL ) {
+					model_t *model = R_GetModelByHandle( ent->e.hModel );
+					if ( model->type == MOD_BRUSH ) {
+						VBOkey = VBOKEY_MODEL | (ent->e.hModel & VBOKEY_IDXMASK);
+					} else if ( *drawSurfs[i].surface == SF_MD3_TEXTURE ) {
+						srfMD3Texture_t *surf = (srfMD3Texture_t *)drawSurfs[i].surface;
+						VBOkey = VBOKEY_MD3TEX;
+						VBOtree = &surf->VBO;
+						tess.dataTexture = surf->image;
+						tess.frameOffs    = (ent->e.frame / surf->framesPerRow) * surf->scaleY +
+							(ent->e.frame & (surf->framesPerRow - 1)) * surf->scaleX;
+						tess.oldFrameOffs = (ent->e.oldframe / surf->framesPerRow) * surf->scaleY +
+							(ent->e.oldframe & (surf->framesPerRow - 1)) * surf->scaleX;
+					} else if ( model->type == MOD_MESH &&
+						ent->e.frame == ent->e.oldframe ) {
+						// combine hModel and frame number into key
+						// allows 65536 models with 256 frames
+						VBOkey = VBOKEY_MD3 | (ent->e.hModel << 8) | ent->e.frame;
+					}
+				}
+			}
+		}
 
-	backEnd.refdef.floatTime = originalTime;
+		if ( VBOkey == VBOKEY_MD3TEX ) {
+			// add one VBO per surface
+			k = i;
+
+			(*VBOtree)->next = tess.firstVBO;
+			tess.firstVBO = *VBOtree;
+			
+			if ( (drawSurfs[i].sort & ~sortMask) == 0 )
+				k++;
+			i++;
+		} else if ( VBOkey == 0 || !findShaderVBO( VBOtree, VBOkey) ) {
+			vboInfo_t	*vbo;
+
+			// build a vertex buffer
+			RB_ClearVertexBuffer( );
+
+			// we also want to collect dynamically lit
+			// vertexes, even if we have to collect them twice
+			endSort = (oldSort - sortMask) & sortMask;
+			
+			k = i;
+			for ( j = i; j < numDrawSurfs ; j++ ) {
+				if( drawSurfs[j].sort >= endSort )
+					break;
+				if( QSORT_CULLED( drawSurfs[j].sort )
+				    && VBOkey == 0 )
+					continue;
+				if( (drawSurfs[j].sort & ~sortMask) == 0 )
+					k++;
+				rb_surfaceTable[ *drawSurfs[j].surface ]( drawSurfs[j].surface );
+			}
+			
+			if ( tess.numVertexes == 0 || tess.numIndexes == 0 ) {
+				i = j;
+				continue;
+			}
+
+			if ( VBOkey > 0 &&
+			     tess.numIndexes >= r_VBOminSize->integer &&
+			     r_VBOminSize->integer >= 0 ) {
+				// create new VBO
+				
+				newShaderVBO( VBOtree, VBOkey );
+				vbo = *VBOtree;
+
+				// allocate VBOs
+				qglGenBuffersARB(1, &vbo->ibo);
+				if ( entityNum == ENTITYNUM_WORLD ) {
+					vbo->vbo = 0;
+				} else {
+					vbo->vbo = vbo->ibo;
+				}
+				
+				vbo->key = VBOkey;
+			} else if ( isGLSL ) {
+				vbo = &backEnd.streamVBO;
+				if( entityNum == ENTITYNUM_WORLD ) {
+					backEnd.streamVBO.vbo = 0;
+				} else {
+					backEnd.streamVBO.vbo = backEnd.streamVBO.ibo;
+				}
+			} else {
+				vbo = NULL;
+				VBOkey = 0;
+			}
+
+			RB_SetupVertexBuffer( shader, vbo );
+			for ( ; i < j; i++ ) {
+				tess.fogNum = QSORT_FOGNUM( drawSurfs[i].sort );
+				entityNum = QSORT_ENTITYNUM( drawSurfs[i].sort );
+				if( QSORT_CULLED( drawSurfs[i].sort )
+				    && VBOkey == 0 )
+					continue;
+				if ( oldEntityNum != entityNum ) {
+					backEnd.currentEntity = &backEnd.refdef.entities[entityNum];
+					backEnd.refdef.floatTime = originalTime - backEnd.currentEntity->e.shaderTime;
+					// we have to reset the shaderTime as well otherwise image animations start
+					// from the wrong frame
+					tess.shaderTime = backEnd.refdef.floatTime - tess.shader->timeOffset;
+					
+					// set up the transformation matrix
+					R_RotateForEntity( backEnd.currentEntity, &backEnd.viewParms, &backEnd.or );
+					
+					// set up the dynamic lighting if needed
+					if ( backEnd.currentEntity->needDlights ) {
+						R_TransformDlights( backEnd.refdef.num_dlights, backEnd.refdef.dlights, &backEnd.or );
+					}
+					
+					oldEntityNum = entityNum;
+					
+				}
+				rb_surfaceTable[ *drawSurfs[i].surface ]( drawSurfs[i].surface );
+			}
+		} else {
+			// find surfaces requiring fog or dlight
+			// and skip surfaces contained in VBO
+			endSort = (oldSort - sortMask) & sortMask;
+
+			k = i;
+			for( j = i; j < numDrawSurfs; j++ ) {
+				if( drawSurfs[j].sort >= endSort)
+					break;
+				if( (drawSurfs[j].sort & ~sortMask) == 0 )
+					k++;
+			}
+			i = j;
+
+			// add VBO
+			(*VBOtree)->next = tess.firstVBO;
+			tess.firstVBO = *VBOtree;
+		}
 
-	// draw the contents of the last shader batch
-	if (oldShader != NULL) {
 		RB_EndSurface();
+		RB_ClearVertexBuffer ();
+		tess.dataTexture = NULL;
+		
+		if( 1 || !isGLSL ) {
+			// remaining surfaces have to be dlighted or fogged
+			while ( k < i ) {
+				oldSort = drawSurfs[k].sort;
+
+				entityNum = QSORT_ENTITYNUM( drawSurfs[k].sort );
+				shader = tr.shaders[ drawSurfs[k].shaderIndex ];
+				fogNum = QSORT_FOGNUM( drawSurfs[k].sort );
+				dlighted = QSORT_DLIGHT( drawSurfs[k].sort );
+				culled = QSORT_CULLED( drawSurfs[k].sort );
+
+				if( culled ) {
+					k++;
+					continue;
+				}
+				RB_BeginSurface( shader, fogNum );
+				for ( j = k; j < i ; j++ ) {
+					if( drawSurfs[j].sort != oldSort)
+						break;
+					rb_surfaceTable[ *drawSurfs[j].surface ]( drawSurfs[j].surface );
+				}
+				
+				if ( tess.numVertexes > 0 && tess.numIndexes > 0 ) {
+					RB_SetupVertexBuffer( shader, NULL );
+					for ( ; k < j; k++ ) {
+						rb_surfaceTable[ *drawSurfs[k].surface ]( drawSurfs[k].surface );
+					}
+					RB_LightSurface();
+				} else {
+					k = j;
+				}
+				RB_ClearVertexBuffer ();
+			}
+		}
 	}
 
+	backEnd.refdef.floatTime = originalTime;
+
+	GL_VBO( 0 );
+
 	// go back to the world modelview matrix
-	qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
-	if ( depthRange ) {
-		qglDepthRange (0, 1);
+	if( !worldMatrix ) {
+		qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
 	}
 
+	if( !backEnd.viewParms.noShadows ) {
 #if 0
-	RB_DrawSun();
+		RB_DrawSun();
 #endif
-	// darken down any stencil shadows
-	RB_ShadowFinish();		
+		// darken down any stencil shadows
+		RB_ShadowFinish();
 
-	// add light flares on lights that aren't obscured
-	RB_RenderFlares();
+		// add light flares on lights that aren't obscured
+		RB_RenderFlares();
+	}
 }
 
 
@@ -708,7 +1749,7 @@
 
 ================
 */
-void	RB_SetGL2D (void) {
+void	RB_SetGL2D ( glRenderState_t *state ) {
 	backEnd.projection2D = qtrue;
 
 	// set 2D virtual screen size
@@ -720,12 +1761,10 @@
 	qglMatrixMode(GL_MODELVIEW);
     qglLoadIdentity ();
 
-	GL_State( GLS_DEPTHTEST_DISABLE |
-			  GLS_SRCBLEND_SRC_ALPHA |
-			  GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA );
-
-	qglDisable( GL_CULL_FACE );
-	qglDisable( GL_CLIP_PLANE0 );
+	state->stateBits = GLS_DEPTHTEST_DISABLE |
+		GLS_SRCBLEND_SRC_ALPHA |
+		GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA;
+	state->faceCulling = CT_TWO_SIDED;
 
 	// set time for 2D shaders
 	backEnd.refdef.time = ri.Milliseconds();
@@ -735,82 +1774,50 @@
 
 /*
 =============
-RE_StretchRaw
+RB_StretchRaw
 
-FIXME: not exactly backend
 Stretches a raw 32 bit power of 2 bitmap image over the given screen rectangle.
 Used for cinematics.
 =============
 */
-void RE_StretchRaw (int x, int y, int w, int h, int cols, int rows, const byte *data, int client, qboolean dirty) {
-	int			i, j;
-	int			start, end;
+const void *RB_StretchRaw ( const void *data ) {
+	const stretchRawCommand_t	*cmd;
+	vec2_t			texCoords[4], vertexes[4];
+	glRenderState_t		state;
 
-	if ( !tr.registered ) {
-		return;
-	}
-	R_SyncRenderThread();
+	cmd = (const stretchRawCommand_t *)data;
 
 	// we definately want to sync every frame for the cinematics
 	qglFinish();
 
-	start = end = 0;
-	if ( r_speeds->integer ) {
-		start = ri.Milliseconds();
-	}
-
-	// make sure rows and cols are powers of 2
-	for ( i = 0 ; ( 1 << i ) < cols ; i++ ) {
-	}
-	for ( j = 0 ; ( 1 << j ) < rows ; j++ ) {
-	}
-	if ( ( 1 << i ) != cols || ( 1 << j ) != rows) {
-		ri.Error (ERR_DROP, "Draw_StretchRaw: size not a power of 2: %i by %i", cols, rows);
-	}
-
-	GL_Bind( tr.scratchImage[client] );
-
-	// if the scratchImage isn't in the format we want, specify it as a new texture
-	if ( cols != tr.scratchImage[client]->width || rows != tr.scratchImage[client]->height ) {
-		tr.scratchImage[client]->width = tr.scratchImage[client]->uploadWidth = cols;
-		tr.scratchImage[client]->height = tr.scratchImage[client]->uploadHeight = rows;
-		qglTexImage2D( GL_TEXTURE_2D, 0, GL_RGB8, cols, rows, 0, GL_RGBA, GL_UNSIGNED_BYTE, data );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );	
-	} else {
-		if (dirty) {
-			// otherwise, just subimage upload it so that drivers can tell we are going to be changing
-			// it and don't try and do a texture compression
-			qglTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, cols, rows, GL_RGBA, GL_UNSIGNED_BYTE, data );
-		}
-	}
+	InitState( &state );
+	RB_SetGL2D( &state );
+	state.program = NULL;
+	state.numImages = 1;
+	state.image[0] = tr.scratchImage[cmd->client];
+
+	SetAttrVec4f(&state, AL_COLOR, tr.identityLight, tr.identityLight,
+		     tr.identityLight, 1.0f );
+
+	texCoords[0][0] = cmd->s1;        texCoords[0][1] = cmd->t1;
+	vertexes[0][0] = cmd->x;          vertexes[0][1] = cmd->y;
+	texCoords[1][0] = cmd->s2;        texCoords[1][1] = cmd->t1;
+	vertexes[1][0] = cmd->x + cmd->w; vertexes[1][1] = cmd->y;
+	texCoords[2][0] = cmd->s2;        texCoords[2][1] = cmd->t2;
+	vertexes[2][0] = cmd->x + cmd->w; vertexes[2][1] = cmd->y + cmd->h;
+	texCoords[3][0] = cmd->s1;        texCoords[3][1] = cmd->t2;
+	vertexes[3][0] = cmd->x;          vertexes[3][1] = cmd->y + cmd->h;
+
+	SetAttrPointer( &state, AL_VERTEX, 0, 2, GL_FLOAT, 0, vertexes );
+	SetAttrPointer( &state, AL_TEXCOORD, 0, 2, GL_FLOAT, 0, texCoords );
+	GL_DrawArrays( &state, GL_QUADS, 0, 4 );
 
-	if ( r_speeds->integer ) {
-		end = ri.Milliseconds();
-		ri.Printf( PRINT_ALL, "qglTexSubImage2D %i, %i: %i msec\n", cols, rows, end - start );
-	}
-
-	RB_SetGL2D();
-
-	qglColor3f( tr.identityLight, tr.identityLight, tr.identityLight );
-
-	qglBegin (GL_QUADS);
-	qglTexCoord2f ( 0.5f / cols,  0.5f / rows );
-	qglVertex2f (x, y);
-	qglTexCoord2f ( ( cols - 0.5f ) / cols ,  0.5f / rows );
-	qglVertex2f (x+w, y);
-	qglTexCoord2f ( ( cols - 0.5f ) / cols, ( rows - 0.5f ) / rows );
-	qglVertex2f (x+w, y+h);
-	qglTexCoord2f ( 0.5f / cols, ( rows - 0.5f ) / rows );
-	qglVertex2f (x, y+h);
-	qglEnd ();
+	return cmd + 1;
 }
 
 void RE_UploadCinematic (int w, int h, int cols, int rows, const byte *data, int client, qboolean dirty) {
 
-	GL_Bind( tr.scratchImage[client] );
+	GL_BindTexture( tr.scratchImage[client]->texnum );
 
 	// if the scratchImage isn't in the format we want, specify it as a new texture
 	if ( cols != tr.scratchImage[client]->width || rows != tr.scratchImage[client]->height ) {
@@ -855,74 +1862,155 @@
 RB_StretchPic
 =============
 */
+static qboolean overlap(const stretchPicCommand_t *a,
+			const stretchPicCommand_t *b ) {
+	if( a->x >= b->x + b->w || b->x >= a->x + a->w )
+		return qfalse;
+
+	if( a->y >= b->y + b->h || b->y >= a->y + a->h )
+		return qfalse;
+
+	return qtrue;
+}
 const void *RB_StretchPic ( const void *data ) {
+	struct pic {
+		const stretchPicCommand_t	*cmd;
+		color4ub_t			color;
+	} *pics;
 	const stretchPicCommand_t	*cmd;
-	shader_t *shader;
-	int		numVerts, numIndexes;
+	shader_t	*shader;
+	GLushort	indexes[6] = { 3, 0, 2, 2, 0, 1 };
+	int		i, j, k, n;
 
 	cmd = (const stretchPicCommand_t *)data;
 
 	if ( !backEnd.projection2D ) {
-		RB_SetGL2D();
+		glRenderState_t dummy;
+		RB_SetGL2D( &dummy );
+	}
+
+	backEnd.currentEntity = &backEnd.entity2D;
+	
+	// read all the following StretchPic commands
+	n = 1;
+	data = cmd+1;
+	for(;;) {
+		if ( *(int *)data == RC_STRETCH_PIC ) {
+			n++;
+			data = data + sizeof(stretchPicCommand_t);
+		} else if ( *(int *)data == RC_SET_COLOR ) {
+			data = data + sizeof(setColorCommand_t);
+		} else
+			break;
+	}
+
+	// add current color to each pic
+	pics = (struct pic *)RB_AllocScratch(n * sizeof(struct pic));
+	for( i = 0; ; ) {
+		if( cmd->commandId == RC_STRETCH_PIC ) {
+			pics[i].cmd = cmd;
+			*(int *)pics[i].color = *(int *)backEnd.color2D;
+			i++; cmd++;
+		} else if( cmd->commandId == RC_SET_COLOR ) {
+			cmd = RB_SetColor( cmd );
+		} else
+			break;
 	}
 
-	shader = cmd->shader;
-	if ( shader != tess.shader ) {
-		if ( tess.numIndexes ) {
-			RB_EndSurface();
+	// try to reorder by shader
+	shader = pics[0].cmd->shader;
+	for( i = 1; i < n ; i++ ) {
+		for( j = i; j < n; j++ ) {
+			if( pics[j].cmd->shader == shader ) {
+				while( j > i &&
+				       !overlap( pics[j].cmd, pics[j-1].cmd ) ) {
+
+					struct pic tmp = pics[j];
+					pics[j] = pics[j-1];
+					pics[j-1] = tmp;
+					j--;
+				}
+				break;
+			}
 		}
-		backEnd.currentEntity = &backEnd.entity2D;
-		RB_BeginSurface( shader, 0 );
+		shader = pics[i].cmd->shader;
 	}
 
-	RB_CHECKOVERFLOW( 4, 6 );
-	numVerts = tess.numVertexes;
-	numIndexes = tess.numIndexes;
-
-	tess.numVertexes += 4;
-	tess.numIndexes += 6;
-
-	tess.indexes[ numIndexes ] = numVerts + 3;
-	tess.indexes[ numIndexes + 1 ] = numVerts + 0;
-	tess.indexes[ numIndexes + 2 ] = numVerts + 2;
-	tess.indexes[ numIndexes + 3 ] = numVerts + 2;
-	tess.indexes[ numIndexes + 4 ] = numVerts + 0;
-	tess.indexes[ numIndexes + 5 ] = numVerts + 1;
-
-	*(int *)tess.vertexColors[ numVerts ] =
-		*(int *)tess.vertexColors[ numVerts + 1 ] =
-		*(int *)tess.vertexColors[ numVerts + 2 ] =
-		*(int *)tess.vertexColors[ numVerts + 3 ] = *(int *)backEnd.color2D;
-
-	tess.xyz[ numVerts ][0] = cmd->x;
-	tess.xyz[ numVerts ][1] = cmd->y;
-	tess.xyz[ numVerts ][2] = 0;
-
-	tess.texCoords[ numVerts ][0][0] = cmd->s1;
-	tess.texCoords[ numVerts ][0][1] = cmd->t1;
-
-	tess.xyz[ numVerts + 1 ][0] = cmd->x + cmd->w;
-	tess.xyz[ numVerts + 1 ][1] = cmd->y;
-	tess.xyz[ numVerts + 1 ][2] = 0;
-
-	tess.texCoords[ numVerts + 1 ][0][0] = cmd->s2;
-	tess.texCoords[ numVerts + 1 ][0][1] = cmd->t1;
-
-	tess.xyz[ numVerts + 2 ][0] = cmd->x + cmd->w;
-	tess.xyz[ numVerts + 2 ][1] = cmd->y + cmd->h;
-	tess.xyz[ numVerts + 2 ][2] = 0;
-
-	tess.texCoords[ numVerts + 2 ][0][0] = cmd->s2;
-	tess.texCoords[ numVerts + 2 ][0][1] = cmd->t2;
-
-	tess.xyz[ numVerts + 3 ][0] = cmd->x;
-	tess.xyz[ numVerts + 3 ][1] = cmd->y + cmd->h;
-	tess.xyz[ numVerts + 3 ][2] = 0;
+	// draw maximal batches
+	for( i = 0; i < n; ) {
+		shader = pics[i].cmd->shader;
+		for( j = i+1; j < n; j++ ) {
+			if( pics[j].cmd->shader != shader )
+				break;
+		}
 
-	tess.texCoords[ numVerts + 3 ][0][0] = cmd->s1;
-	tess.texCoords[ numVerts + 3 ][0][1] = cmd->t2;
+		j -= i;
+		RB_BeginSurface( shader, 0 );
+		tess.numVertexes = 4 * j;
+		tess.numIndexes  = 6 * j;
 
-	return (const void *)(cmd + 1);
+		backEnd.streamVBO.vbo = backEnd.streamVBO.ibo;
+		RB_SetupVertexBuffer( shader, &backEnd.streamVBO );
+		tess.numVertexes = 4 * j;
+		tess.numIndexes  = 6 * j;
+		tess.minIndex = 0;
+		tess.maxIndex = 4 * j - 1;
+
+		for( k = 0; k < j; k++, i++ ) {
+			tess.indexPtr.p16[6*k+0] = indexes[0] + 4*k;
+			tess.indexPtr.p16[6*k+1] = indexes[1] + 4*k;
+			tess.indexPtr.p16[6*k+2] = indexes[2] + 4*k;
+			tess.indexPtr.p16[6*k+3] = indexes[3] + 4*k;
+			tess.indexPtr.p16[6*k+4] = indexes[4] + 4*k;
+			tess.indexPtr.p16[6*k+5] = indexes[5] + 4*k;
+
+			*(int *)(&tess.vertexPtr4[4*k+0].color) =
+			*(int *)(&tess.vertexPtr4[4*k+1].color) =
+			*(int *)(&tess.vertexPtr4[4*k+2].color) =
+			*(int *)(&tess.vertexPtr4[4*k+3].color) = *(int *)&pics[i].color;
+
+			tess.vertexPtr2[4*k+0].xyz[0] = pics[i].cmd->x;
+			tess.vertexPtr2[4*k+0].xyz[1] = pics[i].cmd->y;
+			tess.vertexPtr2[4*k+0].xyz[2] = 0.0f;
+			tess.vertexPtr2[4*k+0].fogNum = 0.0f;
+			tess.vertexPtr1[4*k+0].tc1[0] = pics[i].cmd->s1;
+			tess.vertexPtr1[4*k+0].tc1[1] = pics[i].cmd->t1;
+			tess.vertexPtr1[4*k+0].tc2[0] = pics[i].cmd->s1;
+			tess.vertexPtr1[4*k+0].tc2[1] = pics[i].cmd->t1;
+
+			tess.vertexPtr2[4*k+1].xyz[0] = pics[i].cmd->x + pics[i].cmd->w;
+			tess.vertexPtr2[4*k+1].xyz[1] = pics[i].cmd->y;
+			tess.vertexPtr2[4*k+1].xyz[2] = 0.0f;
+			tess.vertexPtr2[4*k+1].fogNum = 0.0f;
+			tess.vertexPtr1[4*k+1].tc1[0] = pics[i].cmd->s2;
+			tess.vertexPtr1[4*k+1].tc1[1] = pics[i].cmd->t1;
+			tess.vertexPtr1[4*k+1].tc2[0] = pics[i].cmd->s2;
+			tess.vertexPtr1[4*k+1].tc2[1] = pics[i].cmd->t1;
+
+			tess.vertexPtr2[4*k+2].xyz[0] = pics[i].cmd->x + pics[i].cmd->w;
+			tess.vertexPtr2[4*k+2].xyz[1] = pics[i].cmd->y + pics[i].cmd->h;
+			tess.vertexPtr2[4*k+2].xyz[2] = 0.0f;
+			tess.vertexPtr2[4*k+2].fogNum = 0.0f;
+			tess.vertexPtr1[4*k+2].tc1[0] = pics[i].cmd->s2;
+			tess.vertexPtr1[4*k+2].tc1[1] = pics[i].cmd->t2;
+			tess.vertexPtr1[4*k+2].tc2[0] = pics[i].cmd->s2;
+			tess.vertexPtr1[4*k+2].tc2[1] = pics[i].cmd->t2;
+
+			tess.vertexPtr2[4*k+3].xyz[0] = pics[i].cmd->x;
+			tess.vertexPtr2[4*k+3].xyz[1] = pics[i].cmd->y + pics[i].cmd->h;
+			tess.vertexPtr2[4*k+3].xyz[2] = 0.0f;
+			tess.vertexPtr2[4*k+3].fogNum = 0.0f;
+			tess.vertexPtr1[4*k+3].tc1[0] = pics[i].cmd->s1;
+			tess.vertexPtr1[4*k+3].tc1[1] = pics[i].cmd->t2;
+			tess.vertexPtr1[4*k+3].tc2[0] = pics[i].cmd->s1;
+			tess.vertexPtr1[4*k+3].tc2[1] = pics[i].cmd->t2;
+		}
+		RB_EndSurface ();
+		RB_ClearVertexBuffer ();
+	}
+
+	RB_FreeScratch( pics );
+	return (const void *)cmd;
 }
 
 
@@ -936,7 +2024,7 @@
 	const drawSurfsCommand_t	*cmd;
 
 	// finish any 2D drawing if needed
-	if ( tess.numIndexes ) {
+	if ( tess.numIndexes || tess.firstVBO ) {
 		RB_EndSurface();
 	}
 
@@ -944,7 +2032,7 @@
 
 	backEnd.refdef = cmd->refdef;
 	backEnd.viewParms = cmd->viewParms;
-
+	
 	RB_RenderDrawSurfList( cmd->drawSurfs, cmd->numDrawSurfs );
 
 	return (const void *)(cmd + 1);
@@ -964,12 +2052,6 @@
 
 	qglDrawBuffer( cmd->buffer );
 
-	// clear screen for debugging
-	if ( r_clear->integer ) {
-		qglClearColor( 1, 0, 0.5, 1 );
-		qglClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
-	}
-
 	return (const void *)(cmd + 1);
 }
 
@@ -988,9 +2070,12 @@
 	image_t	*image;
 	float	x, y, w, h;
 	int		start, end;
+	vec2_t	vertexes[4], texCoords[4];
+	glRenderState_t	state;
 
+	InitState( &state );
 	if ( !backEnd.projection2D ) {
-		RB_SetGL2D();
+		RB_SetGL2D( &state );
 	}
 
 	qglClear( GL_COLOR_BUFFER_BIT );
@@ -999,13 +2084,22 @@
 
 	start = ri.Milliseconds();
 
+	texCoords[0][0] = 0.0f; texCoords[0][1] = 0.0f;
+	texCoords[1][0] = 1.0f; texCoords[1][1] = 0.0f;
+	texCoords[2][0] = 1.0f; texCoords[2][1] = 1.0f;
+	texCoords[3][0] = 0.0f; texCoords[3][1] = 1.0f;
+	
+	SetAttrPointer( &state, AL_TEXCOORD, 0, 2, GL_FLOAT, 0, texCoords );
+	state.numImages = 1;
+
 	for ( i=0 ; i<tr.numImages ; i++ ) {
 		image = tr.images[i];
+		state.image[0] = image;
 
-		w = glConfig.vidWidth / 20;
-		h = glConfig.vidHeight / 15;
-		x = i % 20 * w;
-		y = i / 20 * h;
+		w = glConfig.vidWidth / 40;
+		h = glConfig.vidHeight / 30;
+		x = i % 40 * w;
+		y = i / 40 * h;
 
 		// show in proportional size in mode 2
 		if ( r_showImages->integer == 2 ) {
@@ -1013,24 +2107,18 @@
 			h *= image->uploadHeight / 512.0f;
 		}
 
-		GL_Bind( image );
-		qglBegin (GL_QUADS);
-		qglTexCoord2f( 0, 0 );
-		qglVertex2f( x, y );
-		qglTexCoord2f( 1, 0 );
-		qglVertex2f( x + w, y );
-		qglTexCoord2f( 1, 1 );
-		qglVertex2f( x + w, y + h );
-		qglTexCoord2f( 0, 1 );
-		qglVertex2f( x, y + h );
-		qglEnd();
+		vertexes[0][0] = x;   vertexes[0][1] = y;
+		vertexes[1][0] = x+w; vertexes[1][1] = y;
+		vertexes[2][0] = x+w; vertexes[2][1] = y+h;
+		vertexes[3][0] = x;   vertexes[3][1] = y+h;
+		
+		SetAttrPointer( &state, AL_VERTEX, 0, 2, GL_FLOAT, 0, vertexes );
+		GL_DrawArrays( &state, GL_QUADS, 0, 4 );
 	}
-
 	qglFinish();
 
 	end = ri.Milliseconds();
-	ri.Printf( PRINT_ALL, "%i msec to draw all images\n", end - start );
-
+	ri.Printf( PRINT_DEVELOPER, "%i msec to draw all images\n", end - start );
 }
 
 /*
@@ -1058,7 +2146,7 @@
 {
 	const clearDepthCommand_t *cmd = data;
 	
-	if(tess.numIndexes)
+	if(tess.numIndexes || tess.firstVBO )
 		RB_EndSurface();
 
 	// texture swapping test
@@ -1080,7 +2168,7 @@
 	const swapBuffersCommand_t	*cmd;
 
 	// finish any 2D drawing if needed
-	if ( tess.numIndexes ) {
+	if ( tess.numIndexes || tess.firstVBO ) {
 		RB_EndSurface();
 	}
 
@@ -1098,18 +2186,17 @@
 		long sum = 0;
 		unsigned char *stencilReadback;
 
-		stencilReadback = ri.Hunk_AllocateTempMemory( glConfig.vidWidth * glConfig.vidHeight );
+		stencilReadback = RB_AllocScratch( glConfig.vidWidth * glConfig.vidHeight );
 		qglReadPixels( 0, 0, glConfig.vidWidth, glConfig.vidHeight, GL_STENCIL_INDEX, GL_UNSIGNED_BYTE, stencilReadback );
 
 		for ( i = 0; i < glConfig.vidWidth * glConfig.vidHeight; i++ ) {
-			sum += stencilReadback[i];
+			sum += stencilReadback[i] & glGlobals.shadowMask;
 		}
 
 		backEnd.pc.c_overDraw += sum;
-		ri.Hunk_FreeTempMemory( stencilReadback );
+		RB_FreeScratch( stencilReadback );
 	}
 
-
 	if ( !glState.finishCalled ) {
 		qglFinish();
 	}
@@ -1118,8 +2205,28 @@
 
 	GLimp_EndFrame();
 
-	backEnd.projection2D = qfalse;
+	if ( qglGenQueriesARB ) {
+		int shader;
+
+		for( shader = 0; shader < tr.numGLSLprograms; shader++ ) {
+			tr.GLSLprograms[shader]->QuerySum = 0;
+		}
+
+		for( shader = 0; shader < tr.numShaders; shader++ ) {
+			if ( tr.shaders[shader]->QueryID ) {
+				GL_GetQuery( tr.shaders[shader]->QueryID,
+					     &tr.shaders[shader]->QueryResult );
+			}
+			if( tr.shaders[shader]->GLSLprogram ) {
+				tr.shaders[shader]->GLSLprogram->QuerySum += QUERY_RESULT(&tr.shaders[shader]->QueryResult);
+				if( tr.shaders[shader]->GLSLprogram->QuerySum > QUERY_MASK )
+					tr.shaders[shader]->GLSLprogram->QuerySum = QUERY_MASK;
+			}
+		}
+	}
 
+	backEnd.projection2D = qfalse;
+	
 	return (const void *)(cmd + 1);
 }
 
@@ -1150,6 +2257,9 @@
 		case RC_STRETCH_PIC:
 			data = RB_StretchPic( data );
 			break;
+		case RC_STRETCH_RAW:
+			data = RB_StretchRaw( data );
+			break;
 		case RC_DRAW_SURFS:
 			data = RB_DrawSurfs( data );
 			break;
@@ -1191,6 +2301,9 @@
 void RB_RenderThread( void ) {
 	const void	*data;
 
+	// set default state
+	GL_SetDefaultState();
+
 	// wait for either a rendering command or a quit command
 	while ( 1 ) {
 		// sleep until we have work to do
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_bsp.c tremulous-ggp1-src/src/renderer/tr_bsp.c
--- tremulous-ggp1-src.p/src/renderer/tr_bsp.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_bsp.c	2012-07-19 04:25:52.021556447 +0200
@@ -39,6 +39,7 @@
 
 int			c_subdivisions;
 int			c_gridVerts;
+int			lightmapWidth, lightmapHeight;
 
 //===============================================================================
 
@@ -133,11 +134,14 @@
 ===============
 */
 #define	LIGHTMAP_SIZE	128
-static	void R_LoadLightmaps( lump_t *l ) {
+static	void R_LoadLightmaps( lump_t *l, lump_t *surfs ) {
 	byte		*buf, *buf_p;
+	dsurface_t	*surf;
 	int			len;
-	byte		image[LIGHTMAP_SIZE*LIGHTMAP_SIZE*4];
-	int			i, j;
+	int		offs;
+	byte		*image, *image_p;
+	texImage_t	pic;
+	int			i, j, k, x, y;
 	float maxIntensity = 0;
 	double sumIntensity = 0;
 
@@ -306,13 +310,20 @@
 	int			i, j;
 	srfSurfaceFace_t	*cv;
 	int			numPoints, numIndexes;
-	int			lightmapNum;
+	int			lightmapNum, lightmapX, lightmapY;
 	int			sfaceSize, ofsIndexes;
 
 	lightmapNum = LittleLong( ds->lightmapNum );
+	if (lightmapNum >= 0) {
+		lightmapX = lightmapNum & (lightmapWidth - 1);
+		lightmapNum /= lightmapWidth;
+		lightmapY = lightmapNum & (lightmapHeight - 1);
+		lightmapNum /= lightmapHeight;
+	}
 
 	// get fog volume
-	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+	surf->fogIndex = (short)LittleLong( ds->fogNum ) + 1;
+	surf->type = (short)SF_FACE;
 
 	// get shader value
 	surf->shader = ShaderForShaderNum( ds->shaderNum, lightmapNum );
@@ -350,6 +361,12 @@
 			cv->points[i][5+j] = LittleFloat( verts[i].lightmap[j] );
 		}
 		R_ColorShiftLightingBytes( verts[i].color, (byte *)&cv->points[i][7] );
+
+		if (lightmapNum >= 0) {
+			// adjust lightmap coords
+			cv->points[i][5] = (cv->points[i][5] + lightmapX) / lightmapWidth;
+			cv->points[i][6] = (cv->points[i][6] + lightmapY) / lightmapHeight;
+		}
 	}
 
 	indexes += LittleLong( ds->firstIndex );
@@ -379,15 +396,23 @@
 	int				i, j;
 	int				width, height, numPoints;
 	drawVert_t points[MAX_PATCH_SIZE*MAX_PATCH_SIZE];
-	int				lightmapNum;
+	int				lightmapNum, lightmapX, lightmapY;
 	vec3_t			bounds[2];
 	vec3_t			tmpVec;
 	static surfaceType_t	skipData = SF_SKIP;
 
 	lightmapNum = LittleLong( ds->lightmapNum );
+	if (lightmapNum >= 0) {
+		lightmapX = lightmapNum & (lightmapWidth - 1);
+		lightmapNum /= lightmapWidth;
+		lightmapY = lightmapNum & (lightmapHeight - 1);
+		lightmapNum /= lightmapHeight;
+	} else {
+		lightmapX = lightmapY = 0;
+	}
 
 	// get fog volume
-	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+	surf->fogIndex = (short)LittleLong( ds->fogNum ) + 1;
 
 	// get shader value
 	surf->shader = ShaderForShaderNum( ds->shaderNum, lightmapNum );
@@ -398,6 +423,7 @@
 	// we may have a nodraw surface, because they might still need to
 	// be around for movement clipping
 	if ( s_worldData.shaders[ LittleLong( ds->shaderNum ) ].surfaceFlags & SURF_NODRAW ) {
+		surf->type = (short)SF_SKIP;
 		surf->data = &skipData;
 		return;
 	}
@@ -417,10 +443,17 @@
 			points[i].lightmap[j] = LittleFloat( verts[i].lightmap[j] );
 		}
 		R_ColorShiftLightingBytes( verts[i].color, points[i].color );
+
+		if (lightmapNum >= 0) {
+			// adjust lightmap coords
+			points[i].lightmap[0] = (points[i].lightmap[0] + lightmapX) / lightmapWidth;
+			points[i].lightmap[1] = (points[i].lightmap[1] + lightmapY) / lightmapHeight;
+		}
 	}
 
 	// pre-tesseleate
 	grid = R_SubdividePatchToGrid( width, height, points );
+	surf->type = (short)(grid->surfaceType);
 	surf->data = (surfaceType_t *)grid;
 
 	// copy the level of detail origin, which is the center
@@ -447,7 +480,8 @@
 	int				numVerts, numIndexes;
 
 	// get fog volume
-	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+	surf->fogIndex = (short)LittleLong( ds->fogNum ) + 1;
+	surf->type = (short)SF_TRIANGLES;
 
 	// get shader
 	surf->shader = ShaderForShaderNum( ds->shaderNum, LIGHTMAP_BY_VERTEX );
@@ -505,7 +539,8 @@
 	int				i;
 
 	// get fog volume
-	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+	surf->fogIndex = (short)LittleLong( ds->fogNum ) + 1;
+	surf->type = (short)SF_FLARE;
 
 	// get shader
 	surf->shader = ShaderForShaderNum( ds->shaderNum, LIGHTMAP_BY_VERTEX );
@@ -1186,7 +1221,7 @@
 		}
 	}
 	while (stitched);
-	ri.Printf( PRINT_ALL, "stitched %d LoD cracks\n", numstitches );
+	ri.Printf( PRINT_DEVELOPER, "stitched %d LoD cracks\n", numstitches );
 }
 
 /*
@@ -1226,6 +1261,9 @@
 R_LoadSurfaces
 ===============
 */
+static int sortByShader(const void *a, const void *b) {
+	return ((msurface_t *)a)->shader - ((msurface_t *)b)->shader;
+}
 static	void R_LoadSurfaces( lump_t *surfs, lump_t *verts, lump_t *indexLump ) {
 	dsurface_t	*in;
 	msurface_t	*out;
@@ -1291,8 +1329,69 @@
 	R_MovePatchSurfacesToHunk();
 #endif
 
-	ri.Printf( PRINT_ALL, "...loaded %d faces, %i meshes, %i trisurfs, %i flares\n", 
+	ri.Printf( PRINT_DEVELOPER, "...loaded %d faces, %i meshes, %i trisurfs, %i flares\n", 
 		numFaces, numMeshes, numTriSurfs, numFlares );
+
+	if ( qglGenBuffersARB ) {
+		// sort surfaces by shader for improved locality
+		msurface_t *sortBuffer = ri.Hunk_AllocateTempMemory( count * sizeof(msurface_t) );
+		Com_Memcpy( sortBuffer, s_worldData.surfaces, count * sizeof(msurface_t) );
+		qsort( sortBuffer, count, sizeof(msurface_t),
+		       sortByShader );
+
+		// render all vertexes into a VBO
+		RB_ClearVertexBuffer( );
+		tess.shader = NULL;
+		
+		for ( i = 0, out = sortBuffer; i < count; i++, out++ ) {
+			switch( out->type ) {
+			case SF_FACE:
+				(*rb_surfaceTable[out->type])(out->data);
+				break;
+			case SF_GRID:
+				(*rb_surfaceTable[out->type])(out->data);
+				break;
+			case SF_TRIANGLES:
+				(*rb_surfaceTable[out->type])(out->data);
+				break;
+			default:
+				break;
+			}
+		}
+		
+		qglGenBuffersARB( 1, &backEnd.worldVBO.vbo );
+		backEnd.worldVBO.ibo = 0;
+		RB_SetupVertexBuffer( NULL, &backEnd.worldVBO );
+		for ( i = 0, out = sortBuffer; i < count; i++, out++ ) {
+			tess.fogNum = out->fogIndex;
+			switch( out->type ) {
+			case SF_FACE:
+				((srfSurfaceFace_t *)(out->data))->vboStart = tess.numVertexes;
+				(*rb_surfaceTable[out->type])(out->data);
+				break;
+			case SF_GRID:
+				((srfGridMesh_t *)(out->data))->vboStart = tess.numVertexes;
+				(*rb_surfaceTable[out->type])(out->data);
+				break;
+			case SF_TRIANGLES:
+				((srfTriangles_t *)(out->data))->vboStart = tess.numVertexes;
+				(*rb_surfaceTable[out->type])(out->data);
+				break;
+			default:
+				break;
+			}
+		}
+		
+		backEnd.worldVBO.maxIndex = tess.numVertexes - 1;
+		backEnd.worldVBO.offs1 = (vaWord1_t *)((intptr_t)tess.vertexPtr1 - (intptr_t)tess.vertexPtr1);
+		backEnd.worldVBO.offs2 = (vaWord2_t *)((intptr_t)tess.vertexPtr2 - (intptr_t)tess.vertexPtr1);
+		backEnd.worldVBO.offs3 = (vaWord3_t *)((intptr_t)tess.vertexPtr3 - (intptr_t)tess.vertexPtr1);
+		backEnd.worldVBO.offs4 = (vaWord4_t *)((intptr_t)tess.vertexPtr4 - (intptr_t)tess.vertexPtr1);
+		
+		RB_FlushVertexBuffer( );
+
+		ri.Hunk_FreeTempMemory( sortBuffer );
+	}
 }
 
 
@@ -1325,7 +1424,7 @@
 		}
 
 		model->type = MOD_BRUSH;
-		model->bmodel = out;
+		model->modelData.brush.bmodel = out;
 		Com_sprintf( model->name, sizeof( model->name ), "*%d", i );
 
 		for (j=0 ; j<3 ; j++) {
@@ -1366,6 +1465,7 @@
 	dnode_t		*in;
 	dleaf_t		*inLeaf;
 	mnode_t 	*out;
+	mcluster_t	*clusters;
 	int			numNodes, numLeafs;
 
 	in = (void *)(fileBase + nodeLump->fileofs);
@@ -1430,6 +1530,20 @@
 
 	// chain decendants
 	R_SetParent (s_worldData.nodes, NULL);
+
+	// calculate cluster bounds
+	clusters = ri.Hunk_Alloc ( s_worldData.numClusters * sizeof(mcluster_t), h_low);
+	tr.clusters = s_worldData.clusters = clusters;
+	for ( i = 0; i < s_worldData.numClusters; i++ ) {
+		ClearBounds( clusters[i].mins, clusters[i].maxs );
+	}
+	out = s_worldData.nodes + numNodes;
+	for ( i = 0; i < numLeafs; i++ ) {
+		if ( ( j = out[i].cluster ) >= 0 ) {
+			AddPointToBounds( out[i].mins, clusters[j].mins, clusters[j].maxs );
+			AddPointToBounds( out[i].maxs, clusters[j].mins, clusters[j].maxs );
+		}
+	}
 }
 
 //=============================================================================
@@ -1555,10 +1669,6 @@
 	s_worldData.fogs = ri.Hunk_Alloc ( s_worldData.numfogs*sizeof(*out), h_low);
 	out = s_worldData.fogs + 1;
 
-	if ( !count ) {
-		return;
-	}
-
 	brushes = (void *)(fileBase + brushesLump->fileofs);
 	if (brushesLump->filelen % sizeof(*brushes)) {
 		ri.Error (ERR_DROP, "LoadMap: funny lump size in %s",s_worldData.name);
@@ -1636,7 +1746,6 @@
 
 		out++;
 	}
-
 }
 
 
@@ -1849,7 +1958,7 @@
 
 	// load into heap
 	R_LoadShaders( &header->lumps[LUMP_SHADERS] );
-	R_LoadLightmaps( &header->lumps[LUMP_LIGHTMAPS] );
+	R_LoadLightmaps( &header->lumps[LUMP_LIGHTMAPS], &header->lumps[LUMP_SURFACES] );
 	R_LoadPlanes (&header->lumps[LUMP_PLANES]);
 	R_LoadFogs( &header->lumps[LUMP_FOGS], &header->lumps[LUMP_BRUSHES], &header->lumps[LUMP_BRUSHSIDES] );
 	R_LoadSurfaces( &header->lumps[LUMP_SURFACES], &header->lumps[LUMP_DRAWVERTS], &header->lumps[LUMP_DRAWINDEXES] );
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_bsp.c.orig tremulous-ggp1-src/src/renderer/tr_bsp.c.orig
--- tremulous-ggp1-src.p/src/renderer/tr_bsp.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_bsp.c.orig	2012-07-19 04:25:20.311556052 +0200
@@ -0,0 +1,1870 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+// tr_map.c
+
+#include "tr_local.h"
+
+/*
+
+Loads and prepares a map file for scene rendering.
+
+A single entry point:
+
+void RE_LoadWorldMap( const char *name );
+
+*/
+
+static	world_t		s_worldData;
+static	byte		*fileBase;
+
+int			c_subdivisions;
+int			c_gridVerts;
+
+//===============================================================================
+
+static void HSVtoRGB( float h, float s, float v, float rgb[3] )
+{
+	int i;
+	float f;
+	float p, q, t;
+
+	h *= 5;
+
+	i = floor( h );
+	f = h - i;
+
+	p = v * ( 1 - s );
+	q = v * ( 1 - s * f );
+	t = v * ( 1 - s * ( 1 - f ) );
+
+	switch ( i )
+	{
+	case 0:
+		rgb[0] = v;
+		rgb[1] = t;
+		rgb[2] = p;
+		break;
+	case 1:
+		rgb[0] = q;
+		rgb[1] = v;
+		rgb[2] = p;
+		break;
+	case 2:
+		rgb[0] = p;
+		rgb[1] = v;
+		rgb[2] = t;
+		break;
+	case 3:
+		rgb[0] = p;
+		rgb[1] = q;
+		rgb[2] = v;
+		break;
+	case 4:
+		rgb[0] = t;
+		rgb[1] = p;
+		rgb[2] = v;
+		break;
+	case 5:
+		rgb[0] = v;
+		rgb[1] = p;
+		rgb[2] = q;
+		break;
+	}
+}
+
+/*
+===============
+R_ColorShiftLightingBytes
+
+===============
+*/
+static	void R_ColorShiftLightingBytes( byte in[4], byte out[4] ) {
+	int		shift, r, g, b;
+
+	// shift the color data based on overbright range
+	shift = r_mapOverBrightBits->integer - tr.overbrightBits;
+
+	// shift the data based on overbright range
+	r = in[0] << shift;
+	g = in[1] << shift;
+	b = in[2] << shift;
+	
+	// normalize by color instead of saturating to white
+	if ( ( r | g | b ) > 255 ) {
+		int		max;
+
+		max = r > g ? r : g;
+		max = max > b ? max : b;
+		r = r * 255 / max;
+		g = g * 255 / max;
+		b = b * 255 / max;
+	}
+
+	out[0] = r;
+	out[1] = g;
+	out[2] = b;
+	out[3] = in[3];
+}
+
+/*
+===============
+R_LoadLightmaps
+
+===============
+*/
+#define	LIGHTMAP_SIZE	128
+static	void R_LoadLightmaps( lump_t *l ) {
+	byte		*buf, *buf_p;
+	int			len;
+	byte		image[LIGHTMAP_SIZE*LIGHTMAP_SIZE*4];
+	int			i, j;
+	float maxIntensity = 0;
+	double sumIntensity = 0;
+
+	len = l->filelen;
+	if ( !len ) {
+		return;
+	}
+	buf = fileBase + l->fileofs;
+
+	// we are about to upload textures
+	R_SyncRenderThread();
+
+	// create all the lightmaps
+	tr.numLightmaps = len / (LIGHTMAP_SIZE * LIGHTMAP_SIZE * 3);
+	if ( tr.numLightmaps == 1 ) {
+		//FIXME: HACK: maps with only one lightmap turn up fullbright for some reason.
+		//this avoids this, but isn't the correct solution.
+		tr.numLightmaps++;
+	}
+
+	// if we are in r_vertexLight mode, we don't need the lightmaps at all
+	if ( r_vertexLight->integer || glConfig.hardwareType == GLHW_PERMEDIA2 ) {
+		return;
+	}
+
+	tr.lightmaps = ri.Hunk_Alloc( tr.numLightmaps * sizeof(image_t *), h_low );
+	for ( i = 0 ; i < tr.numLightmaps ; i++ ) {
+		// expand the 24 bit on-disk to 32 bit
+		buf_p = buf + i * LIGHTMAP_SIZE*LIGHTMAP_SIZE * 3;
+
+		if ( r_lightmap->integer == 2 )
+		{	// color code by intensity as development tool	(FIXME: check range)
+			for ( j = 0; j < LIGHTMAP_SIZE * LIGHTMAP_SIZE; j++ )
+			{
+				float r = buf_p[j*3+0];
+				float g = buf_p[j*3+1];
+				float b = buf_p[j*3+2];
+				float intensity;
+				float out[3] = {0.0, 0.0, 0.0};
+
+				intensity = 0.33f * r + 0.685f * g + 0.063f * b;
+
+				if ( intensity > 255 )
+					intensity = 1.0f;
+				else
+					intensity /= 255.0f;
+
+				if ( intensity > maxIntensity )
+					maxIntensity = intensity;
+
+				HSVtoRGB( intensity, 1.00, 0.50, out );
+
+				image[j*4+0] = out[0] * 255;
+				image[j*4+1] = out[1] * 255;
+				image[j*4+2] = out[2] * 255;
+				image[j*4+3] = 255;
+
+				sumIntensity += intensity;
+			}
+		} else {
+			for ( j = 0 ; j < LIGHTMAP_SIZE * LIGHTMAP_SIZE; j++ ) {
+				R_ColorShiftLightingBytes( &buf_p[j*3], &image[j*4] );
+				image[j*4+3] = 255;
+			}
+		}
+		tr.lightmaps[i] = R_CreateImage( va("*lightmap%d",i), image, 
+			LIGHTMAP_SIZE, LIGHTMAP_SIZE, qfalse, qfalse, GL_CLAMP_TO_EDGE );
+	}
+
+	if ( r_lightmap->integer == 2 )	{
+		ri.Printf( PRINT_ALL, "Brightest lightmap value: %d\n", ( int ) ( maxIntensity * 255 ) );
+	}
+}
+
+
+/*
+=================
+RE_SetWorldVisData
+
+This is called by the clipmodel subsystem so we can share the 1.8 megs of
+space in big maps...
+=================
+*/
+void		RE_SetWorldVisData( const byte *vis ) {
+	tr.externalVisData = vis;
+}
+
+
+/*
+=================
+R_LoadVisibility
+=================
+*/
+static	void R_LoadVisibility( lump_t *l ) {
+	int		len;
+	byte	*buf;
+
+	len = ( s_worldData.numClusters + 63 ) & ~63;
+	s_worldData.novis = ri.Hunk_Alloc( len, h_low );
+	Com_Memset( s_worldData.novis, 0xff, len );
+
+    len = l->filelen;
+	if ( !len ) {
+		return;
+	}
+	buf = fileBase + l->fileofs;
+
+	s_worldData.numClusters = LittleLong( ((int *)buf)[0] );
+	s_worldData.clusterBytes = LittleLong( ((int *)buf)[1] );
+
+	// CM_Load should have given us the vis data to share, so
+	// we don't need to allocate another copy
+	if ( tr.externalVisData ) {
+		s_worldData.vis = tr.externalVisData;
+	} else {
+		byte	*dest;
+
+		dest = ri.Hunk_Alloc( len - 8, h_low );
+		Com_Memcpy( dest, buf + 8, len - 8 );
+		s_worldData.vis = dest;
+	}
+}
+
+//===============================================================================
+
+
+/*
+===============
+ShaderForShaderNum
+===============
+*/
+static shader_t *ShaderForShaderNum( int shaderNum, int lightmapNum ) {
+	shader_t	*shader;
+	dshader_t	*dsh;
+
+	shaderNum = LittleLong( shaderNum );
+	if ( shaderNum < 0 || shaderNum >= s_worldData.numShaders ) {
+		ri.Error( ERR_DROP, "ShaderForShaderNum: bad num %i", shaderNum );
+	}
+	dsh = &s_worldData.shaders[ shaderNum ];
+
+	if ( r_vertexLight->integer || glConfig.hardwareType == GLHW_PERMEDIA2 ) {
+		lightmapNum = LIGHTMAP_BY_VERTEX;
+	}
+
+	if ( r_fullbright->integer ) {
+		lightmapNum = LIGHTMAP_WHITEIMAGE;
+	}
+
+	shader = R_FindShader( dsh->shader, lightmapNum, qtrue );
+
+	// if the shader had errors, just use default shader
+	if ( shader->defaultShader ) {
+		return tr.defaultShader;
+	}
+
+	return shader;
+}
+
+/*
+===============
+ParseFace
+===============
+*/
+static void ParseFace( dsurface_t *ds, drawVert_t *verts, msurface_t *surf, int *indexes  ) {
+	int			i, j;
+	srfSurfaceFace_t	*cv;
+	int			numPoints, numIndexes;
+	int			lightmapNum;
+	int			sfaceSize, ofsIndexes;
+
+	lightmapNum = LittleLong( ds->lightmapNum );
+
+	// get fog volume
+	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+
+	// get shader value
+	surf->shader = ShaderForShaderNum( ds->shaderNum, lightmapNum );
+	if ( r_singleShader->integer && !surf->shader->isSky ) {
+		surf->shader = tr.defaultShader;
+	}
+
+	numPoints = LittleLong( ds->numVerts );
+	if (numPoints > MAX_FACE_POINTS) {
+		ri.Printf( PRINT_WARNING, "WARNING: MAX_FACE_POINTS exceeded: %i\n", numPoints);
+    numPoints = MAX_FACE_POINTS;
+    surf->shader = tr.defaultShader;
+	}
+
+	numIndexes = LittleLong( ds->numIndexes );
+
+	// create the srfSurfaceFace_t
+	sfaceSize = ( size_t ) &((srfSurfaceFace_t *)0)->points[numPoints];
+	ofsIndexes = sfaceSize;
+	sfaceSize += sizeof( int ) * numIndexes;
+
+	cv = ri.Hunk_Alloc( sfaceSize, h_low );
+	cv->surfaceType = SF_FACE;
+	cv->numPoints = numPoints;
+	cv->numIndices = numIndexes;
+	cv->ofsIndices = ofsIndexes;
+
+	verts += LittleLong( ds->firstVert );
+	for ( i = 0 ; i < numPoints ; i++ ) {
+		for ( j = 0 ; j < 3 ; j++ ) {
+			cv->points[i][j] = LittleFloat( verts[i].xyz[j] );
+		}
+		for ( j = 0 ; j < 2 ; j++ ) {
+			cv->points[i][3+j] = LittleFloat( verts[i].st[j] );
+			cv->points[i][5+j] = LittleFloat( verts[i].lightmap[j] );
+		}
+		R_ColorShiftLightingBytes( verts[i].color, (byte *)&cv->points[i][7] );
+	}
+
+	indexes += LittleLong( ds->firstIndex );
+	for ( i = 0 ; i < numIndexes ; i++ ) {
+		((int *)((byte *)cv + cv->ofsIndices ))[i] = LittleLong( indexes[ i ] );
+	}
+
+	// take the plane information from the lightmap vector
+	for ( i = 0 ; i < 3 ; i++ ) {
+		cv->plane.normal[i] = LittleFloat( ds->lightmapVecs[2][i] );
+	}
+	cv->plane.dist = DotProduct( cv->points[0], cv->plane.normal );
+	SetPlaneSignbits( &cv->plane );
+	cv->plane.type = PlaneTypeForNormal( cv->plane.normal );
+
+	surf->data = (surfaceType_t *)cv;
+}
+
+
+/*
+===============
+ParseMesh
+===============
+*/
+static void ParseMesh ( dsurface_t *ds, drawVert_t *verts, msurface_t *surf ) {
+	srfGridMesh_t	*grid;
+	int				i, j;
+	int				width, height, numPoints;
+	drawVert_t points[MAX_PATCH_SIZE*MAX_PATCH_SIZE];
+	int				lightmapNum;
+	vec3_t			bounds[2];
+	vec3_t			tmpVec;
+	static surfaceType_t	skipData = SF_SKIP;
+
+	lightmapNum = LittleLong( ds->lightmapNum );
+
+	// get fog volume
+	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+
+	// get shader value
+	surf->shader = ShaderForShaderNum( ds->shaderNum, lightmapNum );
+	if ( r_singleShader->integer && !surf->shader->isSky ) {
+		surf->shader = tr.defaultShader;
+	}
+
+	// we may have a nodraw surface, because they might still need to
+	// be around for movement clipping
+	if ( s_worldData.shaders[ LittleLong( ds->shaderNum ) ].surfaceFlags & SURF_NODRAW ) {
+		surf->data = &skipData;
+		return;
+	}
+
+	width = LittleLong( ds->patchWidth );
+	height = LittleLong( ds->patchHeight );
+
+	verts += LittleLong( ds->firstVert );
+	numPoints = width * height;
+	for ( i = 0 ; i < numPoints ; i++ ) {
+		for ( j = 0 ; j < 3 ; j++ ) {
+			points[i].xyz[j] = LittleFloat( verts[i].xyz[j] );
+			points[i].normal[j] = LittleFloat( verts[i].normal[j] );
+		}
+		for ( j = 0 ; j < 2 ; j++ ) {
+			points[i].st[j] = LittleFloat( verts[i].st[j] );
+			points[i].lightmap[j] = LittleFloat( verts[i].lightmap[j] );
+		}
+		R_ColorShiftLightingBytes( verts[i].color, points[i].color );
+	}
+
+	// pre-tesseleate
+	grid = R_SubdividePatchToGrid( width, height, points );
+	surf->data = (surfaceType_t *)grid;
+
+	// copy the level of detail origin, which is the center
+	// of the group of all curves that must subdivide the same
+	// to avoid cracking
+	for ( i = 0 ; i < 3 ; i++ ) {
+		bounds[0][i] = LittleFloat( ds->lightmapVecs[0][i] );
+		bounds[1][i] = LittleFloat( ds->lightmapVecs[1][i] );
+	}
+	VectorAdd( bounds[0], bounds[1], bounds[1] );
+	VectorScale( bounds[1], 0.5f, grid->lodOrigin );
+	VectorSubtract( bounds[0], grid->lodOrigin, tmpVec );
+	grid->lodRadius = VectorLength( tmpVec );
+}
+
+/*
+===============
+ParseTriSurf
+===============
+*/
+static void ParseTriSurf( dsurface_t *ds, drawVert_t *verts, msurface_t *surf, int *indexes ) {
+	srfTriangles_t	*tri;
+	int				i, j;
+	int				numVerts, numIndexes;
+
+	// get fog volume
+	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+
+	// get shader
+	surf->shader = ShaderForShaderNum( ds->shaderNum, LIGHTMAP_BY_VERTEX );
+	if ( r_singleShader->integer && !surf->shader->isSky ) {
+		surf->shader = tr.defaultShader;
+	}
+
+	numVerts = LittleLong( ds->numVerts );
+	numIndexes = LittleLong( ds->numIndexes );
+
+	tri = ri.Hunk_Alloc( sizeof( *tri ) + numVerts * sizeof( tri->verts[0] ) 
+		+ numIndexes * sizeof( tri->indexes[0] ), h_low );
+	tri->surfaceType = SF_TRIANGLES;
+	tri->numVerts = numVerts;
+	tri->numIndexes = numIndexes;
+	tri->verts = (drawVert_t *)(tri + 1);
+	tri->indexes = (int *)(tri->verts + tri->numVerts );
+
+	surf->data = (surfaceType_t *)tri;
+
+	// copy vertexes
+	ClearBounds( tri->bounds[0], tri->bounds[1] );
+	verts += LittleLong( ds->firstVert );
+	for ( i = 0 ; i < numVerts ; i++ ) {
+		for ( j = 0 ; j < 3 ; j++ ) {
+			tri->verts[i].xyz[j] = LittleFloat( verts[i].xyz[j] );
+			tri->verts[i].normal[j] = LittleFloat( verts[i].normal[j] );
+		}
+		AddPointToBounds( tri->verts[i].xyz, tri->bounds[0], tri->bounds[1] );
+		for ( j = 0 ; j < 2 ; j++ ) {
+			tri->verts[i].st[j] = LittleFloat( verts[i].st[j] );
+			tri->verts[i].lightmap[j] = LittleFloat( verts[i].lightmap[j] );
+		}
+
+		R_ColorShiftLightingBytes( verts[i].color, tri->verts[i].color );
+	}
+
+	// copy indexes
+	indexes += LittleLong( ds->firstIndex );
+	for ( i = 0 ; i < numIndexes ; i++ ) {
+		tri->indexes[i] = LittleLong( indexes[i] );
+		if ( tri->indexes[i] < 0 || tri->indexes[i] >= numVerts ) {
+			ri.Error( ERR_DROP, "Bad index in triangle surface" );
+		}
+	}
+}
+
+/*
+===============
+ParseFlare
+===============
+*/
+static void ParseFlare( dsurface_t *ds, drawVert_t *verts, msurface_t *surf, int *indexes ) {
+	srfFlare_t		*flare;
+	int				i;
+
+	// get fog volume
+	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
+
+	// get shader
+	surf->shader = ShaderForShaderNum( ds->shaderNum, LIGHTMAP_BY_VERTEX );
+	if ( r_singleShader->integer && !surf->shader->isSky ) {
+		surf->shader = tr.defaultShader;
+	}
+
+	flare = ri.Hunk_Alloc( sizeof( *flare ), h_low );
+	flare->surfaceType = SF_FLARE;
+
+	surf->data = (surfaceType_t *)flare;
+
+	for ( i = 0 ; i < 3 ; i++ ) {
+		flare->origin[i] = LittleFloat( ds->lightmapOrigin[i] );
+		flare->color[i] = LittleFloat( ds->lightmapVecs[0][i] );
+		flare->normal[i] = LittleFloat( ds->lightmapVecs[2][i] );
+	}
+}
+
+
+/*
+=================
+R_MergedWidthPoints
+
+returns true if there are grid points merged on a width edge
+=================
+*/
+int R_MergedWidthPoints(srfGridMesh_t *grid, int offset) {
+	int i, j;
+
+	for (i = 1; i < grid->width-1; i++) {
+		for (j = i + 1; j < grid->width-1; j++) {
+			if ( fabs(grid->verts[i + offset].xyz[0] - grid->verts[j + offset].xyz[0]) > .1) continue;
+			if ( fabs(grid->verts[i + offset].xyz[1] - grid->verts[j + offset].xyz[1]) > .1) continue;
+			if ( fabs(grid->verts[i + offset].xyz[2] - grid->verts[j + offset].xyz[2]) > .1) continue;
+			return qtrue;
+		}
+	}
+	return qfalse;
+}
+
+/*
+=================
+R_MergedHeightPoints
+
+returns true if there are grid points merged on a height edge
+=================
+*/
+int R_MergedHeightPoints(srfGridMesh_t *grid, int offset) {
+	int i, j;
+
+	for (i = 1; i < grid->height-1; i++) {
+		for (j = i + 1; j < grid->height-1; j++) {
+			if ( fabs(grid->verts[grid->width * i + offset].xyz[0] - grid->verts[grid->width * j + offset].xyz[0]) > .1) continue;
+			if ( fabs(grid->verts[grid->width * i + offset].xyz[1] - grid->verts[grid->width * j + offset].xyz[1]) > .1) continue;
+			if ( fabs(grid->verts[grid->width * i + offset].xyz[2] - grid->verts[grid->width * j + offset].xyz[2]) > .1) continue;
+			return qtrue;
+		}
+	}
+	return qfalse;
+}
+
+/*
+=================
+R_FixSharedVertexLodError_r
+
+NOTE: never sync LoD through grid edges with merged points!
+
+FIXME: write generalized version that also avoids cracks between a patch and one that meets half way?
+=================
+*/
+void R_FixSharedVertexLodError_r( int start, srfGridMesh_t *grid1 ) {
+	int j, k, l, m, n, offset1, offset2, touch;
+	srfGridMesh_t *grid2;
+
+	for ( j = start; j < s_worldData.numsurfaces; j++ ) {
+		//
+		grid2 = (srfGridMesh_t *) s_worldData.surfaces[j].data;
+		// if this surface is not a grid
+		if ( grid2->surfaceType != SF_GRID ) continue;
+		// if the LOD errors are already fixed for this patch
+		if ( grid2->lodFixed == 2 ) continue;
+		// grids in the same LOD group should have the exact same lod radius
+		if ( grid1->lodRadius != grid2->lodRadius ) continue;
+		// grids in the same LOD group should have the exact same lod origin
+		if ( grid1->lodOrigin[0] != grid2->lodOrigin[0] ) continue;
+		if ( grid1->lodOrigin[1] != grid2->lodOrigin[1] ) continue;
+		if ( grid1->lodOrigin[2] != grid2->lodOrigin[2] ) continue;
+		//
+		touch = qfalse;
+		for (n = 0; n < 2; n++) {
+			//
+			if (n) offset1 = (grid1->height-1) * grid1->width;
+			else offset1 = 0;
+			if (R_MergedWidthPoints(grid1, offset1)) continue;
+			for (k = 1; k < grid1->width-1; k++) {
+				for (m = 0; m < 2; m++) {
+
+					if (m) offset2 = (grid2->height-1) * grid2->width;
+					else offset2 = 0;
+					if (R_MergedWidthPoints(grid2, offset2)) continue;
+					for ( l = 1; l < grid2->width-1; l++) {
+					//
+						if ( fabs(grid1->verts[k + offset1].xyz[0] - grid2->verts[l + offset2].xyz[0]) > .1) continue;
+						if ( fabs(grid1->verts[k + offset1].xyz[1] - grid2->verts[l + offset2].xyz[1]) > .1) continue;
+						if ( fabs(grid1->verts[k + offset1].xyz[2] - grid2->verts[l + offset2].xyz[2]) > .1) continue;
+						// ok the points are equal and should have the same lod error
+						grid2->widthLodError[l] = grid1->widthLodError[k];
+						touch = qtrue;
+					}
+				}
+				for (m = 0; m < 2; m++) {
+
+					if (m) offset2 = grid2->width-1;
+					else offset2 = 0;
+					if (R_MergedHeightPoints(grid2, offset2)) continue;
+					for ( l = 1; l < grid2->height-1; l++) {
+					//
+						if ( fabs(grid1->verts[k + offset1].xyz[0] - grid2->verts[grid2->width * l + offset2].xyz[0]) > .1) continue;
+						if ( fabs(grid1->verts[k + offset1].xyz[1] - grid2->verts[grid2->width * l + offset2].xyz[1]) > .1) continue;
+						if ( fabs(grid1->verts[k + offset1].xyz[2] - grid2->verts[grid2->width * l + offset2].xyz[2]) > .1) continue;
+						// ok the points are equal and should have the same lod error
+						grid2->heightLodError[l] = grid1->widthLodError[k];
+						touch = qtrue;
+					}
+				}
+			}
+		}
+		for (n = 0; n < 2; n++) {
+			//
+			if (n) offset1 = grid1->width-1;
+			else offset1 = 0;
+			if (R_MergedHeightPoints(grid1, offset1)) continue;
+			for (k = 1; k < grid1->height-1; k++) {
+				for (m = 0; m < 2; m++) {
+
+					if (m) offset2 = (grid2->height-1) * grid2->width;
+					else offset2 = 0;
+					if (R_MergedWidthPoints(grid2, offset2)) continue;
+					for ( l = 1; l < grid2->width-1; l++) {
+					//
+						if ( fabs(grid1->verts[grid1->width * k + offset1].xyz[0] - grid2->verts[l + offset2].xyz[0]) > .1) continue;
+						if ( fabs(grid1->verts[grid1->width * k + offset1].xyz[1] - grid2->verts[l + offset2].xyz[1]) > .1) continue;
+						if ( fabs(grid1->verts[grid1->width * k + offset1].xyz[2] - grid2->verts[l + offset2].xyz[2]) > .1) continue;
+						// ok the points are equal and should have the same lod error
+						grid2->widthLodError[l] = grid1->heightLodError[k];
+						touch = qtrue;
+					}
+				}
+				for (m = 0; m < 2; m++) {
+
+					if (m) offset2 = grid2->width-1;
+					else offset2 = 0;
+					if (R_MergedHeightPoints(grid2, offset2)) continue;
+					for ( l = 1; l < grid2->height-1; l++) {
+					//
+						if ( fabs(grid1->verts[grid1->width * k + offset1].xyz[0] - grid2->verts[grid2->width * l + offset2].xyz[0]) > .1) continue;
+						if ( fabs(grid1->verts[grid1->width * k + offset1].xyz[1] - grid2->verts[grid2->width * l + offset2].xyz[1]) > .1) continue;
+						if ( fabs(grid1->verts[grid1->width * k + offset1].xyz[2] - grid2->verts[grid2->width * l + offset2].xyz[2]) > .1) continue;
+						// ok the points are equal and should have the same lod error
+						grid2->heightLodError[l] = grid1->heightLodError[k];
+						touch = qtrue;
+					}
+				}
+			}
+		}
+		if (touch) {
+			grid2->lodFixed = 2;
+			R_FixSharedVertexLodError_r ( start, grid2 );
+			//NOTE: this would be correct but makes things really slow
+			//grid2->lodFixed = 1;
+		}
+	}
+}
+
+/*
+=================
+R_FixSharedVertexLodError
+
+This function assumes that all patches in one group are nicely stitched together for the highest LoD.
+If this is not the case this function will still do its job but won't fix the highest LoD cracks.
+=================
+*/
+void R_FixSharedVertexLodError( void ) {
+	int i;
+	srfGridMesh_t *grid1;
+
+	for ( i = 0; i < s_worldData.numsurfaces; i++ ) {
+		//
+		grid1 = (srfGridMesh_t *) s_worldData.surfaces[i].data;
+		// if this surface is not a grid
+		if ( grid1->surfaceType != SF_GRID )
+			continue;
+		//
+		if ( grid1->lodFixed )
+			continue;
+		//
+		grid1->lodFixed = 2;
+		// recursively fix other patches in the same LOD group
+		R_FixSharedVertexLodError_r( i + 1, grid1);
+	}
+}
+
+
+/*
+===============
+R_StitchPatches
+===============
+*/
+int R_StitchPatches( int grid1num, int grid2num ) {
+	float *v1, *v2;
+	srfGridMesh_t *grid1, *grid2;
+	int k, l, m, n, offset1, offset2, row, column;
+
+	grid1 = (srfGridMesh_t *) s_worldData.surfaces[grid1num].data;
+	grid2 = (srfGridMesh_t *) s_worldData.surfaces[grid2num].data;
+	for (n = 0; n < 2; n++) {
+		//
+		if (n) offset1 = (grid1->height-1) * grid1->width;
+		else offset1 = 0;
+		if (R_MergedWidthPoints(grid1, offset1))
+			continue;
+		for (k = 0; k < grid1->width-2; k += 2) {
+
+			for (m = 0; m < 2; m++) {
+
+				if ( grid2->width >= MAX_GRID_SIZE )
+					break;
+				if (m) offset2 = (grid2->height-1) * grid2->width;
+				else offset2 = 0;
+				for ( l = 0; l < grid2->width-1; l++) {
+				//
+					v1 = grid1->verts[k + offset1].xyz;
+					v2 = grid2->verts[l + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+
+					v1 = grid1->verts[k + 2 + offset1].xyz;
+					v2 = grid2->verts[l + 1 + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+					//
+					v1 = grid2->verts[l + offset2].xyz;
+					v2 = grid2->verts[l + 1 + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) < .01 &&
+							fabs(v1[1] - v2[1]) < .01 &&
+							fabs(v1[2] - v2[2]) < .01)
+						continue;
+					//
+					//ri.Printf( PRINT_ALL, "found highest LoD crack between two patches\n" );
+					// insert column into grid2 right after after column l
+					if (m) row = grid2->height-1;
+					else row = 0;
+					grid2 = R_GridInsertColumn( grid2, l+1, row,
+									grid1->verts[k + 1 + offset1].xyz, grid1->widthLodError[k+1]);
+					grid2->lodStitched = qfalse;
+					s_worldData.surfaces[grid2num].data = (void *) grid2;
+					return qtrue;
+				}
+			}
+			for (m = 0; m < 2; m++) {
+
+				if (grid2->height >= MAX_GRID_SIZE)
+					break;
+				if (m) offset2 = grid2->width-1;
+				else offset2 = 0;
+				for ( l = 0; l < grid2->height-1; l++) {
+					//
+					v1 = grid1->verts[k + offset1].xyz;
+					v2 = grid2->verts[grid2->width * l + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+
+					v1 = grid1->verts[k + 2 + offset1].xyz;
+					v2 = grid2->verts[grid2->width * (l + 1) + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+					//
+					v1 = grid2->verts[grid2->width * l + offset2].xyz;
+					v2 = grid2->verts[grid2->width * (l + 1) + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) < .01 &&
+							fabs(v1[1] - v2[1]) < .01 &&
+							fabs(v1[2] - v2[2]) < .01)
+						continue;
+					//
+					//ri.Printf( PRINT_ALL, "found highest LoD crack between two patches\n" );
+					// insert row into grid2 right after after row l
+					if (m) column = grid2->width-1;
+					else column = 0;
+					grid2 = R_GridInsertRow( grid2, l+1, column,
+										grid1->verts[k + 1 + offset1].xyz, grid1->widthLodError[k+1]);
+					grid2->lodStitched = qfalse;
+					s_worldData.surfaces[grid2num].data = (void *) grid2;
+					return qtrue;
+				}
+			}
+		}
+	}
+	for (n = 0; n < 2; n++) {
+		//
+		if (n) offset1 = grid1->width-1;
+		else offset1 = 0;
+		if (R_MergedHeightPoints(grid1, offset1))
+			continue;
+		for (k = 0; k < grid1->height-2; k += 2) {
+			for (m = 0; m < 2; m++) {
+
+				if ( grid2->width >= MAX_GRID_SIZE )
+					break;
+				if (m) offset2 = (grid2->height-1) * grid2->width;
+				else offset2 = 0;
+				for ( l = 0; l < grid2->width-1; l++) {
+				//
+					v1 = grid1->verts[grid1->width * k + offset1].xyz;
+					v2 = grid2->verts[l + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+
+					v1 = grid1->verts[grid1->width * (k + 2) + offset1].xyz;
+					v2 = grid2->verts[l + 1 + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+					//
+					v1 = grid2->verts[l + offset2].xyz;
+					v2 = grid2->verts[(l + 1) + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) < .01 &&
+							fabs(v1[1] - v2[1]) < .01 &&
+							fabs(v1[2] - v2[2]) < .01)
+						continue;
+					//
+					//ri.Printf( PRINT_ALL, "found highest LoD crack between two patches\n" );
+					// insert column into grid2 right after after column l
+					if (m) row = grid2->height-1;
+					else row = 0;
+					grid2 = R_GridInsertColumn( grid2, l+1, row,
+									grid1->verts[grid1->width * (k + 1) + offset1].xyz, grid1->heightLodError[k+1]);
+					grid2->lodStitched = qfalse;
+					s_worldData.surfaces[grid2num].data = (void *) grid2;
+					return qtrue;
+				}
+			}
+			for (m = 0; m < 2; m++) {
+
+				if (grid2->height >= MAX_GRID_SIZE)
+					break;
+				if (m) offset2 = grid2->width-1;
+				else offset2 = 0;
+				for ( l = 0; l < grid2->height-1; l++) {
+				//
+					v1 = grid1->verts[grid1->width * k + offset1].xyz;
+					v2 = grid2->verts[grid2->width * l + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+
+					v1 = grid1->verts[grid1->width * (k + 2) + offset1].xyz;
+					v2 = grid2->verts[grid2->width * (l + 1) + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+					//
+					v1 = grid2->verts[grid2->width * l + offset2].xyz;
+					v2 = grid2->verts[grid2->width * (l + 1) + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) < .01 &&
+							fabs(v1[1] - v2[1]) < .01 &&
+							fabs(v1[2] - v2[2]) < .01)
+						continue;
+					//
+					//ri.Printf( PRINT_ALL, "found highest LoD crack between two patches\n" );
+					// insert row into grid2 right after after row l
+					if (m) column = grid2->width-1;
+					else column = 0;
+					grid2 = R_GridInsertRow( grid2, l+1, column,
+									grid1->verts[grid1->width * (k + 1) + offset1].xyz, grid1->heightLodError[k+1]);
+					grid2->lodStitched = qfalse;
+					s_worldData.surfaces[grid2num].data = (void *) grid2;
+					return qtrue;
+				}
+			}
+		}
+	}
+	for (n = 0; n < 2; n++) {
+		//
+		if (n) offset1 = (grid1->height-1) * grid1->width;
+		else offset1 = 0;
+		if (R_MergedWidthPoints(grid1, offset1))
+			continue;
+		for (k = grid1->width-1; k > 1; k -= 2) {
+
+			for (m = 0; m < 2; m++) {
+
+				if ( grid2->width >= MAX_GRID_SIZE )
+					break;
+				if (m) offset2 = (grid2->height-1) * grid2->width;
+				else offset2 = 0;
+				for ( l = 0; l < grid2->width-1; l++) {
+				//
+					v1 = grid1->verts[k + offset1].xyz;
+					v2 = grid2->verts[l + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+
+					v1 = grid1->verts[k - 2 + offset1].xyz;
+					v2 = grid2->verts[l + 1 + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+					//
+					v1 = grid2->verts[l + offset2].xyz;
+					v2 = grid2->verts[(l + 1) + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) < .01 &&
+							fabs(v1[1] - v2[1]) < .01 &&
+							fabs(v1[2] - v2[2]) < .01)
+						continue;
+					//
+					//ri.Printf( PRINT_ALL, "found highest LoD crack between two patches\n" );
+					// insert column into grid2 right after after column l
+					if (m) row = grid2->height-1;
+					else row = 0;
+					grid2 = R_GridInsertColumn( grid2, l+1, row,
+										grid1->verts[k - 1 + offset1].xyz, grid1->widthLodError[k+1]);
+					grid2->lodStitched = qfalse;
+					s_worldData.surfaces[grid2num].data = (void *) grid2;
+					return qtrue;
+				}
+			}
+			for (m = 0; m < 2; m++) {
+
+				if (grid2->height >= MAX_GRID_SIZE)
+					break;
+				if (m) offset2 = grid2->width-1;
+				else offset2 = 0;
+				for ( l = 0; l < grid2->height-1; l++) {
+				//
+					v1 = grid1->verts[k + offset1].xyz;
+					v2 = grid2->verts[grid2->width * l + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+
+					v1 = grid1->verts[k - 2 + offset1].xyz;
+					v2 = grid2->verts[grid2->width * (l + 1) + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+					//
+					v1 = grid2->verts[grid2->width * l + offset2].xyz;
+					v2 = grid2->verts[grid2->width * (l + 1) + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) < .01 &&
+							fabs(v1[1] - v2[1]) < .01 &&
+							fabs(v1[2] - v2[2]) < .01)
+						continue;
+					//
+					//ri.Printf( PRINT_ALL, "found highest LoD crack between two patches\n" );
+					// insert row into grid2 right after after row l
+					if (m) column = grid2->width-1;
+					else column = 0;
+					grid2 = R_GridInsertRow( grid2, l+1, column,
+										grid1->verts[k - 1 + offset1].xyz, grid1->widthLodError[k+1]);
+					if (!grid2)
+						break;
+					grid2->lodStitched = qfalse;
+					s_worldData.surfaces[grid2num].data = (void *) grid2;
+					return qtrue;
+				}
+			}
+		}
+	}
+	for (n = 0; n < 2; n++) {
+		//
+		if (n) offset1 = grid1->width-1;
+		else offset1 = 0;
+		if (R_MergedHeightPoints(grid1, offset1))
+			continue;
+		for (k = grid1->height-1; k > 1; k -= 2) {
+			for (m = 0; m < 2; m++) {
+
+				if ( grid2->width >= MAX_GRID_SIZE )
+					break;
+				if (m) offset2 = (grid2->height-1) * grid2->width;
+				else offset2 = 0;
+				for ( l = 0; l < grid2->width-1; l++) {
+				//
+					v1 = grid1->verts[grid1->width * k + offset1].xyz;
+					v2 = grid2->verts[l + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+
+					v1 = grid1->verts[grid1->width * (k - 2) + offset1].xyz;
+					v2 = grid2->verts[l + 1 + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+					//
+					v1 = grid2->verts[l + offset2].xyz;
+					v2 = grid2->verts[(l + 1) + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) < .01 &&
+							fabs(v1[1] - v2[1]) < .01 &&
+							fabs(v1[2] - v2[2]) < .01)
+						continue;
+					//
+					//ri.Printf( PRINT_ALL, "found highest LoD crack between two patches\n" );
+					// insert column into grid2 right after after column l
+					if (m) row = grid2->height-1;
+					else row = 0;
+					grid2 = R_GridInsertColumn( grid2, l+1, row,
+										grid1->verts[grid1->width * (k - 1) + offset1].xyz, grid1->heightLodError[k+1]);
+					grid2->lodStitched = qfalse;
+					s_worldData.surfaces[grid2num].data = (void *) grid2;
+					return qtrue;
+				}
+			}
+			for (m = 0; m < 2; m++) {
+
+				if (grid2->height >= MAX_GRID_SIZE)
+					break;
+				if (m) offset2 = grid2->width-1;
+				else offset2 = 0;
+				for ( l = 0; l < grid2->height-1; l++) {
+				//
+					v1 = grid1->verts[grid1->width * k + offset1].xyz;
+					v2 = grid2->verts[grid2->width * l + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+
+					v1 = grid1->verts[grid1->width * (k - 2) + offset1].xyz;
+					v2 = grid2->verts[grid2->width * (l + 1) + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) > .1)
+						continue;
+					if ( fabs(v1[1] - v2[1]) > .1)
+						continue;
+					if ( fabs(v1[2] - v2[2]) > .1)
+						continue;
+					//
+					v1 = grid2->verts[grid2->width * l + offset2].xyz;
+					v2 = grid2->verts[grid2->width * (l + 1) + offset2].xyz;
+					if ( fabs(v1[0] - v2[0]) < .01 &&
+							fabs(v1[1] - v2[1]) < .01 &&
+							fabs(v1[2] - v2[2]) < .01)
+						continue;
+					//
+					//ri.Printf( PRINT_ALL, "found highest LoD crack between two patches\n" );
+					// insert row into grid2 right after after row l
+					if (m) column = grid2->width-1;
+					else column = 0;
+					grid2 = R_GridInsertRow( grid2, l+1, column,
+										grid1->verts[grid1->width * (k - 1) + offset1].xyz, grid1->heightLodError[k+1]);
+					grid2->lodStitched = qfalse;
+					s_worldData.surfaces[grid2num].data = (void *) grid2;
+					return qtrue;
+				}
+			}
+		}
+	}
+	return qfalse;
+}
+
+/*
+===============
+R_TryStitchPatch
+
+This function will try to stitch patches in the same LoD group together for the highest LoD.
+
+Only single missing vertice cracks will be fixed.
+
+Vertices will be joined at the patch side a crack is first found, at the other side
+of the patch (on the same row or column) the vertices will not be joined and cracks
+might still appear at that side.
+===============
+*/
+int R_TryStitchingPatch( int grid1num ) {
+	int j, numstitches;
+	srfGridMesh_t *grid1, *grid2;
+
+	numstitches = 0;
+	grid1 = (srfGridMesh_t *) s_worldData.surfaces[grid1num].data;
+	for ( j = 0; j < s_worldData.numsurfaces; j++ ) {
+		//
+		grid2 = (srfGridMesh_t *) s_worldData.surfaces[j].data;
+		// if this surface is not a grid
+		if ( grid2->surfaceType != SF_GRID ) continue;
+		// grids in the same LOD group should have the exact same lod radius
+		if ( grid1->lodRadius != grid2->lodRadius ) continue;
+		// grids in the same LOD group should have the exact same lod origin
+		if ( grid1->lodOrigin[0] != grid2->lodOrigin[0] ) continue;
+		if ( grid1->lodOrigin[1] != grid2->lodOrigin[1] ) continue;
+		if ( grid1->lodOrigin[2] != grid2->lodOrigin[2] ) continue;
+		//
+		while (R_StitchPatches(grid1num, j))
+		{
+			numstitches++;
+		}
+	}
+	return numstitches;
+}
+
+/*
+===============
+R_StitchAllPatches
+===============
+*/
+void R_StitchAllPatches( void ) {
+	int i, stitched, numstitches;
+	srfGridMesh_t *grid1;
+
+	numstitches = 0;
+	do
+	{
+		stitched = qfalse;
+		for ( i = 0; i < s_worldData.numsurfaces; i++ ) {
+			//
+			grid1 = (srfGridMesh_t *) s_worldData.surfaces[i].data;
+			// if this surface is not a grid
+			if ( grid1->surfaceType != SF_GRID )
+				continue;
+			//
+			if ( grid1->lodStitched )
+				continue;
+			//
+			grid1->lodStitched = qtrue;
+			stitched = qtrue;
+			//
+			numstitches += R_TryStitchingPatch( i );
+		}
+	}
+	while (stitched);
+	ri.Printf( PRINT_ALL, "stitched %d LoD cracks\n", numstitches );
+}
+
+/*
+===============
+R_MovePatchSurfacesToHunk
+===============
+*/
+void R_MovePatchSurfacesToHunk(void) {
+	int i, size;
+	srfGridMesh_t *grid, *hunkgrid;
+
+	for ( i = 0; i < s_worldData.numsurfaces; i++ ) {
+		//
+		grid = (srfGridMesh_t *) s_worldData.surfaces[i].data;
+		// if this surface is not a grid
+		if ( grid->surfaceType != SF_GRID )
+			continue;
+		//
+		size = (grid->width * grid->height - 1) * sizeof( drawVert_t ) + sizeof( *grid );
+		hunkgrid = ri.Hunk_Alloc( size, h_low );
+		Com_Memcpy(hunkgrid, grid, size);
+
+		hunkgrid->widthLodError = ri.Hunk_Alloc( grid->width * 4, h_low );
+		Com_Memcpy( hunkgrid->widthLodError, grid->widthLodError, grid->width * 4 );
+
+		hunkgrid->heightLodError = ri.Hunk_Alloc( grid->height * 4, h_low );
+		Com_Memcpy( hunkgrid->heightLodError, grid->heightLodError, grid->height * 4 );
+
+		R_FreeSurfaceGridMesh( grid );
+
+		s_worldData.surfaces[i].data = (void *) hunkgrid;
+	}
+}
+
+/*
+===============
+R_LoadSurfaces
+===============
+*/
+static	void R_LoadSurfaces( lump_t *surfs, lump_t *verts, lump_t *indexLump ) {
+	dsurface_t	*in;
+	msurface_t	*out;
+	drawVert_t	*dv;
+	int			*indexes;
+	int			count;
+	int			numFaces, numMeshes, numTriSurfs, numFlares;
+	int			i;
+
+	numFaces = 0;
+	numMeshes = 0;
+	numTriSurfs = 0;
+	numFlares = 0;
+
+	in = (void *)(fileBase + surfs->fileofs);
+	if (surfs->filelen % sizeof(*in))
+		ri.Error (ERR_DROP, "LoadMap: funny lump size in %s",s_worldData.name);
+	count = surfs->filelen / sizeof(*in);
+
+	dv = (void *)(fileBase + verts->fileofs);
+	if (verts->filelen % sizeof(*dv))
+		ri.Error (ERR_DROP, "LoadMap: funny lump size in %s",s_worldData.name);
+
+	indexes = (void *)(fileBase + indexLump->fileofs);
+	if ( indexLump->filelen % sizeof(*indexes))
+		ri.Error (ERR_DROP, "LoadMap: funny lump size in %s",s_worldData.name);
+
+	out = ri.Hunk_Alloc ( count * sizeof(*out), h_low );	
+
+	s_worldData.surfaces = out;
+	s_worldData.numsurfaces = count;
+
+	for ( i = 0 ; i < count ; i++, in++, out++ ) {
+		switch ( LittleLong( in->surfaceType ) ) {
+		case MST_PATCH:
+			ParseMesh ( in, dv, out );
+			numMeshes++;
+			break;
+		case MST_TRIANGLE_SOUP:
+			ParseTriSurf( in, dv, out, indexes );
+			numTriSurfs++;
+			break;
+		case MST_PLANAR:
+			ParseFace( in, dv, out, indexes );
+			numFaces++;
+			break;
+		case MST_FLARE:
+			ParseFlare( in, dv, out, indexes );
+			numFlares++;
+			break;
+		default:
+			ri.Error( ERR_DROP, "Bad surfaceType" );
+		}
+	}
+
+#ifdef PATCH_STITCHING
+	R_StitchAllPatches();
+#endif
+
+	R_FixSharedVertexLodError();
+
+#ifdef PATCH_STITCHING
+	R_MovePatchSurfacesToHunk();
+#endif
+
+	ri.Printf( PRINT_ALL, "...loaded %d faces, %i meshes, %i trisurfs, %i flares\n", 
+		numFaces, numMeshes, numTriSurfs, numFlares );
+}
+
+
+
+/*
+=================
+R_LoadSubmodels
+=================
+*/
+static	void R_LoadSubmodels( lump_t *l ) {
+	dmodel_t	*in;
+	bmodel_t	*out;
+	int			i, j, count;
+
+	in = (void *)(fileBase + l->fileofs);
+	if (l->filelen % sizeof(*in))
+		ri.Error (ERR_DROP, "LoadMap: funny lump size in %s",s_worldData.name);
+	count = l->filelen / sizeof(*in);
+
+	s_worldData.bmodels = out = ri.Hunk_Alloc( count * sizeof(*out), h_low );
+
+	for ( i=0 ; i<count ; i++, in++, out++ ) {
+		model_t *model;
+
+		model = R_AllocModel();
+
+		assert( model != NULL );			// this should never happen
+		if ( model == NULL ) {
+			ri.Error(ERR_DROP, "R_LoadSubmodels: R_AllocModel() failed");
+		}
+
+		model->type = MOD_BRUSH;
+		model->bmodel = out;
+		Com_sprintf( model->name, sizeof( model->name ), "*%d", i );
+
+		for (j=0 ; j<3 ; j++) {
+			out->bounds[0][j] = LittleFloat (in->mins[j]);
+			out->bounds[1][j] = LittleFloat (in->maxs[j]);
+		}
+
+		out->firstSurface = s_worldData.surfaces + LittleLong( in->firstSurface );
+		out->numSurfaces = LittleLong( in->numSurfaces );
+	}
+}
+
+
+
+//==================================================================
+
+/*
+=================
+R_SetParent
+=================
+*/
+static	void R_SetParent (mnode_t *node, mnode_t *parent)
+{
+	node->parent = parent;
+	if (node->contents != -1)
+		return;
+	R_SetParent (node->children[0], node);
+	R_SetParent (node->children[1], node);
+}
+
+/*
+=================
+R_LoadNodesAndLeafs
+=================
+*/
+static	void R_LoadNodesAndLeafs (lump_t *nodeLump, lump_t *leafLump) {
+	int			i, j, p;
+	dnode_t		*in;
+	dleaf_t		*inLeaf;
+	mnode_t 	*out;
+	int			numNodes, numLeafs;
+
+	in = (void *)(fileBase + nodeLump->fileofs);
+	if (nodeLump->filelen % sizeof(dnode_t) ||
+		leafLump->filelen % sizeof(dleaf_t) ) {
+		ri.Error (ERR_DROP, "LoadMap: funny lump size in %s",s_worldData.name);
+	}
+	numNodes = nodeLump->filelen / sizeof(dnode_t);
+	numLeafs = leafLump->filelen / sizeof(dleaf_t);
+
+	out = ri.Hunk_Alloc ( (numNodes + numLeafs) * sizeof(*out), h_low);	
+
+	s_worldData.nodes = out;
+	s_worldData.numnodes = numNodes + numLeafs;
+	s_worldData.numDecisionNodes = numNodes;
+
+	// load nodes
+	for ( i=0 ; i<numNodes; i++, in++, out++)
+	{
+		for (j=0 ; j<3 ; j++)
+		{
+			out->mins[j] = LittleLong (in->mins[j]);
+			out->maxs[j] = LittleLong (in->maxs[j]);
+		}
+	
+		p = LittleLong(in->planeNum);
+		out->plane = s_worldData.planes + p;
+
+		out->contents = CONTENTS_NODE;	// differentiate from leafs
+
+		for (j=0 ; j<2 ; j++)
+		{
+			p = LittleLong (in->children[j]);
+			if (p >= 0)
+				out->children[j] = s_worldData.nodes + p;
+			else
+				out->children[j] = s_worldData.nodes + numNodes + (-1 - p);
+		}
+	}
+	
+	// load leafs
+	inLeaf = (void *)(fileBase + leafLump->fileofs);
+	for ( i=0 ; i<numLeafs ; i++, inLeaf++, out++)
+	{
+		for (j=0 ; j<3 ; j++)
+		{
+			out->mins[j] = LittleLong (inLeaf->mins[j]);
+			out->maxs[j] = LittleLong (inLeaf->maxs[j]);
+		}
+
+		out->cluster = LittleLong(inLeaf->cluster);
+		out->area = LittleLong(inLeaf->area);
+
+		if ( out->cluster >= s_worldData.numClusters ) {
+			s_worldData.numClusters = out->cluster + 1;
+		}
+
+		out->firstmarksurface = s_worldData.marksurfaces +
+			LittleLong(inLeaf->firstLeafSurface);
+		out->nummarksurfaces = LittleLong(inLeaf->numLeafSurfaces);
+	}	
+
+	// chain decendants
+	R_SetParent (s_worldData.nodes, NULL);
+}
+
+//=============================================================================
+
+/*
+=================
+R_LoadShaders
+=================
+*/
+static	void R_LoadShaders( lump_t *l ) {	
+	int		i, count;
+	dshader_t	*in, *out;
+	
+	in = (void *)(fileBase + l->fileofs);
+	if (l->filelen % sizeof(*in))
+		ri.Error (ERR_DROP, "LoadMap: funny lump size in %s",s_worldData.name);
+	count = l->filelen / sizeof(*in);
+	out = ri.Hunk_Alloc ( count*sizeof(*out), h_low );
+
+	s_worldData.shaders = out;
+	s_worldData.numShaders = count;
+
+	Com_Memcpy( out, in, count*sizeof(*out) );
+
+	for ( i=0 ; i<count ; i++ ) {
+		out[i].surfaceFlags = LittleLong( out[i].surfaceFlags );
+		out[i].contentFlags = LittleLong( out[i].contentFlags );
+	}
+}
+
+
+/*
+=================
+R_LoadMarksurfaces
+=================
+*/
+static	void R_LoadMarksurfaces (lump_t *l)
+{	
+	int		i, j, count;
+	int		*in;
+	msurface_t **out;
+	
+	in = (void *)(fileBase + l->fileofs);
+	if (l->filelen % sizeof(*in))
+		ri.Error (ERR_DROP, "LoadMap: funny lump size in %s",s_worldData.name);
+	count = l->filelen / sizeof(*in);
+	out = ri.Hunk_Alloc ( count*sizeof(*out), h_low);	
+
+	s_worldData.marksurfaces = out;
+	s_worldData.nummarksurfaces = count;
+
+	for ( i=0 ; i<count ; i++)
+	{
+		j = LittleLong(in[i]);
+		out[i] = s_worldData.surfaces + j;
+	}
+}
+
+
+/*
+=================
+R_LoadPlanes
+=================
+*/
+static	void R_LoadPlanes( lump_t *l ) {
+	int			i, j;
+	cplane_t	*out;
+	dplane_t 	*in;
+	int			count;
+	int			bits;
+	
+	in = (void *)(fileBase + l->fileofs);
+	if (l->filelen % sizeof(*in))
+		ri.Error (ERR_DROP, "LoadMap: funny lump size in %s",s_worldData.name);
+	count = l->filelen / sizeof(*in);
+	out = ri.Hunk_Alloc ( count*2*sizeof(*out), h_low);	
+	
+	s_worldData.planes = out;
+	s_worldData.numplanes = count;
+
+	for ( i=0 ; i<count ; i++, in++, out++) {
+		bits = 0;
+		for (j=0 ; j<3 ; j++) {
+			out->normal[j] = LittleFloat (in->normal[j]);
+			if (out->normal[j] < 0) {
+				bits |= 1<<j;
+			}
+		}
+
+		out->dist = LittleFloat (in->dist);
+		out->type = PlaneTypeForNormal( out->normal );
+		out->signbits = bits;
+	}
+}
+
+/*
+=================
+R_LoadFogs
+
+=================
+*/
+static	void R_LoadFogs( lump_t *l, lump_t *brushesLump, lump_t *sidesLump ) {
+	int			i;
+	fog_t		*out;
+	dfog_t		*fogs;
+	dbrush_t 	*brushes, *brush;
+	dbrushside_t	*sides;
+	int			count, brushesCount, sidesCount;
+	int			sideNum;
+	int			planeNum;
+	shader_t	*shader;
+	float		d;
+	int			firstSide;
+
+	fogs = (void *)(fileBase + l->fileofs);
+	if (l->filelen % sizeof(*fogs)) {
+		ri.Error (ERR_DROP, "LoadMap: funny lump size in %s",s_worldData.name);
+	}
+	count = l->filelen / sizeof(*fogs);
+
+	// create fog strucutres for them
+	s_worldData.numfogs = count + 1;
+	s_worldData.fogs = ri.Hunk_Alloc ( s_worldData.numfogs*sizeof(*out), h_low);
+	out = s_worldData.fogs + 1;
+
+	if ( !count ) {
+		return;
+	}
+
+	brushes = (void *)(fileBase + brushesLump->fileofs);
+	if (brushesLump->filelen % sizeof(*brushes)) {
+		ri.Error (ERR_DROP, "LoadMap: funny lump size in %s",s_worldData.name);
+	}
+	brushesCount = brushesLump->filelen / sizeof(*brushes);
+
+	sides = (void *)(fileBase + sidesLump->fileofs);
+	if (sidesLump->filelen % sizeof(*sides)) {
+		ri.Error (ERR_DROP, "LoadMap: funny lump size in %s",s_worldData.name);
+	}
+	sidesCount = sidesLump->filelen / sizeof(*sides);
+
+	for ( i=0 ; i<count ; i++, fogs++) {
+		out->originalBrushNumber = LittleLong( fogs->brushNum );
+
+		if ( (unsigned)out->originalBrushNumber >= brushesCount ) {
+			ri.Error( ERR_DROP, "fog brushNumber out of range" );
+		}
+		brush = brushes + out->originalBrushNumber;
+
+		firstSide = LittleLong( brush->firstSide );
+
+			if ( (unsigned)firstSide > sidesCount - 6 ) {
+			ri.Error( ERR_DROP, "fog brush sideNumber out of range" );
+		}
+
+		// brushes are always sorted with the axial sides first
+		sideNum = firstSide + 0;
+		planeNum = LittleLong( sides[ sideNum ].planeNum );
+		out->bounds[0][0] = -s_worldData.planes[ planeNum ].dist;
+
+		sideNum = firstSide + 1;
+		planeNum = LittleLong( sides[ sideNum ].planeNum );
+		out->bounds[1][0] = s_worldData.planes[ planeNum ].dist;
+
+		sideNum = firstSide + 2;
+		planeNum = LittleLong( sides[ sideNum ].planeNum );
+		out->bounds[0][1] = -s_worldData.planes[ planeNum ].dist;
+
+		sideNum = firstSide + 3;
+		planeNum = LittleLong( sides[ sideNum ].planeNum );
+		out->bounds[1][1] = s_worldData.planes[ planeNum ].dist;
+
+		sideNum = firstSide + 4;
+		planeNum = LittleLong( sides[ sideNum ].planeNum );
+		out->bounds[0][2] = -s_worldData.planes[ planeNum ].dist;
+
+		sideNum = firstSide + 5;
+		planeNum = LittleLong( sides[ sideNum ].planeNum );
+		out->bounds[1][2] = s_worldData.planes[ planeNum ].dist;
+
+		// get information from the shader for fog parameters
+		shader = R_FindShader( fogs->shader, LIGHTMAP_NONE, qtrue );
+
+		out->parms = shader->fogParms;
+
+		out->colorInt = ColorBytes4 ( shader->fogParms.color[0] * tr.identityLight, 
+			                          shader->fogParms.color[1] * tr.identityLight, 
+			                          shader->fogParms.color[2] * tr.identityLight, 1.0 );
+
+		d = shader->fogParms.depthForOpaque < 1 ? 1 : shader->fogParms.depthForOpaque;
+		out->tcScale = 1.0f / ( d * 8 );
+
+		// set the gradient vector
+		sideNum = LittleLong( fogs->visibleSide );
+
+		if ( sideNum == -1 ) {
+			out->hasSurface = qfalse;
+		} else {
+			out->hasSurface = qtrue;
+			planeNum = LittleLong( sides[ firstSide + sideNum ].planeNum );
+			VectorSubtract( vec3_origin, s_worldData.planes[ planeNum ].normal, out->surface );
+			out->surface[3] = -s_worldData.planes[ planeNum ].dist;
+		}
+
+		out++;
+	}
+
+}
+
+
+/*
+================
+R_LoadLightGrid
+
+================
+*/
+void R_LoadLightGrid( lump_t *l ) {
+	int		i;
+	vec3_t	maxs;
+	int		numGridPoints;
+	world_t	*w;
+	float	*wMins, *wMaxs;
+
+	w = &s_worldData;
+
+	w->lightGridInverseSize[0] = 1.0f / w->lightGridSize[0];
+	w->lightGridInverseSize[1] = 1.0f / w->lightGridSize[1];
+	w->lightGridInverseSize[2] = 1.0f / w->lightGridSize[2];
+
+	wMins = w->bmodels[0].bounds[0];
+	wMaxs = w->bmodels[0].bounds[1];
+
+	for ( i = 0 ; i < 3 ; i++ ) {
+		w->lightGridOrigin[i] = w->lightGridSize[i] * ceil( wMins[i] / w->lightGridSize[i] );
+		maxs[i] = w->lightGridSize[i] * floor( wMaxs[i] / w->lightGridSize[i] );
+		w->lightGridBounds[i] = (maxs[i] - w->lightGridOrigin[i])/w->lightGridSize[i] + 1;
+	}
+
+	numGridPoints = w->lightGridBounds[0] * w->lightGridBounds[1] * w->lightGridBounds[2];
+
+	if ( l->filelen != numGridPoints * 8 ) {
+		ri.Printf( PRINT_WARNING, "WARNING: light grid mismatch\n" );
+		w->lightGridData = NULL;
+		return;
+	}
+
+	w->lightGridData = ri.Hunk_Alloc( l->filelen, h_low );
+	Com_Memcpy( w->lightGridData, (void *)(fileBase + l->fileofs), l->filelen );
+
+	// deal with overbright bits
+	for ( i = 0 ; i < numGridPoints ; i++ ) {
+		R_ColorShiftLightingBytes( &w->lightGridData[i*8], &w->lightGridData[i*8] );
+		R_ColorShiftLightingBytes( &w->lightGridData[i*8+3], &w->lightGridData[i*8+3] );
+	}
+}
+
+/*
+================
+R_LoadEntities
+================
+*/
+void R_LoadEntities( lump_t *l ) {
+	char *p, *token, *s;
+	char keyname[MAX_TOKEN_CHARS];
+	char value[MAX_TOKEN_CHARS];
+	world_t	*w;
+
+	w = &s_worldData;
+	w->lightGridSize[0] = 64;
+	w->lightGridSize[1] = 64;
+	w->lightGridSize[2] = 128;
+
+	p = (char *)(fileBase + l->fileofs);
+
+	// store for reference by the cgame
+	w->entityString = ri.Hunk_Alloc( l->filelen + 1, h_low );
+	strcpy( w->entityString, p );
+	w->entityParsePoint = w->entityString;
+
+	token = COM_ParseExt( &p, qtrue );
+	if (!*token || *token != '{') {
+		return;
+	}
+
+	// only parse the world spawn
+	while ( 1 ) {	
+		// parse key
+		token = COM_ParseExt( &p, qtrue );
+
+		if ( !*token || *token == '}' ) {
+			break;
+		}
+		Q_strncpyz(keyname, token, sizeof(keyname));
+
+		// parse value
+		token = COM_ParseExt( &p, qtrue );
+
+		if ( !*token || *token == '}' ) {
+			break;
+		}
+		Q_strncpyz(value, token, sizeof(value));
+
+		// check for remapping of shaders for vertex lighting
+		s = "vertexremapshader";
+		if (!Q_strncmp(keyname, s, strlen(s)) ) {
+			s = strchr(value, ';');
+			if (!s) {
+				ri.Printf( PRINT_WARNING, "WARNING: no semi colon in vertexshaderremap '%s'\n", value );
+				break;
+			}
+			*s++ = 0;
+			if (r_vertexLight->integer) {
+				R_RemapShader(value, s, "0");
+			}
+			continue;
+		}
+		// check for remapping of shaders
+		s = "remapshader";
+		if (!Q_strncmp(keyname, s, strlen(s)) ) {
+			s = strchr(value, ';');
+			if (!s) {
+				ri.Printf( PRINT_WARNING, "WARNING: no semi colon in shaderremap '%s'\n", value );
+				break;
+			}
+			*s++ = 0;
+			R_RemapShader(value, s, "0");
+			continue;
+		}
+		// check for a different grid size
+		if (!Q_stricmp(keyname, "gridsize")) {
+			sscanf(value, "%f %f %f", &w->lightGridSize[0], &w->lightGridSize[1], &w->lightGridSize[2] );
+			continue;
+		}
+	}
+}
+
+/*
+=================
+R_GetEntityToken
+=================
+*/
+qboolean R_GetEntityToken( char *buffer, int size ) {
+	const char	*s;
+
+	s = COM_Parse( &s_worldData.entityParsePoint );
+	Q_strncpyz( buffer, s, size );
+	if ( !s_worldData.entityParsePoint || !s[0] ) {
+		s_worldData.entityParsePoint = s_worldData.entityString;
+		return qfalse;
+	} else {
+		return qtrue;
+	}
+}
+
+/*
+=================
+RE_LoadWorldMap
+
+Called directly from cgame
+=================
+*/
+void RE_LoadWorldMap( const char *name ) {
+	int			i;
+	dheader_t	*header;
+	union {
+		byte *b;
+		void *v;
+	} buffer;
+	byte		*startMarker;
+
+	if ( tr.worldMapLoaded ) {
+		ri.Error( ERR_DROP, "ERROR: attempted to redundantly load world map\n" );
+	}
+
+	// set default sun direction to be used if it isn't
+	// overridden by a shader
+	tr.sunDirection[0] = 0.45f;
+	tr.sunDirection[1] = 0.3f;
+	tr.sunDirection[2] = 0.9f;
+
+	VectorNormalize( tr.sunDirection );
+
+	tr.worldMapLoaded = qtrue;
+
+	// load it
+    ri.FS_ReadFile( name, &buffer.v );
+	if ( !buffer.b ) {
+		ri.Error (ERR_DROP, "RE_LoadWorldMap: %s not found", name);
+	}
+
+	// clear tr.world so if the level fails to load, the next
+	// try will not look at the partially loaded version
+	tr.world = NULL;
+
+	Com_Memset( &s_worldData, 0, sizeof( s_worldData ) );
+	Q_strncpyz( s_worldData.name, name, sizeof( s_worldData.name ) );
+
+	Q_strncpyz( s_worldData.baseName, COM_SkipPath( s_worldData.name ), sizeof( s_worldData.name ) );
+	COM_StripExtension(s_worldData.baseName, s_worldData.baseName, sizeof(s_worldData.baseName));
+
+	startMarker = ri.Hunk_Alloc(0, h_low);
+	c_gridVerts = 0;
+
+	header = (dheader_t *)buffer.b;
+	fileBase = (byte *)header;
+
+	i = LittleLong (header->version);
+	if ( i != BSP_VERSION ) {
+		ri.Error (ERR_DROP, "RE_LoadWorldMap: %s has wrong version number (%i should be %i)", 
+			name, i, BSP_VERSION);
+	}
+
+	// swap all the lumps
+	for (i=0 ; i<sizeof(dheader_t)/4 ; i++) {
+		((int *)header)[i] = LittleLong ( ((int *)header)[i]);
+	}
+
+	// load into heap
+	R_LoadShaders( &header->lumps[LUMP_SHADERS] );
+	R_LoadLightmaps( &header->lumps[LUMP_LIGHTMAPS] );
+	R_LoadPlanes (&header->lumps[LUMP_PLANES]);
+	R_LoadFogs( &header->lumps[LUMP_FOGS], &header->lumps[LUMP_BRUSHES], &header->lumps[LUMP_BRUSHSIDES] );
+	R_LoadSurfaces( &header->lumps[LUMP_SURFACES], &header->lumps[LUMP_DRAWVERTS], &header->lumps[LUMP_DRAWINDEXES] );
+	R_LoadMarksurfaces (&header->lumps[LUMP_LEAFSURFACES]);
+	R_LoadNodesAndLeafs (&header->lumps[LUMP_NODES], &header->lumps[LUMP_LEAFS]);
+	R_LoadSubmodels (&header->lumps[LUMP_MODELS]);
+	R_LoadVisibility( &header->lumps[LUMP_VISIBILITY] );
+	R_LoadEntities( &header->lumps[LUMP_ENTITIES] );
+	R_LoadLightGrid( &header->lumps[LUMP_LIGHTGRID] );
+
+	s_worldData.dataSize = (byte *)ri.Hunk_Alloc(0, h_low) - startMarker;
+
+	// only set tr.world now that we know the entire level has loaded properly
+	tr.world = &s_worldData;
+
+    ri.FS_FreeFile( buffer.v );
+}
+
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_bsp.c.rej tremulous-ggp1-src/src/renderer/tr_bsp.c.rej
--- tremulous-ggp1-src.p/src/renderer/tr_bsp.c.rej	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_bsp.c.rej	2012-07-19 04:25:52.021556447 +0200
@@ -0,0 +1,187 @@
+--- src/renderer/tr_bsp.c	(Revision 2062)
++++ src/renderer/tr_bsp.c	(Arbeitskopie)
+@@ -154,67 +158,145 @@
+ 	// we are about to upload textures
+ 	R_SyncRenderThread();
+ 
+-	// create all the lightmaps
++	// compute the number of lightmaps
+ 	tr.numLightmaps = len / (LIGHTMAP_SIZE * LIGHTMAP_SIZE * 3);
+-	if ( tr.numLightmaps == 1 ) {
+-		//FIXME: HACK: maps with only one lightmap turn up fullbright for some reason.
+-		//this avoids this, but isn't the correct solution.
+-		tr.numLightmaps++;
+-	} else if ( tr.numLightmaps >= MAX_LIGHTMAPS ) { // 20051020 misantropia
++	if ( tr.numLightmaps >= MAX_LIGHTMAPS ) { // 20051020 misantropia
+ 		ri.Printf( PRINT_WARNING, "WARNING: number of lightmaps > MAX_LIGHTMAPS\n" );
+ 		tr.numLightmaps = MAX_LIGHTMAPS;
+ 	}
++	// if all odd indexes are unused, we probably have deluxemaps
++	tr.hasDeluxemaps = (tr.numLightmaps > 1);
++	for( i = 0, surf = (dsurface_t *)(fileBase + surfs->fileofs);
++	     i < surfs->filelen / sizeof(dsurface_t); i++, surf++ ) {
++		int lightmapNum = LittleLong( surf->lightmapNum );
++		if ( lightmapNum >= 0 && (lightmapNum & 1) != 0 ) {
++			tr.hasDeluxemaps = qfalse;
++			break;
++		}
++	}
+ 
+ 	// if we are in r_vertexLight mode, we don't need the lightmaps at all
+ 	if ( r_vertexLight->integer || glConfig.hardwareType == GLHW_PERMEDIA2 ) {
++		lightmapWidth = lightmapHeight = 1;
+ 		return;
+ 	}
++	
++	// see how many lightmaps we can stuff into one texture
++	lightmapWidth = lightmapHeight = 1;
++	while ( lightmapWidth * LIGHTMAP_SIZE < glConfig.maxTextureSize &&
++		lightmapWidth * lightmapHeight < tr.numLightmaps ) {
++		lightmapWidth *= 2;
++		if ( lightmapWidth * lightmapHeight >= tr.numLightmaps )
++			break;
++		lightmapHeight *= 2;
++	}
+ 
+-	for ( i = 0 ; i < tr.numLightmaps ; i++ ) {
+-		// expand the 24 bit on-disk to 32 bit
+-		buf_p = buf + i * LIGHTMAP_SIZE*LIGHTMAP_SIZE * 3;
++	// calculate number of resulting lightmap textures
++	tr.numLightmaps = (tr.numLightmaps + lightmapWidth * lightmapHeight - 1)
++		/ (lightmapWidth * lightmapHeight);
+ 
+-		if ( r_lightmap->integer == 2 )
+-		{	// color code by intensity as development tool	(FIXME: check range)
+-			for ( j = 0; j < LIGHTMAP_SIZE * LIGHTMAP_SIZE; j++ )
+-			{
+-				float r = buf_p[j*3+0];
+-				float g = buf_p[j*3+1];
+-				float b = buf_p[j*3+2];
+-				float intensity;
+-				float out[3] = {0.0, 0.0, 0.0};
++	image = ri.Hunk_AllocateTempMemory( lightmapWidth * lightmapHeight *
++	                                    LIGHTMAP_SIZE * LIGHTMAP_SIZE * 4 );
++	Com_Memset( image, 0, lightmapWidth * lightmapHeight *
++	            LIGHTMAP_SIZE * LIGHTMAP_SIZE * 4);
+ 
+-				intensity = 0.33f * r + 0.685f * g + 0.063f * b;
++	offs = 0;
++	for ( i = 0 ; i < tr.numLightmaps; i++ ) {
++		for ( y = 0; y < lightmapHeight; y++ ) {
++			if ( offs >= len)
++				break;
++			
++			for ( x = 0; x < lightmapWidth; x++ ) {
++				if ( offs >= len )
++					break;
++			
++				// expand the 24 bit on-disk to 32 bit
++				buf_p = buf + offs;
++				image_p = image + (y * LIGHTMAP_SIZE * lightmapWidth + x) * LIGHTMAP_SIZE * 4;
+ 
+-				if ( intensity > 255 )
+-					intensity = 1.0f;
+-				else
+-					intensity /= 255.0f;
++				if ( r_lightmap->integer == 2 )
++				{	// color code by intensity as development tool	(FIXME: check range)
++					for ( j = 0; j < LIGHTMAP_SIZE ; j++ ) {
++						for ( k = 0; k < LIGHTMAP_SIZE; k++ ) {
++							float r = buf_p[(j * LIGHTMAP_SIZE + k)*3+0];
++							float g = buf_p[(j * LIGHTMAP_SIZE + k)*3+1];
++							float b = buf_p[(j * LIGHTMAP_SIZE + k)*3+2];
++							float intensity;
++							float out[3] = {0.0, 0.0, 0.0};
+ 
+-				if ( intensity > maxIntensity )
+-					maxIntensity = intensity;
++							intensity = 0.33f * r + 0.685f * g + 0.063f * b;
+ 
+-				HSVtoRGB( intensity, 1.00, 0.50, out );
++							if ( intensity > 255 )
++								intensity = 1.0f;
++							else
++								intensity /= 255.0f;
+ 
+-				image[j*4+0] = out[0] * 255;
+-				image[j*4+1] = out[1] * 255;
+-				image[j*4+2] = out[2] * 255;
+-				image[j*4+3] = 255;
++							if ( intensity > maxIntensity )
++								maxIntensity = intensity;
+ 
+-				sumIntensity += intensity;
++							HSVtoRGB( intensity, 1.00, 0.50, out );
++
++							image_p[k*4+0] = out[0] * 255;
++							image_p[k*4+1] = out[1] * 255;
++							image_p[k*4+2] = out[2] * 255;
++							image_p[k*4+3] = 255;
++
++							sumIntensity += intensity;
++						}
++						// go to next line
++						image_p += lightmapWidth*LIGHTMAP_SIZE*4;
++					}
++				} else {
++					for ( j = 0; j < LIGHTMAP_SIZE ; j++ ) {
++						for ( k = 0; k < LIGHTMAP_SIZE; k++ ) {
++							R_ColorShiftLightingBytes( &buf_p[(j * LIGHTMAP_SIZE + k)*3], &image_p[k*4+0] );
++							image_p[k*4+3] = 255;
++						}
++						// go to next line
++						image_p += lightmapWidth*LIGHTMAP_SIZE*4;
++					}
++				}
++				if ( tr.hasDeluxemaps ) {
++					offs += LIGHTMAP_SIZE * LIGHTMAP_SIZE * 3;
++					buf_p = buf + offs;
++					image_p = image + (y * LIGHTMAP_SIZE * lightmapWidth + ++x) * LIGHTMAP_SIZE * 4;
++					
++					for ( j = 0; j < LIGHTMAP_SIZE ; j++ ) {
++						for ( k = 0; k < LIGHTMAP_SIZE; k++ ) {
++							// copy deluxemap data
++							image_p[k*4+0] = buf_p[(j * LIGHTMAP_SIZE + k)*3+0];
++							image_p[k*4+1] = buf_p[(j * LIGHTMAP_SIZE + k)*3+1];
++							image_p[k*4+2] = buf_p[(j * LIGHTMAP_SIZE + k)*3+2];
++							image_p[k*4+3] = 255;
++						}
++						// go to next line
++						image_p += lightmapWidth*LIGHTMAP_SIZE*4;
++					}
++				}
++				offs += LIGHTMAP_SIZE * LIGHTMAP_SIZE * 3;
+ 			}
+-		} else {
+-			for ( j = 0 ; j < LIGHTMAP_SIZE * LIGHTMAP_SIZE; j++ ) {
+-				R_ColorShiftLightingBytes( &buf_p[j*3], &image[j*4] );
+-				image[j*4+3] = 255;
+-			}
+ 		}
+-		tr.lightmaps[i] = R_CreateImage( va("*lightmap%d",i), image, 
+-			LIGHTMAP_SIZE, LIGHTMAP_SIZE, qfalse, qfalse, GL_CLAMP_TO_EDGE );
++		pic.format = GL_RGBA8;
++		pic.numMipmaps = 1;
++		pic.data[0] = image;
++
++		tr.lightmaps[i] = R_CreateImage( va("*lightmap%d",i), &pic, 
++						 LIGHTMAP_SIZE * lightmapWidth, LIGHTMAP_SIZE * lightmapHeight,
++						 qfalse, qfalse, GL_CLAMP_TO_EDGE );
++		ri.Printf( PRINT_DEVELOPER, "lightmaps[%i]=%i\n", i, tr.lightmaps[i]->texnum);
+ 	}
++	// dummy lightmap
++	pic.format = GL_RGBA8;
++	pic.numMipmaps = 1;
++	pic.data[0] = image;
++	tr.lightmaps[i] = R_CreateImage( va("*lightmap%d",i), &pic, 
++					 LIGHTMAP_SIZE, LIGHTMAP_SIZE,
++					 qfalse, qfalse, GL_CLAMP_TO_EDGE );
++	tr.deluxeOffset = 1.0f / lightmapWidth;
++	ri.Hunk_FreeTempMemory( image );
+ 
+ 	if ( r_lightmap->integer == 2 )	{
+-		ri.Printf( PRINT_ALL, "Brightest lightmap value: %d\n", ( int ) ( maxIntensity * 255 ) );
++		ri.Printf( PRINT_DEVELOPER, "Brightest lightmap value: %d\n", ( int ) ( maxIntensity * 255 ) );
+ 	}
+ }
+ 
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_cmds.c tremulous-ggp1-src/src/renderer/tr_cmds.c
--- tremulous-ggp1-src.p/src/renderer/tr_cmds.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_cmds.c	2012-07-19 04:25:52.031556446 +0200
@@ -53,7 +53,7 @@
 			tr.pc.c_sphere_cull_md3_in, tr.pc.c_sphere_cull_md3_clip, tr.pc.c_sphere_cull_md3_out, 
 			tr.pc.c_box_cull_md3_in, tr.pc.c_box_cull_md3_clip, tr.pc.c_box_cull_md3_out );
 	} else if (r_speeds->integer == 3) {
-		ri.Printf (PRINT_ALL, "viewcluster: %i\n", tr.viewCluster );
+		ri.Printf (PRINT_ALL, "viewcluster: %i\n", tr.viewParms.viewCluster );
 	} else if (r_speeds->integer == 4) {
 		if ( backEnd.pc.c_dlightVertexes ) {
 			ri.Printf (PRINT_ALL, "dlight srf:%i  culled:%i  verts:%i  tris:%i\n", 
@@ -265,6 +265,81 @@
 	cmd->color[3] = rgba[3];
 }
 
+
+/*
+=============
+RE_StretchRaw
+
+Stretches a raw 32 bit power of 2 bitmap image over the given screen rectangle.
+Used for cinematics.
+=============
+*/
+void RE_StretchRaw (int x, int y, int w, int h,
+		    int cols, int rows, const byte *data,
+		    int client, qboolean dirty) {
+	int			i, j;
+	int			start, end;
+	stretchRawCommand_t	*cmd;
+
+	if ( !tr.registered ) {
+		return;
+	}
+	R_SyncRenderThread();
+
+	start = end = 0;
+	if ( r_speeds->integer ) {
+		start = ri.Milliseconds();
+	}
+
+	// make sure rows and cols are powers of 2
+	for ( i = 0 ; ( 1 << i ) < cols ; i++ ) {
+	}
+	for ( j = 0 ; ( 1 << j ) < rows ; j++ ) {
+	}
+	if ( ( 1 << i ) != cols || ( 1 << j ) != rows) {
+		ri.Error (ERR_DROP, "Draw_StretchRaw: size not a power of 2: %i by %i", cols, rows);
+	}
+
+	// if the scratchImage isn't in the format we want, specify it as a new texture
+	GL_BindTexture( tr.scratchImage[client]->texnum );
+
+	if ( cols != tr.scratchImage[client]->width || rows != tr.scratchImage[client]->height ) {
+		tr.scratchImage[client]->width = tr.scratchImage[client]->uploadWidth = cols;
+		tr.scratchImage[client]->height = tr.scratchImage[client]->uploadHeight = rows;
+		qglTexImage2D( GL_TEXTURE_2D, 0, GL_RGB8, cols, rows, 0, GL_RGBA, GL_UNSIGNED_BYTE, data );
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );	
+	} else {
+		if (dirty) {
+			// otherwise, just subimage upload it so that drivers can tell we are going to be changing
+			// it and don't try and do a texture compression
+			qglTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, cols, rows, GL_RGBA, GL_UNSIGNED_BYTE, data );
+		}
+	}
+
+	if ( r_speeds->integer ) {
+		end = ri.Milliseconds();
+		ri.Printf( PRINT_ALL, "qglTexSubImage2D %i, %i: %i msec\n", cols, rows, end - start );
+	}
+
+	cmd = R_GetCommandBuffer( sizeof( *cmd ) );
+	if ( !cmd ) {
+		return;
+	}
+	cmd->commandId = RC_STRETCH_RAW;
+	cmd->client = client;
+	cmd->x = x;
+	cmd->y = y;
+	cmd->w = w;
+	cmd->h = h;
+	cmd->s1 = 0.5f / cols;
+	cmd->t1 = 0.5f / rows;
+	cmd->s2 = 1.0f - cmd->s1;
+	cmd->t2 = 1.0f - cmd->t1;
+}
+
 /*
 =============
 R_ClipRegion
@@ -437,7 +512,7 @@
 	//
 	if ( r_measureOverdraw->integer )
 	{
-		if ( glConfig.stencilBits < 4 )
+		if ( glGlobals.shadowBits < 4 )
 		{
 			ri.Printf( PRINT_ALL, "Warning: not enough stencil bits to measure overdraw: %d\n", glConfig.stencilBits );
 			ri.Cvar_Set( "r_measureOverdraw", "0" );
@@ -453,7 +528,7 @@
 		{
 			R_SyncRenderThread();
 			qglEnable( GL_STENCIL_TEST );
-			qglStencilMask( ~0U );
+			qglStencilMask( glGlobals.shadowMask );
 			qglClearStencil( 0U );
 			qglStencilFunc( GL_ALWAYS, 0U, ~0U );
 			qglStencilOp( GL_KEEP, GL_INCR, GL_INCR );
@@ -584,6 +659,11 @@
 	}
 	
 	tr.refdef.stereoFrame = stereoFrame;
+
+	// sort shaders by size of occluded area
+	if ( qglGenQueriesARB && stereoFrame != STEREO_RIGHT ) {
+		R_SortShaders( );
+	}
 }
 
 
@@ -594,9 +674,11 @@
 Returns the number of msec spent in the back end
 =============
 */
-void RE_EndFrame( int *frontEndMsec, int *backEndMsec ) {
+void RE_EndFrame( int *frontEndMsec, int *backEndMsec, int *GLMsec ) {
 	swapBuffersCommand_t	*cmd;
 
+	GL_CheckDebugLog();
+
 	if ( !tr.registered ) {
 		return;
 	}
@@ -606,7 +688,28 @@
 	}
 	cmd->commandId = RC_SWAP_BUFFERS;
 
-	R_IssueRenderCommands( qtrue );
+	if( glGlobals.timerQuery &&
+	    qglIsQueryARB( glGlobals.timerQuery ) ) {
+		GLuint available;
+		qglGetQueryObjectuivARB( glGlobals.timerQuery,
+					 GL_QUERY_RESULT_AVAILABLE_ARB,
+					 &available );
+		if( available ) {
+			qglGetQueryObjectui64vEXT( glGlobals.timerQuery,
+						   GL_QUERY_RESULT_ARB,
+						   &glGlobals.timerResult );
+			glGlobals.timerRunning = qfalse;
+		}
+	}
+
+	if( glGlobals.timerQuery && !glGlobals.timerRunning ) {
+		qglBeginQueryARB( GL_TIME_ELAPSED_EXT, glGlobals.timerQuery );
+		R_IssueRenderCommands( qtrue );
+		qglEndQueryARB( GL_TIME_ELAPSED_EXT );
+		glGlobals.timerRunning = qtrue;
+	} else {
+		R_IssueRenderCommands( qtrue );
+	}
 
 	// use the other buffers next frame, because another CPU
 	// may still be rendering into the current ones
@@ -620,6 +723,9 @@
 		*backEndMsec = backEnd.pc.msec;
 	}
 	backEnd.pc.msec = 0;
+	if ( GLMsec ) {
+		*GLMsec = glGlobals.timerResult / 1000000;
+	}
 }
 
 /*
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_curve.c tremulous-ggp1-src/src/renderer/tr_curve.c
--- tremulous-ggp1-src.p/src/renderer/tr_curve.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_curve.c	2012-07-19 04:25:52.031556446 +0200
@@ -206,7 +206,7 @@
 				count++;
 			}
 			if ( count == 0 ) {
-//printf("bad normal\n");
+//ri.Printf("bad normal\n");
 				count = 1;
 			}
 			VectorNormalize2( sum, dv->normal );
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_flares.c tremulous-ggp1-src/src/renderer/tr_flares.c
--- tremulous-ggp1-src.p/src/renderer/tr_flares.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_flares.c	2012-07-19 04:25:52.021556447 +0200
@@ -63,7 +63,7 @@
 
 	int			addedFrame;
 
-	qboolean	inPortal;				// true if in a portal view of the scene
+	int		portalLevel;				// portalLevel if in a portal view of the scene
 	int			frameSceneNum;
 	void		*surface;
 	int			fogNum;
@@ -156,7 +156,7 @@
 	oldest = r_flareStructs;
 	for ( f = r_activeFlares ; f ; f = f->next ) {
 		if ( f->surface == surface && f->frameSceneNum == backEnd.viewParms.frameSceneNum
-			&& f->inPortal == backEnd.viewParms.isPortal ) {
+			&& f->portalLevel == backEnd.viewParms.portalLevel ) {
 			break;
 		}
 	}
@@ -174,7 +174,7 @@
 
 		f->surface = surface;
 		f->frameSceneNum = backEnd.viewParms.frameSceneNum;
-		f->inPortal = backEnd.viewParms.isPortal;
+		f->portalLevel = backEnd.viewParms.portalLevel;
 		f->addedFrame = -1;
 	}
 
@@ -314,7 +314,8 @@
 	vec3_t			color;
 	int				iColor[3];
 	float distance, intensity, factor;
-	byte fogFactors[3] = {255, 255, 255};
+	color4ub_t fogFactors = {255, 255, 255, 255};
+	static GLushort indexes[6] = { 0, 1, 2, 0, 2, 3 };
 
 	backEnd.pc.c_flareRenders++;
 
@@ -354,18 +355,29 @@
 
 	VectorScale(f->color, f->drawIntensity * intensity, color);
 
-// Calculations for fogging
+	tess.numVertexes = 4;
+	tess.numIndexes  = 6;
+	RB_SetupVertexBuffer( tr.flareShader, NULL );
+	
+	// Calculations for fogging
 	if(tr.world && f->fogNum < tr.world->numfogs)
 	{
 		tess.numVertexes = 1;
-		VectorCopy(f->origin, tess.xyz[0]);
+		tess.numIndexes = 0;
+
+		VectorCopy(f->origin, tess.vertexPtr2->xyz);
 		tess.fogNum = f->fogNum;
 	
-		RB_CalcModulateColorsByFog(fogFactors);
+		RB_CalcModulateColorsByFog( &fogFactors, 1);
 		
 		// We don't need to render the flare if colors are 0 anyways.
-		if(!(fogFactors[0] || fogFactors[1] || fogFactors[2]))
+		if(!(fogFactors[0] || fogFactors[1] || fogFactors[2])) {
+			RB_FlushVertexBuffer ();
+			RB_ClearVertexBuffer ();
 			return;
+		}
+		tess.numVertexes = 4;
+		tess.numIndexes  = 6;
 	}
 
 	iColor[0] = color[0] * fogFactors[0];
@@ -375,54 +387,62 @@
 	RB_BeginSurface( tr.flareShader, f->fogNum );
 
 	// FIXME: use quadstamp?
-	tess.xyz[tess.numVertexes][0] = f->windowX - size;
-	tess.xyz[tess.numVertexes][1] = f->windowY - size;
-	tess.texCoords[tess.numVertexes][0][0] = 0;
-	tess.texCoords[tess.numVertexes][0][1] = 0;
-	tess.vertexColors[tess.numVertexes][0] = iColor[0];
-	tess.vertexColors[tess.numVertexes][1] = iColor[1];
-	tess.vertexColors[tess.numVertexes][2] = iColor[2];
-	tess.vertexColors[tess.numVertexes][3] = 255;
-	tess.numVertexes++;
-
-	tess.xyz[tess.numVertexes][0] = f->windowX - size;
-	tess.xyz[tess.numVertexes][1] = f->windowY + size;
-	tess.texCoords[tess.numVertexes][0][0] = 0;
-	tess.texCoords[tess.numVertexes][0][1] = 1;
-	tess.vertexColors[tess.numVertexes][0] = iColor[0];
-	tess.vertexColors[tess.numVertexes][1] = iColor[1];
-	tess.vertexColors[tess.numVertexes][2] = iColor[2];
-	tess.vertexColors[tess.numVertexes][3] = 255;
-	tess.numVertexes++;
-
-	tess.xyz[tess.numVertexes][0] = f->windowX + size;
-	tess.xyz[tess.numVertexes][1] = f->windowY + size;
-	tess.texCoords[tess.numVertexes][0][0] = 1;
-	tess.texCoords[tess.numVertexes][0][1] = 1;
-	tess.vertexColors[tess.numVertexes][0] = iColor[0];
-	tess.vertexColors[tess.numVertexes][1] = iColor[1];
-	tess.vertexColors[tess.numVertexes][2] = iColor[2];
-	tess.vertexColors[tess.numVertexes][3] = 255;
-	tess.numVertexes++;
-
-	tess.xyz[tess.numVertexes][0] = f->windowX + size;
-	tess.xyz[tess.numVertexes][1] = f->windowY - size;
-	tess.texCoords[tess.numVertexes][0][0] = 1;
-	tess.texCoords[tess.numVertexes][0][1] = 0;
-	tess.vertexColors[tess.numVertexes][0] = iColor[0];
-	tess.vertexColors[tess.numVertexes][1] = iColor[1];
-	tess.vertexColors[tess.numVertexes][2] = iColor[2];
-	tess.vertexColors[tess.numVertexes][3] = 255;
-	tess.numVertexes++;
-
-	tess.indexes[tess.numIndexes++] = 0;
-	tess.indexes[tess.numIndexes++] = 1;
-	tess.indexes[tess.numIndexes++] = 2;
-	tess.indexes[tess.numIndexes++] = 0;
-	tess.indexes[tess.numIndexes++] = 2;
-	tess.indexes[tess.numIndexes++] = 3;
+	tess.vertexPtr2[0].xyz[0] = f->windowX - size;
+	tess.vertexPtr2[0].xyz[1] = f->windowY - size;
+	tess.vertexPtr2[0].xyz[2] = 0.0f;
+	tess.vertexPtr2[0].fogNum = 0.0f;
+	tess.vertexPtr1[0].tc1[0] = 0.0f;
+	tess.vertexPtr1[0].tc1[1] = 0.0f;
+	tess.vertexPtr1[0].tc2[0] = 0.0f;
+	tess.vertexPtr1[0].tc2[1] = 0.0f;
+	tess.vertexPtr4[0].color[0] = iColor[0];
+	tess.vertexPtr4[0].color[1] = iColor[1];
+	tess.vertexPtr4[0].color[2] = iColor[2];
+	tess.vertexPtr4[0].color[3] = 255;
+
+	tess.vertexPtr2[1].xyz[0] = f->windowX - size;
+	tess.vertexPtr2[1].xyz[1] = f->windowY + size;
+	tess.vertexPtr2[1].xyz[2] = 0.0f;
+	tess.vertexPtr2[1].fogNum = 0.0f;
+	tess.vertexPtr1[1].tc1[0] = 0.0f;
+	tess.vertexPtr1[1].tc1[1] = 1.0f;
+	tess.vertexPtr1[1].tc2[0] = 0.0f;
+	tess.vertexPtr1[1].tc2[1] = 1.0f;
+	tess.vertexPtr4[1].color[0] = iColor[0];
+	tess.vertexPtr4[1].color[1] = iColor[1];
+	tess.vertexPtr4[1].color[2] = iColor[2];
+	tess.vertexPtr4[1].color[3] = 255;
+
+	tess.vertexPtr2[2].xyz[0] = f->windowX + size;
+	tess.vertexPtr2[2].xyz[1] = f->windowY + size;
+	tess.vertexPtr2[2].xyz[2] = 0.0f;
+	tess.vertexPtr2[2].fogNum = 0.0f;
+	tess.vertexPtr1[2].tc1[0] = 1.0f;
+	tess.vertexPtr1[2].tc1[1] = 1.0f;
+	tess.vertexPtr1[2].tc2[0] = 1.0f;
+	tess.vertexPtr1[2].tc2[1] = 1.0f;
+	tess.vertexPtr4[2].color[0] = iColor[0];
+	tess.vertexPtr4[2].color[1] = iColor[1];
+	tess.vertexPtr4[2].color[2] = iColor[2];
+	tess.vertexPtr4[2].color[3] = 255;
+
+	tess.vertexPtr2[3].xyz[0] = f->windowX + size;
+	tess.vertexPtr2[3].xyz[1] = f->windowY - size;
+	tess.vertexPtr2[3].xyz[2] = 0.0f;
+	tess.vertexPtr2[3].fogNum = 0.0f;
+	tess.vertexPtr1[3].tc1[0] = 1.0f;
+	tess.vertexPtr1[3].tc1[1] = 0.0f;
+	tess.vertexPtr1[3].tc2[0] = 1.0f;
+	tess.vertexPtr1[3].tc2[1] = 0.0f;
+	tess.vertexPtr4[3].color[0] = iColor[0];
+	tess.vertexPtr4[3].color[1] = iColor[1];
+	tess.vertexPtr4[3].color[2] = iColor[2];
+	tess.vertexPtr4[3].color[3] = 255;
+
+	Com_Memcpy( tess.indexPtr.p16, indexes, 6 * sizeof(GLushort) );
 
 	RB_EndSurface();
+	RB_ClearVertexBuffer();
 }
 
 /*
@@ -482,7 +502,7 @@
 		// don't draw any here that aren't from this scene / portal
 		f->drawIntensity = 0;
 		if ( f->frameSceneNum == backEnd.viewParms.frameSceneNum
-			&& f->inPortal == backEnd.viewParms.isPortal ) {
+			&& f->portalLevel == backEnd.viewParms.portalLevel ) {
 			RB_TestFlare( f );
 			if ( f->drawIntensity ) {
 				draw = qtrue;
@@ -502,10 +522,6 @@
 		return;		// none visible
 	}
 
-	if ( backEnd.viewParms.isPortal ) {
-		qglDisable (GL_CLIP_PLANE0);
-	}
-
 	qglPushMatrix();
     qglLoadIdentity();
 	qglMatrixMode( GL_PROJECTION );
@@ -517,7 +533,7 @@
 
 	for ( f = r_activeFlares ; f ; f = f->next ) {
 		if ( f->frameSceneNum == backEnd.viewParms.frameSceneNum
-			&& f->inPortal == backEnd.viewParms.isPortal
+			&& f->portalLevel == backEnd.viewParms.portalLevel
 			&& f->drawIntensity ) {
 			RB_RenderFlare( f );
 		}
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_font.c tremulous-ggp1-src/src/renderer/tr_font.c
--- tremulous-ggp1-src.p/src/renderer/tr_font.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_font.c	2012-07-19 04:25:52.021556447 +0200
@@ -117,14 +117,14 @@
   if ( glyph->format == ft_glyph_format_outline ) {
     size   = pitch*height; 
 
-    bit2 = Z_Malloc(sizeof(FT_Bitmap));
+    bit2 = ri.Malloc(sizeof(FT_Bitmap));
 
     bit2->width      = width;
     bit2->rows       = height;
     bit2->pitch      = pitch;
     bit2->pixel_mode = ft_pixel_mode_grays;
     //bit2->pixel_mode = ft_pixel_mode_mono;
-    bit2->buffer     = Z_Malloc(pitch*height);
+    bit2->buffer     = ri.Malloc(pitch*height);
     bit2->num_grays = 256;
 
     Com_Memset( bit2->buffer, 0, size );
@@ -150,7 +150,7 @@
 	byte	*buffer;
 	int		i, c;
 
-	buffer = Z_Malloc(width*height*4 + 18);
+	buffer = ri.Malloc(width*height*4 + 18);
 	Com_Memset (buffer, 0, 18);
 	buffer[2] = 2;		// uncompressed type
 	buffer[12] = width&255;
@@ -175,7 +175,7 @@
 	//fwrite (buffer, 1, c, f);
 	//fclose (f);
 
-	Z_Free (buffer);
+	ri.Free (buffer);
 }
 
 static glyphInfo_t *RE_ConstructGlyphInfo(unsigned char *imageOut, int *xOut, int *yOut, int *maxHeight, FT_Face face, const unsigned char c, qboolean calcHeight) {
@@ -201,8 +201,8 @@
     }
 
     if (calcHeight) {
-      Z_Free(bitmap->buffer);
-      Z_Free(bitmap);
+      ri.Free(bitmap->buffer);
+      ri.Free(bitmap);
       return &glyph;
     }
 
@@ -223,8 +223,8 @@
       if (*yOut + *maxHeight + 1 >= 255) {
         *yOut = -1;
         *xOut = -1;
-        Z_Free(bitmap->buffer);
-        Z_Free(bitmap);
+        ri.Free(bitmap->buffer);
+        ri.Free(bitmap);
         return &glyph;
       } else {
         *xOut = 0;
@@ -233,8 +233,8 @@
     } else if (*yOut + *maxHeight + 1 >= 255) {
       *yOut = -1;
       *xOut = -1;
-      Z_Free(bitmap->buffer);
-      Z_Free(bitmap);
+      ri.Free(bitmap->buffer);
+      ri.Free(bitmap);
       return &glyph;
     }
 
@@ -289,8 +289,8 @@
     *xOut += scaled_width + 1;
   }
 
-  Z_Free(bitmap->buffer);
-  Z_Free(bitmap);
+  ri.Free(bitmap->buffer);
+  ri.Free(bitmap);
 
   return &glyph;
 }
@@ -333,6 +333,7 @@
   int j, k, xOut, yOut, lastStart, imageNumber;
   int scaledSize, newSize, maxHeight, left, satLevels;
   unsigned char *out, *imageBuff;
+  texImage_t	pic;
   glyphInfo_t *glyph;
   image_t *image;
   qhandle_t h;
@@ -436,9 +437,9 @@
   // make a 256x256 image buffer, once it is full, register it, clean it and keep going 
   // until all glyphs are rendered
 
-  out = Z_Malloc(1024*1024);
+  out = ri.Malloc(1024*1024);
   if (out == NULL) {
-    ri.Printf(PRINT_ALL, "RE_RegisterFont: Z_Malloc failure during output image creation.\n");
+    ri.Printf(PRINT_ALL, "RE_RegisterFont: Malloc failure during output image creation.\n");
     return;
   }
   Com_Memset(out, 0, 1024*1024);
@@ -466,7 +467,7 @@
 
       scaledSize = 256*256;
       newSize = scaledSize * 4;
-      imageBuff = Z_Malloc(newSize);
+      imageBuff = ri.Malloc(newSize);
       left = 0;
       max = 0;
       satLevels = 255;
@@ -494,8 +495,13 @@
 			}
 
     	//Com_sprintf (name, sizeof(name), "fonts/fontImage_%i_%i", imageNumber++, pointSize);
-      image = R_CreateImage(name, imageBuff, 256, 256, qfalse, qfalse, GL_CLAMP_TO_EDGE);
-      h = RE_RegisterShaderFromImage(name, LIGHTMAP_2D, image, qfalse);
+	pic.format = GL_RGBA8;
+	pic.numMipmaps = 1;
+	pic.data[0] = imageBuff;
+
+	image = R_CreateImage(name, &pic, 256, 256, qfalse, qfalse, GL_CLAMP_TO_EDGE);
+	h = RE_RegisterShaderFromImage(name, LIGHTMAP_2D, image, qfalse);
+
       for (j = lastStart; j < i; j++) {
         font->glyphs[j].glyph = h;
 				Q_strncpyz(font->glyphs[j].shaderName, name, sizeof(font->glyphs[j].shaderName));
@@ -504,7 +510,7 @@
 		  Com_Memset(out, 0, 1024*1024);
       xOut = 0;
       yOut = 0;
-      Z_Free(imageBuff);
+      ri.Free(imageBuff);
 			i++;
     } else {
       Com_Memcpy(&font->glyphs[i], glyph, sizeof(glyphInfo_t));
@@ -520,7 +526,7 @@
 		ri.FS_WriteFile(va("fonts/fontImage_%i.dat", pointSize), font, sizeof(fontInfo_t));
 	}
 
-  Z_Free(out);
+  ri.Free(out);
   
   ri.FS_FreeFile(faceData);
 #endif
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_image_bmp.c tremulous-ggp1-src/src/renderer/tr_image_bmp.c
--- tremulous-ggp1-src.p/src/renderer/tr_image_bmp.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_image_bmp.c	2012-07-19 04:25:52.021556447 +0200
@@ -43,7 +43,7 @@
 	unsigned char palette[256][4];
 } BMPHeader_t;
 
-void R_LoadBMP( const char *name, byte **pic, int *width, int *height )
+void R_LoadBMP( const char *name, texImage_t *pic, int *width, int *height )
 {
 	int		columns, rows;
 	unsigned	numPixels;
@@ -59,7 +59,7 @@
 	BMPHeader_t bmpHeader;
 	byte		*bmpRGBA;
 
-	*pic = NULL;
+	pic->numMipmaps = 0;
 
 	if(width)
 		*width = 0;
@@ -181,8 +181,9 @@
 		*height = rows;
 
 	bmpRGBA = ri.Malloc( numPixels * 4 );
-	*pic = bmpRGBA;
-
+	pic->format = GL_RGBA8;
+	pic->numMipmaps = 1;
+	pic->data[0] = bmpRGBA;
 
 	for ( row = rows-1; row >= 0; row-- )
 	{
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_image.c tremulous-ggp1-src/src/renderer/tr_image.c
--- tremulous-ggp1-src.p/src/renderer/tr_image.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_image.c	2012-07-19 04:25:52.031556446 +0200
@@ -115,7 +115,7 @@
 	for ( i = 0 ; i < tr.numImages ; i++ ) {
 		glt = tr.images[ i ];
 		if ( glt->mipmap ) {
-			GL_Bind (glt);
+			GL_BindTexture ( glt->texnum );
 			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
 			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
 		}
@@ -230,10 +230,10 @@
 before or after.
 ================
 */
-static void ResampleTexture( unsigned *in, int inwidth, int inheight, unsigned *out,  
-							int outwidth, int outheight ) {
+static void ResampleTexture( byte *in, int inwidth, int inheight,
+			     byte *out, int outwidth, int outheight ) {
 	int		i, j;
-	unsigned	*inrow, *inrow2;
+	byte		*inrow, *inrow2;
 	unsigned	frac, fracstep;
 	unsigned	p1[2048], p2[2048];
 	byte		*pix1, *pix2, *pix3, *pix4;
@@ -254,19 +254,19 @@
 		frac += fracstep;
 	}
 
-	for (i=0 ; i<outheight ; i++, out += outwidth) {
-		inrow = in + inwidth*(int)((i+0.25)*inheight/outheight);
-		inrow2 = in + inwidth*(int)((i+0.75)*inheight/outheight);
+	for (i=0 ; i<outheight ; i++, out += 4*outwidth) {
+		inrow = in + 4*inwidth*(int)((i+0.25)*inheight/outheight);
+		inrow2 = in + 4*inwidth*(int)((i+0.75)*inheight/outheight);
 		frac = fracstep >> 1;
 		for (j=0 ; j<outwidth ; j++) {
-			pix1 = (byte *)inrow + p1[j];
-			pix2 = (byte *)inrow + p2[j];
-			pix3 = (byte *)inrow2 + p1[j];
-			pix4 = (byte *)inrow2 + p2[j];
-			((byte *)(out+j))[0] = (pix1[0] + pix2[0] + pix3[0] + pix4[0])>>2;
-			((byte *)(out+j))[1] = (pix1[1] + pix2[1] + pix3[1] + pix4[1])>>2;
-			((byte *)(out+j))[2] = (pix1[2] + pix2[2] + pix3[2] + pix4[2])>>2;
-			((byte *)(out+j))[3] = (pix1[3] + pix2[3] + pix3[3] + pix4[3])>>2;
+			pix1 = inrow + p1[j];
+			pix2 = inrow + p2[j];
+			pix3 = inrow2 + p1[j];
+			pix4 = inrow2 + p2[j];
+			out[4*j+0] = (pix1[0] + pix2[0] + pix3[0] + pix4[0])>>2;
+			out[4*j+1] = (pix1[1] + pix2[1] + pix3[1] + pix4[1])>>2;
+			out[4*j+2] = (pix1[2] + pix2[2] + pix3[2] + pix4[2])>>2;
+			out[4*j+3] = (pix1[3] + pix2[3] + pix3[3] + pix4[3])>>2;
 		}
 	}
 }
@@ -279,16 +279,16 @@
 lighting range
 ================
 */
-void R_LightScaleTexture (unsigned *in, int inwidth, int inheight, qboolean only_gamma )
+void R_LightScaleTexture (byte *in, int inwidth, int inheight, qboolean only_gamma )
 {
 	if ( only_gamma )
 	{
 		if ( !glConfig.deviceSupportsGamma )
 		{
-			int		i, c;
+			int	i, c;
 			byte	*p;
 
-			p = (byte *)in;
+			p = in;
 
 			c = inwidth*inheight;
 			for (i=0 ; i<c ; i++, p+=4)
@@ -301,10 +301,10 @@
 	}
 	else
 	{
-		int		i, c;
+		int	i, c;
 		byte	*p;
 
-		p = (byte *)in;
+		p = in;
 
 		c = inwidth*inheight;
 
@@ -397,6 +397,7 @@
 	int		i, j;
 	byte	*out;
 	int		row;
+	int	w0, w1, w2, w3, w4, w5;
 
 	if ( !r_simpleMipMaps->integer ) {
 		R_MipMap2( (unsigned *)in, width, height );
@@ -409,31 +410,210 @@
 
 	row = width * 4;
 	out = in;
+
+	if( width == 1 ) {
+		if( height == 1 ) {
+			return;
+		} else if( height & 1 ) {
+			height >>= 1;
+			for( i = 0; i < height; i++, out+=4, in+=8 ) {
+				w0 = (height - i) * 0x10000 / (2*height+1);
+				w1 = height       * 0x10000 / (2*height+1);
+				w2 = 0x10000 - w0 - w1;
+				out[0] = (w0 * in[0] + w1 * in[4] + w2 * in[ 8]) >> 16;
+				out[1] = (w0 * in[1] + w1 * in[5] + w2 * in[ 9]) >> 16;
+				out[2] = (w0 * in[2] + w1 * in[6] + w2 * in[10]) >> 16;
+				out[3] = (w0 * in[3] + w1 * in[7] + w2 * in[11]) >> 16;
+			}
+		} else {
+			height >>= 1;
+			for( i = 0; i < height; i++, out+=4, in+=8 ) {
+				out[0] = (in[0] + in[4]) >> 1;
+				out[1] = (in[1] + in[5]) >> 1;
+				out[2] = (in[2] + in[6]) >> 1;
+				out[3] = (in[3] + in[7]) >> 1;
+			}
+		}
+	} else if( width & 1 ) {
+		width >>= 1;
+		if( height == 1 ) {
+			for( j = 0; j < width; j++, out+=4, in+=8 ) {
+				w0 = (width - j) * 0x10000 / (2*width+1);
+				w1 = width       * 0x10000 / (2*width+1);
+				w2 = 0x10000 - w0 - w1;
+				out[0] = (w0 * in[0] + w1 * in[4] + w2 * in[ 8]) >> 16;
+				out[1] = (w0 * in[1] + w1 * in[5] + w2 * in[ 9]) >> 16;
+				out[2] = (w0 * in[2] + w1 * in[6] + w2 * in[10]) >> 16;
+				out[3] = (w0 * in[3] + w1 * in[7] + w2 * in[11]) >> 16;
+			}
+		} else if( height & 1 ) {
+			height >>= 1;
+			for (i=0 ; i<height ; i++, in+=row+4) {
+				w0 = (height - i) * 0x100 / (2*height+1);
+				w1 = height       * 0x100 / (2*height+1);
+				w2 = 0x100 - w0 - w1;
+				for (j=0 ; j<width ; j++, out+=4, in+=8) {
+					w3 = (width - j) * 0x100 / (2*width+1);
+					w4 = width       * 0x100 / (2*width+1);
+					w5 = 0x100 - w3 - w4;
+					out[0] = (w0 * w3 * in[      0] + w0 * w4 * in[      4] + w0 * w5 * in[       8] +
+						  w1 * w3 * in[  row+0] + w1 * w4 * in[  row+4] + w1 * w5 * in[  row+ 8] +
+						  w2 * w3 * in[2*row+0] + w2 * w4 * in[2*row+4] + w2 * w5 * in[2*row+ 8]) >> 16;
+					out[1] = (w0 * w3 * in[      1] + w0 * w4 * in[      5] + w0 * w5 * in[       9] +
+						  w1 * w3 * in[  row+1] + w1 * w4 * in[  row+5] + w1 * w5 * in[  row+ 9] +
+						  w2 * w3 * in[2*row+1] + w2 * w4 * in[2*row+5] + w2 * w5 * in[2*row+ 9]) >> 16;
+					out[2] = (w0 * w3 * in[      2] + w0 * w4 * in[      6] + w0 * w5 * in[      10] +
+						  w1 * w3 * in[  row+2] + w1 * w4 * in[  row+6] + w1 * w5 * in[  row+10] +
+						  w2 * w3 * in[2*row+2] + w2 * w4 * in[2*row+6] + w2 * w5 * in[2*row+10]) >> 16;
+					out[3] = (w0 * w3 * in[      3] + w0 * w4 * in[      7] + w0 * w5 * in[      11] +
+						  w1 * w3 * in[  row+3] + w1 * w4 * in[  row+7] + w1 * w5 * in[  row+11] +
+						  w2 * w3 * in[2*row+3] + w2 * w4 * in[2*row+7] + w2 * w5 * in[2*row+11]) >> 16;
+				}
+			}
+		} else {
+			height >>= 1;
+			for (i=0 ; i<height ; i++, in+=row) {
+				for (j=0 ; j<width ; j++, out+=4, in+=8) {
+					w0 = (width - j) * 0x10000 / (2*width+1);
+					w1 = width       * 0x10000 / (2*width+1);
+					w2 = 0x10000 - w0 - w1;
+					out[0] = (w0 * (in[0] + in[row+0]) + w1 * (in[4] + in[row+4]) + w2 * (in[ 8] + in[row+ 8]))>>17;
+					out[1] = (w0 * (in[1] + in[row+1]) + w1 * (in[5] + in[row+5]) + w2 * (in[ 9] + in[row+ 9]))>>17;
+					out[2] = (w0 * (in[2] + in[row+2]) + w1 * (in[6] + in[row+6]) + w2 * (in[10] + in[row+10]))>>17;
+					out[3] = (w0 * (in[3] + in[row+3]) + w1 * (in[7] + in[row+7]) + w2 * (in[11] + in[row+11]))>>17;
+				}
+			}
+		}
+	} else {
+		width >>= 1;
+		if( height == 1 ) {
+			for( j = 0; j < width; j++, out+=4, in+=8 ) {
+				out[0] = (in[0] + in[4]) >> 1;
+				out[1] = (in[1] + in[5]) >> 1;
+				out[2] = (in[2] + in[6]) >> 1;
+				out[3] = (in[3] + in[7]) >> 1;
+			}
+		} else if( height & 1 ) {
+			height >>= 1;
+			for (i=0 ; i<height ; i++, in+=row) {
+				w0 = (height - i) * 0x10000 / (2*height+1);
+				w1 = height       * 0x10000 / (2*height+1);
+				w2 = 0x10000 - w0 - w1;
+				for (j=0 ; j<width ; j++, out+=4, in+=8) {
+					out[0] = (w0 * (in[0] + in[4]) + w1 * (in[row+0] + in[row+4]) + w2 * (in[2*row+0] + in[2*row+4]))>>17;
+					out[1] = (w0 * (in[1] + in[5]) + w1 * (in[row+1] + in[row+5]) + w2 * (in[2*row+1] + in[2*row+5]))>>17;
+					out[2] = (w0 * (in[2] + in[6]) + w1 * (in[row+2] + in[row+6]) + w2 * (in[2*row+2] + in[2*row+6]))>>17;
+					out[3] = (w0 * (in[3] + in[7]) + w1 * (in[row+3] + in[row+7]) + w2 * (in[2*row+3] + in[2*row+7]))>>17;
+				}
+			}
+		} else {
+			height >>= 1;
+			for (i=0 ; i<height ; i++, in+=row) {
+				for (j=0 ; j<width ; j++, out+=4, in+=8) {
+					out[0] = (in[0] + in[4] + in[row+0] + in[row+4])>>2;
+					out[1] = (in[1] + in[5] + in[row+1] + in[row+5])>>2;
+					out[2] = (in[2] + in[6] + in[row+2] + in[row+6])>>2;
+					out[3] = (in[3] + in[7] + in[row+3] + in[row+7])>>2;
+				}
+			}
+		}
+	}
+}
+
+
+/*
+================
+R_MipMapHeightMap
+
+Operates in place, quartering the size of the texture
+The red & green and blue channels are set the the x, y and z of the
+average normal and the alpha channel is the max or average height.
+================
+*/
+static byte avg(byte a, byte b) { return (a+b) >> 1; }
+static byte avg4(byte a, byte b, byte c, byte d) { return (a+b+c+d) >> 2; }
+static void R_MipMapHeightMap (byte *in, int width, int height) {
+	int	i, j;
+	byte	*out;
+	int	row;
+	vec3_t  normal, normalSum;
+
+	if ( width == 1 && height == 1 ) {
+		return;
+	}
+
+	row = width * 4;
+	out = in;
 	width >>= 1;
 	height >>= 1;
 
 	if ( width == 0 || height == 0 ) {
 		width += height;	// get largest
 		for (i=0 ; i<width ; i++, out+=4, in+=8 ) {
-			out[0] = ( in[0] + in[4] )>>1;
-			out[1] = ( in[1] + in[5] )>>1;
-			out[2] = ( in[2] + in[6] )>>1;
-			out[3] = ( in[3] + in[7] )>>1;
+			VectorClear( normalSum );
+
+			normal[0] = in[0] * 1.0f/127.5f - 1.0f;
+			normal[1] = in[1] * 1.0f/127.5f - 1.0f;
+			normal[2] = 1.0f - normal[0]*normal[0] - normal[1]*normal[1];
+			normal[2] *= Q_rsqrt(normal[2]);
+			VectorAdd( normal, normalSum, normalSum );
+
+			normal[0] = in[4] * 1.0f/127.5f - 1.0f;
+			normal[1] = in[5] * 1.0f/127.5f - 1.0f;
+			normal[2] = 1.0f - normal[0]*normal[0] - normal[1]*normal[1];
+			normal[2] *= Q_rsqrt(normal[2]);
+			VectorAdd( normal, normalSum, normalSum );
+
+			VectorNormalizeFast( normalSum );
+			out[0] = (normalSum[0] + 1.0f) * 127.5f;
+			out[1] = (normalSum[1] + 1.0f) * 127.5f;
+			out[2] = (normalSum[2] + 1.0f) * 127.5f;
+			
+			out[3] = avg( in[3], in[7] );
 		}
 		return;
 	}
 
 	for (i=0 ; i<height ; i++, in+=row) {
 		for (j=0 ; j<width ; j++, out+=4, in+=8) {
-			out[0] = (in[0] + in[4] + in[row+0] + in[row+4])>>2;
-			out[1] = (in[1] + in[5] + in[row+1] + in[row+5])>>2;
-			out[2] = (in[2] + in[6] + in[row+2] + in[row+6])>>2;
-			out[3] = (in[3] + in[7] + in[row+3] + in[row+7])>>2;
+			VectorClear( normalSum );
+
+			normal[0] = in[0] * 1.0f/127.5f - 1.0f;
+			normal[1] = in[1] * 1.0f/127.5f - 1.0f;
+			normal[2] = 1.0f - normal[0]*normal[0] - normal[1]*normal[1];
+			normal[2] *= Q_rsqrt(normal[2]);
+			VectorAdd( normal, normalSum, normalSum );
+
+			normal[0] = in[4] * 1.0f/127.5f - 1.0f;
+			normal[1] = in[5] * 1.0f/127.5f - 1.0f;
+			normal[2] = 1.0f - normal[0]*normal[0] - normal[1]*normal[1];
+			normal[2] *= Q_rsqrt(normal[2]);
+			VectorAdd( normal, normalSum, normalSum );
+
+			normal[0] = in[row+0] * 1.0f/127.5f - 1.0f;
+			normal[1] = in[row+1] * 1.0f/127.5f - 1.0f;
+			normal[2] = 1.0f - normal[0]*normal[0] - normal[1]*normal[1];
+			normal[2] *= Q_rsqrt(normal[2]);
+			VectorAdd( normal, normalSum, normalSum );
+
+			normal[0] = in[row+4] * 1.0f/127.5f - 1.0f;
+			normal[1] = in[row+5] * 1.0f/127.5f - 1.0f;
+			normal[2] = 1.0f - normal[0]*normal[0] - normal[1]*normal[1];
+			normal[2] *= Q_rsqrt(normal[2]);
+			VectorAdd( normal, normalSum, normalSum );
+
+			VectorNormalizeFast( normalSum );
+			out[0] = (normalSum[0] + 1.0f) * 127.5f;
+			out[1] = (normalSum[1] + 1.0f) * 127.5f;
+			out[2] = (normalSum[2] + 1.0f) * 127.5f;
+
+			out[3] = avg4( in[3], in[7],
+				       in[row+3], in[row+7] );
 		}
 	}
+	return;
 }
 
-
 /*
 ==================
 R_BlendOverTexture
@@ -649,12 +829,13 @@
 		}
 		else if ( samples == 4 )
 		{
-			if(r_greyscale->integer)
+			*hasAlpha = qtrue;
+			if( r_greyscale->integer || !hasColor )
 			{
 				if(r_texturebits->integer == 16)
 					internalFormat = GL_LUMINANCE8_ALPHA8;
 				else if(r_texturebits->integer == 32)
-					internalFormat = GL_LUMINANCE16_ALPHA16;
+					internalFormat = GL_LUMINANCE8_ALPHA8;
 				else
 					internalFormat = GL_LUMINANCE_ALPHA;
 			}
@@ -676,69 +857,59 @@
 		}
 	}
 
-	// copy or resample data as appropriate for first MIP level
-	if ( ( scaled_width == width ) && 
-		( scaled_height == height ) ) {
-		if (!mipmap)
-		{
-			qglTexImage2D (GL_TEXTURE_2D, 0, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
-			*pUploadWidth = scaled_width;
-			*pUploadHeight = scaled_height;
-			*format = internalFormat;
+	w = width; h = height;
 
-			goto done;
-		}
-		Com_Memcpy (scaledBuffer, data, width*height*4);
-	}
-	else
-	{
-		// use the normal mip-mapping function to go down from here
-		while ( width > scaled_width || height > scaled_height ) {
-			R_MipMap( (byte *)data, width, height );
-			width >>= 1;
-			height >>= 1;
-			if ( width < 1 ) {
-				width = 1;
-			}
-			if ( height < 1 ) {
-				height = 1;
-			}
-		}
-		Com_Memcpy( scaledBuffer, data, width * height * 4 );
-	}
-
-	R_LightScaleTexture (scaledBuffer, scaled_width, scaled_height, !mipmap );
+	// there may be base_level unused levels, but we need the
+	// data for mipmapping
+	for( i = 0; i <= max_level; i++ ) {
+		if( i == 0 ) {
+			// data pointer is already set up
+		} else if( i < pic->numMipmaps ) {
+			// mipmap provided by image loader
+			data = pic->data[i];
 
-	*pUploadWidth = scaled_width;
-	*pUploadHeight = scaled_height;
-	*format = internalFormat;
+			if( w > 1 ) w >>= 1;
+			if( h > 1 ) h >>= 1;
+		} else {
+			// compute mipmaps inplace
+			R_MipMap( data, w, h );
 
-	qglTexImage2D (GL_TEXTURE_2D, 0, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
+			if( w > 1 ) w >>= 1;
+			if( h > 1 ) h >>= 1;
+		}
 
-	if (mipmap)
-	{
-		int		miplevel;
+		if( i >= base_level ) {
+			if( !compressed ) {
+				R_LightScaleTexture (data, w, h, !mipmap );
+				if ( r_colorMipLevels->integer ) {
+					R_BlendOverTexture( data, w * h,
+							    mipBlendColors[i - base_level] );
+				}
+				qglTexImage2D (GL_TEXTURE_2D, i - base_level,
+					       internalFormat, w, h, 0,
+					       GL_RGBA, GL_UNSIGNED_BYTE, data);
+			} else {
+				qglCompressedTexImage2DARB( GL_TEXTURE_2D, i - base_level,
+							    internalFormat, w, h, 0,
+							    pic->size[i], data );
+			}
+		}
 
-		miplevel = 0;
-		while (scaled_width > 1 || scaled_height > 1)
-		{
-			R_MipMap( (byte *)scaledBuffer, scaled_width, scaled_height );
-			scaled_width >>= 1;
-			scaled_height >>= 1;
-			if (scaled_width < 1)
-				scaled_width = 1;
-			if (scaled_height < 1)
-				scaled_height = 1;
-			miplevel++;
+		if( i == base_level ) {
+			*pUploadWidth = w;
+			*pUploadHeight = h;
+			*format = internalFormat;
+			*maxMipLevel = max_level - base_level;
 
-			if ( r_colorMipLevels->integer ) {
-				R_BlendOverTexture( (byte *)scaledBuffer, scaled_width * scaled_height, mipBlendColors[miplevel] );
+			if( qglGenerateMipmap &&
+			    pic->numMipmaps <= base_level + 1 &&
+			    !r_colorMipLevels->integer ) {
+				// use automatic mipmap generation
+				qglGenerateMipmap( GL_TEXTURE_2D );
+				break;
 			}
-
-			qglTexImage2D (GL_TEXTURE_2D, miplevel, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
 		}
 	}
-done:
 
 	if (mipmap)
 	{
@@ -760,6 +931,232 @@
 
 	GL_CheckErrors();
 
+	if ( resampledBuffer )
+		ri.Hunk_FreeTempMemory( resampledBuffer );
+	if( uncompressedBuffer )
+		ri.Hunk_FreeTempMemory( uncompressedBuffer );
+}
+
+
+/*
+================
+R_BuildMaxPyramid
+
+Operates in place, computes a max pyramid in the blue channel.
+================
+*/
+static ID_INLINE byte max(byte a, byte b) { return (a >= b) ? a : b; }
+static void R_BuildMaxPyramid (byte *in, int width, int height) {
+	int	i, j;
+	int	row, stepIn, stepOut;
+
+	if ( width == 1 && height == 1 ) {
+		in[2] = in[3]; // single texel is automatically max
+		return;
+	}
+
+	row = width * 4;
+
+	if ( width == 0 || height == 0 ) {
+		return;
+	}
+
+	for( i = 0; i < height; i++ )
+		for( j = 0; j < width; j++ )
+			in[i * row + j * 4 + 2] = 0;
+
+	// build first level from alpha
+	stepIn = 1;
+	stepOut = 2;
+	
+	for( i = stepIn - 1; i < height; i += stepOut ) {
+		for( j=stepIn - 1; j < width; j += stepOut ) {
+			byte maximum = in[i * row + j * 4 + 3];
+			maximum = max(maximum, in[i * row + (j+stepIn) * 4 + 3]);
+			maximum = max(maximum, in[(i+stepIn) * row + j * 4 + 3]);
+			maximum = max(maximum, in[(i+stepIn) * row + (j+stepIn) * 4 + 3]);
+			in[i * row + j * 4 + 2] = maximum;
+		}
+	}
+	// build higher levels from computed max's in blue
+	stepIn = 1;
+	stepOut = 4;
+	while(stepOut <= width || stepOut <= height) {
+		for( i = 2*stepIn - 1; i < height; i += stepOut ) {
+			for( j = 2*stepIn - 1; j < width; j += stepOut ) {
+				byte maximum = in[(i-stepIn) * row + (j-stepIn) * 4 + 2];
+				maximum = max(maximum, in[(i-stepIn) * row + (j+stepIn) * 4 + 2]);
+				maximum = max(maximum, in[(i+stepIn) * row + (j-stepIn) * 4 + 2]);
+				maximum = max(maximum, in[(i+stepIn) * row + (j+stepIn) * 4 + 2]);
+				in[i * row + j * 4 + 2] = maximum;
+
+			}
+		}
+		stepIn *= 2;
+		stepOut *= 2;
+	}
+	return;
+}
+
+
+/*
+===============
+UploadHeightMap
+
+Upload a normal/height texture with all required mipmaps
+===============
+*/
+static void UploadHeightMap( texImage_t *pic,
+			     int width, int height, 
+			     qboolean picmip, 
+			     int *format, 
+			     int *pUploadWidth, int *pUploadHeight,
+			     int *maxMipLevel )
+{
+	byte		*data = pic->data[0];
+	byte		*scaledBuffer = NULL;
+	byte		*resampledBuffer = NULL;
+	int		scaled_width, scaled_height;
+	int		i, c;
+	byte		*scan;
+	GLenum		internalFormat = GL_RGB;
+	int		miplevel;
+	float		hMax = 0;
+	qboolean	skip;
+
+	//
+	// convert to exact power of 2 sizes
+	//
+	for (scaled_width = 1 ; scaled_width < width ; scaled_width<<=1)
+		;
+	for (scaled_height = 1 ; scaled_height < height ; scaled_height<<=1)
+		;
+	if ( r_roundImagesDown->integer && scaled_width > width )
+		scaled_width >>= 1;
+	if ( r_roundImagesDown->integer && scaled_height > height )
+		scaled_height >>= 1;
+
+	if ( scaled_width != width || scaled_height != height ) {
+		resampledBuffer = ri.Hunk_AllocateTempMemory( scaled_width * scaled_height * 4 );
+		ResampleTexture (data, width, height, resampledBuffer, scaled_width, scaled_height);
+		data = resampledBuffer;
+
+		width = scaled_width;
+		height = scaled_height;
+	}
+
+	//
+	// perform optional picmip operation
+	//
+	if ( picmip ) {
+		scaled_width >>= r_picmip->integer;
+		scaled_height >>= r_picmip->integer;
+	}
+
+	//
+	// clamp to minimum size
+	//
+	if (scaled_width < 1) {
+		scaled_width = 1;
+	}
+	if (scaled_height < 1) {
+		scaled_height = 1;
+	}
+
+	//
+	// clamp to the current upper OpenGL limit
+	// scale both axis down equally so we don't have to
+	// deal with a half mip resampling
+	//
+	while ( scaled_width > glConfig.maxTextureSize
+		|| scaled_height > glConfig.maxTextureSize ) {
+		scaled_width >>= 1;
+		scaled_height >>= 1;
+	}
+	// calculate maxMipLevel for this texture
+	for( i = 1, *maxMipLevel = 0; i < scaled_width || i < scaled_height;
+	     i <<= 1, (*maxMipLevel)++);
+
+	scaledBuffer = ri.Hunk_AllocateTempMemory( sizeof( unsigned ) * scaled_width * scaled_height );
+
+	// select proper internal format
+	internalFormat = GL_RGBA8;
+	skip = qfalse;
+
+	// copy or resample data as appropriate for first MIP level
+	// use the normal mip-mapping function to go down from here
+	while ( width > scaled_width || height > scaled_height ) {
+		R_MipMapHeightMap( (byte *)data, width, height );
+		width >>= 1;
+		height >>= 1;
+		if ( width < 1 ) {
+			width = 1;
+		}
+		if ( height < 1 ) {
+			height = 1;
+		}
+	}
+	Com_Memcpy( scaledBuffer, data, width * height * 4 );
+
+	//
+	// scan the texture for maximum height values and increase
+	// height values so that the maximum is 255.
+	//
+	c = scaled_width * scaled_height;
+	scan = ((byte *)scaledBuffer);
+
+	for ( i = 0; i < c; i++ )
+	{
+		if ( scan[i*4+3] > hMax ) 
+		{
+			hMax = scan[i*4+3];
+		}
+	}
+	if( hMax < 255 ) {
+		for ( i = 0; i < c; i++ )
+		{
+			scan[i*4+3] += 255 - hMax;
+		}
+	}
+
+	*pUploadWidth = scaled_width;
+	*pUploadHeight = scaled_height;
+	*format = internalFormat;
+
+	for( miplevel = 0; miplevel <= *maxMipLevel; miplevel++ ) {
+		// prepare blue channel of height map
+		switch( r_parallax->integer ) {
+		case 0:
+			break;
+		case 1:
+			break;
+		case 2:
+			// blue channel holds the max pyramid of the alpha channel
+			R_BuildMaxPyramid( (byte *)scaledBuffer, scaled_width, scaled_height );
+			break;
+		}
+		
+		qglTexImage2D (GL_TEXTURE_2D, miplevel, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
+		
+		R_MipMapHeightMap( (byte *)scaledBuffer, scaled_width, scaled_height );
+		scaled_width >>= 1;
+		scaled_height >>= 1;
+		if (scaled_width < 1)
+			scaled_width = 1;
+		if (scaled_height < 1)
+			scaled_height = 1;
+	}
+	
+	if( r_parallax->integer == 2 ) {
+		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	} else {
+		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	}
+	
+	GL_CheckErrors();
+	
 	if ( scaledBuffer != 0 )
 		ri.Hunk_FreeTempMemory( scaledBuffer );
 	if ( resampledBuffer != 0 )
@@ -774,8 +1171,8 @@
 This is the only way any image_t are created
 ================
 */
-image_t *R_CreateImage( const char *name, const byte *pic, int width, int height, 
-					   qboolean mipmap, qboolean allowPicmip, int glWrapClampMode ) {
+image_t *R_CreateImage( const char *name, texImage_t *pic, int width, int height, 
+			qboolean mipmap, qboolean allowPicmip, int glWrapClampMode ) {
 	image_t		*image;
 	qboolean	isLightmap = qfalse;
 	long		hash;
@@ -792,7 +1189,8 @@
 	}
 
 	image = tr.images[tr.numImages] = ri.Hunk_Alloc( sizeof( image_t ), h_low );
-	image->texnum = 1024 + tr.numImages;
+	qglGenTextures(1, &image->texnum);
+	//image->texnum = 1024 + tr.numImages;
 	tr.numImages++;
 
 	image->mipmap = mipmap;
@@ -811,29 +1209,38 @@
 		image->TMU = 0;
 	}
 
-	if ( qglActiveTextureARB ) {
-		GL_SelectTexture( image->TMU );
-	}
-
-	GL_Bind(image);
+	GL_BindTexture( image->texnum );
 
-	Upload32( (unsigned *)pic, image->width, image->height, 
-								image->mipmap,
-								allowPicmip,
-								isLightmap,
-								&image->internalFormat,
-								&image->uploadWidth,
-								&image->uploadHeight );
+	if( pic && pic->numMipmaps > 0 ) {
+		if( *name == '^' ) {
+			// height map
+			UploadHeightMap( pic,
+					 image->width, image->height, 
+					 allowPicmip,
+					 &image->internalFormat,
+					 &image->uploadWidth,
+					 &image->uploadHeight,
+					 &image->maxMipLevel
+				);
+			image->hasAlpha = qtrue;
+		} else {
+			Upload32( pic,
+				  image->width, image->height, 
+				  image->mipmap,
+				  allowPicmip,
+				  isLightmap,
+				  &image->internalFormat,
+				  &image->uploadWidth,
+				  &image->uploadHeight,
+				  &image->hasAlpha,
+				  &image->maxMipLevel
+				);
+		}
+	}
 
 	qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, glWrapClampMode );
 	qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, glWrapClampMode );
 
-	qglBindTexture( GL_TEXTURE_2D, 0 );
-
-	if ( image->TMU == 1 ) {
-		GL_SelectTexture( 0 );
-	}
-
 	hash = generateHashValue(name);
 	image->next = hashTable[hash];
 	hashTable[hash] = image;
@@ -846,13 +1253,14 @@
 typedef struct
 {
 	char *ext;
-	void (*ImageLoader)( const char *, unsigned char **, int *, int * );
+	void (*ImageLoader)( const char *, texImage_t *, int *, int * );
 } imageExtToLoaderMap_t;
 
 // Note that the ordering indicates the order of preference used
 // when there are multiple images of different formats available
 static imageExtToLoaderMap_t imageLoaders[ ] =
 {
+	{ "dds",  R_LoadDDS },
 	{ "tga",  R_LoadTGA },
 	{ "jpg",  R_LoadJPG },
 	{ "jpeg", R_LoadJPG },
@@ -872,14 +1280,14 @@
 32 bit format.
 =================
 */
-void R_LoadImage( const char *name, byte **pic, int *width, int *height )
+void R_LoadImage( const char *name, texImage_t *pic, int *width, int *height )
 {
 	qboolean orgNameFailed = qfalse;
 	int i;
 	char localName[ MAX_QPATH ];
 	const char *ext;
 
-	*pic = NULL;
+	pic->numMipmaps = 0;
 	*width = 0;
 	*height = 0;
 
@@ -903,7 +1311,7 @@
 		// A loader was found
 		if( i < numImageLoaders )
 		{
-			if( *pic == NULL )
+			if( pic->numMipmaps == 0 )
 			{
 				// Loader failed, most likely because the file isn't there;
 				// try again without the extension
@@ -927,7 +1335,7 @@
 		// Load
 		imageLoaders[ i ].ImageLoader( altName, pic, width, height );
 
-		if( *pic )
+		if( pic->numMipmaps > 0 )
 		{
 			if( orgNameFailed )
 			{
@@ -952,7 +1360,7 @@
 image_t	*R_FindImageFile( const char *name, qboolean mipmap, qboolean allowPicmip, int glWrapClampMode ) {
 	image_t	*image;
 	int		width, height;
-	byte	*pic;
+	texImage_t	pic;
 	long	hash;
 
 	if (!name) {
@@ -986,16 +1394,142 @@
 	// load the pic from disk
 	//
 	R_LoadImage( name, &pic, &width, &height );
-	if ( pic == NULL ) {
+	if ( pic.numMipmaps == 0 ) {
+		return NULL;
+	}
+
+	image = R_CreateImage( ( char * ) name, &pic, width, height, mipmap, allowPicmip, glWrapClampMode );
+	ri.Free( pic.data[0] );
+	return image;
+}
+
+/*
+===============
+R_FindHeightMapFile
+
+Finds or loads the given height map file.
+Returns NULL if it fails, not a default image.
+==============
+*/
+image_t	*R_FindHeightMapFile( const char *name, qboolean mipmap, int glWrapClampMode ) {
+	image_t	*image;
+	int		width, height;
+	texImage_t	pic;
+	long	hash;
+	char localName[ MAX_QPATH ];
+
+	if (!name) {
 		return NULL;
 	}
 
-	image = R_CreateImage( ( char * ) name, pic, width, height, mipmap, allowPicmip, glWrapClampMode );
-	ri.Free( pic );
+	localName[0] = '^';
+	strcpy( localName+1, name );
+
+	hash = generateHashValue( localName );
+
+	//
+	// see if the image is already loaded
+	//
+	for (image=hashTable[hash]; image; image=image->next) {
+		if ( !strcmp( name, image->imgName ) ) {
+			// the white image can be used with any set of parms, but other mismatches are errors
+			if ( strcmp( name, "*white" ) ) {
+				if ( image->mipmap != mipmap ) {
+					ri.Printf( PRINT_DEVELOPER, "WARNING: reused image %s with mixed mipmap parm\n", name );
+				}
+				if ( image->allowPicmip ) {
+					ri.Printf( PRINT_DEVELOPER, "WARNING: reused image %s with mixed allowPicmip parm\n", name );
+				}
+				if ( image->wrapClampMode != glWrapClampMode ) {
+					ri.Printf( PRINT_ALL, "WARNING: reused image %s with mixed glWrapClampMode parm\n", name );
+				}
+			}
+			return image;
+		}
+	}
+
+	//
+	// load the pic from disk
+	//
+	R_LoadImage( localName+1, &pic, &width, &height );
+	if ( pic.numMipmaps == 0 ) {
+		return NULL;
+	}
+
+	image = R_CreateImage( localName, &pic, width, height, mipmap, qfalse, glWrapClampMode );
+	ri.Free( pic.data[0] );
 	return image;
 }
 
 
+image_t *R_CombineImages( int num, image_t **images ) {
+	int	i, cols, width, height, lod, maxLod, xoffs;
+	byte	*data;
+	image_t	*result;
+	
+	if( num <= 1 )
+		return NULL;
+	
+	/* check that all images are compatible */
+	for( i = 1; i < num; i++ ) {
+		if( images[i]->uploadWidth    != images[0]->uploadWidth ||
+		    images[i]->uploadHeight   != images[0]->uploadHeight ||
+		    images[i]->internalFormat != images[0]->internalFormat )
+			return NULL;
+	}
+	
+	width = images[0]->uploadWidth;
+	height = images[0]->uploadHeight;
+	
+	/* Check that they fit into one texture */
+	for( cols = 1; cols < num; cols *= 2 ) {
+		if( cols * width >= glConfig.maxTextureSize )
+			break;
+	}
+	
+	/* TODO: avoid the GPU->CPU->GPU roundtrip with some render-to-texture
+	 *       magic */
+	data = ri.Hunk_AllocateTempMemory( width * height * sizeof(color4ub_t) );
+	
+	result = R_CreateImage( "*combined", NULL, cols * width,
+				height, images[0]->mipmap,
+				images[0]->allowPicmip, GL_REPEAT );
+	result->uploadWidth = cols * width;
+	result->uploadHeight = height;
+	result->internalFormat = images[0]->internalFormat;
+
+	if( !images[0]->mipmap ) {
+		maxLod = 0;
+	} else {
+		for( maxLod = 0; (1<<maxLod) < width &&
+			     (1<<maxLod) < height; maxLod++ );
+	}
+	for( lod = 0; lod <= maxLod; lod++ ) {
+		qglTexImage2D( GL_TEXTURE_2D, lod, result->internalFormat,
+			       cols * width, height,
+			       0, GL_RGBA, GL_UNSIGNED_BYTE, NULL );
+		xoffs = 0;
+		for( i = 0; i < num; i++ ) {
+			GL_BindTexture( images[i]->texnum );
+			qglGetTexImage( GL_TEXTURE_2D, lod, GL_RGBA, GL_UNSIGNED_BYTE, data );
+			GL_BindTexture( result->texnum );
+			qglTexSubImage2D( GL_TEXTURE_2D, lod, 
+					  xoffs, 0,
+					  width, height,
+					  GL_RGBA, GL_UNSIGNED_BYTE, data );
+			GL_CheckErrors();
+			
+			xoffs += width;
+		}
+		width >>= 1; height >>= 1;
+	}
+	qglTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, maxLod );
+	
+	ri.Hunk_FreeTempMemory( data );
+	
+	return result;
+}
+
 /*
 ================
 R_CreateDlightImage
@@ -1005,6 +1539,7 @@
 static void R_CreateDlightImage( void ) {
 	int		x,y;
 	byte	data[DLIGHT_SIZE][DLIGHT_SIZE][4];
+	texImage_t	pic;
 	int		b;
 
 	// make a centered inverse-square falloff blob for dynamic lighting
@@ -1026,7 +1561,11 @@
 			data[y][x][3] = 255;			
 		}
 	}
-	tr.dlightImage = R_CreateImage("*dlight", (byte *)data, DLIGHT_SIZE, DLIGHT_SIZE, qfalse, qfalse, GL_CLAMP_TO_EDGE );
+	pic.format = GL_RGBA8;
+	pic.numMipmaps = 1;
+	pic.data[0] = &data[0][0][0];
+
+	tr.dlightImage = R_CreateImage("*dlight", &pic, DLIGHT_SIZE, DLIGHT_SIZE, qfalse, qfalse, GL_CLAMP_TO_EDGE );
 }
 
 
@@ -1093,6 +1632,7 @@
 #define	FOG_T	32
 static void R_CreateFogImage( void ) {
 	int		x,y;
+	texImage_t	pic;
 	byte	*data;
 	float	g;
 	float	d;
@@ -1116,7 +1656,11 @@
 	// standard openGL clamping doesn't really do what we want -- it includes
 	// the border color at the edges.  OpenGL 1.2 has clamp-to-edge, which does
 	// what we want.
-	tr.fogImage = R_CreateImage("*fog", (byte *)data, FOG_S, FOG_T, qfalse, qfalse, GL_CLAMP_TO_EDGE );
+	pic.format = GL_RGBA8;
+	pic.numMipmaps = 1;
+	pic.data[0] = data;
+
+	tr.fogImage = R_CreateImage("*fog", &pic, FOG_S, FOG_T, qfalse, qfalse, GL_CLAMP_TO_EDGE );
 	ri.Hunk_FreeTempMemory( data );
 
 	borderColor[0] = 1.0;
@@ -1136,6 +1680,7 @@
 static void R_CreateDefaultImage( void ) {
 	int		x;
 	byte	data[DEFAULT_SIZE][DEFAULT_SIZE][4];
+	texImage_t	pic;
 
 	// the default image will be a box, to allow you to see the mapping coordinates
 	Com_Memset( data, 32, sizeof( data ) );
@@ -1160,7 +1705,11 @@
 		data[x][DEFAULT_SIZE-1][2] =
 		data[x][DEFAULT_SIZE-1][3] = 255;
 	}
-	tr.defaultImage = R_CreateImage("*default", (byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, qtrue, qfalse, GL_REPEAT );
+	pic.format = GL_RGBA8;
+	pic.numMipmaps = 1;
+	pic.data[0] = &data[0][0][0];
+
+	tr.defaultImage = R_CreateImage("*default", &pic, DEFAULT_SIZE, DEFAULT_SIZE, qtrue, qfalse, GL_REPEAT );
 }
 
 /*
@@ -1171,12 +1720,17 @@
 void R_CreateBuiltinImages( void ) {
 	int		x,y;
 	byte	data[DEFAULT_SIZE][DEFAULT_SIZE][4];
+	texImage_t	pic;
 
 	R_CreateDefaultImage();
 
+	pic.format = GL_RGBA8;
+	pic.numMipmaps = 1;
+	pic.data[0] = &data[0][0][0];
+
 	// we use a solid white image instead of disabling texturing
 	Com_Memset( data, 255, sizeof( data ) );
-	tr.whiteImage = R_CreateImage("*white", (byte *)data, 8, 8, qfalse, qfalse, GL_REPEAT );
+	tr.whiteImage = R_CreateImage("*white", &pic, 8, 8, qfalse, qfalse, GL_REPEAT );
 
 	// with overbright bits active, we need an image which is some fraction of full color,
 	// for default lightmaps, etc
@@ -1189,12 +1743,12 @@
 		}
 	}
 
-	tr.identityLightImage = R_CreateImage("*identityLight", (byte *)data, 8, 8, qfalse, qfalse, GL_REPEAT );
+	tr.identityLightImage = R_CreateImage("*identityLight", &pic, 8, 8, qfalse, qfalse, GL_REPEAT );
 
 
 	for(x=0;x<32;x++) {
 		// scratchimage is usually used for cinematic drawing
-		tr.scratchImage[x] = R_CreateImage("*scratch", (byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, qfalse, qtrue, GL_CLAMP_TO_EDGE );
+		tr.scratchImage[x] = R_CreateImage("*scratch", &pic, DEFAULT_SIZE, DEFAULT_SIZE, qfalse, qtrue, GL_CLAMP_TO_EDGE );
 	}
 
 	R_CreateDlightImage();
@@ -1317,14 +1871,7 @@
 	tr.numImages = 0;
 
 	Com_Memset( glState.currenttextures, 0, sizeof( glState.currenttextures ) );
-	if ( qglActiveTextureARB ) {
-		GL_SelectTexture( 1 );
-		qglBindTexture( GL_TEXTURE_2D, 0 );
-		GL_SelectTexture( 0 );
-		qglBindTexture( GL_TEXTURE_2D, 0 );
-	} else {
-		qglBindTexture( GL_TEXTURE_2D, 0 );
-	}
+	GL_UnbindAllTextures( );
 }
 
 /*
@@ -1433,7 +1980,7 @@
 
 	if (len == MAX_TOKEN_CHARS)
 	{
-//		Com_Printf ("Token exceeded %i chars, discarded.\n", MAX_TOKEN_CHARS);
+//		ri.Printf (PRINT_WARNING, "Token exceeded %i chars, discarded.\n", MAX_TOKEN_CHARS);
 		len = 0;
 	}
 	com_token[len] = 0;
@@ -1462,12 +2009,12 @@
 	char		surfName[MAX_QPATH];
 
 	if ( !name || !name[0] ) {
-		Com_Printf( "Empty name passed to RE_RegisterSkin\n" );
+		ri.Printf( PRINT_WARNING, "Empty name passed to RE_RegisterSkin\n" );
 		return 0;
 	}
 
 	if ( strlen( name ) >= MAX_QPATH ) {
-		Com_Printf( "Skin name exceeds MAX_QPATH\n" );
+		ri.Printf( PRINT_WARNING, "Skin name exceeds MAX_QPATH\n" );
 		return 0;
 	}
 
@@ -1501,12 +2048,12 @@
 	if ( strcmp( name + strlen( name ) - 5, ".skin" ) ) {
 		skin->numSurfaces = 1;
 		skin->surfaces[0] = ri.Hunk_Alloc( sizeof(skin->surfaces[0]), h_low );
-		skin->surfaces[0]->shader = R_FindShader( name, LIGHTMAP_NONE, qtrue );
+		skin->surfaces[0]->shader = R_FindShader( name, tr.defaultMD3Shader->lightmapIndex, qtrue );
 		return hSkin;
 	}
 
 	// load and parse the skin file
-    ri.FS_ReadFile( name, &text.v );
+	ri.FS_ReadFile( name, &text.v );
 	if ( !text.c ) {
 		return 0;
 	}
@@ -1536,7 +2083,7 @@
 
 		surf = skin->surfaces[ skin->numSurfaces ] = ri.Hunk_Alloc( sizeof( *skin->surfaces[0] ), h_low );
 		Q_strncpyz( surf->name, surfName, sizeof( surf->name ) );
-		surf->shader = R_FindShader( token, LIGHTMAP_NONE, qtrue );
+		surf->shader = R_FindShader( token, tr.defaultMD3Shader->lightmapIndex, qtrue );
 		skin->numSurfaces++;
 	}
 
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_image.c.orig tremulous-ggp1-src/src/renderer/tr_image.c.orig
--- tremulous-ggp1-src.p/src/renderer/tr_image.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_image.c.orig	2012-07-19 04:25:20.311556052 +0200
@@ -0,0 +1,1607 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+// tr_image.c
+#include "tr_local.h"
+
+static byte			 s_intensitytable[256];
+static unsigned char s_gammatable[256];
+
+int		gl_filter_min = GL_LINEAR_MIPMAP_NEAREST;
+int		gl_filter_max = GL_LINEAR;
+
+#define FILE_HASH_SIZE		1024
+static	image_t*		hashTable[FILE_HASH_SIZE];
+
+/*
+** R_GammaCorrect
+*/
+void R_GammaCorrect( byte *buffer, int bufSize ) {
+	int i;
+
+	for ( i = 0; i < bufSize; i++ ) {
+		buffer[i] = s_gammatable[buffer[i]];
+	}
+}
+
+typedef struct {
+	char *name;
+	int	minimize, maximize;
+} textureMode_t;
+
+textureMode_t modes[] = {
+	{"GL_NEAREST", GL_NEAREST, GL_NEAREST},
+	{"GL_LINEAR", GL_LINEAR, GL_LINEAR},
+	{"GL_NEAREST_MIPMAP_NEAREST", GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST},
+	{"GL_LINEAR_MIPMAP_NEAREST", GL_LINEAR_MIPMAP_NEAREST, GL_LINEAR},
+	{"GL_NEAREST_MIPMAP_LINEAR", GL_NEAREST_MIPMAP_LINEAR, GL_NEAREST},
+	{"GL_LINEAR_MIPMAP_LINEAR", GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR}
+};
+
+/*
+================
+return a hash value for the filename
+================
+*/
+static long generateHashValue( const char *fname ) {
+	int		i;
+	long	hash;
+	char	letter;
+
+	hash = 0;
+	i = 0;
+	while (fname[i] != '\0') {
+		letter = tolower(fname[i]);
+		if (letter =='.') break;				// don't include extension
+		if (letter =='\\') letter = '/';		// damn path names
+		hash+=(long)(letter)*(i+119);
+		i++;
+	}
+	hash &= (FILE_HASH_SIZE-1);
+	return hash;
+}
+
+/*
+===============
+GL_TextureMode
+===============
+*/
+void GL_TextureMode( const char *string ) {
+	int		i;
+	image_t	*glt;
+
+	for ( i=0 ; i< 6 ; i++ ) {
+		if ( !Q_stricmp( modes[i].name, string ) ) {
+			break;
+		}
+	}
+
+	// hack to prevent trilinear from being set on voodoo,
+	// because their driver freaks...
+	if ( i == 5 && glConfig.hardwareType == GLHW_3DFX_2D3D ) {
+		ri.Printf( PRINT_ALL, "Refusing to set trilinear on a voodoo.\n" );
+		i = 3;
+	}
+
+
+	if ( i == 6 ) {
+		ri.Printf (PRINT_ALL, "bad filter name\n");
+		return;
+	}
+
+	gl_filter_min = modes[i].minimize;
+	gl_filter_max = modes[i].maximize;
+
+	// change all the existing mipmap texture objects
+	for ( i = 0 ; i < tr.numImages ; i++ ) {
+		glt = tr.images[ i ];
+		if ( glt->mipmap ) {
+			GL_Bind (glt);
+			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
+			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
+		}
+	}
+}
+
+/*
+===============
+R_SumOfUsedImages
+===============
+*/
+int R_SumOfUsedImages( void ) {
+	int	total;
+	int i;
+
+	total = 0;
+	for ( i = 0; i < tr.numImages; i++ ) {
+		if ( tr.images[i]->frameUsed == tr.frameCount ) {
+			total += tr.images[i]->uploadWidth * tr.images[i]->uploadHeight;
+		}
+	}
+
+	return total;
+}
+
+/*
+===============
+R_ImageList_f
+===============
+*/
+void R_ImageList_f( void ) {
+	int		i;
+	image_t	*image;
+	int		texels;
+	const char *yesno[] = {
+		"no ", "yes"
+	};
+
+	ri.Printf (PRINT_ALL, "\n      -w-- -h-- -mm- -TMU- -if-- wrap --name-------\n");
+	texels = 0;
+
+	for ( i = 0 ; i < tr.numImages ; i++ ) {
+		image = tr.images[ i ];
+
+		texels += image->uploadWidth*image->uploadHeight;
+		ri.Printf (PRINT_ALL,  "%4i: %4i %4i  %s   %d   ",
+			i, image->uploadWidth, image->uploadHeight, yesno[image->mipmap], image->TMU );
+		switch ( image->internalFormat ) {
+		case 1:
+			ri.Printf( PRINT_ALL, "I    " );
+			break;
+		case 2:
+			ri.Printf( PRINT_ALL, "IA   " );
+			break;
+		case 3:
+			ri.Printf( PRINT_ALL, "RGB  " );
+			break;
+		case 4:
+			ri.Printf( PRINT_ALL, "RGBA " );
+			break;
+		case GL_RGBA8:
+			ri.Printf( PRINT_ALL, "RGBA8" );
+			break;
+		case GL_RGB8:
+			ri.Printf( PRINT_ALL, "RGB8" );
+			break;
+		case GL_RGB4_S3TC:
+		case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+			ri.Printf( PRINT_ALL, "S3TC " );
+			break;
+		case GL_RGBA4:
+			ri.Printf( PRINT_ALL, "RGBA4" );
+			break;
+		case GL_RGB5:
+			ri.Printf( PRINT_ALL, "RGB5 " );
+			break;
+		default:
+			ri.Printf( PRINT_ALL, "???? " );
+		}
+
+		switch ( image->wrapClampMode ) {
+		case GL_REPEAT:
+			ri.Printf( PRINT_ALL, "rept " );
+			break;
+		case GL_CLAMP_TO_EDGE:
+			ri.Printf( PRINT_ALL, "clmp " );
+			break;
+		default:
+			ri.Printf( PRINT_ALL, "%4i ", image->wrapClampMode );
+			break;
+		}
+		
+		ri.Printf( PRINT_ALL, " %s\n", image->imgName );
+	}
+	ri.Printf (PRINT_ALL, " ---------\n");
+	ri.Printf (PRINT_ALL, " %i total texels (not including mipmaps)\n", texels);
+	ri.Printf (PRINT_ALL, " %i total images\n\n", tr.numImages );
+}
+
+//=======================================================================
+
+/*
+================
+ResampleTexture
+
+Used to resample images in a more general than quartering fashion.
+
+This will only be filtered properly if the resampled size
+is greater than half the original size.
+
+If a larger shrinking is needed, use the mipmap function 
+before or after.
+================
+*/
+static void ResampleTexture( unsigned *in, int inwidth, int inheight, unsigned *out,  
+							int outwidth, int outheight ) {
+	int		i, j;
+	unsigned	*inrow, *inrow2;
+	unsigned	frac, fracstep;
+	unsigned	p1[2048], p2[2048];
+	byte		*pix1, *pix2, *pix3, *pix4;
+
+	if (outwidth>2048)
+		ri.Error(ERR_DROP, "ResampleTexture: max width");
+								
+	fracstep = inwidth*0x10000/outwidth;
+
+	frac = fracstep>>2;
+	for ( i=0 ; i<outwidth ; i++ ) {
+		p1[i] = 4*(frac>>16);
+		frac += fracstep;
+	}
+	frac = 3*(fracstep>>2);
+	for ( i=0 ; i<outwidth ; i++ ) {
+		p2[i] = 4*(frac>>16);
+		frac += fracstep;
+	}
+
+	for (i=0 ; i<outheight ; i++, out += outwidth) {
+		inrow = in + inwidth*(int)((i+0.25)*inheight/outheight);
+		inrow2 = in + inwidth*(int)((i+0.75)*inheight/outheight);
+		frac = fracstep >> 1;
+		for (j=0 ; j<outwidth ; j++) {
+			pix1 = (byte *)inrow + p1[j];
+			pix2 = (byte *)inrow + p2[j];
+			pix3 = (byte *)inrow2 + p1[j];
+			pix4 = (byte *)inrow2 + p2[j];
+			((byte *)(out+j))[0] = (pix1[0] + pix2[0] + pix3[0] + pix4[0])>>2;
+			((byte *)(out+j))[1] = (pix1[1] + pix2[1] + pix3[1] + pix4[1])>>2;
+			((byte *)(out+j))[2] = (pix1[2] + pix2[2] + pix3[2] + pix4[2])>>2;
+			((byte *)(out+j))[3] = (pix1[3] + pix2[3] + pix3[3] + pix4[3])>>2;
+		}
+	}
+}
+
+/*
+================
+R_LightScaleTexture
+
+Scale up the pixel values in a texture to increase the
+lighting range
+================
+*/
+void R_LightScaleTexture (unsigned *in, int inwidth, int inheight, qboolean only_gamma )
+{
+	if ( only_gamma )
+	{
+		if ( !glConfig.deviceSupportsGamma )
+		{
+			int		i, c;
+			byte	*p;
+
+			p = (byte *)in;
+
+			c = inwidth*inheight;
+			for (i=0 ; i<c ; i++, p+=4)
+			{
+				p[0] = s_gammatable[p[0]];
+				p[1] = s_gammatable[p[1]];
+				p[2] = s_gammatable[p[2]];
+			}
+		}
+	}
+	else
+	{
+		int		i, c;
+		byte	*p;
+
+		p = (byte *)in;
+
+		c = inwidth*inheight;
+
+		if ( glConfig.deviceSupportsGamma )
+		{
+			for (i=0 ; i<c ; i++, p+=4)
+			{
+				p[0] = s_intensitytable[p[0]];
+				p[1] = s_intensitytable[p[1]];
+				p[2] = s_intensitytable[p[2]];
+			}
+		}
+		else
+		{
+			for (i=0 ; i<c ; i++, p+=4)
+			{
+				p[0] = s_gammatable[s_intensitytable[p[0]]];
+				p[1] = s_gammatable[s_intensitytable[p[1]]];
+				p[2] = s_gammatable[s_intensitytable[p[2]]];
+			}
+		}
+	}
+}
+
+
+/*
+================
+R_MipMap2
+
+Operates in place, quartering the size of the texture
+Proper linear filter
+================
+*/
+static void R_MipMap2( unsigned *in, int inWidth, int inHeight ) {
+	int			i, j, k;
+	byte		*outpix;
+	int			inWidthMask, inHeightMask;
+	int			total;
+	int			outWidth, outHeight;
+	unsigned	*temp;
+
+	outWidth = inWidth >> 1;
+	outHeight = inHeight >> 1;
+	temp = ri.Hunk_AllocateTempMemory( outWidth * outHeight * 4 );
+
+	inWidthMask = inWidth - 1;
+	inHeightMask = inHeight - 1;
+
+	for ( i = 0 ; i < outHeight ; i++ ) {
+		for ( j = 0 ; j < outWidth ; j++ ) {
+			outpix = (byte *) ( temp + i * outWidth + j );
+			for ( k = 0 ; k < 4 ; k++ ) {
+				total = 
+					1 * ((byte *)&in[ ((i*2-1)&inHeightMask)*inWidth + ((j*2-1)&inWidthMask) ])[k] +
+					2 * ((byte *)&in[ ((i*2-1)&inHeightMask)*inWidth + ((j*2)&inWidthMask) ])[k] +
+					2 * ((byte *)&in[ ((i*2-1)&inHeightMask)*inWidth + ((j*2+1)&inWidthMask) ])[k] +
+					1 * ((byte *)&in[ ((i*2-1)&inHeightMask)*inWidth + ((j*2+2)&inWidthMask) ])[k] +
+
+					2 * ((byte *)&in[ ((i*2)&inHeightMask)*inWidth + ((j*2-1)&inWidthMask) ])[k] +
+					4 * ((byte *)&in[ ((i*2)&inHeightMask)*inWidth + ((j*2)&inWidthMask) ])[k] +
+					4 * ((byte *)&in[ ((i*2)&inHeightMask)*inWidth + ((j*2+1)&inWidthMask) ])[k] +
+					2 * ((byte *)&in[ ((i*2)&inHeightMask)*inWidth + ((j*2+2)&inWidthMask) ])[k] +
+
+					2 * ((byte *)&in[ ((i*2+1)&inHeightMask)*inWidth + ((j*2-1)&inWidthMask) ])[k] +
+					4 * ((byte *)&in[ ((i*2+1)&inHeightMask)*inWidth + ((j*2)&inWidthMask) ])[k] +
+					4 * ((byte *)&in[ ((i*2+1)&inHeightMask)*inWidth + ((j*2+1)&inWidthMask) ])[k] +
+					2 * ((byte *)&in[ ((i*2+1)&inHeightMask)*inWidth + ((j*2+2)&inWidthMask) ])[k] +
+
+					1 * ((byte *)&in[ ((i*2+2)&inHeightMask)*inWidth + ((j*2-1)&inWidthMask) ])[k] +
+					2 * ((byte *)&in[ ((i*2+2)&inHeightMask)*inWidth + ((j*2)&inWidthMask) ])[k] +
+					2 * ((byte *)&in[ ((i*2+2)&inHeightMask)*inWidth + ((j*2+1)&inWidthMask) ])[k] +
+					1 * ((byte *)&in[ ((i*2+2)&inHeightMask)*inWidth + ((j*2+2)&inWidthMask) ])[k];
+				outpix[k] = total / 36;
+			}
+		}
+	}
+
+	Com_Memcpy( in, temp, outWidth * outHeight * 4 );
+	ri.Hunk_FreeTempMemory( temp );
+}
+
+/*
+================
+R_MipMap
+
+Operates in place, quartering the size of the texture
+================
+*/
+static void R_MipMap (byte *in, int width, int height) {
+	int		i, j;
+	byte	*out;
+	int		row;
+
+	if ( !r_simpleMipMaps->integer ) {
+		R_MipMap2( (unsigned *)in, width, height );
+		return;
+	}
+
+	if ( width == 1 && height == 1 ) {
+		return;
+	}
+
+	row = width * 4;
+	out = in;
+	width >>= 1;
+	height >>= 1;
+
+	if ( width == 0 || height == 0 ) {
+		width += height;	// get largest
+		for (i=0 ; i<width ; i++, out+=4, in+=8 ) {
+			out[0] = ( in[0] + in[4] )>>1;
+			out[1] = ( in[1] + in[5] )>>1;
+			out[2] = ( in[2] + in[6] )>>1;
+			out[3] = ( in[3] + in[7] )>>1;
+		}
+		return;
+	}
+
+	for (i=0 ; i<height ; i++, in+=row) {
+		for (j=0 ; j<width ; j++, out+=4, in+=8) {
+			out[0] = (in[0] + in[4] + in[row+0] + in[row+4])>>2;
+			out[1] = (in[1] + in[5] + in[row+1] + in[row+5])>>2;
+			out[2] = (in[2] + in[6] + in[row+2] + in[row+6])>>2;
+			out[3] = (in[3] + in[7] + in[row+3] + in[row+7])>>2;
+		}
+	}
+}
+
+
+/*
+==================
+R_BlendOverTexture
+
+Apply a color blend over a set of pixels
+==================
+*/
+static void R_BlendOverTexture( byte *data, int pixelCount, byte blend[4] ) {
+	int		i;
+	int		inverseAlpha;
+	int		premult[3];
+
+	inverseAlpha = 255 - blend[3];
+	premult[0] = blend[0] * blend[3];
+	premult[1] = blend[1] * blend[3];
+	premult[2] = blend[2] * blend[3];
+
+	for ( i = 0 ; i < pixelCount ; i++, data+=4 ) {
+		data[0] = ( data[0] * inverseAlpha + premult[0] ) >> 9;
+		data[1] = ( data[1] * inverseAlpha + premult[1] ) >> 9;
+		data[2] = ( data[2] * inverseAlpha + premult[2] ) >> 9;
+	}
+}
+
+byte	mipBlendColors[16][4] = {
+	{0,0,0,0},
+	{255,0,0,128},
+	{0,255,0,128},
+	{0,0,255,128},
+	{255,0,0,128},
+	{0,255,0,128},
+	{0,0,255,128},
+	{255,0,0,128},
+	{0,255,0,128},
+	{0,0,255,128},
+	{255,0,0,128},
+	{0,255,0,128},
+	{0,0,255,128},
+	{255,0,0,128},
+	{0,255,0,128},
+	{0,0,255,128},
+};
+
+
+/*
+===============
+Upload32
+
+===============
+*/
+extern qboolean charSet;
+static void Upload32( unsigned *data, 
+						  int width, int height, 
+						  qboolean mipmap, 
+						  qboolean picmip, 
+							qboolean lightMap,
+						  int *format, 
+						  int *pUploadWidth, int *pUploadHeight )
+{
+	int			samples;
+	unsigned	*scaledBuffer = NULL;
+	unsigned	*resampledBuffer = NULL;
+	int			scaled_width, scaled_height;
+	int			i, c;
+	byte		*scan;
+	GLenum		internalFormat = GL_RGB;
+	float		rMax = 0, gMax = 0, bMax = 0;
+
+	//
+	// convert to exact power of 2 sizes
+	//
+	for (scaled_width = 1 ; scaled_width < width ; scaled_width<<=1)
+		;
+	for (scaled_height = 1 ; scaled_height < height ; scaled_height<<=1)
+		;
+	if ( r_roundImagesDown->integer && scaled_width > width )
+		scaled_width >>= 1;
+	if ( r_roundImagesDown->integer && scaled_height > height )
+		scaled_height >>= 1;
+
+	if ( scaled_width != width || scaled_height != height ) {
+		resampledBuffer = ri.Hunk_AllocateTempMemory( scaled_width * scaled_height * 4 );
+		ResampleTexture (data, width, height, resampledBuffer, scaled_width, scaled_height);
+		data = resampledBuffer;
+		width = scaled_width;
+		height = scaled_height;
+	}
+
+	//
+	// perform optional picmip operation
+	//
+	if ( picmip ) {
+		scaled_width >>= r_picmip->integer;
+		scaled_height >>= r_picmip->integer;
+	}
+
+	//
+	// clamp to minimum size
+	//
+	if (scaled_width < 1) {
+		scaled_width = 1;
+	}
+	if (scaled_height < 1) {
+		scaled_height = 1;
+	}
+
+	//
+	// clamp to the current upper OpenGL limit
+	// scale both axis down equally so we don't have to
+	// deal with a half mip resampling
+	//
+	while ( scaled_width > glConfig.maxTextureSize
+		|| scaled_height > glConfig.maxTextureSize ) {
+		scaled_width >>= 1;
+		scaled_height >>= 1;
+	}
+
+	scaledBuffer = ri.Hunk_AllocateTempMemory( sizeof( unsigned ) * scaled_width * scaled_height );
+
+	//
+	// scan the texture for each channel's max values
+	// and verify if the alpha channel is being used or not
+	//
+	c = width*height;
+	scan = ((byte *)data);
+	samples = 3;
+
+	if( r_greyscale->integer )
+	{
+		for ( i = 0; i < c; i++ )
+		{
+			byte luma = LUMA(scan[i*4], scan[i*4 + 1], scan[i*4 + 2]);
+			scan[i*4] = luma;
+			scan[i*4 + 1] = luma;
+			scan[i*4 + 2] = luma;
+		}
+	}
+	else if( r_greyscale->value )
+	{
+		for ( i = 0; i < c; i++ )
+		{
+			float luma = LUMA(scan[i*4], scan[i*4 + 1], scan[i*4 + 2]);
+			scan[i*4] = LERP(scan[i*4], luma, r_greyscale->value);
+			scan[i*4 + 1] = LERP(scan[i*4 + 1], luma, r_greyscale->value);
+			scan[i*4 + 2] = LERP(scan[i*4 + 2], luma, r_greyscale->value);
+		}
+	}
+
+	if(lightMap)
+	{
+		if(r_greyscale->integer)
+			internalFormat = GL_LUMINANCE;
+		else
+			internalFormat = GL_RGB;
+	}
+	else
+	{
+		for ( i = 0; i < c; i++ )
+		{
+			if ( scan[i*4+0] > rMax )
+			{
+				rMax = scan[i*4+0];
+			}
+			if ( scan[i*4+1] > gMax )
+			{
+				gMax = scan[i*4+1];
+			}
+			if ( scan[i*4+2] > bMax )
+			{
+				bMax = scan[i*4+2];
+			}
+			if ( scan[i*4 + 3] != 255 ) 
+			{
+				samples = 4;
+				break;
+			}
+		}
+		// select proper internal format
+		if ( samples == 3 )
+		{
+			if(r_greyscale->integer)
+			{
+				if(r_texturebits->integer == 16)
+					internalFormat = GL_LUMINANCE8;
+				else if(r_texturebits->integer == 32)
+					internalFormat = GL_LUMINANCE16;
+				else
+					internalFormat = GL_LUMINANCE;
+			}
+			else
+			{
+				if ( glConfig.textureCompression == TC_S3TC_ARB )
+				{
+					internalFormat = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
+				}
+				else if ( glConfig.textureCompression == TC_S3TC )
+				{
+					internalFormat = GL_RGB4_S3TC;
+				}
+				else if ( r_texturebits->integer == 16 )
+				{
+					internalFormat = GL_RGB5;
+				}
+				else if ( r_texturebits->integer == 32 )
+				{
+					internalFormat = GL_RGB8;
+				}
+				else
+				{
+					internalFormat = GL_RGB;
+				}
+			}
+		}
+		else if ( samples == 4 )
+		{
+			if(r_greyscale->integer)
+			{
+				if(r_texturebits->integer == 16)
+					internalFormat = GL_LUMINANCE8_ALPHA8;
+				else if(r_texturebits->integer == 32)
+					internalFormat = GL_LUMINANCE16_ALPHA16;
+				else
+					internalFormat = GL_LUMINANCE_ALPHA;
+			}
+			else
+			{
+				if ( r_texturebits->integer == 16 )
+				{
+					internalFormat = GL_RGBA4;
+				}
+				else if ( r_texturebits->integer == 32 )
+				{
+					internalFormat = GL_RGBA8;
+				}
+				else
+				{
+					internalFormat = GL_RGBA;
+				}
+			}
+		}
+	}
+
+	// copy or resample data as appropriate for first MIP level
+	if ( ( scaled_width == width ) && 
+		( scaled_height == height ) ) {
+		if (!mipmap)
+		{
+			qglTexImage2D (GL_TEXTURE_2D, 0, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
+			*pUploadWidth = scaled_width;
+			*pUploadHeight = scaled_height;
+			*format = internalFormat;
+
+			goto done;
+		}
+		Com_Memcpy (scaledBuffer, data, width*height*4);
+	}
+	else
+	{
+		// use the normal mip-mapping function to go down from here
+		while ( width > scaled_width || height > scaled_height ) {
+			R_MipMap( (byte *)data, width, height );
+			width >>= 1;
+			height >>= 1;
+			if ( width < 1 ) {
+				width = 1;
+			}
+			if ( height < 1 ) {
+				height = 1;
+			}
+		}
+		Com_Memcpy( scaledBuffer, data, width * height * 4 );
+	}
+
+	R_LightScaleTexture (scaledBuffer, scaled_width, scaled_height, !mipmap );
+
+	*pUploadWidth = scaled_width;
+	*pUploadHeight = scaled_height;
+	*format = internalFormat;
+
+	qglTexImage2D (GL_TEXTURE_2D, 0, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
+
+	if (mipmap)
+	{
+		int		miplevel;
+
+		miplevel = 0;
+		while (scaled_width > 1 || scaled_height > 1)
+		{
+			R_MipMap( (byte *)scaledBuffer, scaled_width, scaled_height );
+			scaled_width >>= 1;
+			scaled_height >>= 1;
+			if (scaled_width < 1)
+				scaled_width = 1;
+			if (scaled_height < 1)
+				scaled_height = 1;
+			miplevel++;
+
+			if ( r_colorMipLevels->integer ) {
+				R_BlendOverTexture( (byte *)scaledBuffer, scaled_width * scaled_height, mipBlendColors[miplevel] );
+			}
+
+			qglTexImage2D (GL_TEXTURE_2D, miplevel, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
+		}
+	}
+done:
+
+	if (mipmap)
+	{
+		if ( glConfig.textureFilterAnisotropic )
+			qglTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT,
+					(GLint)Com_Clamp( 1, glConfig.maxAnisotropy, r_ext_max_anisotropy->integer ) );
+
+		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
+		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_max);
+	}
+	else
+	{
+		if ( glConfig.textureFilterAnisotropic )
+			qglTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 1 );
+
+		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
+		qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
+	}
+
+	GL_CheckErrors();
+
+	if ( scaledBuffer != 0 )
+		ri.Hunk_FreeTempMemory( scaledBuffer );
+	if ( resampledBuffer != 0 )
+		ri.Hunk_FreeTempMemory( resampledBuffer );
+}
+
+
+/*
+================
+R_CreateImage
+
+This is the only way any image_t are created
+================
+*/
+image_t *R_CreateImage( const char *name, const byte *pic, int width, int height, 
+					   qboolean mipmap, qboolean allowPicmip, int glWrapClampMode ) {
+	image_t		*image;
+	qboolean	isLightmap = qfalse;
+	long		hash;
+
+	if (strlen(name) >= MAX_QPATH ) {
+		ri.Error (ERR_DROP, "R_CreateImage: \"%s\" is too long\n", name);
+	}
+	if ( !strncmp( name, "*lightmap", 9 ) ) {
+		isLightmap = qtrue;
+	}
+
+	if ( tr.numImages == MAX_DRAWIMAGES ) {
+		ri.Error( ERR_DROP, "R_CreateImage: MAX_DRAWIMAGES hit\n");
+	}
+
+	image = tr.images[tr.numImages] = ri.Hunk_Alloc( sizeof( image_t ), h_low );
+	image->texnum = 1024 + tr.numImages;
+	tr.numImages++;
+
+	image->mipmap = mipmap;
+	image->allowPicmip = allowPicmip;
+
+	strcpy (image->imgName, name);
+
+	image->width = width;
+	image->height = height;
+	image->wrapClampMode = glWrapClampMode;
+
+	// lightmaps are always allocated on TMU 1
+	if ( qglActiveTextureARB && isLightmap ) {
+		image->TMU = 1;
+	} else {
+		image->TMU = 0;
+	}
+
+	if ( qglActiveTextureARB ) {
+		GL_SelectTexture( image->TMU );
+	}
+
+	GL_Bind(image);
+
+	Upload32( (unsigned *)pic, image->width, image->height, 
+								image->mipmap,
+								allowPicmip,
+								isLightmap,
+								&image->internalFormat,
+								&image->uploadWidth,
+								&image->uploadHeight );
+
+	qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, glWrapClampMode );
+	qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, glWrapClampMode );
+
+	qglBindTexture( GL_TEXTURE_2D, 0 );
+
+	if ( image->TMU == 1 ) {
+		GL_SelectTexture( 0 );
+	}
+
+	hash = generateHashValue(name);
+	image->next = hashTable[hash];
+	hashTable[hash] = image;
+
+	return image;
+}
+
+//===================================================================
+
+typedef struct
+{
+	char *ext;
+	void (*ImageLoader)( const char *, unsigned char **, int *, int * );
+} imageExtToLoaderMap_t;
+
+// Note that the ordering indicates the order of preference used
+// when there are multiple images of different formats available
+static imageExtToLoaderMap_t imageLoaders[ ] =
+{
+	{ "tga",  R_LoadTGA },
+	{ "jpg",  R_LoadJPG },
+	{ "jpeg", R_LoadJPG },
+	{ "png",  R_LoadPNG },
+	{ "pcx",  R_LoadPCX },
+	{ "bmp",  R_LoadBMP }
+};
+
+static int numImageLoaders = sizeof( imageLoaders ) /
+		sizeof( imageLoaders[ 0 ] );
+
+/*
+=================
+R_LoadImage
+
+Loads any of the supported image types into a cannonical
+32 bit format.
+=================
+*/
+void R_LoadImage( const char *name, byte **pic, int *width, int *height )
+{
+	qboolean orgNameFailed = qfalse;
+	int i;
+	char localName[ MAX_QPATH ];
+	const char *ext;
+
+	*pic = NULL;
+	*width = 0;
+	*height = 0;
+
+	Q_strncpyz( localName, name, MAX_QPATH );
+
+	ext = COM_GetExtension( localName );
+
+	if( *ext )
+	{
+		// Look for the correct loader and use it
+		for( i = 0; i < numImageLoaders; i++ )
+		{
+			if( !Q_stricmp( ext, imageLoaders[ i ].ext ) )
+			{
+				// Load
+				imageLoaders[ i ].ImageLoader( localName, pic, width, height );
+				break;
+			}
+		}
+
+		// A loader was found
+		if( i < numImageLoaders )
+		{
+			if( *pic == NULL )
+			{
+				// Loader failed, most likely because the file isn't there;
+				// try again without the extension
+				orgNameFailed = qtrue;
+				COM_StripExtension( name, localName, MAX_QPATH );
+			}
+			else
+			{
+				// Something loaded
+				return;
+			}
+		}
+	}
+
+	// Try and find a suitable match using all
+	// the image formats supported
+	for( i = 0; i < numImageLoaders; i++ )
+	{
+		char *altName = va( "%s.%s", localName, imageLoaders[ i ].ext );
+
+		// Load
+		imageLoaders[ i ].ImageLoader( altName, pic, width, height );
+
+		if( *pic )
+		{
+			if( orgNameFailed )
+			{
+				ri.Printf( PRINT_DEVELOPER, "WARNING: %s not present, using %s instead\n",
+						name, altName );
+			}
+
+			break;
+		}
+	}
+}
+
+
+/*
+===============
+R_FindImageFile
+
+Finds or loads the given image.
+Returns NULL if it fails, not a default image.
+==============
+*/
+image_t	*R_FindImageFile( const char *name, qboolean mipmap, qboolean allowPicmip, int glWrapClampMode ) {
+	image_t	*image;
+	int		width, height;
+	byte	*pic;
+	long	hash;
+
+	if (!name) {
+		return NULL;
+	}
+
+	hash = generateHashValue(name);
+
+	//
+	// see if the image is already loaded
+	//
+	for (image=hashTable[hash]; image; image=image->next) {
+		if ( !strcmp( name, image->imgName ) ) {
+			// the white image can be used with any set of parms, but other mismatches are errors
+			if ( strcmp( name, "*white" ) ) {
+				if ( image->mipmap != mipmap ) {
+					ri.Printf( PRINT_DEVELOPER, "WARNING: reused image %s with mixed mipmap parm\n", name );
+				}
+				if ( image->allowPicmip != allowPicmip ) {
+					ri.Printf( PRINT_DEVELOPER, "WARNING: reused image %s with mixed allowPicmip parm\n", name );
+				}
+				if ( image->wrapClampMode != glWrapClampMode ) {
+					ri.Printf( PRINT_ALL, "WARNING: reused image %s with mixed glWrapClampMode parm\n", name );
+				}
+			}
+			return image;
+		}
+	}
+
+	//
+	// load the pic from disk
+	//
+	R_LoadImage( name, &pic, &width, &height );
+	if ( pic == NULL ) {
+		return NULL;
+	}
+
+	image = R_CreateImage( ( char * ) name, pic, width, height, mipmap, allowPicmip, glWrapClampMode );
+	ri.Free( pic );
+	return image;
+}
+
+
+/*
+================
+R_CreateDlightImage
+================
+*/
+#define	DLIGHT_SIZE	16
+static void R_CreateDlightImage( void ) {
+	int		x,y;
+	byte	data[DLIGHT_SIZE][DLIGHT_SIZE][4];
+	int		b;
+
+	// make a centered inverse-square falloff blob for dynamic lighting
+	for (x=0 ; x<DLIGHT_SIZE ; x++) {
+		for (y=0 ; y<DLIGHT_SIZE ; y++) {
+			float	d;
+
+			d = ( DLIGHT_SIZE/2 - 0.5f - x ) * ( DLIGHT_SIZE/2 - 0.5f - x ) +
+				( DLIGHT_SIZE/2 - 0.5f - y ) * ( DLIGHT_SIZE/2 - 0.5f - y );
+			b = 4000 / d;
+			if (b > 255) {
+				b = 255;
+			} else if ( b < 75 ) {
+				b = 0;
+			}
+			data[y][x][0] = 
+			data[y][x][1] = 
+			data[y][x][2] = b;
+			data[y][x][3] = 255;			
+		}
+	}
+	tr.dlightImage = R_CreateImage("*dlight", (byte *)data, DLIGHT_SIZE, DLIGHT_SIZE, qfalse, qfalse, GL_CLAMP_TO_EDGE );
+}
+
+
+/*
+=================
+R_InitFogTable
+=================
+*/
+void R_InitFogTable( void ) {
+	int		i;
+	float	d;
+	float	exp;
+	
+	exp = 0.5;
+
+	for ( i = 0 ; i < FOG_TABLE_SIZE ; i++ ) {
+		d = pow ( (float)i/(FOG_TABLE_SIZE-1), exp );
+
+		tr.fogTable[i] = d;
+	}
+}
+
+/*
+================
+R_FogFactor
+
+Returns a 0.0 to 1.0 fog density value
+This is called for each texel of the fog texture on startup
+and for each vertex of transparent shaders in fog dynamically
+================
+*/
+float	R_FogFactor( float s, float t ) {
+	float	d;
+
+	s -= 1.0/512;
+	if ( s < 0 ) {
+		return 0;
+	}
+	if ( t < 1.0/32 ) {
+		return 0;
+	}
+	if ( t < 31.0/32 ) {
+		s *= (t - 1.0f/32.0f) / (30.0f/32.0f);
+	}
+
+	// we need to leave a lot of clamp range
+	s *= 8;
+
+	if ( s > 1.0 ) {
+		s = 1.0;
+	}
+
+	d = tr.fogTable[ (int)(s * (FOG_TABLE_SIZE-1)) ];
+
+	return d;
+}
+
+/*
+================
+R_CreateFogImage
+================
+*/
+#define	FOG_S	256
+#define	FOG_T	32
+static void R_CreateFogImage( void ) {
+	int		x,y;
+	byte	*data;
+	float	g;
+	float	d;
+	float	borderColor[4];
+
+	data = ri.Hunk_AllocateTempMemory( FOG_S * FOG_T * 4 );
+
+	g = 2.0;
+
+	// S is distance, T is depth
+	for (x=0 ; x<FOG_S ; x++) {
+		for (y=0 ; y<FOG_T ; y++) {
+			d = R_FogFactor( ( x + 0.5f ) / FOG_S, ( y + 0.5f ) / FOG_T );
+
+			data[(y*FOG_S+x)*4+0] = 
+			data[(y*FOG_S+x)*4+1] = 
+			data[(y*FOG_S+x)*4+2] = 255;
+			data[(y*FOG_S+x)*4+3] = 255*d;
+		}
+	}
+	// standard openGL clamping doesn't really do what we want -- it includes
+	// the border color at the edges.  OpenGL 1.2 has clamp-to-edge, which does
+	// what we want.
+	tr.fogImage = R_CreateImage("*fog", (byte *)data, FOG_S, FOG_T, qfalse, qfalse, GL_CLAMP_TO_EDGE );
+	ri.Hunk_FreeTempMemory( data );
+
+	borderColor[0] = 1.0;
+	borderColor[1] = 1.0;
+	borderColor[2] = 1.0;
+	borderColor[3] = 1;
+
+	qglTexParameterfv( GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor );
+}
+
+/*
+==================
+R_CreateDefaultImage
+==================
+*/
+#define	DEFAULT_SIZE	16
+static void R_CreateDefaultImage( void ) {
+	int		x;
+	byte	data[DEFAULT_SIZE][DEFAULT_SIZE][4];
+
+	// the default image will be a box, to allow you to see the mapping coordinates
+	Com_Memset( data, 32, sizeof( data ) );
+	for ( x = 0 ; x < DEFAULT_SIZE ; x++ ) {
+		data[0][x][0] =
+		data[0][x][1] =
+		data[0][x][2] =
+		data[0][x][3] = 255;
+
+		data[x][0][0] =
+		data[x][0][1] =
+		data[x][0][2] =
+		data[x][0][3] = 255;
+
+		data[DEFAULT_SIZE-1][x][0] =
+		data[DEFAULT_SIZE-1][x][1] =
+		data[DEFAULT_SIZE-1][x][2] =
+		data[DEFAULT_SIZE-1][x][3] = 255;
+
+		data[x][DEFAULT_SIZE-1][0] =
+		data[x][DEFAULT_SIZE-1][1] =
+		data[x][DEFAULT_SIZE-1][2] =
+		data[x][DEFAULT_SIZE-1][3] = 255;
+	}
+	tr.defaultImage = R_CreateImage("*default", (byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, qtrue, qfalse, GL_REPEAT );
+}
+
+/*
+==================
+R_CreateBuiltinImages
+==================
+*/
+void R_CreateBuiltinImages( void ) {
+	int		x,y;
+	byte	data[DEFAULT_SIZE][DEFAULT_SIZE][4];
+
+	R_CreateDefaultImage();
+
+	// we use a solid white image instead of disabling texturing
+	Com_Memset( data, 255, sizeof( data ) );
+	tr.whiteImage = R_CreateImage("*white", (byte *)data, 8, 8, qfalse, qfalse, GL_REPEAT );
+
+	// with overbright bits active, we need an image which is some fraction of full color,
+	// for default lightmaps, etc
+	for (x=0 ; x<DEFAULT_SIZE ; x++) {
+		for (y=0 ; y<DEFAULT_SIZE ; y++) {
+			data[y][x][0] = 
+			data[y][x][1] = 
+			data[y][x][2] = tr.identityLightByte;
+			data[y][x][3] = 255;			
+		}
+	}
+
+	tr.identityLightImage = R_CreateImage("*identityLight", (byte *)data, 8, 8, qfalse, qfalse, GL_REPEAT );
+
+
+	for(x=0;x<32;x++) {
+		// scratchimage is usually used for cinematic drawing
+		tr.scratchImage[x] = R_CreateImage("*scratch", (byte *)data, DEFAULT_SIZE, DEFAULT_SIZE, qfalse, qtrue, GL_CLAMP_TO_EDGE );
+	}
+
+	R_CreateDlightImage();
+	R_CreateFogImage();
+}
+
+
+/*
+===============
+R_SetColorMappings
+===============
+*/
+void R_SetColorMappings( void ) {
+	int		i, j;
+	float	g;
+	int		inf;
+	int		shift;
+
+	// setup the overbright lighting
+	tr.overbrightBits = r_overBrightBits->integer;
+	if ( !glConfig.deviceSupportsGamma ) {
+		tr.overbrightBits = 0;		// need hardware gamma for overbright
+	}
+
+	// never overbright in windowed mode
+	if ( !glConfig.isFullscreen ) 
+	{
+		tr.overbrightBits = 0;
+	}
+
+	// allow 2 overbright bits in 24 bit, but only 1 in 16 bit
+	if ( glConfig.colorBits > 16 ) {
+		if ( tr.overbrightBits > 2 ) {
+			tr.overbrightBits = 2;
+		}
+	} else {
+		if ( tr.overbrightBits > 1 ) {
+			tr.overbrightBits = 1;
+		}
+	}
+	if ( tr.overbrightBits < 0 ) {
+		tr.overbrightBits = 0;
+	}
+
+	tr.identityLight = 1.0f / ( 1 << tr.overbrightBits );
+	tr.identityLightByte = 255 * tr.identityLight;
+
+
+	if ( r_intensity->value <= 1 ) {
+		ri.Cvar_Set( "r_intensity", "1" );
+	}
+
+	if ( r_gamma->value < 0.5f ) {
+		ri.Cvar_Set( "r_gamma", "0.5" );
+	} else if ( r_gamma->value > 3.0f ) {
+		ri.Cvar_Set( "r_gamma", "3.0" );
+	}
+
+	g = r_gamma->value;
+
+	shift = tr.overbrightBits;
+
+	for ( i = 0; i < 256; i++ ) {
+		if ( g == 1 ) {
+			inf = i;
+		} else {
+			inf = 255 * pow ( i/255.0f, 1.0f / g ) + 0.5f;
+		}
+		inf <<= shift;
+		if (inf < 0) {
+			inf = 0;
+		}
+		if (inf > 255) {
+			inf = 255;
+		}
+		s_gammatable[i] = inf;
+	}
+
+	for (i=0 ; i<256 ; i++) {
+		j = i * r_intensity->value;
+		if (j > 255) {
+			j = 255;
+		}
+		s_intensitytable[i] = j;
+	}
+
+	if ( glConfig.deviceSupportsGamma )
+	{
+		GLimp_SetGamma( s_gammatable, s_gammatable, s_gammatable );
+	}
+}
+
+/*
+===============
+R_InitImages
+===============
+*/
+void	R_InitImages( void ) {
+	Com_Memset(hashTable, 0, sizeof(hashTable));
+	// build brightness translation tables
+	R_SetColorMappings();
+
+	// create default texture and white texture
+	R_CreateBuiltinImages();
+}
+
+/*
+===============
+R_DeleteTextures
+===============
+*/
+void R_DeleteTextures( void ) {
+	int		i;
+
+	for ( i=0; i<tr.numImages ; i++ ) {
+		qglDeleteTextures( 1, &tr.images[i]->texnum );
+	}
+	Com_Memset( tr.images, 0, sizeof( tr.images ) );
+
+	tr.numImages = 0;
+
+	Com_Memset( glState.currenttextures, 0, sizeof( glState.currenttextures ) );
+	if ( qglActiveTextureARB ) {
+		GL_SelectTexture( 1 );
+		qglBindTexture( GL_TEXTURE_2D, 0 );
+		GL_SelectTexture( 0 );
+		qglBindTexture( GL_TEXTURE_2D, 0 );
+	} else {
+		qglBindTexture( GL_TEXTURE_2D, 0 );
+	}
+}
+
+/*
+============================================================================
+
+SKINS
+
+============================================================================
+*/
+
+/*
+==================
+CommaParse
+
+This is unfortunate, but the skin files aren't
+compatable with our normal parsing rules.
+==================
+*/
+static char *CommaParse( char **data_p ) {
+	int c = 0, len;
+	char *data;
+	static	char	com_token[MAX_TOKEN_CHARS];
+
+	data = *data_p;
+	len = 0;
+	com_token[0] = 0;
+
+	// make sure incoming data is valid
+	if ( !data ) {
+		*data_p = NULL;
+		return com_token;
+	}
+
+	while ( 1 ) {
+		// skip whitespace
+		while( (c = *data) <= ' ') {
+			if( !c ) {
+				break;
+			}
+			data++;
+		}
+
+
+		c = *data;
+
+		// skip double slash comments
+		if ( c == '/' && data[1] == '/' )
+		{
+			while (*data && *data != '\n')
+				data++;
+		}
+		// skip /* */ comments
+		else if ( c=='/' && data[1] == '*' ) 
+		{
+			while ( *data && ( *data != '*' || data[1] != '/' ) ) 
+			{
+				data++;
+			}
+			if ( *data ) 
+			{
+				data += 2;
+			}
+		}
+		else
+		{
+			break;
+		}
+	}
+
+	if ( c == 0 ) {
+		return "";
+	}
+
+	// handle quoted strings
+	if (c == '\"')
+	{
+		data++;
+		while (1)
+		{
+			c = *data++;
+			if (c=='\"' || !c)
+			{
+				com_token[len] = 0;
+				*data_p = ( char * ) data;
+				return com_token;
+			}
+			if (len < MAX_TOKEN_CHARS)
+			{
+				com_token[len] = c;
+				len++;
+			}
+		}
+	}
+
+	// parse a regular word
+	do
+	{
+		if (len < MAX_TOKEN_CHARS)
+		{
+			com_token[len] = c;
+			len++;
+		}
+		data++;
+		c = *data;
+	} while (c>32 && c != ',' );
+
+	if (len == MAX_TOKEN_CHARS)
+	{
+//		Com_Printf ("Token exceeded %i chars, discarded.\n", MAX_TOKEN_CHARS);
+		len = 0;
+	}
+	com_token[len] = 0;
+
+	*data_p = ( char * ) data;
+	return com_token;
+}
+
+
+/*
+===============
+RE_RegisterSkin
+
+===============
+*/
+qhandle_t RE_RegisterSkin( const char *name ) {
+	qhandle_t	hSkin;
+	skin_t		*skin;
+	skinSurface_t	*surf;
+	union {
+		char *c;
+		void *v;
+	} text;
+	char		*text_p;
+	char		*token;
+	char		surfName[MAX_QPATH];
+
+	if ( !name || !name[0] ) {
+		Com_Printf( "Empty name passed to RE_RegisterSkin\n" );
+		return 0;
+	}
+
+	if ( strlen( name ) >= MAX_QPATH ) {
+		Com_Printf( "Skin name exceeds MAX_QPATH\n" );
+		return 0;
+	}
+
+
+	// see if the skin is already loaded
+	for ( hSkin = 1; hSkin < tr.numSkins ; hSkin++ ) {
+		skin = tr.skins[hSkin];
+		if ( !Q_stricmp( skin->name, name ) ) {
+			if( skin->numSurfaces == 0 ) {
+				return 0;		// default skin
+			}
+			return hSkin;
+		}
+	}
+
+	// allocate a new skin
+	if ( tr.numSkins == MAX_SKINS ) {
+		ri.Printf( PRINT_WARNING, "WARNING: RE_RegisterSkin( '%s' ) MAX_SKINS hit\n", name );
+		return 0;
+	}
+	tr.numSkins++;
+	skin = ri.Hunk_Alloc( sizeof( skin_t ), h_low );
+	tr.skins[hSkin] = skin;
+	Q_strncpyz( skin->name, name, sizeof( skin->name ) );
+	skin->numSurfaces = 0;
+
+	// make sure the render thread is stopped
+	R_SyncRenderThread();
+
+	// If not a .skin file, load as a single shader
+	if ( strcmp( name + strlen( name ) - 5, ".skin" ) ) {
+		skin->numSurfaces = 1;
+		skin->surfaces[0] = ri.Hunk_Alloc( sizeof(skin->surfaces[0]), h_low );
+		skin->surfaces[0]->shader = R_FindShader( name, LIGHTMAP_NONE, qtrue );
+		return hSkin;
+	}
+
+	// load and parse the skin file
+    ri.FS_ReadFile( name, &text.v );
+	if ( !text.c ) {
+		return 0;
+	}
+
+	text_p = text.c;
+	while ( text_p && *text_p ) {
+		// get surface name
+		token = CommaParse( &text_p );
+		Q_strncpyz( surfName, token, sizeof( surfName ) );
+
+		if ( !token[0] ) {
+			break;
+		}
+		// lowercase the surface name so skin compares are faster
+		Q_strlwr( surfName );
+
+		if ( *text_p == ',' ) {
+			text_p++;
+		}
+
+		if ( strstr( token, "tag_" ) ) {
+			continue;
+		}
+		
+		// parse the shader name
+		token = CommaParse( &text_p );
+
+		surf = skin->surfaces[ skin->numSurfaces ] = ri.Hunk_Alloc( sizeof( *skin->surfaces[0] ), h_low );
+		Q_strncpyz( surf->name, surfName, sizeof( surf->name ) );
+		surf->shader = R_FindShader( token, LIGHTMAP_NONE, qtrue );
+		skin->numSurfaces++;
+	}
+
+	ri.FS_FreeFile( text.v );
+
+
+	// never let a skin have 0 shaders
+	if ( skin->numSurfaces == 0 ) {
+		return 0;		// use default skin
+	}
+
+	return hSkin;
+}
+
+
+/*
+===============
+R_InitSkins
+===============
+*/
+void	R_InitSkins( void ) {
+	skin_t		*skin;
+
+	tr.numSkins = 1;
+
+	// make the default skin have all default shaders
+	skin = tr.skins[0] = ri.Hunk_Alloc( sizeof( skin_t ), h_low );
+	Q_strncpyz( skin->name, "<default skin>", sizeof( skin->name )  );
+	skin->numSurfaces = 1;
+	skin->surfaces[0] = ri.Hunk_Alloc( sizeof( *skin->surfaces ), h_low );
+	skin->surfaces[0]->shader = tr.defaultShader;
+}
+
+/*
+===============
+R_GetSkinByHandle
+===============
+*/
+skin_t	*R_GetSkinByHandle( qhandle_t hSkin ) {
+	if ( hSkin < 1 || hSkin >= tr.numSkins ) {
+		return tr.skins[0];
+	}
+	return tr.skins[ hSkin ];
+}
+
+/*
+===============
+R_SkinList_f
+===============
+*/
+void	R_SkinList_f( void ) {
+	int			i, j;
+	skin_t		*skin;
+
+	ri.Printf (PRINT_ALL, "------------------\n");
+
+	for ( i = 0 ; i < tr.numSkins ; i++ ) {
+		skin = tr.skins[i];
+
+		ri.Printf( PRINT_ALL, "%3i:%s\n", i, skin->name );
+		for ( j = 0 ; j < skin->numSurfaces ; j++ ) {
+			ri.Printf( PRINT_ALL, "       %s = %s\n", 
+				skin->surfaces[j]->name, skin->surfaces[j]->shader->name );
+		}
+	}
+	ri.Printf (PRINT_ALL, "------------------\n");
+}
+
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_image.c.rej tremulous-ggp1-src/src/renderer/tr_image.c.rej
--- tremulous-ggp1-src.p/src/renderer/tr_image.c.rej	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_image.c.rej	2012-07-19 04:25:52.031556446 +0200
@@ -0,0 +1,434 @@
+--- src/renderer/tr_image.c	(Revision 2062)
++++ src/renderer/tr_image.c	(Arbeitskopie)
+@@ -657,128 +837,362 @@
+ 	{0,0,255,128},
+ };
+ 
++static qboolean TexFormatSupported( GLenum internalFormat, int width, int height ) {
++	qglTexImage2D (GL_PROXY_TEXTURE_2D, 0, internalFormat,
++		       width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
++	qglGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, 0,
++				  GL_TEXTURE_WIDTH, &width);
++	return (width != 0);
++}
+ 
++static qboolean IsCompressedFormat( GLenum format ) {
++	switch( format ) {
++	case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
++	case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
++	case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
++	case GL_COMPRESSED_LUMINANCE_LATC1_EXT:
++	case GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:
++		return qtrue;
++	case GL_RGBA8:
++		return qfalse;
++	default:
++		ri.Printf( PRINT_WARNING, "unknown texture format %x\n", format );
++		return qfalse;
++	}
++}
++
++static void UncompressImage( GLenum format, int width, int height,
++			     byte *in, byte *out ) {
++	int             x, y, alphasize, row = 4*width;
++	unsigned short  col0, col1;
++	color4ub_t      palette[16];
++	unsigned int    colorbits0, colorbits1, alphabits0, alphabits1, alphamask;
++
++	for( x = 0; x < width; x += 4 ) {
++		for( y = 0; x < height; y += 4 ) {
++			switch( format ) {
++			case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
++			case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
++			case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
++				// setup color palette
++				col0 = in[0] | (in[1] << 8); // R5G6B5
++				col1 = in[2] | (in[3] << 8);
++
++				palette[0][0] = ((col0 >> 8) & 0xf8) | ((col0 >> 13) & 0x07);
++				palette[0][1] = ((col0 >> 3) & 0xfc) | ((col0 >> 9) & 0x03);
++				palette[0][2] = ((col0 << 3) & 0xf8) | (col0 & 0x07);
++				palette[0][3] = 255;
++
++				palette[1][0] = ((col1 >> 8) & 0xf8) | ((col1 >> 13) & 0x07);
++				palette[1][1] = ((col1 >> 3) & 0xfc) | ((col1 >> 9) & 0x03);
++				palette[1][2] = ((col1 << 3) & 0xf8) | (col1 & 0x07);
++				palette[1][3] = 255;
++
++				if( col0 <= col1 ) {
++					palette[2][0] = (palette[0][0] + palette[1][0]) >> 1;
++					palette[2][1] = (palette[0][1] + palette[1][1]) >> 1;
++					palette[2][2] = (palette[0][2] + palette[1][2]) >> 1;
++					palette[2][3] = 255;
++					palette[3][0] = 0;
++					palette[3][1] = 0;
++					palette[3][2] = 0;
++					palette[3][3] = 0; // will be overwritten for non-DXT1 formats
++				} else {
++					palette[2][0] = (2*palette[0][0] + palette[1][0]) / 3;
++					palette[2][1] = (2*palette[0][1] + palette[1][1]) / 3;
++					palette[2][2] = (2*palette[0][2] + palette[1][2]) / 3;
++					palette[2][3] = 255;
++					palette[3][0] = (palette[0][0] + 2*palette[1][0]) / 3;
++					palette[3][1] = (palette[0][1] + 2*palette[1][1]) / 3;
++					palette[3][2] = (palette[0][2] + 2*palette[1][2]) / 3;
++					palette[3][3] = 255;
++				}
++				colorbits0 = in[2] + (in[3] << 8) + (in[4] << 16);
++				colorbits1 = in[5] + (in[6] << 8) + (in[7] << 16);
++				break;
++			case GL_COMPRESSED_LUMINANCE_LATC1_EXT:
++			case GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:
++				palette[0][0] = palette[0][1] = palette[0][2] = in[8];
++				palette[1][0] = palette[1][1] = palette[1][2] = in[9];
++				if( in[8] > in[9] ) {
++					palette[2][0] = palette[2][1] = palette[2][2] =
++						(6*in[8] + 1*in[9]) / 7;
++					palette[3][0] = palette[3][1] = palette[3][2] =
++						(5*in[8] + 2*in[9]) / 7;
++					palette[4][0] = palette[4][1] = palette[4][2] =
++						(4*in[8] + 3*in[9]) / 7;
++					palette[5][0] = palette[5][1] = palette[5][2] =
++						(3*in[8] + 4*in[9]) / 7;
++					palette[6][0] = palette[6][1] = palette[6][2] =
++						(2*in[8] + 5*in[9]) / 7;
++					palette[7][0] = palette[7][1] = palette[7][2] =
++						(1*in[8] + 6*in[9]) / 7;
++				} else {
++					palette[2][0] = palette[2][1] = palette[2][2] =
++						(4*in[8] + 1*in[9]) / 5;
++					palette[3][0] = palette[3][1] = palette[3][2] =
++						(3*in[8] + 2*in[9]) / 5;
++					palette[4][0] = palette[4][1] = palette[4][2] =
++						(2*in[8] + 3*in[9]) / 5;
++					palette[5][0] = palette[5][1] = palette[5][2] =
++						(1*in[8] + 4*in[9]) / 5;
++					palette[6][0] = palette[6][1] = palette[6][2] =
++						0;
++					palette[7][0] = palette[7][1] = palette[7][2] =
++						255;
++				}
++				break;
++			default:
++				ri.Error( ERR_DROP, "Uncompress of format %x not implemented\n", format );
++				break;
++			}
++
++			// setup alpha palette
++			switch( format ) {
++			case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
++			case GL_COMPRESSED_LUMINANCE_LATC1_EXT:
++				alphasize = 0;
++				break;
++			case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
++				palette[0][3] = 0x00;
++				palette[1][3] = 0x11;
++				palette[2][3] = 0x22;
++				palette[3][3] = 0x33;
++				palette[4][3] = 0x44;
++				palette[5][3] = 0x55;
++				palette[6][3] = 0x66;
++				palette[7][3] = 0x77;
++				palette[8][3] = 0x88;
++				palette[9][3] = 0x99;
++				palette[10][3] = 0xaa;
++				palette[11][3] = 0xbb;
++				palette[12][3] = 0xcc;
++				palette[13][3] = 0xdd;
++				palette[14][3] = 0xee;
++				palette[15][3] = 0xff;
++				
++				alphasize = 4; alphamask = 0x0f;
++				alphabits0 = in[8] + (in[9] << 8) + (in[10] << 16) + (in[11] << 24);
++				alphabits1 = in[12] + (in[13] << 8) + (in[14] << 16) + (in[15] << 24);
++				break;
++			case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
++			case GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:
++				palette[0][3] = in[8];
++				palette[1][3] = in[9];
++				if( in[8] > in[9] ) {
++					palette[2][3] = (6*in[8] + 1*in[9]) / 7;
++					palette[3][3] = (5*in[8] + 2*in[9]) / 7;
++					palette[4][3] = (4*in[8] + 3*in[9]) / 7;
++					palette[5][3] = (3*in[8] + 4*in[9]) / 7;
++					palette[6][3] = (2*in[8] + 5*in[9]) / 7;
++					palette[7][3] = (1*in[8] + 6*in[9]) / 7;
++				} else {
++					palette[2][3] = (4*in[8] + 1*in[9]) / 5;
++					palette[3][3] = (3*in[8] + 2*in[9]) / 5;
++					palette[4][3] = (2*in[8] + 3*in[9]) / 5;
++					palette[5][3] = (1*in[8] + 4*in[9]) / 5;
++					palette[6][3] = 0;
++					palette[7][3] = 255;
++				}
++				
++				alphasize = 3; alphamask = 0x07;
++				alphabits0 = in[10] + (in[11] << 8) + (in[12] << 16);
++				alphabits1 = in[13] + (in[14] << 8) + (in[15] << 16);
++				break;
++			}
++
++			// decode 16 pixels
++#define decodePixel(xoff, yoff, wordidx)				\
++			if( (xoff == 0 || x + xoff < width) && (yoff == 0 || y + yoff < height) ) { \
++				int off = 4*(xoff + row * yoff);	\
++				out[off+0] = palette[colorbits##wordidx & 0x07][0]; \
++				out[off+1] = palette[colorbits##wordidx & 0x07][1]; \
++				out[off+2] = palette[colorbits##wordidx & 0x07][2]; \
++				if( alphasize ) {			\
++					out[off+3] = palette[alphabits##wordidx & alphamask][3]; \
++				} else {				\
++					out[off+3] = palette[colorbits##wordidx & 0x07][3]; \
++				}					\
++			}						\
++			alphabits##wordidx >>= alphasize;		\
++			colorbits##wordidx >>= 3;
++			
++			decodePixel( 0, 0, 0 );
++			decodePixel( 0, 1, 0 );
++			decodePixel( 0, 2, 0 );
++			decodePixel( 0, 3, 0 );
++			decodePixel( 1, 0, 0 );
++			decodePixel( 1, 1, 0 );
++			decodePixel( 1, 2, 0 );
++			decodePixel( 1, 3, 0 );
++			decodePixel( 2, 0, 1 );
++			decodePixel( 2, 1, 1 );
++			decodePixel( 2, 2, 1 );
++			decodePixel( 2, 3, 1 );
++			decodePixel( 3, 0, 1 );
++			decodePixel( 3, 1, 1 );
++			decodePixel( 3, 2, 1 );
++			decodePixel( 3, 3, 1 );
++#undef decodePixel			
++			out += 4*(width - x > 4 ? 4 : width - x);
++		}
++		out += 3*row;
++	}
++}
++
+ /*
+ ===============
+ Upload32
+ 
++Upload a color texture with all required mipmaps
+ ===============
+ */
+-extern qboolean charSet;
+-static void Upload32( unsigned *data, 
+-						  int width, int height, 
+-						  qboolean mipmap, 
+-						  qboolean picmip, 
+-							qboolean lightMap,
+-						  int *format, 
+-						  int *pUploadWidth, int *pUploadHeight )
++static void Upload32( texImage_t *pic,
++		      int width, int height, 
++		      qboolean mipmap, 
++		      qboolean picmip, 
++		      qboolean lightMap,
++		      int *format, 
++		      int *pUploadWidth, int *pUploadHeight,
++		      qboolean *hasAlpha, int *maxMipLevel )
+ {
+-	int			samples;
+-	unsigned	*scaledBuffer = NULL;
+-	unsigned	*resampledBuffer = NULL;
+-	int			scaled_width, scaled_height;
+-	int			i, c;
++	int		base_level, max_level;
++	int		pot_width, pot_height, w, h, w2, h2;
++	qboolean	compressed = qfalse;
++	qboolean	uncompress = qfalse;
++	qboolean	rescale = qfalse;
++	qboolean	hasColor = qfalse;
++	int		samples;
++	byte		*data = pic->data[0];
++	byte		*uncompressedBuffer = NULL;
++	byte		*resampledBuffer = NULL;
++	int		i, c;
+ 	byte		*scan;
+ 	GLenum		internalFormat = GL_RGB;
+-	float		rMax = 0, gMax = 0, bMax = 0;
+ 
+ 	//
+ 	// convert to exact power of 2 sizes
+ 	//
+-	for (scaled_width = 1 ; scaled_width < width ; scaled_width<<=1)
++	for( pot_width = 1 ; pot_width < width ; pot_width<<=1)
+ 		;
+-	for (scaled_height = 1 ; scaled_height < height ; scaled_height<<=1)
++	for( pot_height = 1 ; pot_height < height ; pot_height<<=1)
+ 		;
+-	if ( r_roundImagesDown->integer && scaled_width > width )
+-		scaled_width >>= 1;
+-	if ( r_roundImagesDown->integer && scaled_height > height )
+-		scaled_height >>= 1;
+ 
+-	if ( scaled_width != width || scaled_height != height ) {
+-		resampledBuffer = ri.Hunk_AllocateTempMemory( scaled_width * scaled_height * 4 );
+-		ResampleTexture (data, width, height, resampledBuffer, scaled_width, scaled_height);
+-		data = resampledBuffer;
+-		width = scaled_width;
+-		height = scaled_height;
+-	}
++	if ( r_roundImagesDown->integer && pot_width > width )
++		pot_width >>= 1;
++	if ( r_roundImagesDown->integer && pot_height > height )
++		pot_height >>= 1;
+ 
+ 	//
+-	// perform optional picmip operation
++	// compute mip levels
+ 	//
+-	if ( picmip ) {
+-		scaled_width >>= r_picmip->integer;
+-		scaled_height >>= r_picmip->integer;
++	base_level = 0;
++	if( picmip && r_picmip->integer >= 0 )
++		base_level = r_picmip->integer;
++
++	w = width;
++	h = height;
++	max_level = 0;
++	while( w > 1 || h > 1 ) {
++		// OpenGL rounds down non-pot sizes
++		w >>= 1;
++		h >>= 1;
++		max_level++;
+ 	}
+ 
+-	//
+-	// clamp to minimum size
+-	//
+-	if (scaled_width < 1) {
+-		scaled_width = 1;
++	// compressed textures require all mip levels
++	if( (compressed = IsCompressedFormat( pic->format )) ) {
++		if( !qglCompressedTexImage2DARB ) {
++			uncompress = qtrue;
++		} else if( pic->numMipmaps < max_level + 1 ) {
++			uncompress = qtrue;
++		}
+ 	}
+-	if (scaled_height < 1) {
+-		scaled_height = 1;
++
++	// find best texture format supported
++	w = width; h = height; w2 = pot_width; h2 = pot_height;
++	for( i = 0; i <= max_level; i++ ) {
++		if( i < base_level )
++			continue;
++		if( compressed && !uncompress &&
++		    TexFormatSupported( pic->format, w, h ) ) {
++			break;
++		}
++		if( TexFormatSupported( GL_RGBA8, w, h ) ) {
++			uncompress = compressed;
++			break;
++		}
++		if( TexFormatSupported( GL_RGBA8, w2, h2 ) ) {
++			uncompress = compressed;
++			rescale = qtrue;
++			break;
++		}
+ 	}
++	base_level = i;
++	if( !mipmap ) {
++		max_level = base_level;
++	}
+ 
+-	//
+-	// clamp to the current upper OpenGL limit
+-	// scale both axis down equally so we don't have to
+-	// deal with a half mip resampling
+-	//
+-	while ( scaled_width > glConfig.maxTextureSize
+-		|| scaled_height > glConfig.maxTextureSize ) {
+-		scaled_width >>= 1;
+-		scaled_height >>= 1;
++	if( uncompress ) {
++		uncompressedBuffer = ri.Hunk_AllocateTempMemory( width * height * sizeof(color4ub_t) );
++		UncompressImage( pic->format, width, height,
++				 data, uncompressedBuffer );
++		data = uncompressedBuffer;
++		compressed = qfalse;
++		pic->numMipmaps = 1;
+ 	}
+ 
+-	scaledBuffer = ri.Hunk_AllocateTempMemory( sizeof( unsigned ) * scaled_width * scaled_height );
++	if ( rescale ) {
++		resampledBuffer = ri.Hunk_AllocateTempMemory( pot_width * pot_height * 4 );
++		ResampleTexture (data, width, height, resampledBuffer, pot_width, pot_height);
++		data = resampledBuffer;
+ 
++		width = pot_width;
++		height = pot_height;
++		pic->numMipmaps = 1;
++	}
++
+ 	//
+ 	// scan the texture for each channel's max values
+ 	// and verify if the alpha channel is being used or not
+ 	//
+ 	c = width*height;
+-	scan = ((byte *)data);
++	scan = data;
+ 	samples = 3;
+ 
+-	if(lightMap)
+-	{
++	if(lightMap) {
+ 		if(r_greyscale->integer)
+ 			internalFormat = GL_LUMINANCE;
+ 		else
+ 			internalFormat = GL_RGB;
+-	}
+-	else
+-	{
++	} else if( compressed ) {
++		internalFormat = pic->format;
++		*hasAlpha = qtrue;
++	} else {
+ 		for ( i = 0; i < c; i++ )
+ 		{
+-			if ( scan[i*4+0] > rMax )
+-			{
+-				rMax = scan[i*4+0];
++			if( scan[i*4 + 0] != scan[i*4 + 1] || scan[i*4 + 0] != scan[i*4 + 2] ) {
++				hasColor = qtrue;
++				if( samples == 4 )
++					break;
+ 			}
+-			if ( scan[i*4+1] > gMax )
++			if( scan[i*4 + 3] != 255 ) 
+ 			{
+-				gMax = scan[i*4+1];
+-			}
+-			if ( scan[i*4+2] > bMax )
+-			{
+-				bMax = scan[i*4+2];
+-			}
+-			if ( scan[i*4 + 3] != 255 ) 
+-			{
+ 				samples = 4;
+-				break;
++				if( hasColor )
++					break;
+ 			}
+ 		}
+ 		// select proper internal format
+ 		if ( samples == 3 )
+ 		{
+-			if(r_greyscale->integer)
++			*hasAlpha = qfalse;
++			if( r_greyscale->integer || !hasColor )
+ 			{
+ 				if(r_texturebits->integer == 16)
+ 					internalFormat = GL_LUMINANCE8;
+ 				else if(r_texturebits->integer == 32)
+-					internalFormat = GL_LUMINANCE16;
++					internalFormat = GL_LUMINANCE8;
+ 				else
+ 					internalFormat = GL_LUMINANCE;
+ 			}
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_image_dds.c tremulous-ggp1-src/src/renderer/tr_image_dds.c
--- tremulous-ggp1-src.p/src/renderer/tr_image_dds.c	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_image_dds.c	2012-07-19 04:25:52.031556446 +0200
@@ -0,0 +1,363 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+
+This file is part of Tremfusion.
+
+Tremfusion is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremfusion is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremfusion; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+
+#include "tr_local.h"
+#define	LL(x) x=LittleLong(x)
+
+#define DDS_MAGIC   0x20534444
+
+// DDS_PIXELFORMAT.dwFlags
+#define DDPF_ALPHAPIXELS 0x00000001
+#define DDPF_ALPHA       0x00000002
+#define DDPF_FOURCC      0x00000004
+#define DDPF_RGB         0x00000040
+#define DDPF_YUV         0x00000200
+#define DDPF_LUMINANCE   0x00020000
+
+#define FOURCC_DX10 0x30315844
+#define FOURCC_DXT1 0x31545844
+#define FOURCC_DXT2 0x32545844
+#define FOURCC_DXT3 0x33545844
+#define FOURCC_DXT4 0x34545844
+#define FOURCC_DXT5 0x35545844
+#define FOURCC_ATI1 0x31495451
+#define FOURCC_ATI2 0x32495451
+
+typedef struct {
+  unsigned int dwSize;
+  unsigned int dwFlags;
+  unsigned int dwFourCC;
+  unsigned int dwRGBBitCount;
+  unsigned int dwRBitMask;
+  unsigned int dwGBitMask;
+  unsigned int dwBBitMask;
+  unsigned int dwABitMask;
+} DDS_PIXELFORMAT;
+
+// DDS_HEADER.dwHeaderFlags
+#define DDSD_CAPS        0x00000001
+#define DDSD_HEIGHT      0x00000002
+#define DDSD_WIDTH       0x00000004
+#define DDSD_PITCH       0x00000008
+#define DDSD_PIXELFORMAT 0x00001000
+#define DDSD_MIPMAPCOUNT 0x00020000
+#define DDSD_LINEARSIZE  0x00080000
+#define DDSD_DEPTH       0x00800000
+
+// DDS_HEADER.dwSurfaceFlags
+#define DDSCAPS_COMPLEX 0x00000008
+#define DDSCAPS_TEXTURE 0x00001000
+#define DDSCAPS_MIPMAP  0x00400000
+
+// DDS_HEADER.dwCubemapFlags
+#define DDSCAPS2_CUBEMAP           0x00000200
+#define DDSCAPS2_CUBEMAP_POSITIVEX 0x00000400
+#define DDSCAPS2_CUBEMAP_NEGATIVEX 0x00000800
+#define DDSCAPS2_CUBEMAP_POSITIVEY 0x00001000
+#define DDSCAPS2_CUBEMAP_NEGATIVEY 0x00002000
+#define DDSCAPS2_CUBEMAP_POSITIVEZ 0x00004000
+#define DDSCAPS2_CUBEMAP_NEGATIVEZ 0x00008000
+#define DDSCAPS2_VOLUME            0x00200000
+
+typedef struct {
+  unsigned int    dwSize;
+  unsigned int    dwHeaderFlags;
+  unsigned int    dwHeight;
+  unsigned int    dwWidth;
+  unsigned int    dwPitchOrLinearSize;
+  unsigned int    dwDepth;
+  unsigned int    dwMipMapCount;
+  unsigned int    dwReserved1[11];
+  DDS_PIXELFORMAT ddspf;
+  unsigned int    dwSurfaceFlags;
+  unsigned int    dwCubemapFlags;
+  unsigned int    dwReserved2[3];
+} DDS_HEADER;
+
+typedef enum DXGI_FORMAT {
+  DXGI_FORMAT_UNKNOWN                      = 0,
+  DXGI_FORMAT_R32G32B32A32_TYPELESS        = 1,
+  DXGI_FORMAT_R32G32B32A32_FLOAT           = 2,
+  DXGI_FORMAT_R32G32B32A32_UINT            = 3,
+  DXGI_FORMAT_R32G32B32A32_SINT            = 4,
+  DXGI_FORMAT_R32G32B32_TYPELESS           = 5,
+  DXGI_FORMAT_R32G32B32_FLOAT              = 6,
+  DXGI_FORMAT_R32G32B32_UINT               = 7,
+  DXGI_FORMAT_R32G32B32_SINT               = 8,
+  DXGI_FORMAT_R16G16B16A16_TYPELESS        = 9,
+  DXGI_FORMAT_R16G16B16A16_FLOAT           = 10,
+  DXGI_FORMAT_R16G16B16A16_UNORM           = 11,
+  DXGI_FORMAT_R16G16B16A16_UINT            = 12,
+  DXGI_FORMAT_R16G16B16A16_SNORM           = 13,
+  DXGI_FORMAT_R16G16B16A16_SINT            = 14,
+  DXGI_FORMAT_R32G32_TYPELESS              = 15,
+  DXGI_FORMAT_R32G32_FLOAT                 = 16,
+  DXGI_FORMAT_R32G32_UINT                  = 17,
+  DXGI_FORMAT_R32G32_SINT                  = 18,
+  DXGI_FORMAT_R32G8X24_TYPELESS            = 19,
+  DXGI_FORMAT_D32_FLOAT_S8X24_UINT         = 20,
+  DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS     = 21,
+  DXGI_FORMAT_X32_TYPELESS_G8X24_UINT      = 22,
+  DXGI_FORMAT_R10G10B10A2_TYPELESS         = 23,
+  DXGI_FORMAT_R10G10B10A2_UNORM            = 24,
+  DXGI_FORMAT_R10G10B10A2_UINT             = 25,
+  DXGI_FORMAT_R11G11B10_FLOAT              = 26,
+  DXGI_FORMAT_R8G8B8A8_TYPELESS            = 27,
+  DXGI_FORMAT_R8G8B8A8_UNORM               = 28,
+  DXGI_FORMAT_R8G8B8A8_UNORM_SRGB          = 29,
+  DXGI_FORMAT_R8G8B8A8_UINT                = 30,
+  DXGI_FORMAT_R8G8B8A8_SNORM               = 31,
+  DXGI_FORMAT_R8G8B8A8_SINT                = 32,
+  DXGI_FORMAT_R16G16_TYPELESS              = 33,
+  DXGI_FORMAT_R16G16_FLOAT                 = 34,
+  DXGI_FORMAT_R16G16_UNORM                 = 35,
+  DXGI_FORMAT_R16G16_UINT                  = 36,
+  DXGI_FORMAT_R16G16_SNORM                 = 37,
+  DXGI_FORMAT_R16G16_SINT                  = 38,
+  DXGI_FORMAT_R32_TYPELESS                 = 39,
+  DXGI_FORMAT_D32_FLOAT                    = 40,
+  DXGI_FORMAT_R32_FLOAT                    = 41,
+  DXGI_FORMAT_R32_UINT                     = 42,
+  DXGI_FORMAT_R32_SINT                     = 43,
+  DXGI_FORMAT_R24G8_TYPELESS               = 44,
+  DXGI_FORMAT_D24_UNORM_S8_UINT            = 45,
+  DXGI_FORMAT_R24_UNORM_X8_TYPELESS        = 46,
+  DXGI_FORMAT_X24_TYPELESS_G8_UINT         = 47,
+  DXGI_FORMAT_R8G8_TYPELESS                = 48,
+  DXGI_FORMAT_R8G8_UNORM                   = 49,
+  DXGI_FORMAT_R8G8_UINT                    = 50,
+  DXGI_FORMAT_R8G8_SNORM                   = 51,
+  DXGI_FORMAT_R8G8_SINT                    = 52,
+  DXGI_FORMAT_R16_TYPELESS                 = 53,
+  DXGI_FORMAT_R16_FLOAT                    = 54,
+  DXGI_FORMAT_D16_UNORM                    = 55,
+  DXGI_FORMAT_R16_UNORM                    = 56,
+  DXGI_FORMAT_R16_UINT                     = 57,
+  DXGI_FORMAT_R16_SNORM                    = 58,
+  DXGI_FORMAT_R16_SINT                     = 59,
+  DXGI_FORMAT_R8_TYPELESS                  = 60,
+  DXGI_FORMAT_R8_UNORM                     = 61,
+  DXGI_FORMAT_R8_UINT                      = 62,
+  DXGI_FORMAT_R8_SNORM                     = 63,
+  DXGI_FORMAT_R8_SINT                      = 64,
+  DXGI_FORMAT_A8_UNORM                     = 65,
+  DXGI_FORMAT_R1_UNORM                     = 66,
+  DXGI_FORMAT_R9G9B9E5_SHAREDEXP           = 67,
+  DXGI_FORMAT_R8G8_B8G8_UNORM              = 68,
+  DXGI_FORMAT_G8R8_G8B8_UNORM              = 69,
+  DXGI_FORMAT_BC1_TYPELESS                 = 70,
+  DXGI_FORMAT_BC1_UNORM                    = 71,
+  DXGI_FORMAT_BC1_UNORM_SRGB               = 72,
+  DXGI_FORMAT_BC2_TYPELESS                 = 73,
+  DXGI_FORMAT_BC2_UNORM                    = 74,
+  DXGI_FORMAT_BC2_UNORM_SRGB               = 75,
+  DXGI_FORMAT_BC3_TYPELESS                 = 76,
+  DXGI_FORMAT_BC3_UNORM                    = 77,
+  DXGI_FORMAT_BC3_UNORM_SRGB               = 78,
+  DXGI_FORMAT_BC4_TYPELESS                 = 79,
+  DXGI_FORMAT_BC4_UNORM                    = 80,
+  DXGI_FORMAT_BC4_SNORM                    = 81,
+  DXGI_FORMAT_BC5_TYPELESS                 = 82,
+  DXGI_FORMAT_BC5_UNORM                    = 83,
+  DXGI_FORMAT_BC5_SNORM                    = 84,
+  DXGI_FORMAT_B5G6R5_UNORM                 = 85,
+  DXGI_FORMAT_B5G5R5A1_UNORM               = 86,
+  DXGI_FORMAT_B8G8R8A8_UNORM               = 87,
+  DXGI_FORMAT_B8G8R8X8_UNORM               = 88,
+  DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM   = 89,
+  DXGI_FORMAT_B8G8R8A8_TYPELESS            = 90,
+  DXGI_FORMAT_B8G8R8A8_UNORM_SRGB          = 91,
+  DXGI_FORMAT_B8G8R8X8_TYPELESS            = 92,
+  DXGI_FORMAT_B8G8R8X8_UNORM_SRGB          = 93,
+  DXGI_FORMAT_BC6H_TYPELESS                = 94,
+  DXGI_FORMAT_BC6H_UF16                    = 95,
+  DXGI_FORMAT_BC6H_SF16                    = 96,
+  DXGI_FORMAT_BC7_TYPELESS                 = 97,
+  DXGI_FORMAT_BC7_UNORM                    = 98,
+  DXGI_FORMAT_BC7_UNORM_SRGB               = 99,
+  DXGI_FORMAT_FORCE_UINT                   = 0xffffffffUL 
+} DXGI_FORMAT;
+
+typedef enum {
+  D3D10_RESOURCE_DIMENSION_UNKNOWN     = 0,
+  D3D10_RESOURCE_DIMENSION_BUFFER      = 1,
+  D3D10_RESOURCE_DIMENSION_TEXTURE1D   = 2,
+  D3D10_RESOURCE_DIMENSION_TEXTURE2D   = 3,
+  D3D10_RESOURCE_DIMENSION_TEXTURE3D   = 4 
+} D3D10_RESOURCE_DIMENSION;
+
+// DDS_HEADER_DXT10.miscFlag;
+#define DDS_RESOURCE_MISC_TEXTURECUBE 0x00000004
+
+typedef struct {
+  DXGI_FORMAT              dxgiFormat;
+  D3D10_RESOURCE_DIMENSION resourceDimension;
+  unsigned int             miscFlag;
+  unsigned int             arraySize;
+  unsigned int             reserved;
+} DDS_HEADER_DXT10;
+
+static void SetupBlocks( texImage_t *pic, int width, int height, GLuint format,
+			 int blockW, int blockH, int blockSize, int mipmaps,
+			 byte *data ) {
+	int i;
+	int size = 0;
+
+	pic->format = format;
+	pic->numMipmaps = mipmaps;
+
+	for( i = 0; i < mipmaps; i++ ) {
+		int blocksHoriz = (width + blockW - 1) / blockW;
+		int blocksVert  = (height + blockH - 1) / blockH;
+
+		pic->size[i] = blocksHoriz * blocksVert * blockSize;
+
+		if( width > 1 ) width >>= 1;
+		if( height > 1 ) height >>= 1;
+
+		size += pic->size[i];
+	}
+
+	pic->data[0] = ri.Malloc(size);
+	Com_Memcpy( pic->data[0], data, size );
+
+	for( i = 1; i < mipmaps; i++ ) {
+		pic->data[i] = pic->data[i-1] + pic->size[i-1];
+	}
+}
+
+void R_LoadDDS ( const char *name, texImage_t *pic, int *width, int *height)
+{
+	union {
+		byte *b;
+		void *v;
+	} buffer;
+	DDS_HEADER *hdr;
+	int length;
+
+	pic->numMipmaps = 0;
+
+	if(width)
+		*width = 0;
+	if(height)
+		*height = 0;
+
+	//
+	// load the file
+	//
+	length = ri.FS_ReadFile ( ( char * ) name, &buffer.v);
+	if (!buffer.b || length < 0) {
+		return;
+	}
+
+	if( length < 4 || Q_strncmp((char *)buffer.v, "DDS ", 4) ) {
+		ri.Error( ERR_DROP, "LoadDDS: missig DDS signature (%s)\n", name );
+	}
+
+	if( length < 4 + sizeof(DDS_HEADER) ) {
+		ri.Error( ERR_DROP, "LoadDDS: DDS header missing (%s)\n", name );
+	}
+	hdr = (DDS_HEADER *)(buffer.b + 4);
+	LL(hdr->dwSize);
+	LL(hdr->dwHeaderFlags);
+	LL(hdr->dwHeight);
+	LL(hdr->dwWidth);
+	LL(hdr->dwMipMapCount);
+	LL(hdr->ddspf.dwSize);
+	LL(hdr->ddspf.dwFlags);
+	LL(hdr->ddspf.dwFourCC);
+	LL(hdr->ddspf.dwRGBBitCount);
+	LL(hdr->ddspf.dwRBitMask);
+	LL(hdr->ddspf.dwGBitMask);
+	LL(hdr->ddspf.dwBBitMask);
+	LL(hdr->ddspf.dwABitMask);
+	LL(hdr->dwSurfaceFlags);
+	LL(hdr->dwCubemapFlags);
+
+	if( hdr->dwSize != sizeof( DDS_HEADER ) ||
+	    hdr->ddspf.dwSize != sizeof( DDS_PIXELFORMAT ) ) {
+		ri.Error( ERR_DROP, "LoadDDS: DDS header missing (%s)\n", name );
+	}
+
+	GLuint glFormat = 0;
+	int    mipmaps = hdr->dwMipMapCount ? hdr->dwMipMapCount : 1;
+	byte  *base = (byte *)(hdr + 1);
+	
+	if( (hdr->ddspf.dwFlags & DDPF_FOURCC) ) {
+		if( hdr->ddspf.dwFourCC == FOURCC_DX10 ) {
+			// has special DX10 header
+			ri.Error( ERR_DROP, "LoadDDS: unsupported texture format(%s)\n", name );
+		} else {
+			// check if it is one of the DXTn formats
+			switch( hdr->ddspf.dwFourCC ) {
+			case FOURCC_DXT1:
+				glFormat = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
+				break;
+			case FOURCC_DXT2:
+			case FOURCC_DXT3:
+				glFormat = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;
+				break;
+			case FOURCC_DXT4:
+			case FOURCC_DXT5:
+				glFormat = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
+				break;
+			case FOURCC_ATI1:
+				glFormat = GL_COMPRESSED_LUMINANCE_LATC1_EXT;
+				break;
+			case FOURCC_ATI2:
+				glFormat = GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT;
+				break;
+			default:
+				ri.Error( ERR_DROP, "LoadDDS: unsupported texture format(%s)\n", name );
+				break;
+			}
+		}
+
+	} else {
+		// linear data
+		glFormat = GL_RGBA8;
+	}
+
+	switch( glFormat ) {
+	case GL_RGBA8:
+		break;
+	case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+		SetupBlocks( pic, hdr->dwWidth, hdr->dwHeight, glFormat,
+			     4, 4, 8, mipmaps, base );
+		break;
+	case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
+		SetupBlocks( pic, hdr->dwWidth, hdr->dwHeight, glFormat,
+			     4, 4, 16, mipmaps, base );
+		break;
+	case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
+		SetupBlocks( pic, hdr->dwWidth, hdr->dwHeight, glFormat,
+			     4, 4, 16, mipmaps, base );
+		break;
+	}
+
+	if (width)
+		*width = hdr->dwWidth;
+	if (height)
+		*height = hdr->dwHeight;
+
+	ri.FS_FreeFile (buffer.v);
+}
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_image_jpg.c tremulous-ggp1-src/src/renderer/tr_image_jpg.c
--- tremulous-ggp1-src.p/src/renderer/tr_image_jpg.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_image_jpg.c	2012-07-19 04:25:52.031556446 +0200
@@ -98,6 +98,8 @@
 	} fbuffer;
   byte  *buf;
 
+  pic->numMipmaps = 0;
+
   /* In this example we want to open the input file before doing anything else,
    * so that the setjmp() error recovery below can assume the file is open.
    * VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
@@ -212,7 +214,9 @@
     buf[--dindex] = buf[--sindex];
   } while(sindex);
 
-  *pic = out;
+  pic->format = GL_RGBA8;
+  pic->numMipmaps = 1;
+  pic->data[0] = out;
 
   /* Step 7: Finish decompression */
 
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_image_jpg.c.orig tremulous-ggp1-src/src/renderer/tr_image_jpg.c.orig
--- tremulous-ggp1-src.p/src/renderer/tr_image_jpg.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_image_jpg.c.orig	2012-07-19 04:25:20.311556052 +0200
@@ -0,0 +1,438 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+
+#include "tr_local.h"
+
+/*
+ * Include file for users of JPEG library.
+ * You will need to have included system headers that define at least
+ * the typedefs FILE and size_t before you can include jpeglib.h.
+ * (stdio.h is sufficient on ANSI-conforming systems.)
+ * You may also wish to include "jerror.h".
+ */
+
+#ifdef USE_INTERNAL_JPEG
+#  define JPEG_INTERNALS
+#endif
+
+#include <jpeglib.h>
+
+#ifndef USE_INTERNAL_JPEG
+#  if JPEG_LIB_VERSION < 80
+#    error Need system libjpeg >= 80
+#  endif
+#endif
+
+static void R_JPGErrorExit(j_common_ptr cinfo)
+{
+  char buffer[JMSG_LENGTH_MAX];
+  
+  (*cinfo->err->format_message) (cinfo, buffer);
+  
+  /* Let the memory manager delete any temp files before we die */
+  jpeg_destroy(cinfo);
+  
+  ri.Error(ERR_FATAL, "%s\n", buffer);
+}
+
+static void R_JPGOutputMessage(j_common_ptr cinfo)
+{
+  char buffer[JMSG_LENGTH_MAX];
+  
+  /* Create the message */
+  (*cinfo->err->format_message) (cinfo, buffer);
+  
+  /* Send it to stderr, adding a newline */
+  ri.Printf(PRINT_ALL, "%s\n", buffer);
+}
+
+void R_LoadJPG(const char *filename, unsigned char **pic, int *width, int *height)
+{
+  /* This struct contains the JPEG decompression parameters and pointers to
+   * working space (which is allocated as needed by the JPEG library).
+   */
+  struct jpeg_decompress_struct cinfo = {NULL};
+  /* We use our private extension JPEG error handler.
+   * Note that this struct must live as long as the main JPEG parameter
+   * struct, to avoid dangling-pointer problems.
+   */
+  /* This struct represents a JPEG error handler.  It is declared separately
+   * because applications often want to supply a specialized error handler
+   * (see the second half of this file for an example).  But here we just
+   * take the easy way out and use the standard error handler, which will
+   * print a message on stderr and call exit() if compression fails.
+   * Note that this struct must live as long as the main JPEG parameter
+   * struct, to avoid dangling-pointer problems.
+   */
+  struct jpeg_error_mgr jerr;
+  /* More stuff */
+  JSAMPARRAY buffer;		/* Output row buffer */
+  unsigned int row_stride;	/* physical row width in output buffer */
+  unsigned int pixelcount, memcount;
+  unsigned int sindex, dindex;
+  byte *out;
+  int len;
+	union {
+		byte *b;
+		void *v;
+	} fbuffer;
+  byte  *buf;
+
+  /* In this example we want to open the input file before doing anything else,
+   * so that the setjmp() error recovery below can assume the file is open.
+   * VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
+   * requires it in order to read binary files.
+   */
+
+  len = ri.FS_ReadFile ( ( char * ) filename, &fbuffer.v);
+  if (!fbuffer.b || len < 0) {
+	return;
+  }
+
+  /* Step 1: allocate and initialize JPEG decompression object */
+
+  /* We have to set up the error handler first, in case the initialization
+   * step fails.  (Unlikely, but it could happen if you are out of memory.)
+   * This routine fills in the contents of struct jerr, and returns jerr's
+   * address which we place into the link field in cinfo.
+   */
+  cinfo.err = jpeg_std_error(&jerr);
+  cinfo.err->error_exit = R_JPGErrorExit;
+  cinfo.err->output_message = R_JPGOutputMessage;
+
+  /* Now we can initialize the JPEG decompression object. */
+  jpeg_create_decompress(&cinfo);
+
+  /* Step 2: specify data source (eg, a file) */
+
+  jpeg_mem_src(&cinfo, fbuffer.b, len);
+
+  /* Step 3: read file parameters with jpeg_read_header() */
+
+  (void) jpeg_read_header(&cinfo, TRUE);
+  /* We can ignore the return value from jpeg_read_header since
+   *   (a) suspension is not possible with the stdio data source, and
+   *   (b) we passed TRUE to reject a tables-only JPEG file as an error.
+   * See libjpeg.doc for more info.
+   */
+
+  /* Step 4: set parameters for decompression */
+
+  /*
+   * Make sure it always converts images to RGB color space. This will
+   * automatically convert 8-bit greyscale images to RGB as well.
+   */
+  cinfo.out_color_space = JCS_RGB;
+
+  /* Step 5: Start decompressor */
+
+  (void) jpeg_start_decompress(&cinfo);
+  /* We can ignore the return value since suspension is not possible
+   * with the stdio data source.
+   */
+
+  /* We may need to do some setup of our own at this point before reading
+   * the data.  After jpeg_start_decompress() we have the correct scaled
+   * output image dimensions available, as well as the output colormap
+   * if we asked for color quantization.
+   * In this example, we need to make an output work buffer of the right size.
+   */ 
+  /* JSAMPLEs per row in output buffer */
+
+  pixelcount = cinfo.output_width * cinfo.output_height;
+
+  if(!cinfo.output_width || !cinfo.output_height
+      || ((pixelcount * 4) / cinfo.output_width) / 4 != cinfo.output_height
+      || pixelcount > 0x1FFFFFFF || cinfo.output_components != 3
+    )
+  {
+    // Free the memory to make sure we don't leak memory
+    ri.FS_FreeFile (fbuffer.v);
+    jpeg_destroy_decompress(&cinfo);
+  
+    ri.Error(ERR_DROP, "LoadJPG: %s has an invalid image format: %dx%d*4=%d, components: %d\n", filename,
+		    cinfo.output_width, cinfo.output_height, pixelcount * 4, cinfo.output_components);
+  }
+
+  memcount = pixelcount * 4;
+  row_stride = cinfo.output_width * cinfo.output_components;
+
+  out = ri.Malloc(memcount);
+
+  *width = cinfo.output_width;
+  *height = cinfo.output_height;
+
+  /* Step 6: while (scan lines remain to be read) */
+  /*           jpeg_read_scanlines(...); */
+
+  /* Here we use the library's state variable cinfo.output_scanline as the
+   * loop counter, so that we don't have to keep track ourselves.
+   */
+  while (cinfo.output_scanline < cinfo.output_height) {
+    /* jpeg_read_scanlines expects an array of pointers to scanlines.
+     * Here the array is only one element long, but you could ask for
+     * more than one scanline at a time if that's more convenient.
+     */
+	buf = ((out+(row_stride*cinfo.output_scanline)));
+	buffer = &buf;
+    (void) jpeg_read_scanlines(&cinfo, buffer, 1);
+  }
+  
+  buf = out;
+
+  // Expand from RGB to RGBA
+  sindex = pixelcount * cinfo.output_components;
+  dindex = memcount;
+
+  do
+  {	
+    buf[--dindex] = 255;
+    buf[--dindex] = buf[--sindex];
+    buf[--dindex] = buf[--sindex];
+    buf[--dindex] = buf[--sindex];
+  } while(sindex);
+
+  *pic = out;
+
+  /* Step 7: Finish decompression */
+
+  jpeg_finish_decompress(&cinfo);
+  /* We can ignore the return value since suspension is not possible
+   * with the stdio data source.
+   */
+
+  /* Step 8: Release JPEG decompression object */
+
+  /* This is an important step since it will release a good deal of memory. */
+  jpeg_destroy_decompress(&cinfo);
+
+  /* After finish_decompress, we can close the input file.
+   * Here we postpone it until after no more JPEG errors are possible,
+   * so as to simplify the setjmp error logic above.  (Actually, I don't
+   * think that jpeg_destroy can do an error exit, but why assume anything...)
+   */
+  ri.FS_FreeFile (fbuffer.v);
+
+  /* At this point you may want to check to see whether any corrupt-data
+   * warnings occurred (test whether jerr.pub.num_warnings is nonzero).
+   */
+
+  /* And we're done! */
+}
+
+
+/* Expanded data destination object for stdio output */
+
+typedef struct {
+  struct jpeg_destination_mgr pub; /* public fields */
+
+  byte* outfile;		/* target stream */
+  int	size;
+} my_destination_mgr;
+
+typedef my_destination_mgr * my_dest_ptr;
+
+
+/*
+ * Initialize destination --- called by jpeg_start_compress
+ * before any data is actually written.
+ */
+
+static void
+init_destination (j_compress_ptr cinfo)
+{
+  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
+
+  dest->pub.next_output_byte = dest->outfile;
+  dest->pub.free_in_buffer = dest->size;
+}
+
+
+/*
+ * Empty the output buffer --- called whenever buffer fills up.
+ *
+ * In typical applications, this should write the entire output buffer
+ * (ignoring the current state of next_output_byte & free_in_buffer),
+ * reset the pointer & count to the start of the buffer, and return TRUE
+ * indicating that the buffer has been dumped.
+ *
+ * In applications that need to be able to suspend compression due to output
+ * overrun, a FALSE return indicates that the buffer cannot be emptied now.
+ * In this situation, the compressor will return to its caller (possibly with
+ * an indication that it has not accepted all the supplied scanlines).  The
+ * application should resume compression after it has made more room in the
+ * output buffer.  Note that there are substantial restrictions on the use of
+ * suspension --- see the documentation.
+ *
+ * When suspending, the compressor will back up to a convenient restart point
+ * (typically the start of the current MCU). next_output_byte & free_in_buffer
+ * indicate where the restart point will be if the current call returns FALSE.
+ * Data beyond this point will be regenerated after resumption, so do not
+ * write it out when emptying the buffer externally.
+ */
+
+static boolean
+empty_output_buffer (j_compress_ptr cinfo)
+{
+  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
+  
+  jpeg_destroy_compress(cinfo);
+  
+  // Make crash fatal or we would probably leak memory.
+  ri.Error(ERR_FATAL, "Output buffer for encoded JPEG image has insufficient size of %d bytes\n",
+           dest->size);
+
+  return FALSE;
+}
+
+/*
+ * Terminate destination --- called by jpeg_finish_compress
+ * after all data has been written.  Usually needs to flush buffer.
+ *
+ * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
+ * application must deal with any cleanup that should happen even
+ * for error exit.
+ */
+
+static void term_destination(j_compress_ptr cinfo)
+{
+}
+
+
+/*
+ * Prepare for output to a stdio stream.
+ * The caller must have already opened the stream, and is responsible
+ * for closing it after finishing compression.
+ */
+
+static void
+jpegDest (j_compress_ptr cinfo, byte* outfile, int size)
+{
+  my_dest_ptr dest;
+
+  /* The destination object is made permanent so that multiple JPEG images
+   * can be written to the same file without re-executing jpeg_stdio_dest.
+   * This makes it dangerous to use this manager and a different destination
+   * manager serially with the same JPEG object, because their private object
+   * sizes may be different.  Caveat programmer.
+   */
+  if (cinfo->dest == NULL) {	/* first time for this JPEG object? */
+    cinfo->dest = (struct jpeg_destination_mgr *)
+      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
+				  sizeof(my_destination_mgr));
+  }
+
+  dest = (my_dest_ptr) cinfo->dest;
+  dest->pub.init_destination = init_destination;
+  dest->pub.empty_output_buffer = empty_output_buffer;
+  dest->pub.term_destination = term_destination;
+  dest->outfile = outfile;
+  dest->size = size;
+}
+
+/*
+=================
+SaveJPGToBuffer
+
+Encodes JPEG from image in image_buffer and writes to buffer.
+Expects RGB input data
+=================
+*/
+size_t RE_SaveJPGToBuffer(byte *buffer, size_t bufSize, int quality,
+    int image_width, int image_height, byte *image_buffer, int padding)
+{
+  struct jpeg_compress_struct cinfo;
+  struct jpeg_error_mgr jerr;
+  JSAMPROW row_pointer[1];	/* pointer to JSAMPLE row[s] */
+  my_dest_ptr dest;
+  int row_stride;		/* physical row width in image buffer */
+  size_t outcount;
+
+  /* Step 1: allocate and initialize JPEG compression object */
+  cinfo.err = jpeg_std_error(&jerr);
+  cinfo.err->error_exit = R_JPGErrorExit;
+  cinfo.err->output_message = R_JPGOutputMessage;
+
+  /* Now we can initialize the JPEG compression object. */
+  jpeg_create_compress(&cinfo);
+
+  /* Step 2: specify data destination (eg, a file) */
+  /* Note: steps 2 and 3 can be done in either order. */
+  jpegDest(&cinfo, buffer, bufSize);
+
+  /* Step 3: set parameters for compression */
+  cinfo.image_width = image_width; 	/* image width and height, in pixels */
+  cinfo.image_height = image_height;
+  cinfo.input_components = 3;		/* # of color components per pixel */
+  cinfo.in_color_space = JCS_RGB; 	/* colorspace of input image */
+
+  jpeg_set_defaults(&cinfo);
+  jpeg_set_quality(&cinfo, quality, TRUE /* limit to baseline-JPEG values */);
+  /* If quality is set high, disable chroma subsampling */
+  if (quality >= 85) {
+    cinfo.comp_info[0].h_samp_factor = 1;
+    cinfo.comp_info[0].v_samp_factor = 1;
+  }
+
+  /* Step 4: Start compressor */
+  jpeg_start_compress(&cinfo, TRUE);
+
+  /* Step 5: while (scan lines remain to be written) */
+  /*           jpeg_write_scanlines(...); */
+  row_stride = image_width * cinfo.input_components + padding; /* JSAMPLEs per row in image_buffer */
+  
+  while (cinfo.next_scanline < cinfo.image_height) {
+    /* jpeg_write_scanlines expects an array of pointers to scanlines.
+     * Here the array is only one element long, but you could pass
+     * more than one scanline at a time if that's more convenient.
+     */
+    row_pointer[0] = &image_buffer[((cinfo.image_height-1)*row_stride)-cinfo.next_scanline * row_stride];
+    (void) jpeg_write_scanlines(&cinfo, row_pointer, 1);
+  }
+
+  /* Step 6: Finish compression */
+  jpeg_finish_compress(&cinfo);
+  
+  dest = (my_dest_ptr) cinfo.dest;
+  outcount = dest->size - dest->pub.free_in_buffer;
+ 
+  /* Step 7: release JPEG compression object */
+  jpeg_destroy_compress(&cinfo);
+
+  /* And we're done! */
+  return outcount;
+}
+
+void RE_SaveJPG(char * filename, int quality, int image_width, int image_height, byte *image_buffer, int padding)
+{
+  byte *out;
+  size_t bufSize;
+
+  bufSize = image_width * image_height * 3;
+  out = ri.Hunk_AllocateTempMemory(bufSize);
+
+  bufSize = RE_SaveJPGToBuffer(out, bufSize, quality, image_width, image_height, image_buffer, padding);
+  ri.FS_WriteFile(filename, out, bufSize);
+
+  ri.Hunk_FreeTempMemory(out);
+}
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_image_jpg.c.rej tremulous-ggp1-src/src/renderer/tr_image_jpg.c.rej
--- tremulous-ggp1-src.p/src/renderer/tr_image_jpg.c.rej	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_image_jpg.c.rej	2012-07-19 04:25:52.031556446 +0200
@@ -0,0 +1,11 @@
+--- src/renderer/tr_image_jpg.c	(Revision 2062)
++++ src/renderer/tr_image_jpg.c	(Arbeitskopie)
+@@ -34,7 +34,7 @@
+ #define JPEG_INTERNALS
+ #include "../jpeg-6b/jpeglib.h"
+ 
+-void R_LoadJPG( const char *filename, unsigned char **pic, int *width, int *height ) {
++void R_LoadJPG( const char *filename, texImage_t *pic, int *width, int *height ) {
+   /* This struct contains the JPEG decompression parameters and pointers to
+    * working space (which is allocated as needed by the JPEG library).
+    */
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_image_pcx.c tremulous-ggp1-src/src/renderer/tr_image_pcx.c
--- tremulous-ggp1-src.p/src/renderer/tr_image_pcx.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_image_pcx.c	2012-07-19 04:25:52.031556446 +0200
@@ -49,7 +49,7 @@
 	unsigned char	data[];
 } pcx_t;
 
-void R_LoadPCX ( const char *filename, byte **pic, int *width, int *height)
+void R_LoadPCX ( const char *filename, texImage_t *pic, int *width, int *height)
 {
 	union {
 		byte *b;
@@ -70,7 +70,7 @@
 		*width = 0;
 	if (height)
 		*height = 0;
-	*pic = NULL;
+	pic->numMipmaps = 0;
 
 	//
 	// load the file
@@ -169,7 +169,9 @@
 	if (height)
 		*height = h;
 
-	*pic = out;
+	pic->format = GL_RGBA8;
+	pic->numMipmaps = 1;
+	pic->data[0] = out;
 
 	ri.FS_FreeFile (pcx);
 	ri.Free (pic8);
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_image_png.c tremulous-ggp1-src/src/renderer/tr_image_png.c
--- tremulous-ggp1-src.p/src/renderer/tr_image_png.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_image_png.c	2012-07-19 04:25:52.041556450 +0200
@@ -1903,7 +1903,7 @@
  *  The PNG loader
  */
 
-void R_LoadPNG(const char *name, byte **pic, int *width, int *height)
+void R_LoadPNG(const char *name, texImage_t *pic, int *width, int *height)
 {
 	struct BufferedFile *ThePNG;
 	byte *OutBuffer;
@@ -1946,7 +1946,7 @@
 	 *  Zero out return values.
 	 */
 
-	*pic = NULL;
+	pic->numMipmaps = 0;
 
 	if(width)
 	{
@@ -2065,7 +2065,7 @@
 	{
 		CloseBufferedFile(ThePNG);
 
-		Com_Printf(S_COLOR_YELLOW "%s: invalid image size\n", name);
+		ri.Printf( PRINT_WARNING, "%s: invalid image size\n", name );
 
 		return; 
 	}
@@ -2458,7 +2458,9 @@
 	 *  update the pointer to the image data
 	 */
 
-	*pic = OutBuffer;
+	pic->format = GL_RGBA8;
+	pic->numMipmaps = 1;
+	pic->data[0] = OutBuffer;
 
 	/*
 	 *  Fill width and height.
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_image_tga.c tremulous-ggp1-src/src/renderer/tr_image_tga.c
--- tremulous-ggp1-src.p/src/renderer/tr_image_tga.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_image_tga.c	2012-07-19 04:25:52.021556447 +0200
@@ -39,7 +39,7 @@
 	unsigned char	pixel_size, attributes;
 } TargaHeader;
 
-void R_LoadTGA ( const char *name, byte **pic, int *width, int *height)
+void R_LoadTGA ( const char *name, texImage_t *pic, int *width, int *height)
 {
 	unsigned	columns, rows, numPixels;
 	byte	*pixbuf;
@@ -54,7 +54,7 @@
 	byte		*targa_rgba;
 	int length;
 
-	*pic = NULL;
+	pic->numMipmaps = 0;
 
 	if(width)
 		*width = 0;
@@ -315,7 +315,9 @@
   if (height)
 	  *height = rows;
 
-  *pic = targa_rgba;
+  pic->format = GL_RGBA8;
+  pic->numMipmaps = 1;
+  pic->data[0] = targa_rgba;
 
   ri.FS_FreeFile (buffer.v);
 }
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_init.c tremulous-ggp1-src/src/renderer/tr_init.c
--- tremulous-ggp1-src.p/src/renderer/tr_init.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_init.c	2012-07-19 04:25:52.021556447 +0200
@@ -29,6 +29,8 @@
 
 static void GfxInfo_f( void );
 
+cvar_t	*r_scratchmegs;
+
 cvar_t	*r_flareSize;
 cvar_t	*r_flareFade;
 cvar_t	*r_flareCoeff;
@@ -88,6 +90,19 @@
 cvar_t	*r_ext_texture_env_add;
 cvar_t	*r_ext_texture_filter_anisotropic;
 cvar_t	*r_ext_max_anisotropy;
+cvar_t	*r_ext_texture_compression;
+cvar_t	*r_ext_vertex_buffer_object;
+cvar_t	*r_ext_pixel_buffer_object;
+cvar_t	*r_ext_vertex_shader;
+cvar_t	*r_ext_geometry_shader;
+cvar_t  *r_ext_framebuffer_object;
+cvar_t	*r_ext_occlusion_query;
+cvar_t	*r_ext_timer_query;
+cvar_t	*r_ext_instanced_arrays;
+cvar_t  *r_ext_texture_float;
+cvar_t	*r_ext_texture3D;
+cvar_t	*r_ext_separate_stencil;
+cvar_t	*r_ext_debug_output;
 
 cvar_t	*r_ignoreGLErrors;
 cvar_t	*r_logFile;
@@ -95,9 +110,8 @@
 cvar_t	*r_stencilbits;
 cvar_t	*r_depthbits;
 cvar_t	*r_colorbits;
-cvar_t	*r_primitives;
 cvar_t	*r_texturebits;
-cvar_t  *r_ext_multisample;
+cvar_t	*r_ext_multisample;
 
 cvar_t	*r_drawBuffer;
 cvar_t	*r_lightmap;
@@ -150,6 +164,12 @@
 cvar_t	*r_printShaders;
 cvar_t	*r_saveFontData;
 
+cvar_t	*r_flush;
+cvar_t	*r_VBOminSize;
+cvar_t	*r_depthPass;
+cvar_t	*r_perPixelLighting;
+cvar_t	*r_parallax;
+
 cvar_t	*r_marksOnTriangleMeshes;
 
 cvar_t	*r_aviMotionJpegQuality;
@@ -288,8 +308,29 @@
 		{
 			glConfig.maxTextureSize = 0;
 		}
+		
+		// reserve some stencil bits for portal/mirror rendering
+		if ( glConfig.stencilBits > 8 ) {
+			temp = 4;
+		} else if ( glConfig.stencilBits > 6 ) {
+			temp = 3;
+		} else if ( glConfig.stencilBits > 4 ) {
+			temp = 2;
+		} else if ( glConfig.stencilBits > 2 ) {
+			temp = 1;
+		} else {
+			temp = 0;
+		}
+		
+		glGlobals.portalBits = temp;
+		glGlobals.shadowBits = glConfig.stencilBits - temp;
+		glGlobals.portalLevels = (1 << temp) - 1;
+		glGlobals.portalMask = glGlobals.portalLevels << glGlobals.shadowBits;
+		glGlobals.shadowMask = (1 << glGlobals.shadowBits) - 1;
 	}
 
+	RB_InitScratchMemory( );
+
 	// init command buffers and SMP
 	R_InitCommandBuffers();
 
@@ -298,8 +339,86 @@
 
 	// set default state
 	GL_SetDefaultState();
+
+	// enable debug_output extension
+	if( qglDebugMessageControlARB ) {
+		if( r_ext_debug_output->integer & 0x4 )
+			qglDebugMessageControlARB( GL_DONT_CARE, GL_DONT_CARE,
+						   GL_DEBUG_SEVERITY_HIGH_ARB,
+						   0, NULL, GL_TRUE );
+		if( r_ext_debug_output->integer & 0x2 )
+			qglDebugMessageControlARB( GL_DONT_CARE, GL_DONT_CARE,
+						   GL_DEBUG_SEVERITY_MEDIUM_ARB,
+						   0, NULL, GL_TRUE );
+		if( r_ext_debug_output->integer & 0x1 )
+			qglDebugMessageControlARB( GL_DONT_CARE, GL_DONT_CARE,
+						   GL_DEBUG_SEVERITY_LOW_ARB,
+						   0, NULL, GL_TRUE );
+		qglDebugMessageInsertARB( GL_DEBUG_SOURCE_APPLICATION_ARB,
+					  GL_DEBUG_TYPE_OTHER_ARB, 1,
+					  GL_DEBUG_SEVERITY_LOW_ARB,
+					  -1, "debug log started" );
+	} else if ( qglDebugMessageEnableAMD ) {
+		if( r_ext_debug_output->integer & 0x4 )
+			qglDebugMessageEnableAMD( 0, GL_DEBUG_SEVERITY_HIGH_AMD,
+						  0, NULL, GL_TRUE );
+		if( r_ext_debug_output->integer & 0x2 )
+			qglDebugMessageEnableAMD( 0, GL_DEBUG_SEVERITY_MEDIUM_AMD,
+						  0, NULL, GL_TRUE );
+		if( r_ext_debug_output->integer & 0x1 )
+			qglDebugMessageEnableAMD( 0, GL_DEBUG_SEVERITY_LOW_AMD,
+						  0, NULL, GL_TRUE );
+		qglDebugMessageInsertAMD( GL_DEBUG_CATEGORY_APPLICATION_AMD,
+					  GL_DEBUG_SEVERITY_LOW_AMD, 1,
+					  0, "debug log started" );
+	}
+
+	if( glGlobals.pixelBufferObjects ) {
+		qglGenBuffersARB( 1, &glGlobals.PBO );
+	} else {
+		glGlobals.PBO = 0;
+	}
+
+#if GL_SGIS_generate_mipmap
+	qglHint( GL_GENERATE_MIPMAP_HINT_SGIS, GL_NICEST );
+	qglGetError();	// ignore error
+#endif
 }
 
+
+/*
+==================
+GL_CheckDebugLog
+==================
+*/
+void GL_CheckDebugLog( void ) {
+	GLint messagesAvailable;
+	char  message[1024];
+	GLenum source, type, id, severity;
+	GLsizei length;
+
+	if( qglDebugMessageControlARB ) {
+		qglGetIntegerv( GL_DEBUG_LOGGED_MESSAGES_ARB, &messagesAvailable );
+		while( messagesAvailable-- ) {
+			if( qglGetDebugMessageLogARB( 1, sizeof(message),
+						      &source, &type, &id,
+						      &severity, &length, message) ) {
+				ri.Printf( PRINT_ALL, "GL debug: %s\n", message );
+			}
+		}
+	} else if( qglDebugMessageEnableAMD ) {
+		qglGetIntegerv( GL_DEBUG_LOGGED_MESSAGES_AMD, &messagesAvailable );
+		while( messagesAvailable-- ) {
+			if( qglGetDebugMessageLogAMD( 1, sizeof(message),
+						      &type, &id,
+						      &severity, &length, message) ) {
+				ri.Printf( PRINT_ALL, "GL debug: %s\n", message );
+			}
+		}
+	}
+}
+
+
 /*
 ==================
 GL_CheckErrors
@@ -310,6 +429,9 @@
 	char	s[64];
 
 	err = qglGetError();
+
+	GL_CheckDebugLog();
+
 	if ( err == GL_NO_ERROR ) {
 		return;
 	}
@@ -854,29 +976,22 @@
 
 	qglCullFace(GL_FRONT);
 
-	qglColor4f (1,1,1,1);
-
 	// initialize downstream texture unit if we're running
 	// in a multitexture environment
 	if ( qglActiveTextureARB ) {
-		GL_SelectTexture( 1 );
-		GL_TextureMode( r_textureMode->string );
-		GL_TexEnv( GL_MODULATE );
-		qglDisable( GL_TEXTURE_2D );
-		GL_SelectTexture( 0 );
+		int i;
+		
+		for( i = 1; i < glConfig.numTextureUnits; i++ ) {
+			GL_TexEnv( i, GL_MODULATE );
+		}
 	}
 
-	qglEnable(GL_TEXTURE_2D);
 	GL_TextureMode( r_textureMode->string );
-	GL_TexEnv( GL_MODULATE );
+	GL_TexEnv( 0, GL_MODULATE );
 
 	qglShadeModel( GL_SMOOTH );
 	qglDepthFunc( GL_LEQUAL );
 
-	// the vertex array is always enabled, but the color and texture
-	// arrays are enabled and disabled around the compiled vertex array call
-	qglEnableClientState (GL_VERTEX_ARRAY);
-
 	//
 	// make sure our GL state vector is set correctly
 	//
@@ -916,6 +1031,7 @@
 	ri.Printf( PRINT_ALL, "GL_MAX_TEXTURE_SIZE: %d\n", glConfig.maxTextureSize );
 	ri.Printf( PRINT_ALL, "GL_MAX_TEXTURE_UNITS_ARB: %d\n", glConfig.numTextureUnits );
 	ri.Printf( PRINT_ALL, "\nPIXELFORMAT: color(%d-bits) Z(%d-bit) stencil(%d-bits)\n", glConfig.colorBits, glConfig.depthBits, glConfig.stencilBits );
+	ri.Printf( PRINT_ALL, "\nSTENCILFORMAT: portals(%d-bits) shadows(%d-bit)\n", glGlobals.portalBits, glGlobals.shadowBits );
 	ri.Printf( PRINT_ALL, "MODE: %d x %d %s hz:", glConfig.vidWidth, glConfig.vidHeight, fsstrings[r_fullscreen->integer == 1] );
 	if ( glConfig.displayFrequency )
 	{
@@ -934,31 +1050,6 @@
 		ri.Printf( PRINT_ALL, "GAMMA: software w/ %d overbright bits\n", tr.overbrightBits );
 	}
 
-	// rendering primitives
-	{
-		int		primitives;
-
-		// default is to use triangles if compiled vertex arrays are present
-		ri.Printf( PRINT_ALL, "rendering primitives: " );
-		primitives = r_primitives->integer;
-		if ( primitives == 0 ) {
-			if ( qglLockArraysEXT ) {
-				primitives = 2;
-			} else {
-				primitives = 1;
-			}
-		}
-		if ( primitives == -1 ) {
-			ri.Printf( PRINT_ALL, "none\n" );
-		} else if ( primitives == 2 ) {
-			ri.Printf( PRINT_ALL, "single glDrawElements\n" );
-		} else if ( primitives == 1 ) {
-			ri.Printf( PRINT_ALL, "multiple glArrayElement\n" );
-		} else if ( primitives == 3 ) {
-			ri.Printf( PRINT_ALL, "multiple glColor4ubv + glTexCoord2fv + glVertex3fv\n" );
-		}
-	}
-
 	ri.Printf( PRINT_ALL, "texturemode: %s\n", r_textureMode->string );
 	ri.Printf( PRINT_ALL, "picmip: %d\n", r_picmip->integer );
 	ri.Printf( PRINT_ALL, "texture bits: %d\n", r_texturebits->integer );
@@ -996,11 +1087,26 @@
 	//
 	// latched and archived variables
 	//
+	r_scratchmegs = ri.Cvar_Get( "r_scratchmegs", va( "%d", SMP_SCRATCHMEGS ), CVAR_ARCHIVE | CVAR_LATCH );
+
 	r_allowExtensions = ri.Cvar_Get( "r_allowExtensions", "1", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ext_compressed_textures = ri.Cvar_Get( "r_ext_compressed_textures", "0", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ext_multitexture = ri.Cvar_Get( "r_ext_multitexture", "1", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ext_compiled_vertex_array = ri.Cvar_Get( "r_ext_compiled_vertex_array", "1", CVAR_ARCHIVE | CVAR_LATCH);
 	r_ext_texture_env_add = ri.Cvar_Get( "r_ext_texture_env_add", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_texture_compression = ri.Cvar_Get( "r_ext_texture_compression", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_vertex_buffer_object = ri.Cvar_Get( "r_ext_vertex_buffer_object", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_pixel_buffer_object = ri.Cvar_Get( "r_ext_pixel_buffer_object", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_vertex_shader = ri.Cvar_Get( "r_ext_vertex_shader", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_geometry_shader = ri.Cvar_Get( "r_ext_geometry_shader", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_framebuffer_object = ri.Cvar_Get( "r_ext_framebuffer_object", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_occlusion_query = ri.Cvar_Get( "r_ext_occlusion_query", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_timer_query = ri.Cvar_Get( "r_ext_timer_query", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_instanced_arrays = ri.Cvar_Get( "r_ext_instanced_arrays", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_texture_float = ri.Cvar_Get( "r_ext_texture_float", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_texture3D = ri.Cvar_Get( "r_ext_texture3D", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_separate_stencil = ri.Cvar_Get( "r_ext_separate_stencil", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_debug_output = ri.Cvar_Get( "r_ext_debug_output", "0", CVAR_LATCH);
 
 	r_picmip = ri.Cvar_Get ("r_picmip", GENERIC_HW_R_PICMIP_DEFAULT,
 			CVAR_ARCHIVE | CVAR_LATCH );
@@ -1017,7 +1123,7 @@
 	r_stencilbits = ri.Cvar_Get( "r_stencilbits", "8", CVAR_ARCHIVE | CVAR_LATCH );
 	r_depthbits = ri.Cvar_Get( "r_depthbits", "0", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ext_multisample = ri.Cvar_Get( "r_ext_multisample", "0", CVAR_ARCHIVE | CVAR_LATCH );
-	ri.Cvar_CheckRange( r_ext_multisample, 0, 4, qtrue );
+	ri.Cvar_CheckRange( r_ext_multisample, 0, 16, qtrue );
 	r_overBrightBits = ri.Cvar_Get ("r_overBrightBits", "1", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ignorehwgamma = ri.Cvar_Get( "r_ignorehwgamma", "0", CVAR_ARCHIVE | CVAR_LATCH);
 	r_fullscreen = ri.Cvar_Get( "r_fullscreen", "1", CVAR_ARCHIVE );
@@ -1071,8 +1177,6 @@
 	r_railCoreWidth = ri.Cvar_Get( "r_railCoreWidth", "6", CVAR_ARCHIVE );
 	r_railSegmentLength = ri.Cvar_Get( "r_railSegmentLength", "32", CVAR_ARCHIVE );
 
-	r_primitives = ri.Cvar_Get( "r_primitives", "0", CVAR_ARCHIVE );
-
 	r_ambientScale = ri.Cvar_Get( "r_ambientScale", "0.6", CVAR_CHEAT );
 	r_directedScale = ri.Cvar_Get( "r_directedScale", "1", CVAR_CHEAT );
 
@@ -1132,6 +1236,12 @@
 	r_maxpolys = ri.Cvar_Get( "r_maxpolys", va("%d", MAX_POLYS), 0);
 	r_maxpolyverts = ri.Cvar_Get( "r_maxpolyverts", va("%d", MAX_POLYVERTS), 0);
 
+	r_flush = ri.Cvar_Get("r_flush","0", 0);
+	r_VBOminSize = ri.Cvar_Get("r_VBOminSize","0",CVAR_ARCHIVE);
+	r_depthPass = ri.Cvar_Get("r_depthPass","0", CVAR_LATCH | CVAR_ARCHIVE);
+	r_perPixelLighting = ri.Cvar_Get("r_perPixelLighting","0", CVAR_LATCH | CVAR_ARCHIVE);
+	r_parallax = ri.Cvar_Get("r_parallax","0",CVAR_LATCH | CVAR_ARCHIVE);
+
 	// make sure all the commands added here are also
 	// removed in R_Shutdown
 	ri.Cmd_AddCommand( "imagelist", R_ImageList_f );
@@ -1155,18 +1265,26 @@
 
 	ri.Printf( PRINT_ALL, "----- R_Init -----\n" );
 
+	if( sizeof(vaWord1_t) != 16 )
+		ri.Printf( PRINT_ERROR, "Incorrect vaWord1 size\n" );
+	if( sizeof(vaWord2_t) != 16 )
+		ri.Printf( PRINT_ERROR, "Incorrect vaWord2 size\n" );
+	if( sizeof(vaWord3_t) != 16 )
+		ri.Printf( PRINT_ERROR, "Incorrect vaWord3 size\n" );
+
 	// clear all our internal state
 	Com_Memset( &tr, 0, sizeof( tr ) );
+	tr.worldEntity.e.axis[0][0] = 1.0f;
+	tr.worldEntity.e.axis[1][1] = 1.0f;
+	tr.worldEntity.e.axis[2][2] = 1.0f;
 	Com_Memset( &backEnd, 0, sizeof( backEnd ) );
 	Com_Memset( &tess, 0, sizeof( tess ) );
+	backEnd.entity2D.e.axis[0][0] = 1.0f;
+	backEnd.entity2D.e.axis[1][1] = 1.0f;
+	backEnd.entity2D.e.axis[2][2] = 1.0f;
 
 //	Swap_Init();
 
-	if ( (intptr_t)tess.xyz & 15 ) {
-		Com_Printf( "WARNING: tess.xyz not 16 byte aligned\n" );
-	}
-	Com_Memset( tess.constantColor255, 255, sizeof( tess.constantColor255 ) );
-
 	//
 	// init function tables
 	//
@@ -1224,6 +1342,10 @@
 
 	InitOpenGL();
 
+	if( qglGenBuffersARB ) {
+		qglGenBuffersARB( 1, &backEnd.streamVBO.ibo );
+	}
+
 	R_InitImages();
 
 	R_InitShaders();
@@ -1242,6 +1364,17 @@
 	ri.Printf( PRINT_ALL, "----- finished R_Init -----\n" );
 }
 
+static void freeVboInfo(vboInfo_t *info) {
+	if( info ) {
+		freeVboInfo( info->left );
+		freeVboInfo( info->right );
+		if ( info->ibo && qglIsBufferARB( info->ibo ) )
+			qglDeleteBuffersARB( 1, &info->ibo );
+		if ( info->vbo && qglIsBufferARB( info->vbo ) )
+			qglDeleteBuffersARB( 1, &info->vbo );
+	}
+}
+
 /*
 ===============
 RE_Shutdown
@@ -1249,7 +1382,7 @@
 */
 void RE_Shutdown( qboolean destroyWindow ) {	
 
-	ri.Printf( PRINT_ALL, "RE_Shutdown( %i )\n", destroyWindow );
+	ri.Printf( PRINT_DEVELOPER, "RE_Shutdown( %i )\n", destroyWindow );
 
 	ri.Cmd_RemoveCommand ("modellist");
 	ri.Cmd_RemoveCommand ("screenshotJPEG");
@@ -1266,6 +1399,86 @@
 		R_SyncRenderThread();
 		R_ShutdownCommandBuffers();
 		R_DeleteTextures();
+
+		if ( qglDeleteQueriesARB && tr.numShaders ) {
+			int shader;
+			
+			for ( shader = 0; shader < tr.numShaders; shader++ ) {
+				if ( tr.shaders[shader]->QueryID ) {
+					qglDeleteQueriesARB( 1, &tr.shaders[shader]->QueryID );
+					tr.shaders[shader]->QueryID = 0;
+				}
+			}
+		}
+
+		GL_VBO( 0 );
+		if ( qglIsBufferARB && tr.numShaders ) {
+			int shader;
+			
+			for ( shader = 0; shader < tr.numShaders; shader++ ) {
+				freeVboInfo( tr.shaders[shader]->VBOs );
+				tr.shaders[shader]->VBOs = NULL;
+			}
+			if ( qglIsBufferARB( backEnd.worldVBO.vbo ) )
+				qglDeleteBuffersARB( 1, &backEnd.worldVBO.vbo );
+		}
+		if ( qglIsBufferARB && tr.numModels ) {
+			int model, lod;
+			
+			for ( model = 0; model < tr.numModels; model++ ) {
+				if ( tr.models[model]->type != MOD_MESH )
+					continue;
+				
+				for ( lod = 0; lod < MD3_MAX_LODS; lod++ ) {
+					if( tr.models[model]->modelData.md3.md3srf[lod] ) {
+						freeVboInfo( tr.models[model]->modelData.md3.md3srf[lod]->VBO );
+						tr.models[model]->modelData.md3.md3srf[lod]->VBO = NULL;
+					}
+				}
+			}
+		}
+		if( qglGenBuffersARB && backEnd.streamVBO.ibo ) 
+			qglDeleteBuffersARB( 1, &backEnd.streamVBO.ibo );
+		if( glGlobals.PBO )
+			qglDeleteBuffersARB( 1, &glGlobals.PBO );
+		
+		if ( tess.vertexBuffer ) {
+			ri.Free( tess.vertexBuffer );
+			tess.vertexBuffer = NULL;
+		}
+
+		if ( qglCreateProgram ) {
+			int i;
+
+			for( i = 1; i < AL_NUMATTRIBUTES; i++ ) {
+				qglDisableVertexAttribArrayARB( i );
+			}
+			
+			GL_Program( NULL );
+			for ( i = 0; i < tr.numGLSLprograms; i++ ) {
+				qglDeleteProgram( tr.GLSLprograms[i]->handle );
+			}
+			for ( i = 0; i < tr.numGLSLshaders; i++ ) {
+				qglDeleteShader( tr.GLSLshaders[i]->handle );
+			}
+		}
+	}
+
+	// disable debugging
+	if( qglDebugMessageControlARB ) {
+		qglDebugMessageInsertARB( GL_DEBUG_SOURCE_APPLICATION_ARB,
+					  GL_DEBUG_TYPE_OTHER_ARB, 1,
+					  GL_DEBUG_SEVERITY_LOW_ARB,
+					  -1, "debug log stopped" );
+		GL_CheckDebugLog();
+		qglDebugMessageControlARB( GL_DONT_CARE, GL_DONT_CARE,
+					   GL_DONT_CARE, 0, NULL, GL_FALSE );
+	} else if ( qglDebugMessageEnableAMD ) {
+		qglDebugMessageInsertAMD( GL_DEBUG_CATEGORY_APPLICATION_AMD,
+					  GL_DEBUG_SEVERITY_LOW_AMD, 1,
+					  0, "debug log stopped" );
+		GL_CheckDebugLog();
+		qglDebugMessageEnableAMD( 0, 0, 0, NULL, GL_FALSE );
 	}
 
 	R_DoneFreeType();
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_init.c.orig tremulous-ggp1-src/src/renderer/tr_init.c.orig
--- tremulous-ggp1-src.p/src/renderer/tr_init.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_init.c.orig	2012-07-19 04:25:20.311556052 +0200
@@ -0,0 +1,1358 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+// tr_init.c -- functions that are not called every frame
+
+#include "tr_local.h"
+
+glconfig_t  glConfig;
+glstate_t	glState;
+
+static void GfxInfo_f( void );
+
+cvar_t	*r_flareSize;
+cvar_t	*r_flareFade;
+cvar_t	*r_flareCoeff;
+
+cvar_t	*r_railWidth;
+cvar_t	*r_railCoreWidth;
+cvar_t	*r_railSegmentLength;
+
+cvar_t	*r_ignoreFastPath;
+
+cvar_t	*r_verbose;
+cvar_t	*r_ignore;
+
+cvar_t	*r_detailTextures;
+
+cvar_t	*r_znear;
+cvar_t	*r_zproj;
+cvar_t	*r_stereoSeparation;
+
+cvar_t	*r_smp;
+cvar_t	*r_showSmp;
+cvar_t	*r_skipBackEnd;
+
+cvar_t	*r_stereoEnabled;
+cvar_t	*r_anaglyphMode;
+
+cvar_t	*r_greyscale;
+
+cvar_t	*r_ignorehwgamma;
+cvar_t	*r_measureOverdraw;
+
+cvar_t	*r_inGameVideo;
+cvar_t	*r_fastsky;
+cvar_t	*r_drawSun;
+cvar_t	*r_dynamiclight;
+cvar_t	*r_dlightBacks;
+
+cvar_t	*r_lodbias;
+cvar_t	*r_lodscale;
+
+cvar_t	*r_norefresh;
+cvar_t	*r_drawentities;
+cvar_t	*r_drawworld;
+cvar_t	*r_speeds;
+cvar_t	*r_fullbright;
+cvar_t	*r_novis;
+cvar_t	*r_nocull;
+cvar_t	*r_facePlaneCull;
+cvar_t	*r_showcluster;
+cvar_t	*r_nocurves;
+
+cvar_t	*r_allowExtensions;
+
+cvar_t	*r_ext_compressed_textures;
+cvar_t	*r_ext_multitexture;
+cvar_t	*r_ext_compiled_vertex_array;
+cvar_t	*r_ext_texture_env_add;
+cvar_t	*r_ext_texture_filter_anisotropic;
+cvar_t	*r_ext_max_anisotropy;
+
+cvar_t	*r_ignoreGLErrors;
+cvar_t	*r_logFile;
+
+cvar_t	*r_stencilbits;
+cvar_t	*r_depthbits;
+cvar_t	*r_colorbits;
+cvar_t	*r_primitives;
+cvar_t	*r_texturebits;
+cvar_t  *r_ext_multisample;
+
+cvar_t	*r_drawBuffer;
+cvar_t	*r_lightmap;
+cvar_t	*r_vertexLight;
+cvar_t	*r_uiFullScreen;
+cvar_t	*r_shadows;
+cvar_t	*r_flares;
+cvar_t	*r_nobind;
+cvar_t	*r_singleShader;
+cvar_t	*r_roundImagesDown;
+cvar_t	*r_colorMipLevels;
+cvar_t	*r_picmip;
+cvar_t	*r_showtris;
+cvar_t	*r_showsky;
+cvar_t	*r_shownormals;
+cvar_t	*r_finish;
+cvar_t	*r_clear;
+cvar_t	*r_swapInterval;
+cvar_t	*r_textureMode;
+cvar_t	*r_offsetFactor;
+cvar_t	*r_offsetUnits;
+cvar_t	*r_gamma;
+cvar_t	*r_intensity;
+cvar_t	*r_lockpvs;
+cvar_t	*r_noportals;
+cvar_t	*r_portalOnly;
+
+cvar_t	*r_subdivisions;
+cvar_t	*r_lodCurveError;
+
+cvar_t	*r_fullscreen;
+cvar_t  *r_noborder;
+
+cvar_t	*r_width;
+cvar_t	*r_height;
+cvar_t	*r_pixelAspect;
+
+cvar_t	*r_overBrightBits;
+cvar_t	*r_mapOverBrightBits;
+
+cvar_t	*r_debugSurface;
+cvar_t	*r_simpleMipMaps;
+
+cvar_t	*r_showImages;
+
+cvar_t	*r_ambientScale;
+cvar_t	*r_directedScale;
+cvar_t	*r_debugLight;
+cvar_t	*r_debugSort;
+cvar_t	*r_printShaders;
+cvar_t	*r_saveFontData;
+
+cvar_t	*r_marksOnTriangleMeshes;
+
+cvar_t	*r_aviMotionJpegQuality;
+cvar_t	*r_screenshotJpegQuality;
+
+cvar_t	*r_maxpolys;
+int		max_polys;
+cvar_t	*r_maxpolyverts;
+int		max_polyverts;
+
+#define GENERIC_HW_R_PICMIP_DEFAULT				"0"
+#define GENERIC_HW_R_TEXTUREMODE_DEFAULT	"GL_LINEAR_MIPMAP_LINEAR"
+
+/*
+==================
+GL_ResolveHardwareType
+
+Chipset specific configuration
+==================
+*/
+void GL_ResolveHardwareType( void )
+{
+	char		buf[ 1024 ];
+	cvar_t	*lastValidRenderer = ri.Cvar_Get(
+			"r_lastValidRenderer", "(uninitialized)", CVAR_ARCHIVE );
+
+	Q_strncpyz( buf, glConfig.renderer_string, sizeof( buf ) );
+	Q_strlwr( buf );
+
+	// NOTE: if changing cvars, do it within this block.  This allows them
+	// to be overridden when testing driver fixes, etc. but only sets
+	// them to their default state when the hardware is first installed/run.
+	if( Q_stricmp( lastValidRenderer->string, glConfig.renderer_string ) )
+	{
+		glConfig.hardwareType = GLHW_GENERIC;
+
+		ri.Cvar_Set( "r_textureMode", GENERIC_HW_R_TEXTUREMODE_DEFAULT );
+
+		// VOODOO GRAPHICS w/ 2MB
+		if ( strstr( buf, "voodoo graphics/1 tmu/2 mb" ) )
+		{
+			ri.Cvar_Set( "r_picmip", "2" );
+			ri.Cvar_Get( "r_picmip", "1", CVAR_ARCHIVE | CVAR_LATCH );
+		}
+		else
+		{
+			ri.Cvar_Set( "r_picmip", GENERIC_HW_R_PICMIP_DEFAULT );
+
+			if ( strstr( buf, "rage 128" ) || strstr( buf, "rage128" ) )
+			{
+				ri.Cvar_Set( "r_finish", "0" );
+			}
+			// Savage3D and Savage4 should always have trilinear enabled
+			else if ( strstr( buf, "savage3d" ) || strstr( buf, "s3 savage4" ) )
+			{
+				ri.Cvar_Set( "r_texturemode", "GL_LINEAR_MIPMAP_LINEAR" );
+			}
+		}
+	}
+	
+	//
+	// this is where hardware specific workarounds that should be
+	// detected/initialized every startup should go.
+	//
+	if ( strstr( buf, "banshee" ) || strstr( buf, "voodoo3" ) )
+	{
+		glConfig.hardwareType = GLHW_3DFX_2D3D;
+	}
+	// VOODOO GRAPHICS w/ 2MB
+	else if ( strstr( buf, "voodoo graphics/1 tmu/2 mb" ) )
+	{
+	}
+	else if ( strstr( buf, "glzicd" ) )
+	{
+	}
+	else if ( strstr( buf, "rage pro" ) ||
+			strstr( buf, "Rage Pro" ) ||
+			strstr( buf, "ragepro" ) )
+	{
+		glConfig.hardwareType = GLHW_RAGEPRO;
+	}
+	else if ( strstr( buf, "rage 128" ) )
+	{
+	}
+	else if ( strstr( buf, "permedia2" ) )
+	{
+		glConfig.hardwareType = GLHW_PERMEDIA2;
+	}
+	else if ( strstr( buf, "riva 128" ) )
+	{
+		glConfig.hardwareType = GLHW_RIVA128;
+	}
+	else if ( strstr( buf, "riva tnt " ) )
+	{
+	}
+}
+
+/*
+** InitOpenGL
+**
+** This function is responsible for initializing a valid OpenGL subsystem.  This
+** is done by calling GLimp_Init (which gives us a working OGL subsystem) then
+** setting variables, checking GL constants, and reporting the gfx system config
+** to the user.
+*/
+static void InitOpenGL( void )
+{
+	char renderer_buffer[1024];
+
+	//
+	// initialize OS specific portions of the renderer
+	//
+	// GLimp_Init directly or indirectly references the following cvars:
+	//		- r_fullscreen
+	//		- r_(width|height|pixelAspect)
+	//		- r_(color|depth|stencil)bits
+	//		- r_ignorehwgamma
+	//		- r_gamma
+	//
+	
+	if ( glConfig.vidWidth == 0 )
+	{
+		GLint		temp;
+		
+		GLimp_Init();
+
+		strcpy( renderer_buffer, glConfig.renderer_string );
+		Q_strlwr( renderer_buffer );
+
+		// OpenGL driver constants
+		qglGetIntegerv( GL_MAX_TEXTURE_SIZE, &temp );
+		glConfig.maxTextureSize = temp;
+
+		// stubbed or broken drivers may have reported 0...
+		if ( glConfig.maxTextureSize <= 0 ) 
+		{
+			glConfig.maxTextureSize = 0;
+		}
+	}
+
+	// init command buffers and SMP
+	R_InitCommandBuffers();
+
+	// print info
+	GfxInfo_f();
+
+	// set default state
+	GL_SetDefaultState();
+}
+
+/*
+==================
+GL_CheckErrors
+==================
+*/
+void GL_CheckErrors( void ) {
+	int		err;
+	char	s[64];
+
+	err = qglGetError();
+	if ( err == GL_NO_ERROR ) {
+		return;
+	}
+	if ( r_ignoreGLErrors->integer ) {
+		return;
+	}
+	switch( err ) {
+		case GL_INVALID_ENUM:
+			strcpy( s, "GL_INVALID_ENUM" );
+			break;
+		case GL_INVALID_VALUE:
+			strcpy( s, "GL_INVALID_VALUE" );
+			break;
+		case GL_INVALID_OPERATION:
+			strcpy( s, "GL_INVALID_OPERATION" );
+			break;
+		case GL_STACK_OVERFLOW:
+			strcpy( s, "GL_STACK_OVERFLOW" );
+			break;
+		case GL_STACK_UNDERFLOW:
+			strcpy( s, "GL_STACK_UNDERFLOW" );
+			break;
+		case GL_OUT_OF_MEMORY:
+			strcpy( s, "GL_OUT_OF_MEMORY" );
+			break;
+		default:
+			Com_sprintf( s, sizeof(s), "%i", err);
+			break;
+	}
+
+	ri.Error( ERR_FATAL, "GL_CheckErrors: %s", s );
+}
+
+
+/* 
+============================================================================== 
+ 
+						SCREEN SHOTS 
+
+NOTE TTimo
+some thoughts about the screenshots system:
+screenshots get written in fs_homepath + fs_gamedir
+vanilla q3 .. baseq3/screenshots/ *.tga
+team arena .. missionpack/screenshots/ *.tga
+
+two commands: "screenshot" and "screenshotJPEG"
+we use statics to store a count and start writing the first screenshot/screenshot????.tga (.jpg) available
+(with FS_FileExists / FS_FOpenFileWrite calls)
+FIXME: the statics don't get a reinit between fs_game changes
+
+============================================================================== 
+*/ 
+
+/* 
+================== 
+RB_ReadPixels
+
+Reads an image but takes care of alignment issues for reading RGB images.
+
+Reads a minimum offset for where the RGB data starts in the image from
+integer stored at pointer offset. When the function has returned the actual
+offset was written back to address offset. This address will always have an
+alignment of packAlign to ensure efficient copying.
+
+Stores the length of padding after a line of pixels to address padlen
+
+Return value must be freed with ri.Hunk_FreeTempMemory()
+================== 
+*/  
+
+byte *RB_ReadPixels(int x, int y, int width, int height, size_t *offset, int *padlen)
+{
+	byte *buffer, *bufstart;
+	int padwidth, linelen;
+	GLint packAlign;
+	
+	qglGetIntegerv(GL_PACK_ALIGNMENT, &packAlign);
+	
+	linelen = width * 3;
+	padwidth = PAD(linelen, packAlign);
+	
+	// Allocate a few more bytes so that we can choose an alignment we like
+	buffer = ri.Hunk_AllocateTempMemory(padwidth * height + *offset + packAlign - 1);
+	
+	bufstart = (byte *) PAD((intptr_t) buffer + *offset, packAlign);
+	qglReadPixels(x, y, width, height, GL_RGB, GL_UNSIGNED_BYTE, bufstart);
+	
+	*offset = bufstart - buffer;
+	*padlen = padwidth - linelen;
+	
+	return buffer;
+}
+
+/* 
+================== 
+RB_TakeScreenshot
+================== 
+*/  
+void RB_TakeScreenshot(int x, int y, int width, int height, char *fileName)
+{
+	byte *allbuf, *buffer;
+	byte *srcptr, *destptr;
+	byte *endline, *endmem;
+	byte temp;
+	
+	int linelen, padlen;
+	size_t offset = 18, memcount;
+		
+	allbuf = RB_ReadPixels(x, y, width, height, &offset, &padlen);
+	buffer = allbuf + offset - 18;
+	
+	Com_Memset (buffer, 0, 18);
+	buffer[2] = 2;		// uncompressed type
+	buffer[12] = width & 255;
+	buffer[13] = width >> 8;
+	buffer[14] = height & 255;
+	buffer[15] = height >> 8;
+	buffer[16] = 24;	// pixel size
+
+	// swap rgb to bgr and remove padding from line endings
+	linelen = width * 3;
+	
+	srcptr = destptr = allbuf + offset;
+	endmem = srcptr + (linelen + padlen) * height;
+	
+	while(srcptr < endmem)
+	{
+		endline = srcptr + linelen;
+
+		while(srcptr < endline)
+		{
+			temp = srcptr[0];
+			*destptr++ = srcptr[2];
+			*destptr++ = srcptr[1];
+			*destptr++ = temp;
+			
+			srcptr += 3;
+		}
+		
+		// Skip the pad
+		srcptr += padlen;
+	}
+
+	memcount = linelen * height;
+
+	// gamma correct
+	if(glConfig.deviceSupportsGamma)
+		R_GammaCorrect(allbuf + offset, memcount);
+
+	ri.FS_WriteFile(fileName, buffer, memcount + 18);
+
+	ri.Hunk_FreeTempMemory(allbuf);
+}
+
+/* 
+================== 
+RB_TakeScreenshotJPEG
+================== 
+*/
+
+void RB_TakeScreenshotJPEG(int x, int y, int width, int height, char *fileName)
+{
+	byte *buffer;
+	size_t offset = 0, memcount;
+	int padlen;
+
+	buffer = RB_ReadPixels(x, y, width, height, &offset, &padlen);
+	memcount = (width * 3 + padlen) * height;
+
+	// gamma correct
+	if(glConfig.deviceSupportsGamma)
+		R_GammaCorrect(buffer + offset, memcount);
+
+	RE_SaveJPG(fileName, r_screenshotJpegQuality->integer, width, height, buffer + offset, padlen);
+	ri.Hunk_FreeTempMemory(buffer);
+}
+
+/*
+==================
+RB_TakeScreenshotCmd
+==================
+*/
+const void *RB_TakeScreenshotCmd( const void *data ) {
+	const screenshotCommand_t	*cmd;
+	
+	cmd = (const screenshotCommand_t *)data;
+	
+	if (cmd->jpeg)
+		RB_TakeScreenshotJPEG( cmd->x, cmd->y, cmd->width, cmd->height, cmd->fileName);
+	else
+		RB_TakeScreenshot( cmd->x, cmd->y, cmd->width, cmd->height, cmd->fileName);
+	
+	return (const void *)(cmd + 1);	
+}
+
+/*
+==================
+R_TakeScreenshot
+==================
+*/
+void R_TakeScreenshot( int x, int y, int width, int height, char *name, qboolean jpeg ) {
+	static char	fileName[MAX_OSPATH]; // bad things if two screenshots per frame?
+	screenshotCommand_t	*cmd;
+
+	cmd = R_GetCommandBuffer( sizeof( *cmd ) );
+	if ( !cmd ) {
+		return;
+	}
+	cmd->commandId = RC_SCREENSHOT;
+
+	cmd->x = x;
+	cmd->y = y;
+	cmd->width = width;
+	cmd->height = height;
+	Q_strncpyz( fileName, name, sizeof(fileName) );
+	cmd->fileName = fileName;
+	cmd->jpeg = jpeg;
+}
+
+/* 
+================== 
+R_ScreenshotFilename
+================== 
+*/  
+void R_ScreenshotFilename( int lastNumber, char *fileName ) {
+	int		a,b,c,d;
+
+	if ( lastNumber < 0 || lastNumber > 9999 ) {
+		Com_sprintf( fileName, MAX_OSPATH, "screenshots/shot9999.tga" );
+		return;
+	}
+
+	a = lastNumber / 1000;
+	lastNumber -= a*1000;
+	b = lastNumber / 100;
+	lastNumber -= b*100;
+	c = lastNumber / 10;
+	lastNumber -= c*10;
+	d = lastNumber;
+
+	Com_sprintf( fileName, MAX_OSPATH, "screenshots/shot%i%i%i%i.tga"
+		, a, b, c, d );
+}
+
+/* 
+================== 
+R_ScreenshotFilename
+================== 
+*/  
+void R_ScreenshotFilenameJPEG( int lastNumber, char *fileName ) {
+	int		a,b,c,d;
+
+	if ( lastNumber < 0 || lastNumber > 9999 ) {
+		Com_sprintf( fileName, MAX_OSPATH, "screenshots/shot9999.jpg" );
+		return;
+	}
+
+	a = lastNumber / 1000;
+	lastNumber -= a*1000;
+	b = lastNumber / 100;
+	lastNumber -= b*100;
+	c = lastNumber / 10;
+	lastNumber -= c*10;
+	d = lastNumber;
+
+	Com_sprintf( fileName, MAX_OSPATH, "screenshots/shot%i%i%i%i.jpg"
+		, a, b, c, d );
+}
+
+/*
+====================
+R_LevelShot
+
+levelshots are specialized 128*128 thumbnails for
+the menu system, sampled down from full screen distorted images
+====================
+*/
+void R_LevelShot( void ) {
+	char		checkname[MAX_OSPATH];
+	byte		*buffer;
+	byte		*source, *allsource;
+	byte		*src, *dst;
+	size_t			offset = 0;
+	int			padlen;
+	int			x, y;
+	int			r, g, b;
+	float		xScale, yScale;
+	int			xx, yy;
+
+	Com_sprintf(checkname, sizeof(checkname), "levelshots/%s.tga", tr.world->baseName);
+
+	allsource = RB_ReadPixels(0, 0, glConfig.vidWidth, glConfig.vidHeight, &offset, &padlen);
+	source = allsource + offset;
+
+	buffer = ri.Hunk_AllocateTempMemory(128 * 128*3 + 18);
+	Com_Memset (buffer, 0, 18);
+	buffer[2] = 2;		// uncompressed type
+	buffer[12] = 128;
+	buffer[14] = 128;
+	buffer[16] = 24;	// pixel size
+
+	// resample from source
+	xScale = glConfig.vidWidth / 512.0f;
+	yScale = glConfig.vidHeight / 384.0f;
+	for ( y = 0 ; y < 128 ; y++ ) {
+		for ( x = 0 ; x < 128 ; x++ ) {
+			r = g = b = 0;
+			for ( yy = 0 ; yy < 3 ; yy++ ) {
+				for ( xx = 0 ; xx < 4 ; xx++ ) {
+					src = source + (3 * glConfig.vidWidth + padlen) * (int)((y*3 + yy) * yScale) +
+						3 * (int) ((x*4 + xx) * xScale);
+					r += src[0];
+					g += src[1];
+					b += src[2];
+				}
+			}
+			dst = buffer + 18 + 3 * ( y * 128 + x );
+			dst[0] = b / 12;
+			dst[1] = g / 12;
+			dst[2] = r / 12;
+		}
+	}
+
+	// gamma correct
+	if ( glConfig.deviceSupportsGamma ) {
+		R_GammaCorrect( buffer + 18, 128 * 128 * 3 );
+	}
+
+	ri.FS_WriteFile( checkname, buffer, 128 * 128*3 + 18 );
+
+	ri.Hunk_FreeTempMemory(buffer);
+	ri.Hunk_FreeTempMemory(allsource);
+
+	ri.Printf( PRINT_ALL, "Wrote %s\n", checkname );
+}
+
+/* 
+================== 
+R_ScreenShot_f
+
+screenshot
+screenshot [silent]
+screenshot [levelshot]
+screenshot [filename]
+
+Doesn't print the pacifier message if there is a second arg
+================== 
+*/  
+void R_ScreenShot_f (void) {
+	char	checkname[MAX_OSPATH];
+	static	int	lastNumber = -1;
+	qboolean	silent;
+
+	if ( !strcmp( ri.Cmd_Argv(1), "levelshot" ) ) {
+		R_LevelShot();
+		return;
+	}
+
+	if ( !strcmp( ri.Cmd_Argv(1), "silent" ) ) {
+		silent = qtrue;
+	} else {
+		silent = qfalse;
+	}
+
+	if ( ri.Cmd_Argc() == 2 && !silent ) {
+		// explicit filename
+		Com_sprintf( checkname, MAX_OSPATH, "screenshots/%s.tga", ri.Cmd_Argv( 1 ) );
+	} else {
+		// scan for a free filename
+
+		// if we have saved a previous screenshot, don't scan
+		// again, because recording demo avis can involve
+		// thousands of shots
+		if ( lastNumber == -1 ) {
+			lastNumber = 0;
+		}
+		// scan for a free number
+		for ( ; lastNumber <= 9999 ; lastNumber++ ) {
+			R_ScreenshotFilename( lastNumber, checkname );
+
+      if (!ri.FS_FileExists( checkname ))
+      {
+        break; // file doesn't exist
+      }
+		}
+
+		if ( lastNumber >= 9999 ) {
+			ri.Printf (PRINT_ALL, "ScreenShot: Couldn't create a file\n"); 
+			return;
+ 		}
+
+		lastNumber++;
+	}
+
+	R_TakeScreenshot( 0, 0, glConfig.vidWidth, glConfig.vidHeight, checkname, qfalse );
+
+	if ( !silent ) {
+		ri.Printf (PRINT_ALL, "Wrote %s\n", checkname);
+	}
+} 
+
+void R_ScreenShotJPEG_f (void) {
+	char		checkname[MAX_OSPATH];
+	static	int	lastNumber = -1;
+	qboolean	silent;
+
+	if ( !strcmp( ri.Cmd_Argv(1), "levelshot" ) ) {
+		R_LevelShot();
+		return;
+	}
+
+	if ( !strcmp( ri.Cmd_Argv(1), "silent" ) ) {
+		silent = qtrue;
+	} else {
+		silent = qfalse;
+	}
+
+	if ( ri.Cmd_Argc() == 2 && !silent ) {
+		// explicit filename
+		Com_sprintf( checkname, MAX_OSPATH, "screenshots/%s.jpg", ri.Cmd_Argv( 1 ) );
+	} else {
+		// scan for a free filename
+
+		// if we have saved a previous screenshot, don't scan
+		// again, because recording demo avis can involve
+		// thousands of shots
+		if ( lastNumber == -1 ) {
+			lastNumber = 0;
+		}
+		// scan for a free number
+		for ( ; lastNumber <= 9999 ; lastNumber++ ) {
+			R_ScreenshotFilenameJPEG( lastNumber, checkname );
+
+      if (!ri.FS_FileExists( checkname ))
+      {
+        break; // file doesn't exist
+      }
+		}
+
+		if ( lastNumber == 10000 ) {
+			ri.Printf (PRINT_ALL, "ScreenShot: Couldn't create a file\n"); 
+			return;
+ 		}
+
+		lastNumber++;
+	}
+
+	R_TakeScreenshot( 0, 0, glConfig.vidWidth, glConfig.vidHeight, checkname, qtrue );
+
+	if ( !silent ) {
+		ri.Printf (PRINT_ALL, "Wrote %s\n", checkname);
+	}
+} 
+
+//============================================================================
+
+/*
+==================
+RB_TakeVideoFrameCmd
+==================
+*/
+const void *RB_TakeVideoFrameCmd( const void *data )
+{
+	const videoFrameCommand_t	*cmd;
+	byte				*cBuf;
+	size_t				memcount, linelen;
+	int				padwidth, avipadwidth, padlen, avipadlen;
+	GLint packAlign;
+	
+	cmd = (const videoFrameCommand_t *)data;
+	
+	qglGetIntegerv(GL_PACK_ALIGNMENT, &packAlign);
+
+	linelen = cmd->width * 3;
+
+	// Alignment stuff for glReadPixels
+	padwidth = PAD(linelen, packAlign);
+	padlen = padwidth - linelen;
+	// AVI line padding
+	avipadwidth = PAD(linelen, AVI_LINE_PADDING);
+	avipadlen = avipadwidth - linelen;
+
+	cBuf = (byte *) PAD((intptr_t) cmd->captureBuffer, packAlign);
+		
+	qglReadPixels(0, 0, cmd->width, cmd->height, GL_RGB,
+		GL_UNSIGNED_BYTE, cBuf);
+
+	memcount = padwidth * cmd->height;
+
+	// gamma correct
+	if(glConfig.deviceSupportsGamma)
+		R_GammaCorrect(cBuf, memcount);
+
+	if(cmd->motionJpeg)
+	{
+		memcount = RE_SaveJPGToBuffer(cmd->encodeBuffer, linelen * cmd->height,
+			r_aviMotionJpegQuality->integer,
+			cmd->width, cmd->height, cBuf, padlen);
+		ri.CL_WriteAVIVideoFrame(cmd->encodeBuffer, memcount);
+	}
+	else
+	{
+		byte *lineend, *memend;
+		byte *srcptr, *destptr;
+	
+		srcptr = cBuf;
+		destptr = cmd->encodeBuffer;
+		memend = srcptr + memcount;
+		
+		// swap R and B and remove line paddings
+		while(srcptr < memend)
+		{
+			lineend = srcptr + linelen;
+			while(srcptr < lineend)
+			{
+				*destptr++ = srcptr[2];
+				*destptr++ = srcptr[1];
+				*destptr++ = srcptr[0];
+				srcptr += 3;
+			}
+			
+			Com_Memset(destptr, '\0', avipadlen);
+			destptr += avipadlen;
+			
+			srcptr += padlen;
+		}
+		
+		ri.CL_WriteAVIVideoFrame(cmd->encodeBuffer, avipadwidth * cmd->height);
+	}
+
+	return (const void *)(cmd + 1);	
+}
+
+//============================================================================
+
+/*
+** GL_SetDefaultState
+*/
+void GL_SetDefaultState( void )
+{
+	qglClearDepth( 1.0f );
+
+	qglCullFace(GL_FRONT);
+
+	qglColor4f (1,1,1,1);
+
+	// initialize downstream texture unit if we're running
+	// in a multitexture environment
+	if ( qglActiveTextureARB ) {
+		GL_SelectTexture( 1 );
+		GL_TextureMode( r_textureMode->string );
+		GL_TexEnv( GL_MODULATE );
+		qglDisable( GL_TEXTURE_2D );
+		GL_SelectTexture( 0 );
+	}
+
+	qglEnable(GL_TEXTURE_2D);
+	GL_TextureMode( r_textureMode->string );
+	GL_TexEnv( GL_MODULATE );
+
+	qglShadeModel( GL_SMOOTH );
+	qglDepthFunc( GL_LEQUAL );
+
+	// the vertex array is always enabled, but the color and texture
+	// arrays are enabled and disabled around the compiled vertex array call
+	qglEnableClientState (GL_VERTEX_ARRAY);
+
+	//
+	// make sure our GL state vector is set correctly
+	//
+	glState.glStateBits = GLS_DEPTHTEST_DISABLE | GLS_DEPTHMASK_TRUE;
+
+	qglPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
+	qglDepthMask( GL_TRUE );
+	qglDisable( GL_DEPTH_TEST );
+	qglEnable( GL_SCISSOR_TEST );
+	qglDisable( GL_CULL_FACE );
+	qglDisable( GL_BLEND );
+}
+
+
+/*
+================
+GfxInfo_f
+================
+*/
+void GfxInfo_f( void ) 
+{
+	const char *enablestrings[] =
+	{
+		"disabled",
+		"enabled"
+	};
+	const char *fsstrings[] =
+	{
+		"windowed",
+		"fullscreen"
+	};
+
+	ri.Printf( PRINT_ALL, "\nGL_VENDOR: %s\n", glConfig.vendor_string );
+	ri.Printf( PRINT_ALL, "GL_RENDERER: %s\n", glConfig.renderer_string );
+	ri.Printf( PRINT_ALL, "GL_VERSION: %s\n", glConfig.version_string );
+	ri.Printf( PRINT_ALL, "GL_EXTENSIONS: %s\n", glConfig.extensions_string );
+	ri.Printf( PRINT_ALL, "GL_MAX_TEXTURE_SIZE: %d\n", glConfig.maxTextureSize );
+	ri.Printf( PRINT_ALL, "GL_MAX_TEXTURE_UNITS_ARB: %d\n", glConfig.numTextureUnits );
+	ri.Printf( PRINT_ALL, "\nPIXELFORMAT: color(%d-bits) Z(%d-bit) stencil(%d-bits)\n", glConfig.colorBits, glConfig.depthBits, glConfig.stencilBits );
+	ri.Printf( PRINT_ALL, "MODE: %d x %d %s hz:", glConfig.vidWidth, glConfig.vidHeight, fsstrings[r_fullscreen->integer == 1] );
+	if ( glConfig.displayFrequency )
+	{
+		ri.Printf( PRINT_ALL, "%d\n", glConfig.displayFrequency );
+	}
+	else
+	{
+		ri.Printf( PRINT_ALL, "N/A\n" );
+	}
+	if ( glConfig.deviceSupportsGamma )
+	{
+		ri.Printf( PRINT_ALL, "GAMMA: hardware w/ %d overbright bits\n", tr.overbrightBits );
+	}
+	else
+	{
+		ri.Printf( PRINT_ALL, "GAMMA: software w/ %d overbright bits\n", tr.overbrightBits );
+	}
+
+	// rendering primitives
+	{
+		int		primitives;
+
+		// default is to use triangles if compiled vertex arrays are present
+		ri.Printf( PRINT_ALL, "rendering primitives: " );
+		primitives = r_primitives->integer;
+		if ( primitives == 0 ) {
+			if ( qglLockArraysEXT ) {
+				primitives = 2;
+			} else {
+				primitives = 1;
+			}
+		}
+		if ( primitives == -1 ) {
+			ri.Printf( PRINT_ALL, "none\n" );
+		} else if ( primitives == 2 ) {
+			ri.Printf( PRINT_ALL, "single glDrawElements\n" );
+		} else if ( primitives == 1 ) {
+			ri.Printf( PRINT_ALL, "multiple glArrayElement\n" );
+		} else if ( primitives == 3 ) {
+			ri.Printf( PRINT_ALL, "multiple glColor4ubv + glTexCoord2fv + glVertex3fv\n" );
+		}
+	}
+
+	ri.Printf( PRINT_ALL, "texturemode: %s\n", r_textureMode->string );
+	ri.Printf( PRINT_ALL, "picmip: %d\n", r_picmip->integer );
+	ri.Printf( PRINT_ALL, "texture bits: %d\n", r_texturebits->integer );
+	ri.Printf( PRINT_ALL, "multitexture: %s\n", enablestrings[qglActiveTextureARB != 0] );
+	ri.Printf( PRINT_ALL, "compiled vertex arrays: %s\n", enablestrings[qglLockArraysEXT != 0 ] );
+	ri.Printf( PRINT_ALL, "texenv add: %s\n", enablestrings[glConfig.textureEnvAddAvailable != 0] );
+	ri.Printf( PRINT_ALL, "compressed textures: %s\n", enablestrings[glConfig.textureCompression!=TC_NONE] );
+	if ( r_vertexLight->integer || glConfig.hardwareType == GLHW_PERMEDIA2 )
+	{
+		ri.Printf( PRINT_ALL, "HACK: using vertex lightmap approximation\n" );
+	}
+	if ( glConfig.hardwareType == GLHW_RAGEPRO )
+	{
+		ri.Printf( PRINT_ALL, "HACK: ragePro approximations\n" );
+	}
+	if ( glConfig.hardwareType == GLHW_RIVA128 )
+	{
+		ri.Printf( PRINT_ALL, "HACK: riva128 approximations\n" );
+	}
+	if ( glConfig.smpActive ) {
+		ri.Printf( PRINT_ALL, "Using dual processor acceleration\n" );
+	}
+	if ( r_finish->integer ) {
+		ri.Printf( PRINT_ALL, "Forcing glFinish\n" );
+	}
+}
+
+/*
+===============
+R_Register
+===============
+*/
+void R_Register( void ) 
+{
+	//
+	// latched and archived variables
+	//
+	r_allowExtensions = ri.Cvar_Get( "r_allowExtensions", "1", CVAR_ARCHIVE | CVAR_LATCH );
+	r_ext_compressed_textures = ri.Cvar_Get( "r_ext_compressed_textures", "0", CVAR_ARCHIVE | CVAR_LATCH );
+	r_ext_multitexture = ri.Cvar_Get( "r_ext_multitexture", "1", CVAR_ARCHIVE | CVAR_LATCH );
+	r_ext_compiled_vertex_array = ri.Cvar_Get( "r_ext_compiled_vertex_array", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_texture_env_add = ri.Cvar_Get( "r_ext_texture_env_add", "1", CVAR_ARCHIVE | CVAR_LATCH);
+
+	r_picmip = ri.Cvar_Get ("r_picmip", GENERIC_HW_R_PICMIP_DEFAULT,
+			CVAR_ARCHIVE | CVAR_LATCH );
+	r_ext_texture_filter_anisotropic = ri.Cvar_Get( "r_ext_texture_filter_anisotropic",
+			"0", CVAR_ARCHIVE | CVAR_LATCH );
+	r_ext_max_anisotropy = ri.Cvar_Get( "r_ext_max_anisotropy", "2", CVAR_ARCHIVE | CVAR_LATCH );
+
+	r_roundImagesDown = ri.Cvar_Get ("r_roundImagesDown", "1", CVAR_ARCHIVE | CVAR_LATCH );
+	r_colorMipLevels = ri.Cvar_Get ("r_colorMipLevels", "0", CVAR_LATCH );
+	ri.Cvar_CheckRange( r_picmip, 0, 16, qtrue );
+	r_detailTextures = ri.Cvar_Get( "r_detailtextures", "1", CVAR_ARCHIVE | CVAR_LATCH );
+	r_texturebits = ri.Cvar_Get( "r_texturebits", "0", CVAR_ARCHIVE | CVAR_LATCH );
+	r_colorbits = ri.Cvar_Get( "r_colorbits", "0", CVAR_ARCHIVE | CVAR_LATCH );
+	r_stencilbits = ri.Cvar_Get( "r_stencilbits", "8", CVAR_ARCHIVE | CVAR_LATCH );
+	r_depthbits = ri.Cvar_Get( "r_depthbits", "0", CVAR_ARCHIVE | CVAR_LATCH );
+	r_ext_multisample = ri.Cvar_Get( "r_ext_multisample", "0", CVAR_ARCHIVE | CVAR_LATCH );
+	ri.Cvar_CheckRange( r_ext_multisample, 0, 4, qtrue );
+	r_overBrightBits = ri.Cvar_Get ("r_overBrightBits", "1", CVAR_ARCHIVE | CVAR_LATCH );
+	r_ignorehwgamma = ri.Cvar_Get( "r_ignorehwgamma", "0", CVAR_ARCHIVE | CVAR_LATCH);
+	r_fullscreen = ri.Cvar_Get( "r_fullscreen", "1", CVAR_ARCHIVE );
+	r_noborder = Cvar_Get("r_noborder", "0", CVAR_ARCHIVE);
+	r_width = ri.Cvar_Get( "r_width", "640", CVAR_ARCHIVE | CVAR_LATCH );
+	r_height = ri.Cvar_Get( "r_height", "480", CVAR_ARCHIVE | CVAR_LATCH );
+	r_pixelAspect = ri.Cvar_Get( "r_pixelAspect", "1", CVAR_ARCHIVE | CVAR_LATCH );
+	r_simpleMipMaps = ri.Cvar_Get( "r_simpleMipMaps", "1", CVAR_ARCHIVE | CVAR_LATCH );
+	r_vertexLight = ri.Cvar_Get( "r_vertexLight", "0", CVAR_ARCHIVE | CVAR_LATCH );
+	r_uiFullScreen = ri.Cvar_Get( "r_uifullscreen", "0", 0);
+	r_subdivisions = ri.Cvar_Get ("r_subdivisions", "4", CVAR_ARCHIVE | CVAR_LATCH);
+	r_smp = ri.Cvar_Get( "r_smp", "0", CVAR_ARCHIVE | CVAR_LATCH);
+	r_stereoEnabled = ri.Cvar_Get( "r_stereoEnabled", "0", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ignoreFastPath = ri.Cvar_Get( "r_ignoreFastPath", "1", CVAR_ARCHIVE | CVAR_LATCH );
+	r_greyscale = ri.Cvar_Get("r_greyscale", "0", CVAR_ARCHIVE | CVAR_LATCH);
+	ri.Cvar_CheckRange(r_greyscale, 0, 1, qfalse);
+
+	//
+	// temporary latched variables that can only change over a restart
+	//
+	r_fullbright = ri.Cvar_Get ("r_fullbright", "0", CVAR_LATCH|CVAR_CHEAT );
+	r_mapOverBrightBits = ri.Cvar_Get ("r_mapOverBrightBits", "2", CVAR_LATCH );
+	r_intensity = ri.Cvar_Get ("r_intensity", "1", CVAR_LATCH );
+	r_singleShader = ri.Cvar_Get ("r_singleShader", "0", CVAR_CHEAT | CVAR_LATCH );
+
+	//
+	// archived variables that can change at any time
+	//
+	r_lodCurveError = ri.Cvar_Get( "r_lodCurveError", "250", CVAR_ARCHIVE|CVAR_CHEAT );
+	r_lodbias = ri.Cvar_Get( "r_lodbias", "0", CVAR_ARCHIVE );
+	r_flares = ri.Cvar_Get ("r_flares", "0", CVAR_ARCHIVE );
+	r_znear = ri.Cvar_Get( "r_znear", "1", CVAR_CHEAT );
+	ri.Cvar_CheckRange( r_znear, 0.001f, 200, qfalse );
+	r_zproj = ri.Cvar_Get( "r_zproj", "64", CVAR_ARCHIVE );
+	r_stereoSeparation = ri.Cvar_Get( "r_stereoSeparation", "64", CVAR_ARCHIVE );
+	r_ignoreGLErrors = ri.Cvar_Get( "r_ignoreGLErrors", "1", CVAR_ARCHIVE );
+	r_fastsky = ri.Cvar_Get( "r_fastsky", "0", CVAR_ARCHIVE );
+	r_inGameVideo = ri.Cvar_Get( "r_inGameVideo", "1", CVAR_ARCHIVE );
+	r_drawSun = ri.Cvar_Get( "r_drawSun", "0", CVAR_ARCHIVE );
+	r_dynamiclight = ri.Cvar_Get( "r_dynamiclight", "1", CVAR_ARCHIVE );
+	r_dlightBacks = ri.Cvar_Get( "r_dlightBacks", "1", CVAR_ARCHIVE );
+	r_finish = ri.Cvar_Get ("r_finish", "0", CVAR_ARCHIVE);
+	r_textureMode = ri.Cvar_Get( "r_textureMode",
+			GENERIC_HW_R_TEXTUREMODE_DEFAULT, CVAR_ARCHIVE );
+	r_swapInterval = ri.Cvar_Get( "r_swapInterval", "0",
+					CVAR_ARCHIVE | CVAR_LATCH );
+	r_gamma = ri.Cvar_Get( "r_gamma", "1", CVAR_ARCHIVE );
+	r_facePlaneCull = ri.Cvar_Get ("r_facePlaneCull", "1", CVAR_ARCHIVE );
+
+	r_railWidth = ri.Cvar_Get( "r_railWidth", "16", CVAR_ARCHIVE );
+	r_railCoreWidth = ri.Cvar_Get( "r_railCoreWidth", "6", CVAR_ARCHIVE );
+	r_railSegmentLength = ri.Cvar_Get( "r_railSegmentLength", "32", CVAR_ARCHIVE );
+
+	r_primitives = ri.Cvar_Get( "r_primitives", "0", CVAR_ARCHIVE );
+
+	r_ambientScale = ri.Cvar_Get( "r_ambientScale", "0.6", CVAR_CHEAT );
+	r_directedScale = ri.Cvar_Get( "r_directedScale", "1", CVAR_CHEAT );
+
+	r_anaglyphMode = ri.Cvar_Get("r_anaglyphMode", "0", CVAR_ARCHIVE);
+
+	//
+	// temporary variables that can change at any time
+	//
+	r_showImages = ri.Cvar_Get( "r_showImages", "0", CVAR_TEMP );
+
+	r_debugLight = ri.Cvar_Get( "r_debuglight", "0", CVAR_TEMP );
+	r_debugSort = ri.Cvar_Get( "r_debugSort", "0", CVAR_CHEAT );
+	r_printShaders = ri.Cvar_Get( "r_printShaders", "0", 0 );
+	r_saveFontData = ri.Cvar_Get( "r_saveFontData", "0", 0 );
+
+	r_nocurves = ri.Cvar_Get ("r_nocurves", "0", CVAR_CHEAT );
+	r_drawworld = ri.Cvar_Get ("r_drawworld", "1", CVAR_CHEAT );
+	r_lightmap = ri.Cvar_Get ("r_lightmap", "0", CVAR_CHEAT );
+	r_portalOnly = ri.Cvar_Get ("r_portalOnly", "0", CVAR_CHEAT );
+
+	r_flareSize = ri.Cvar_Get ("r_flareSize", "40", CVAR_CHEAT);
+	r_flareFade = ri.Cvar_Get ("r_flareFade", "7", CVAR_CHEAT);
+	r_flareCoeff = ri.Cvar_Get ("r_flareCoeff", FLARE_STDCOEFF, CVAR_CHEAT);
+
+	r_showSmp = ri.Cvar_Get ("r_showSmp", "0", CVAR_CHEAT);
+	r_skipBackEnd = ri.Cvar_Get ("r_skipBackEnd", "0", CVAR_CHEAT);
+
+	r_measureOverdraw = ri.Cvar_Get( "r_measureOverdraw", "0", CVAR_CHEAT );
+	r_lodscale = ri.Cvar_Get( "r_lodscale", "5", CVAR_CHEAT );
+	r_norefresh = ri.Cvar_Get ("r_norefresh", "0", CVAR_CHEAT);
+	r_drawentities = ri.Cvar_Get ("r_drawentities", "1", CVAR_CHEAT );
+	r_ignore = ri.Cvar_Get( "r_ignore", "1", CVAR_CHEAT );
+	r_nocull = ri.Cvar_Get ("r_nocull", "0", CVAR_CHEAT);
+	r_novis = ri.Cvar_Get ("r_novis", "0", CVAR_CHEAT);
+	r_showcluster = ri.Cvar_Get ("r_showcluster", "0", CVAR_CHEAT);
+	r_speeds = ri.Cvar_Get ("r_speeds", "0", CVAR_CHEAT);
+	r_verbose = ri.Cvar_Get( "r_verbose", "0", CVAR_CHEAT );
+	r_logFile = ri.Cvar_Get( "r_logFile", "0", CVAR_CHEAT );
+	r_debugSurface = ri.Cvar_Get ("r_debugSurface", "0", CVAR_CHEAT);
+	r_nobind = ri.Cvar_Get ("r_nobind", "0", CVAR_CHEAT);
+	r_showtris = ri.Cvar_Get ("r_showtris", "0", CVAR_CHEAT);
+	r_showsky = ri.Cvar_Get ("r_showsky", "0", CVAR_CHEAT);
+	r_shownormals = ri.Cvar_Get ("r_shownormals", "0", CVAR_CHEAT);
+	r_clear = ri.Cvar_Get ("r_clear", "0", CVAR_CHEAT);
+	r_offsetFactor = ri.Cvar_Get( "r_offsetfactor", "-1", CVAR_CHEAT );
+	r_offsetUnits = ri.Cvar_Get( "r_offsetunits", "-2", CVAR_CHEAT );
+	r_drawBuffer = ri.Cvar_Get( "r_drawBuffer", "GL_BACK", CVAR_CHEAT );
+	r_lockpvs = ri.Cvar_Get ("r_lockpvs", "0", CVAR_CHEAT);
+	r_noportals = ri.Cvar_Get ("r_noportals", "0", CVAR_CHEAT);
+	r_shadows = ri.Cvar_Get( "cg_shadows", "1", 0 );
+
+	r_marksOnTriangleMeshes = ri.Cvar_Get("r_marksOnTriangleMeshes", "0", CVAR_ARCHIVE);
+
+	r_aviMotionJpegQuality = ri.Cvar_Get("r_aviMotionJpegQuality", "90", CVAR_ARCHIVE);
+	r_screenshotJpegQuality = ri.Cvar_Get("r_screenshotJpegQuality", "90", CVAR_ARCHIVE);
+
+	r_maxpolys = ri.Cvar_Get( "r_maxpolys", va("%d", MAX_POLYS), 0);
+	r_maxpolyverts = ri.Cvar_Get( "r_maxpolyverts", va("%d", MAX_POLYVERTS), 0);
+
+	// make sure all the commands added here are also
+	// removed in R_Shutdown
+	ri.Cmd_AddCommand( "imagelist", R_ImageList_f );
+	ri.Cmd_AddCommand( "shaderlist", R_ShaderList_f );
+	ri.Cmd_AddCommand( "skinlist", R_SkinList_f );
+	ri.Cmd_AddCommand( "modellist", R_Modellist_f );
+	ri.Cmd_AddCommand( "screenshot", R_ScreenShot_f );
+	ri.Cmd_AddCommand( "screenshotJPEG", R_ScreenShotJPEG_f );
+	ri.Cmd_AddCommand( "gfxinfo", GfxInfo_f );
+}
+
+/*
+===============
+R_Init
+===============
+*/
+void R_Init( void ) {	
+	int	err;
+	int i;
+	byte *ptr;
+
+	ri.Printf( PRINT_ALL, "----- R_Init -----\n" );
+
+	// clear all our internal state
+	Com_Memset( &tr, 0, sizeof( tr ) );
+	Com_Memset( &backEnd, 0, sizeof( backEnd ) );
+	Com_Memset( &tess, 0, sizeof( tess ) );
+
+//	Swap_Init();
+
+	if ( (intptr_t)tess.xyz & 15 ) {
+		Com_Printf( "WARNING: tess.xyz not 16 byte aligned\n" );
+	}
+	Com_Memset( tess.constantColor255, 255, sizeof( tess.constantColor255 ) );
+
+	//
+	// init function tables
+	//
+	for ( i = 0; i < FUNCTABLE_SIZE; i++ )
+	{
+		tr.sinTable[i]		= sin( DEG2RAD( i * 360.0f / ( ( float ) ( FUNCTABLE_SIZE - 1 ) ) ) );
+		tr.squareTable[i]	= ( i < FUNCTABLE_SIZE/2 ) ? 1.0f : -1.0f;
+		tr.sawToothTable[i] = (float)i / FUNCTABLE_SIZE;
+		tr.inverseSawToothTable[i] = 1.0f - tr.sawToothTable[i];
+
+		if ( i < FUNCTABLE_SIZE / 2 )
+		{
+			if ( i < FUNCTABLE_SIZE / 4 )
+			{
+				tr.triangleTable[i] = ( float ) i / ( FUNCTABLE_SIZE / 4 );
+			}
+			else
+			{
+				tr.triangleTable[i] = 1.0f - tr.triangleTable[i-FUNCTABLE_SIZE / 4];
+			}
+		}
+		else
+		{
+			tr.triangleTable[i] = -tr.triangleTable[i-FUNCTABLE_SIZE/2];
+		}
+	}
+
+	R_InitFogTable();
+
+	R_NoiseInit();
+
+	R_Register();
+
+	max_polys = r_maxpolys->integer;
+	if (max_polys < MAX_POLYS)
+		max_polys = MAX_POLYS;
+
+	max_polyverts = r_maxpolyverts->integer;
+	if (max_polyverts < MAX_POLYVERTS)
+		max_polyverts = MAX_POLYVERTS;
+
+	ptr = ri.Hunk_Alloc( sizeof( *backEndData[0] ) + sizeof(srfPoly_t) * max_polys + sizeof(polyVert_t) * max_polyverts, h_low);
+	backEndData[0] = (backEndData_t *) ptr;
+	backEndData[0]->polys = (srfPoly_t *) ((char *) ptr + sizeof( *backEndData[0] ));
+	backEndData[0]->polyVerts = (polyVert_t *) ((char *) ptr + sizeof( *backEndData[0] ) + sizeof(srfPoly_t) * max_polys);
+	if ( r_smp->integer ) {
+		ptr = ri.Hunk_Alloc( sizeof( *backEndData[1] ) + sizeof(srfPoly_t) * max_polys + sizeof(polyVert_t) * max_polyverts, h_low);
+		backEndData[1] = (backEndData_t *) ptr;
+		backEndData[1]->polys = (srfPoly_t *) ((char *) ptr + sizeof( *backEndData[1] ));
+		backEndData[1]->polyVerts = (polyVert_t *) ((char *) ptr + sizeof( *backEndData[1] ) + sizeof(srfPoly_t) * max_polys);
+	} else {
+		backEndData[1] = NULL;
+	}
+	R_ToggleSmpFrame();
+
+	InitOpenGL();
+
+	R_InitImages();
+
+	R_InitShaders();
+
+	R_InitSkins();
+
+	R_ModelInit();
+
+	R_InitFreeType();
+
+
+	err = qglGetError();
+	if ( err != GL_NO_ERROR )
+		ri.Printf (PRINT_ALL, "glGetError() = 0x%x\n", err);
+
+	ri.Printf( PRINT_ALL, "----- finished R_Init -----\n" );
+}
+
+/*
+===============
+RE_Shutdown
+===============
+*/
+void RE_Shutdown( qboolean destroyWindow ) {	
+
+	ri.Printf( PRINT_ALL, "RE_Shutdown( %i )\n", destroyWindow );
+
+	ri.Cmd_RemoveCommand ("modellist");
+	ri.Cmd_RemoveCommand ("screenshotJPEG");
+	ri.Cmd_RemoveCommand ("screenshot");
+	ri.Cmd_RemoveCommand ("imagelist");
+	ri.Cmd_RemoveCommand ("shaderlist");
+	ri.Cmd_RemoveCommand ("skinlist");
+	ri.Cmd_RemoveCommand ("gfxinfo");
+	ri.Cmd_RemoveCommand( "modelist" );
+	ri.Cmd_RemoveCommand( "shaderstate" );
+
+
+	if ( tr.registered ) {
+		R_SyncRenderThread();
+		R_ShutdownCommandBuffers();
+		R_DeleteTextures();
+	}
+
+	R_DoneFreeType();
+
+	// shut down platform specific OpenGL stuff
+	if ( destroyWindow ) {
+		GLimp_Shutdown();
+	}
+
+	tr.registered = qfalse;
+}
+
+
+/*
+=============
+RE_EndRegistration
+
+Touch all images to make sure they are resident
+=============
+*/
+void RE_EndRegistration( void ) {
+	R_SyncRenderThread();
+	if (!Sys_LowPhysicalMemory()) {
+		RB_ShowImages();
+	}
+}
+
+
+/*
+@@@@@@@@@@@@@@@@@@@@@
+GetRefAPI
+
+@@@@@@@@@@@@@@@@@@@@@
+*/
+refexport_t *GetRefAPI ( int apiVersion, refimport_t *rimp ) {
+	static refexport_t	re;
+
+	ri = *rimp;
+
+	Com_Memset( &re, 0, sizeof( re ) );
+
+	if ( apiVersion != REF_API_VERSION ) {
+		ri.Printf(PRINT_ALL, "Mismatched REF_API_VERSION: expected %i, got %i\n", 
+			REF_API_VERSION, apiVersion );
+		return NULL;
+	}
+
+	// the RE_ functions are Renderer Entry points
+
+	re.Shutdown = RE_Shutdown;
+
+	re.BeginRegistration = RE_BeginRegistration;
+	re.RegisterModel = RE_RegisterModel;
+	re.RegisterSkin = RE_RegisterSkin;
+	re.RegisterShader = RE_RegisterShader;
+	re.RegisterShaderNoMip = RE_RegisterShaderNoMip;
+	re.LoadWorld = RE_LoadWorldMap;
+	re.SetWorldVisData = RE_SetWorldVisData;
+	re.EndRegistration = RE_EndRegistration;
+
+	re.BeginFrame = RE_BeginFrame;
+	re.EndFrame = RE_EndFrame;
+
+	re.MarkFragments = R_MarkFragments;
+	re.LerpTag = R_LerpTag;
+	re.ModelBounds = R_ModelBounds;
+
+	re.ClearScene = RE_ClearScene;
+	re.AddRefEntityToScene = RE_AddRefEntityToScene;
+	re.AddPolyToScene = RE_AddPolyToScene;
+	re.LightForPoint = R_LightForPoint;
+	re.AddLightToScene = RE_AddLightToScene;
+	re.AddAdditiveLightToScene = RE_AddAdditiveLightToScene;
+	re.RenderScene = RE_RenderScene;
+
+	re.SetColor = RE_SetColor;
+	re.SetClipRegion = RE_SetClipRegion;
+	re.DrawStretchPic = RE_StretchPic;
+	re.DrawStretchRaw = RE_StretchRaw;
+	re.UploadCinematic = RE_UploadCinematic;
+
+	re.RegisterFont = RE_RegisterFont;
+	re.RemapShader = R_RemapShader;
+	re.GetEntityToken = R_GetEntityToken;
+	re.inPVS = R_inPVS;
+
+	re.TakeVideoFrame = RE_TakeVideoFrame;
+
+	return &re;
+}
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_iqm.c tremulous-ggp1-src/src/renderer/tr_iqm.c
--- tremulous-ggp1-src.p/src/renderer/tr_iqm.c	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_iqm.c	2012-07-19 04:25:52.031556446 +0200
@@ -0,0 +1,799 @@
+/* copyright */
+
+#include "tr_local.h"
+
+#define	LL(x) x=LittleLong(x)
+
+static qboolean IQM_CheckRange( iqmHeader_t *header, int offset,
+				int count,int size ) {
+	// return true if the range specified by offset, count and size
+	// doesn't fit into the file
+	return ( count <= 0 ||
+		 offset < 0 ||
+		 offset > header->filesize ||
+		 offset + count * size < 0 ||
+		 offset + count * size > header->filesize );
+}
+// "multiply" 3x4 matrices, these are assumed to be the top 3 rows
+// of a 4x4 matrix with the last row = (0 0 0 1)
+static void Matrix34Multiply( float *a, float *b, float *out ) {
+	out[ 0] = a[0] * b[0] + a[1] * b[4] + a[ 2] * b[ 8];
+	out[ 1] = a[0] * b[1] + a[1] * b[5] + a[ 2] * b[ 9];
+	out[ 2] = a[0] * b[2] + a[1] * b[6] + a[ 2] * b[10];
+	out[ 3] = a[0] * b[3] + a[1] * b[7] + a[ 2] * b[11] + a[ 3];
+	out[ 4] = a[4] * b[0] + a[5] * b[4] + a[ 6] * b[ 8];
+	out[ 5] = a[4] * b[1] + a[5] * b[5] + a[ 6] * b[ 9];
+	out[ 6] = a[4] * b[2] + a[5] * b[6] + a[ 6] * b[10];
+	out[ 7] = a[4] * b[3] + a[5] * b[7] + a[ 6] * b[11] + a[ 7];
+	out[ 8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[ 8];
+	out[ 9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[ 9];
+	out[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10];
+	out[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11];
+}
+static void InterpolateMatrix( float *a, float *b, float lerp, float *mat ) {
+	float unLerp = 1.0f - lerp;
+
+	mat[ 0] = a[ 0] * unLerp + b[ 0] * lerp;
+	mat[ 1] = a[ 1] * unLerp + b[ 1] * lerp;
+	mat[ 2] = a[ 2] * unLerp + b[ 2] * lerp;
+	mat[ 3] = a[ 3] * unLerp + b[ 3] * lerp;
+	mat[ 4] = a[ 4] * unLerp + b[ 4] * lerp;
+	mat[ 5] = a[ 5] * unLerp + b[ 5] * lerp;
+	mat[ 6] = a[ 6] * unLerp + b[ 6] * lerp;
+	mat[ 7] = a[ 7] * unLerp + b[ 7] * lerp;
+	mat[ 8] = a[ 8] * unLerp + b[ 8] * lerp;
+	mat[ 9] = a[ 9] * unLerp + b[ 9] * lerp;
+	mat[10] = a[10] * unLerp + b[10] * lerp;
+	mat[11] = a[11] * unLerp + b[11] * lerp;
+}
+
+/*
+=================
+R_LoadIQM
+=================
+Load an IQM model and compute the joint matrices for every frame.
+*/
+qboolean R_LoadIQM( model_t *mod, void *buffer, int filesize, const char *mod_name ) {
+	iqmHeader_t		*header;
+	iqmVertexArray_t	*vertexarray;
+	iqmTriangle_t		*triangle;
+	iqmMesh_t		*mesh;
+	iqmJoint_t		*joint;
+	iqmPose_t		*pose;
+	unsigned short		*framedata;
+	char			*str;
+	int			i, j;
+	float			*jointMats, *mat;
+	size_t			size, joint_names;
+	iqmData_t		*iqmData;
+	srfIQModel_t		*surface;
+
+	if( filesize < sizeof(iqmHeader_t) ) {
+		return qfalse;
+	}
+
+	header = (iqmHeader_t *)buffer;
+	if( Q_strncmp( header->magic, IQM_MAGIC, sizeof(header->magic) ) ) {
+		return qfalse;
+	}
+
+	LL( header->version );
+	if( header->version != IQM_VERSION ) {
+		return qfalse;
+	}
+
+	LL( header->filesize );
+	if( header->filesize > filesize || header->filesize > 16<<20 ) {
+		return qfalse;
+	}
+
+	LL( header->flags );
+	LL( header->num_text );
+	LL( header->ofs_text );
+	LL( header->num_meshes );
+	LL( header->ofs_meshes );
+	LL( header->num_vertexarrays );
+	LL( header->num_vertexes );
+	LL( header->ofs_vertexarrays );
+	LL( header->num_triangles );
+	LL( header->ofs_triangles );
+	LL( header->ofs_adjacency );
+	LL( header->num_joints );
+	LL( header->ofs_joints );
+	LL( header->num_poses );
+	LL( header->ofs_poses );
+	LL( header->num_anims );
+	LL( header->ofs_anims );
+	LL( header->num_frames );
+	LL( header->num_framechannels );
+	LL( header->ofs_frames );
+	LL( header->ofs_bounds );
+	LL( header->num_comment );
+	LL( header->ofs_comment );
+	LL( header->num_extensions );
+	LL( header->ofs_extensions );
+
+	// check and swap vertex arrays
+	if( IQM_CheckRange( header, header->ofs_vertexarrays,
+			    header->num_vertexarrays,
+			    sizeof(iqmVertexArray_t) ) ) {
+		return qfalse;
+	}
+	vertexarray = (iqmVertexArray_t *)((byte *)header + header->ofs_vertexarrays);
+	for( i = 0; i < header->num_vertexarrays; i++, vertexarray++ ) {
+		int	j, n, *intPtr;
+
+		if( vertexarray->size <= 0 || vertexarray->size > 4 ) {
+			return qfalse;
+		}
+
+		// total number of values
+		n = header->num_vertexes * vertexarray->size;
+
+		switch( vertexarray->format ) {
+		case IQM_BYTE:
+		case IQM_UBYTE:
+			// 1 byte, no swapping necessary
+			if( IQM_CheckRange( header, vertexarray->offset,
+					    n, sizeof(byte) ) ) {
+				return qfalse;
+			}
+			break;
+		case IQM_INT:
+		case IQM_UINT:
+		case IQM_FLOAT:
+			// 4-byte swap
+			if( IQM_CheckRange( header, vertexarray->offset,
+					    n, sizeof(float) ) ) {
+				return qfalse;
+			}
+			intPtr = (int *)((byte *)header + vertexarray->offset);
+			for( j = 0; j < n; j++, intPtr++ ) {
+				LL( *intPtr );
+			}
+			break;
+		default:
+			// not supported
+			return qfalse;
+			break;
+		}
+
+		switch( vertexarray->type ) {
+		case IQM_POSITION:
+		case IQM_NORMAL:
+			if( vertexarray->format != IQM_FLOAT ||
+			    vertexarray->size != 3 ) {
+				return qfalse;
+			}
+			break;
+		case IQM_TANGENT:
+			if( vertexarray->format != IQM_FLOAT ||
+			    vertexarray->size != 4 ) {
+				return qfalse;
+			}
+			break;
+		case IQM_TEXCOORD:
+			if( vertexarray->format != IQM_FLOAT ||
+			    vertexarray->size != 2 ) {
+				return qfalse;
+			}
+			break;
+		case IQM_BLENDINDEXES:
+		case IQM_BLENDWEIGHTS:
+			if( vertexarray->format != IQM_UBYTE ||
+			    vertexarray->size != 4 ) {
+				return qfalse;
+			}
+			break;
+		case IQM_COLOR:
+			if( vertexarray->format != IQM_UBYTE ||
+			    vertexarray->size != 4 ) {
+				return qfalse;
+			}
+			break;
+		}
+	}
+
+	// check and swap triangles
+	if( IQM_CheckRange( header, header->ofs_triangles,
+			    header->num_triangles, sizeof(iqmTriangle_t) ) ) {
+		return qfalse;
+	}
+	triangle = (iqmTriangle_t *)((byte *)header + header->ofs_triangles);
+	for( i = 0; i < header->num_triangles; i++, triangle++ ) {
+		LL( triangle->vertex[0] );
+		LL( triangle->vertex[1] );
+		LL( triangle->vertex[2] );
+		
+		if( triangle->vertex[0] < 0 || triangle->vertex[0] > header->num_vertexes ||
+		    triangle->vertex[1] < 0 || triangle->vertex[1] > header->num_vertexes ||
+		    triangle->vertex[2] < 0 || triangle->vertex[2] > header->num_vertexes ) {
+			return qfalse;
+		}
+	}
+
+	// check and swap meshes
+	if( IQM_CheckRange( header, header->ofs_meshes,
+			    header->num_meshes, sizeof(iqmMesh_t) ) ) {
+		return qfalse;
+	}
+	mesh = (iqmMesh_t *)((byte *)header + header->ofs_meshes);
+	for( i = 0; i < header->num_meshes; i++, mesh++) {
+		LL( mesh->name );
+		LL( mesh->material );
+		LL( mesh->first_vertex );
+		LL( mesh->num_vertexes );
+		LL( mesh->first_triangle );
+		LL( mesh->num_triangles );
+		
+		if( mesh->first_vertex >= header->num_vertexes ||
+		    mesh->first_vertex + mesh->num_vertexes > header->num_vertexes ||
+		    mesh->first_triangle >= header->num_triangles ||
+		    mesh->first_triangle + mesh->num_triangles > header->num_triangles ||
+		    mesh->name < 0 ||
+		    mesh->name >= header->num_text ||
+		    mesh->material < 0 ||
+		    mesh->material >= header->num_text ) {
+			return qfalse;
+		}
+	}
+
+	// check and swap joints
+	if( IQM_CheckRange( header, header->ofs_joints,
+			    header->num_joints, sizeof(iqmJoint_t) ) ) {
+		return qfalse;
+	}
+	joint = (iqmJoint_t *)((byte *)header + header->ofs_joints);
+	joint_names = 0;
+	for( i = 0; i < header->num_joints; i++, joint++ ) {
+		LL( joint->name );
+		LL( joint->parent );
+		LL( joint->translate[0] );
+		LL( joint->translate[1] );
+		LL( joint->translate[2] );
+		LL( joint->rotate[0] );
+		LL( joint->rotate[1] );
+		LL( joint->rotate[2] );
+		LL( joint->scale[0] );
+		LL( joint->scale[1] );
+		LL( joint->scale[2] );
+
+		if( joint->parent < -1 ||
+		    joint->parent >= header->num_joints ||
+		    joint->name < 0 ||
+		    joint->name >= header->num_text ) {
+			return qfalse;
+		}
+		joint_names += strlen( (char *)header + header->ofs_text +
+				       joint->name ) + 1;
+	}
+
+	// check and swap poses
+	if( header->num_poses != header->num_joints ) {
+		return qfalse;
+	}
+	if( IQM_CheckRange( header, header->ofs_poses,
+			    header->num_poses, sizeof(iqmPose_t) ) ) {
+		return qfalse;
+	}
+	pose = (iqmPose_t *)((byte *)header + header->ofs_poses);
+	for( i = 0; i < header->num_poses; i++, pose++ ) {
+		LL( pose->parent );
+		LL( pose->mask );
+		LL( pose->channeloffset[0] );
+		LL( pose->channeloffset[1] );
+		LL( pose->channeloffset[2] );
+		LL( pose->channeloffset[3] );
+		LL( pose->channeloffset[4] );
+		LL( pose->channeloffset[5] );
+		LL( pose->channeloffset[6] );
+		LL( pose->channeloffset[7] );
+		LL( pose->channeloffset[8] );
+		LL( pose->channelscale[0] );
+		LL( pose->channelscale[1] );
+		LL( pose->channelscale[2] );
+		LL( pose->channelscale[3] );
+		LL( pose->channelscale[4] );
+		LL( pose->channelscale[5] );
+		LL( pose->channelscale[6] );
+		LL( pose->channelscale[7] );
+		LL( pose->channelscale[8] );
+	}
+
+	// allocate the model and copy the data
+	size = sizeof(iqmData_t);
+	size += header->num_meshes * sizeof( srfIQModel_t );
+	size += header->num_joints * header->num_frames * 12 * sizeof( float );
+	size += header->num_vertexes * 3 * sizeof(float); // positions
+	size += header->num_vertexes * 2 * sizeof(float); // texcoords
+	size += header->num_vertexes * 3 * sizeof(float); // normals
+	size += header->num_vertexes * 4 * sizeof(float); // tangents
+	size += header->num_vertexes * 4 * sizeof(byte);  // blendIndexes
+	size += header->num_vertexes * 4 * sizeof(byte);  // blendWeights
+	size += header->num_vertexes * 4 * sizeof(byte);  // colors
+	size += header->num_joints * sizeof(int);         // parents
+	size += header->num_triangles * 3 * sizeof(int);  // triangles
+	size += joint_names;                              // joint names
+
+	mod->type = MOD_IQM;
+	iqmData = (iqmData_t *)ri.Hunk_Alloc( size, h_low );
+	mod->modelData.iqm.iqmData = iqmData;
+
+	// fill header
+	iqmData->num_vertexes = header->num_vertexes;
+	iqmData->num_triangles = header->num_triangles;
+	iqmData->num_frames   = header->num_frames;
+	iqmData->num_surfaces = header->num_meshes;
+	iqmData->num_joints   = header->num_joints;
+	iqmData->surfaces     = (srfIQModel_t *)(iqmData + 1);
+	iqmData->poseMats     = (float *)(iqmData->surfaces + iqmData->num_surfaces);
+	iqmData->positions    = iqmData->poseMats + 12 * header->num_joints * header->num_frames;
+	iqmData->texcoords    = iqmData->positions + 3 * header->num_vertexes;
+	iqmData->normals      = iqmData->texcoords + 2 * header->num_vertexes;
+	iqmData->tangents     = iqmData->normals + 3 * header->num_vertexes;
+	iqmData->blendIndexes = (byte *)(iqmData->tangents + 4 * header->num_vertexes);
+	iqmData->blendWeights = iqmData->blendIndexes + 4 * header->num_vertexes;
+	iqmData->colors       = iqmData->blendWeights + 4 * header->num_vertexes;
+	iqmData->jointParents = (int *)(iqmData->colors + 4 * header->num_vertexes);
+	iqmData->triangles    = iqmData->jointParents + header->num_joints;
+	iqmData->names        = (char *)(iqmData->triangles + 3 * header->num_triangles);
+
+	// calculate joint matrices and their inverses
+	// they are needed only until the pose matrices are calculated
+	jointMats = (float *)ri.Hunk_AllocateTempMemory( header->num_joints * 2 * 3 * 4 * sizeof(float) );
+	mat = jointMats;
+	joint = (iqmJoint_t *)((byte *)header + header->ofs_joints);
+	for( i = 0; i < header->num_joints; i++, joint++ ) {
+		float tmpMat[12];
+
+		float rotW = DotProduct(joint->rotate, joint->rotate);
+		rotW = -SQRTFAST(1.0f - rotW);
+
+		float xx = 2.0f * joint->rotate[0] * joint->rotate[0];
+		float yy = 2.0f * joint->rotate[1] * joint->rotate[1];
+		float zz = 2.0f * joint->rotate[2] * joint->rotate[2];
+		float xy = 2.0f * joint->rotate[0] * joint->rotate[1];
+		float xz = 2.0f * joint->rotate[0] * joint->rotate[2];
+		float yz = 2.0f * joint->rotate[1] * joint->rotate[2];
+		float wx = 2.0f * rotW * joint->rotate[0];
+		float wy = 2.0f * rotW * joint->rotate[1];
+		float wz = 2.0f * rotW * joint->rotate[2];
+
+		tmpMat[ 0] = joint->scale[0] * (1.0f - (yy + zz));
+		tmpMat[ 1] = joint->scale[0] * (xy - wz);
+		tmpMat[ 2] = joint->scale[0] * (xz + wy);
+		tmpMat[ 3] = joint->translate[0];
+		tmpMat[ 4] = joint->scale[1] * (xy + wz);
+		tmpMat[ 5] = joint->scale[1] * (1.0f - (xx + zz));
+		tmpMat[ 6] = joint->scale[1] * (yz - wx);
+		tmpMat[ 7] = joint->translate[1];
+		tmpMat[ 8] = joint->scale[2] * (xz - wy);
+		tmpMat[ 9] = joint->scale[2] * (yz + wx);
+		tmpMat[10] = joint->scale[2] * (1.0f - (xx + yy));
+		tmpMat[11] = joint->translate[2];
+
+		if( joint->parent >= 0 ) {
+			// premultiply with parent-matrix
+			Matrix34Multiply( jointMats + 2 * 12 * joint->parent,
+					  tmpMat, mat);
+		} else {
+			Com_Memcpy( mat, tmpMat, sizeof(tmpMat) );
+		}
+
+		mat += 12;
+
+		// compute the inverse matrix by combining the
+		// inverse scale, rotation and translation
+		tmpMat[ 0] = joint->scale[0] * (1.0f - (yy + zz));
+		tmpMat[ 1] = joint->scale[1] * (xy + wz);
+		tmpMat[ 2] = joint->scale[2] * (xz - wy);
+		tmpMat[ 3] = -DotProduct((tmpMat + 0), joint->translate);
+		tmpMat[ 4] = joint->scale[0] * (xy - wz);
+		tmpMat[ 5] = joint->scale[1] * (1.0f - (xx + zz));
+		tmpMat[ 6] = joint->scale[2] * (yz + wx);
+		tmpMat[ 7] = -DotProduct((tmpMat + 4), joint->translate);
+		tmpMat[ 8] = joint->scale[0] * (xz + wy);
+		tmpMat[ 9] = joint->scale[1] * (yz - wx);
+		tmpMat[10] = joint->scale[2] * (1.0f - (xx + yy));
+		tmpMat[11] = -DotProduct((tmpMat + 8), joint->translate);
+
+		if( joint->parent >= 0 ) {
+			// premultiply with inverse parent-matrix
+			Matrix34Multiply( tmpMat,
+					  jointMats + 2 * 12 * joint->parent + 12,
+					  mat);
+		} else {
+			Com_Memcpy( mat, tmpMat, sizeof(tmpMat) );
+		}
+
+		mat += 12;
+	}
+
+	// calculate pose matrices
+	framedata = (unsigned short *)((byte *)header + header->ofs_frames);
+	mat = iqmData->poseMats;
+	for( i = 0; i < header->num_frames; i++ ) {
+		pose = (iqmPose_t *)((byte *)header + header->ofs_poses);
+		for( j = 0; j < header->num_poses; j++, pose++ ) {
+			vec3_t	translate, rotate, scale;
+			float	mat1[12], mat2[12];
+
+			translate[0] = pose->channeloffset[0];
+			if( pose->mask & 0x001)
+				translate[0] += *framedata++ * pose->channelscale[0];
+			translate[1] = pose->channeloffset[1];
+			if( pose->mask & 0x002)
+				translate[1] += *framedata++ * pose->channelscale[1];
+			translate[2] = pose->channeloffset[2];
+			if( pose->mask & 0x004)
+				translate[2] += *framedata++ * pose->channelscale[2];
+			rotate[0] = pose->channeloffset[3];
+			if( pose->mask & 0x008)
+				rotate[0] += *framedata++ * pose->channelscale[3];
+			rotate[1] = pose->channeloffset[4];
+			if( pose->mask & 0x010)
+				rotate[1] += *framedata++ * pose->channelscale[4];
+			rotate[2] = pose->channeloffset[5];
+			if( pose->mask & 0x020)
+				rotate[2] += *framedata++ * pose->channelscale[5];
+			scale[0] = pose->channeloffset[6];
+			if( pose->mask & 0x040)
+				scale[0] += *framedata++ * pose->channelscale[6];
+			scale[1] = pose->channeloffset[7];
+			if( pose->mask & 0x080)
+				scale[1] += *framedata++ * pose->channelscale[7];
+			scale[2] = pose->channeloffset[8];
+			if( pose->mask & 0x100)
+				scale[2] += *framedata++ * pose->channelscale[8];
+
+			// construct transformation matrix
+			float rotW = DotProduct(rotate, rotate);
+			rotW = -SQRTFAST(1.0f - rotW);
+
+			float xx = 2.0f * rotate[0] * rotate[0];
+			float yy = 2.0f * rotate[1] * rotate[1];
+			float zz = 2.0f * rotate[2] * rotate[2];
+			float xy = 2.0f * rotate[0] * rotate[1];
+			float xz = 2.0f * rotate[0] * rotate[2];
+			float yz = 2.0f * rotate[1] * rotate[2];
+			float wx = 2.0f * rotW * rotate[0];
+			float wy = 2.0f * rotW * rotate[1];
+			float wz = 2.0f * rotW * rotate[2];
+
+			mat1[ 0] = scale[0] * (1.0f - (yy + zz));
+			mat1[ 1] = scale[0] * (xy - wz);
+			mat1[ 2] = scale[0] * (xz + wy);
+			mat1[ 3] = translate[0];
+			mat1[ 4] = scale[1] * (xy + wz);
+			mat1[ 5] = scale[1] * (1.0f - (xx + zz));
+			mat1[ 6] = scale[1] * (yz - wx);
+			mat1[ 7] = translate[1];
+			mat1[ 8] = scale[2] * (xz - wy);
+			mat1[ 9] = scale[2] * (yz + wx);
+			mat1[10] = scale[2] * (1.0f - (xx + yy));
+			mat1[11] = translate[2];
+			
+			if( pose->parent >= 0 ) {
+				Matrix34Multiply( jointMats + 12 * 2 * pose->parent,
+						  mat1, mat2 );
+			} else {
+				Com_Memcpy( mat2, mat1, sizeof(mat1) );
+			}
+			
+			Matrix34Multiply( mat2, jointMats + 12 * (2 * j + 1), mat );
+			mat += 12;
+		}
+	}
+	ri.Hunk_FreeTempMemory( jointMats );
+
+	// register shaders
+	// overwrite the material offset with the shader index
+	mesh = (iqmMesh_t *)((byte *)header + header->ofs_meshes);
+	surface = iqmData->surfaces;
+	str = (char *)header + header->ofs_text;
+	for( i = 0; i < header->num_meshes; i++, mesh++, surface++ ) {
+		surface->surfaceType = SF_IQM;
+		surface->shader = R_FindShader( str + mesh->material, LIGHTMAP_NONE, qtrue );
+		if( surface->shader->defaultShader )
+			surface->shader = tr.defaultShader;
+		surface->data = iqmData;
+		surface->first_vertex = mesh->first_vertex;
+		surface->num_vertexes = mesh->num_vertexes;
+		surface->first_triangle = mesh->first_triangle;
+		surface->num_triangles = mesh->num_triangles;
+        }
+
+	// copy vertexarrays and indexes
+	vertexarray = (iqmVertexArray_t *)((byte *)header + header->ofs_vertexarrays);
+	for( i = 0; i < header->num_vertexarrays; i++, vertexarray++ ) {
+		int	n;
+
+		// total number of values
+		n = header->num_vertexes * vertexarray->size;
+
+		switch( vertexarray->type ) {
+		case IQM_POSITION:
+			Com_Memcpy( iqmData->positions,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(float) );
+			break;
+		case IQM_NORMAL:
+			Com_Memcpy( iqmData->normals,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(float) );
+			break;
+		case IQM_TANGENT:
+			Com_Memcpy( iqmData->tangents,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(float) );
+			break;
+		case IQM_TEXCOORD:
+			Com_Memcpy( iqmData->texcoords,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(float) );
+			break;
+		case IQM_BLENDINDEXES:
+			Com_Memcpy( iqmData->blendIndexes,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(byte) );
+			break;
+		case IQM_BLENDWEIGHTS:
+			Com_Memcpy( iqmData->blendWeights,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(byte) );
+			break;
+		case IQM_COLOR:
+			Com_Memcpy( iqmData->colors,
+				    (byte *)header + vertexarray->offset,
+				    n * sizeof(byte) );
+			break;
+		}
+	}
+
+	// copy joint parents
+	joint = (iqmJoint_t *)((byte *)header + header->ofs_joints);
+	for( i = 0; i < header->num_joints; i++, joint++ ) {
+		iqmData->jointParents[i] = joint->parent;
+	}
+
+	// copy triangles
+	triangle = (iqmTriangle_t *)((byte *)header + header->ofs_triangles);
+	for( i = 0; i < header->num_triangles; i++, triangle++ ) {
+		iqmData->triangles[3*i+0] = triangle->vertex[0];
+		iqmData->triangles[3*i+1] = triangle->vertex[1];
+		iqmData->triangles[3*i+2] = triangle->vertex[2];
+	}
+
+	// copy joint names
+	str = iqmData->names;
+	for( i = 0; i < header->num_joints; i++ ) {
+		char *name = (char *)header + header->ofs_text +
+			joint->name;
+		int len = strlen( name ) + 1;
+		Com_Memcpy( str, name, len );
+		str += len;
+	}
+
+	return qtrue;
+}
+
+/*
+=================
+R_AddIQMSurfaces
+=================
+Add all surfaces of this model
+*/
+void R_AddIQMSurfaces( trRefEntity_t *ent ) {
+	iqmData_t		*data;
+	srfIQModel_t		*surface;
+	int			i;
+
+	data = tr.currentModel->modelData.iqm.iqmData;
+	surface = data->surfaces;
+
+	R_SetupEntityLighting( &tr.refdef, ent );
+
+	for ( i = 0 ; i < data->num_surfaces ; i++ ) {
+		R_AddDrawSurf( &surface->surfaceType,
+			       surface->shader->depthShader, 0, 0, qfalse );
+		R_AddDrawSurf( &surface->surfaceType,
+			       surface->shader, 0 /*fogNum*/, 0, qfalse );
+		surface++;
+	}
+}
+
+
+static void ComputeJointMats( iqmData_t *data, int frame, int oldframe,
+			      float backlerp, float *mat ) {
+	float	*mat1, *mat2;
+	int	*joint = data->jointParents;
+	int	i;
+
+	if (  oldframe == frame ) {
+		mat1 = mat2 = data->poseMats + 12 * data->num_joints * frame;
+		for( i = 0; i < data->num_joints; i++, joint++ ) {
+			if( *joint >= 0 ) {
+				Matrix34Multiply( mat + 12 * *joint,
+						  mat1 + 12*i, mat + 12*i );
+			} else {
+				Com_Memcpy( mat + 12*i, mat1 + 12*i, 12 * sizeof(float) );
+			}
+		}
+	} else  {
+		mat1 = data->poseMats + 12 * data->num_joints * frame;
+		mat2 = data->poseMats + 12 * data->num_joints * oldframe;
+		
+		for( i = 0; i < 12 * data->num_joints; i++, joint++ ) {
+			if( *joint >= 0 ) {
+				float tmpMat[12];
+				InterpolateMatrix( mat1 + 12*i, mat2 + 12*i,
+						   backlerp, tmpMat );
+				Matrix34Multiply( mat + 12 * *joint,
+						  tmpMat, mat + 12*i );
+				
+			} else {
+				InterpolateMatrix( mat1 + 12*i, mat2 + 12*i,
+						   backlerp, mat );
+			}
+		}
+	}
+}
+
+
+/*
+=================
+RB_AddIQMSurfaces
+=================
+Compute vertices for this model surface
+*/
+void RB_IQMSurfaceAnim( surfaceType_t *surface ) {
+	srfIQModel_t	*surf = (srfIQModel_t *)surface;
+	iqmData_t	*data = surf->data;
+	int		i;
+
+	if( tess.vertexPtr1 ) {
+		vaWord1_t	*ptr1 = tess.vertexPtr1 + tess.numVertexes;
+		vaWord2_t	*ptr2 = tess.vertexPtr2 + tess.numVertexes;
+		vaWord3_t	*ptr3 = tess.vertexPtr3 + tess.numVertexes;
+		vaWord4_t	*ptr4 = tess.vertexPtr4 + tess.numVertexes;
+
+		float	*mat;
+		int	frame = backEnd.currentEntity->e.frame % data->num_frames;
+		int	oldframe = backEnd.currentEntity->e.oldframe % data->num_frames;
+		float	backlerp = backEnd.currentEntity->e.backlerp;
+
+		// compute interpolated joint matrices
+		mat = (float *)RB_AllocScratch( data->num_joints * 12 * sizeof( float ) );
+		ComputeJointMats( data, frame, oldframe, backlerp, mat );
+
+		// transform vertexes and fill other data
+		for( i = 0; i < surf->num_vertexes; i++, ptr1++, ptr2++, ptr3++, ptr4++ ) {
+			int	j, k;
+			float	vtxMat[12];
+			float	nrmMat[9];
+			int	vtx = i + surf->first_vertex;
+
+			// compute the vertex matrix by blending the up to
+			// four blend weights
+			for( k = 0; k < 12; k++ )
+				vtxMat[k] = data->blendWeights[4*vtx]
+					* mat[12*data->blendIndexes[4*vtx] + k];
+			for( j = 1; j < 4; j++ ) {
+				if( data->blendWeights[4*vtx + j] <= 0 )
+					break;
+				for( k = 0; k < 12; k++ )
+					vtxMat[k] += data->blendWeights[4*vtx + j]
+						* mat[12*data->blendIndexes[4*vtx + j] + k];
+			}
+			for( k = 0; k < 12; k++ )
+				vtxMat[k] *= 1.0f / 255.0f;
+
+			// compute the normal matrix as transpose of the adjoint
+			// of the vertex matrix
+			nrmMat[ 0] = vtxMat[ 5]*vtxMat[10] - vtxMat[ 6]*vtxMat[ 9];
+			nrmMat[ 1] = vtxMat[ 6]*vtxMat[ 8] - vtxMat[ 4]*vtxMat[10];
+			nrmMat[ 2] = vtxMat[ 4]*vtxMat[ 9] - vtxMat[ 5]*vtxMat[ 8];
+			nrmMat[ 3] = vtxMat[ 2]*vtxMat[ 9] - vtxMat[ 1]*vtxMat[10];
+			nrmMat[ 4] = vtxMat[ 0]*vtxMat[10] - vtxMat[ 2]*vtxMat[ 8];
+			nrmMat[ 5] = vtxMat[ 1]*vtxMat[ 8] - vtxMat[ 0]*vtxMat[ 9];
+			nrmMat[ 6] = vtxMat[ 1]*vtxMat[ 6] - vtxMat[ 2]*vtxMat[ 5];
+			nrmMat[ 7] = vtxMat[ 2]*vtxMat[ 4] - vtxMat[ 0]*vtxMat[ 6];
+			nrmMat[ 8] = vtxMat[ 0]*vtxMat[ 5] - vtxMat[ 1]*vtxMat[ 4];
+
+			ptr1->tc1[0] = data->texcoords[2*vtx + 0];
+			ptr1->tc1[1] = data->texcoords[2*vtx + 1];
+			ptr1->tc2[0] = ptr1->tc1[0];
+			ptr1->tc2[1] = ptr1->tc1[1];
+
+			ptr2->xyz[0] =
+				vtxMat[ 0] * data->positions[3*vtx+0] +
+				vtxMat[ 1] * data->positions[3*vtx+1] +
+				vtxMat[ 2] * data->positions[3*vtx+2] +
+				vtxMat[ 3];
+			ptr2->xyz[1] =
+				vtxMat[ 4] * data->positions[3*vtx+0] +
+				vtxMat[ 5] * data->positions[3*vtx+1] +
+				vtxMat[ 6] * data->positions[3*vtx+2] +
+				vtxMat[ 7];
+			ptr2->xyz[2] =
+				vtxMat[ 8] * data->positions[3*vtx+0] +
+				vtxMat[ 9] * data->positions[3*vtx+1] +
+				vtxMat[10] * data->positions[3*vtx+2] +
+				vtxMat[11];
+			ptr2->fogNum = 0.0f;
+
+			ptr3->normal[0] =
+				nrmMat[ 0] * data->normals[3*vtx+0] +
+				nrmMat[ 1] * data->normals[3*vtx+1] +
+				nrmMat[ 2] * data->normals[3*vtx+2];
+			ptr3->normal[1] =
+				nrmMat[ 3] * data->normals[3*vtx+0] +
+				nrmMat[ 4] * data->normals[3*vtx+1] +
+				nrmMat[ 5] * data->normals[3*vtx+2];
+			ptr3->normal[2] =
+				nrmMat[ 6] * data->normals[3*vtx+0] +
+				nrmMat[ 7] * data->normals[3*vtx+1] +
+				nrmMat[ 8] * data->normals[3*vtx+2];
+			ptr3->reserved = 0.0f;
+
+			ptr4->color[0] = data->colors[4*vtx+0];
+			ptr4->color[1] = data->colors[4*vtx+1];
+			ptr4->color[2] = data->colors[4*vtx+2];
+			ptr4->color[3] = data->colors[4*vtx+3];
+		}
+
+		RB_FreeScratch( mat );
+	}
+
+	if( tess.indexPtr.p16 ) {
+		int	*tri = data->triangles;
+		tri += 3 * surf->first_triangle;
+
+		GLushort	*ptr = tess.indexPtr.p16 + tess.numIndexes;
+		GLushort	base = tess.numVertexes;
+
+		for( i = 0; i < surf->num_triangles; i++ ) {
+			*ptr++ = base + (GLushort)(*tri++ - surf->first_vertex);
+			*ptr++ = base + (GLushort)(*tri++ - surf->first_vertex);
+			*ptr++ = base + (GLushort)(*tri++ - surf->first_vertex);
+		}
+	}
+
+	tess.numIndexes += 3 * surf->num_triangles;
+	tess.numVertexes += surf->num_vertexes;
+}
+
+int R_IQMLerpTag( orientation_t *tag, iqmData_t *data,
+		  int startFrame, int endFrame, 
+		  float frac, const char *tagName ) {
+	int	joint;
+	char	*names = data->names;
+	float	*mat;
+
+	// get joint number by reading the joint names
+	for( joint = 0; joint < data->num_joints; joint++ ) {
+		if( !strcmp( tagName, names ) )
+			break;
+		names += strlen( names ) + 1;
+	}
+	if( joint >= data->num_joints )
+		return qfalse;
+
+	mat = (float *)ri.Hunk_AllocateTempMemory( data->num_joints * 12 * sizeof( float ) );
+	ComputeJointMats( data, startFrame, endFrame, frac, mat );
+	tag->axis[0][0] = mat[12 * joint + 0];
+	tag->axis[1][0] = mat[12 * joint + 1];
+	tag->axis[2][0] = mat[12 * joint + 2];
+	tag->origin[0] = mat[12 * joint + 3];
+	tag->axis[0][1] = mat[12 * joint + 4];
+	tag->axis[1][1] = mat[12 * joint + 5];
+	tag->axis[2][1] = mat[12 * joint + 6];
+	tag->origin[1] = mat[12 * joint + 7];
+	tag->axis[0][2] = mat[12 * joint + 8];
+	tag->axis[1][2] = mat[12 * joint + 9];
+	tag->axis[2][2] = mat[12 * joint + 10];
+	tag->origin[0] = mat[12 * joint + 11];
+	ri.Hunk_FreeTempMemory( mat );
+
+	return qfalse;
+}
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_light.c tremulous-ggp1-src/src/renderer/tr_light.c
--- tremulous-ggp1-src.p/src/renderer/tr_light.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_light.c	2012-07-19 04:25:52.031556446 +0200
@@ -95,11 +95,11 @@
 	for ( i = 0 ; i < bmodel->numSurfaces ; i++ ) {
 		surf = bmodel->firstSurface + i;
 
-		if ( *surf->data == SF_FACE ) {
+		if ( surf->type == SF_FACE ) {
 			((srfSurfaceFace_t *)surf->data)->dlightBits[ tr.smpFrame ] = mask;
-		} else if ( *surf->data == SF_GRID ) {
+		} else if ( surf->type == SF_GRID ) {
 			((srfGridMesh_t *)surf->data)->dlightBits[ tr.smpFrame ] = mask;
-		} else if ( *surf->data == SF_TRIANGLES ) {
+		} else if ( surf->type == SF_TRIANGLES ) {
 			((srfTriangles_t *)surf->data)->dlightBits[ tr.smpFrame ] = mask;
 		}
 	}
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_local.h tremulous-ggp1-src/src/renderer/tr_local.h
--- tremulous-ggp1-src.p/src/renderer/tr_local.h	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_local.h	2012-07-19 04:25:52.021556447 +0200
@@ -30,9 +30,10 @@
 #include "../qcommon/qcommon.h"
 #include "tr_public.h"
 #include "qgl.h"
+#include "iqm.h"
 
-#define GL_INDEX_TYPE		GL_UNSIGNED_INT
-typedef unsigned int glIndex_t;
+//#define GL_INDEX_TYPE		GL_UNSIGNED_INT
+//typedef unsigned int glIndex_t;
 
 // fast float to int conversion
 #if id386 && !defined(__GNUC__)
@@ -47,6 +48,13 @@
 // parallel on a dual cpu machine
 #define	SMP_FRAMES		2
 
+// To avoid allocating memory in the backend thread
+// I preallocate a fixed size block and just allocate
+// free temp memory within this block. The size can
+// be set with the cVar r_scratchmegs, the default is
+// defined here.
+#define SMP_SCRATCHMEGS		4
+
 // 12 bits
 // see QSORT_SHADERNUM_SHIFT
 #define	MAX_SHADERS				16384
@@ -55,6 +63,8 @@
 #define MAX_STATES_PER_SHADER 32
 #define MAX_STATE_NAME 32
 
+#define NUM_TEXTURE_BUNDLES 4
+
 // can't be increased without changing bit packing for drawsurfs
 
 
@@ -67,7 +77,6 @@
 	int		additive;			// texture detail is lost tho when the lightmap is dark
 } dlight_t;
 
-
 // a trRefEntity_t has all the information passed in by
 // the client game, as well as some locally derived info
 typedef struct {
@@ -103,7 +112,9 @@
 	int			TMU;				// only needed for voodoo2
 
 	qboolean	mipmap;
+	int		maxMipLevel;
 	qboolean	allowPicmip;
+	qboolean        hasAlpha;
 	int			wrapClampMode;		// GL_CLAMP_TO_EDGE or GL_REPEAT
 
 	struct image_s*	next;
@@ -114,6 +125,7 @@
 typedef enum {
 	SS_BAD,
 	SS_PORTAL,			// mirrors, portals, viewscreens
+	SS_DEPTH,		// Z-only pass
 	SS_ENVIRONMENT,		// sky box
 	SS_OPAQUE,			// opaque
 
@@ -284,6 +296,7 @@
 
 typedef struct {
 	image_t			*image[MAX_IMAGE_ANIMATIONS];
+	image_t			*combinedImage;
 	int				numImageAnimations;
 	float			imageAnimationSpeed;
 
@@ -297,10 +310,9 @@
 	qboolean		isLightmap;
 	qboolean		vertexLightmap;
 	qboolean		isVideoMap;
+	int		multitextureEnv;		// 0, GL_MODULATE, GL_ADD
 } textureBundle_t;
 
-#define NUM_TEXTURE_BUNDLES 2
-
 typedef struct {
 	qboolean		active;
 	
@@ -325,7 +337,8 @@
 
 // any change in the LIGHTMAP_* defines here MUST be reflected in
 // R_FindShader() in tr_bsp.c
-#define LIGHTMAP_2D         -4	// shader is for 2D rendering
+#define LIGHTMAP_2D         -5	// shader is for 2D rendering
+#define LIGHTMAP_MD3        -4  // shader for MD3 rendering (interpolation)
 #define LIGHTMAP_BY_VERTEX  -3	// pre-lit triangle models
 #define LIGHTMAP_WHITEIMAGE -2
 #define LIGHTMAP_NONE       -1
@@ -353,6 +366,92 @@
 } fogParms_t;
 
 
+typedef byte color4ub_t[4];
+
+/* This is the interleaved layout of the vertex data in RAM and VBO.
+ * The struct simply stores all known data per vertex, even if
+ * it isn't needed because the shaders doesn't use e.g. normals.
+ * But keeping track of all shaders that may affect a vertex is
+ * simply too much hassle and building a new VBO for each shader
+ * is probably wasting more graphics memory than the unused data
+ * here.
+ */
+typedef struct vaWord1_s {
+  vec2_t	tc1;
+  vec2_t	tc2;
+} vaWord1_t;  // same layout in VBO
+typedef struct vaWord2_s {
+  vec3_t	xyz;
+  float		fogNum;
+} vaWord2_t;  // same layout in VBO
+typedef struct vaWord3_s {
+  vec3_t	normal;
+  float		reserved;
+} vaWord3_t;
+typedef struct vaWord4_s {
+  color4ub_t	color;
+} vaWord4_t;  // same layout in VBO
+
+#define VBOKEY_TYPEMASK	0x70000000
+#define VBOKEY_IDXMASK	0x0fffffff
+#define VBOKEY_VIS	0x10000000
+#define VBOKEY_MODEL	0x20000000
+#define VBOKEY_MD3	0x30000000
+#define VBOKEY_MD3TEX	0x40000000
+
+typedef struct vboInfo_s {
+	struct vboInfo_s *left, *right;
+	struct vboInfo_s *next;
+	int	key;
+	GLuint  vbo;
+	GLuint  ibo;
+	int	numIndexes;
+	int     minIndex;
+	int     maxIndex;
+	vaWord1_t	*offs1;
+	vaWord2_t	*offs2;
+	vaWord3_t	*offs3;
+	vaWord4_t	*offs4;
+	GLushort	*offsIdx;
+} vboInfo_t;
+
+// NVIDIA uses special indexes for built-in Variables,
+// these values are chosen to avoid conflicts with the
+// built-in attributes we use:
+typedef enum {
+	AL_VERTEX = 0,
+	AL_NORMAL = 1,
+	AL_UNUSED = 2,
+	AL_COLOR = 3,
+	AL_TRANSX = 4,
+	AL_TRANSY = 5,
+	AL_TRANSZ = 6,
+	AL_TIMES = 7,
+	AL_TEXCOORD = 8,
+	AL_TEXCOORD2 = 9,
+	AL_TEXCOORD3 = 10,
+	AL_TEXCOORD4 = 11,
+	AL_AMBIENTLIGHT = 12,
+	AL_DIRECTEDLIGHT = 13,
+	AL_LIGHTDIR = 14,
+	AL_CAMERAPOS = 15,
+	AL_NUMATTRIBUTES = 16
+} attribLocation_t;
+
+typedef struct GLSLshader_s {
+	GLhandleARB	handle;
+	unsigned int	hash;
+} GLSLshader_t;
+
+typedef struct GLSLprogram_s {
+	GLhandleARB	handle;
+	GLint		unifFogPlanes;
+	GLint		unifFogColors;
+	GLSLshader_t	*vertex, *geometry, *fragment;
+	unsigned int	attributes;	// bit mask
+	GLuint		QuerySum;
+} GLSLprogram_t;
+
 typedef struct shader_s {
 	char		name[MAX_QPATH];		// game path, including extension
 	int			lightmapIndex;			// for a shader to match, both name and lightmapIndex must match
@@ -376,24 +475,19 @@
 	qboolean	entityMergable;			// merge across entites optimizable (smoke, blood)
 
 	qboolean	isSky;
+	qboolean	isDepth;
 	skyParms_t	sky;
 	fogParms_t	fogParms;
 
 	float		portalRange;			// distance to fog out at
 
-	int			multitextureEnv;		// 0, GL_MODULATE, GL_ADD (FIXME: put in stage)
-
 	cullType_t	cullType;				// CT_FRONT_SIDED, CT_BACK_SIDED, or CT_TWO_SIDED
-	qboolean	polygonOffset;			// set for decals and other items that must be offset 
 	qboolean	noMipMaps;				// for console fonts, 2D elements, etc.
 	qboolean	noPicMip;				// for images that must always be full resolution
 
 	fogPass_t	fogPass;				// draw a blended pass, possibly with depth test equals
 
-	qboolean	needsNormal;			// not all shaders will need all data to be gathered
-	qboolean	needsST1;
-	qboolean	needsST2;
-	qboolean	needsColor;
+	qboolean        useVBO;
 
 	int			numDeforms;
 	deformStage_t	deforms[MAX_SHADER_DEFORMS];
@@ -409,12 +503,18 @@
   int numStates;                                    // if non-zero this is a state shader
   struct shader_s *currentShader;                   // current state if this is a state shader
   struct shader_s *parentShader;                    // current state if this is a state shader
+  struct shader_s *depthShader;			    // associated shader for the Z-pass
   int currentState;                                 // current state index for cycle purposes
   long expireTime;                                  // time in milliseconds this expires
 
   struct shader_s *remappedShader;                  // current shader this one is remapped too
 
   int shaderStates[MAX_STATES_PER_SHADER];          // index to valid shader states
+  vboInfo_t	*VBOs;
+
+  GLuint        QueryID;
+  GLuint	QueryResult;
+  GLSLprogram_t *GLSLprogram;
 
 	struct	shader_s	*next;
 } shader_t;
@@ -498,18 +598,22 @@
 	orientationr_t	or;
 	orientationr_t	world;
 	vec3_t		pvsOrigin;			// may be different than or.origin for portals
-	qboolean	isPortal;			// true if this view is through a portal
+	int		portalLevel;			// number of portals we're looking through
 	qboolean	isMirror;			// the portal is a mirror, invert the face culling
+	qboolean	isFirst;			// this is the first view of the scene, so glClear has to be called
+	qboolean	noShadows;			// don't compute shadows, used for portal surfaces
 	int			frameSceneNum;		// copied from tr.frameSceneNum
 	int			frameCount;			// copied from tr.frameCount
 	cplane_t	portalPlane;		// clip anything behind this if mirroring
 	int			viewportX, viewportY, viewportWidth, viewportHeight;
 	float		fovX, fovY;
 	float		projectionMatrix[16];
-	cplane_t	frustum[4];
+	cplane_t	frustum[5];
 	vec3_t		visBounds[2];
 	float		zFar;
 	stereoFrame_t	stereoFrame;
+	int		viewCluster;
+	int		frustPlanes, frustType;
 } viewParms_t;
 
 
@@ -534,17 +638,20 @@
 #ifdef RAVENMD4
 	SF_MDR,
 #endif
+	SF_IQM,
 	SF_FLARE,
 	SF_ENTITY,				// beams, rails, lightning, etc that can be determined by entity
 	SF_DISPLAY_LIST,
+	SF_MD3_TEXTURE,
 
 	SF_NUM_SURFACE_TYPES,
 	SF_MAX = 0x7fffffff			// ensures that sizeof( surfaceType_t ) == sizeof( int )
 } surfaceType_t;
 
 typedef struct drawSurf_s {
-	unsigned			sort;			// bit combination for fast compares
-	surfaceType_t		*surface;		// any of surface*_t
+	unsigned		sort;		// bit combination for fast compares
+	int			shaderIndex;
+	surfaceType_t		*surface;	// any of surface*_t
 } drawSurf_t;
 
 #define	MAX_FACE_POINTS		64
@@ -596,6 +703,7 @@
 
 	// vertexes
 	int				width, height;
+	int			vboStart;
 	float			*widthLodError;
 	float			*heightLodError;
 	drawVert_t		verts[1];		// variable sized
@@ -615,6 +723,7 @@
 	int			numPoints;
 	int			numIndices;
 	int			ofsIndices;
+	int			vboStart;
 	float		points[1][VERTEXSIZE];	// variable sized
 										// there is a variable length list of indices here also
 } srfSurfaceFace_t;
@@ -637,11 +746,55 @@
 	int				*indexes;
 
 	int				numVerts;
+	int				vboStart;
+
 	drawVert_t		*verts;
 } srfTriangles_t;
 
 
-extern	void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])(void *);
+// MD3 surface stored in a texture on the GPU
+typedef struct {
+	surfaceType_t	surfaceType;
+	image_t		*image;
+	vboInfo_t	*VBO;
+	int		framesPerRow;
+	float		scaleX, scaleY;
+} srfMD3Texture_t;
+
+// inter-quake-model
+typedef struct {
+	int		num_vertexes;
+	int		num_triangles;
+	int		num_frames;
+	int		num_surfaces;
+	int		num_joints;
+	struct srfIQModel_s	*surfaces;
+
+	float		*positions;
+	float		*texcoords;
+	float		*normals;
+	float		*tangents;
+	byte		*blendIndexes;
+	byte		*blendWeights;
+	byte		*colors;
+	int		*triangles;
+
+	int		*jointParents;
+	float		*poseMats;
+	char		*names;
+} iqmData_t;
+
+// inter-quake-model surface
+typedef struct srfIQModel_s {
+	surfaceType_t	surfaceType;
+	shader_t	*shader;
+	iqmData_t	*data;
+	int		first_vertex, num_vertexes;
+	int		first_triangle, num_triangles;
+} srfIQModel_t;
+
+
+extern	void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])(surfaceType_t *);
 
 /*
 ==============================================================================
@@ -663,7 +816,8 @@
 typedef struct msurface_s {
 	int					viewCount;		// if == tr.viewCount, already added
 	struct shader_s		*shader;
-	int					fogIndex;
+	short			fogIndex;
+	short			type;			// copy of data->surfaceType
 
 	surfaceType_t		*data;			// any of srf*_t
 } msurface_t;
@@ -697,6 +851,10 @@
 } bmodel_t;
 
 typedef struct {
+	vec3_t		mins, maxs;		// for bounding box culling
+} mcluster_t;
+
+typedef struct {
 	char		name[MAX_QPATH];		// ie: maps/tim_dm2.bsp
 	char		baseName[MAX_QPATH];	// ie: tim_dm2
 
@@ -733,6 +891,7 @@
 	int			numClusters;
 	int			clusterBytes;
 	const byte	*vis;			// may be passed in by CM_LoadMap to save space
+	mcluster_t      *clusters;
 
 	byte		*novis;			// clusterBytes of 0xff
 
@@ -748,8 +907,9 @@
 	MOD_MESH,
 	MOD_MD4,
 #ifdef RAVENMD4
-	MOD_MDR
+	MOD_MDR,
 #endif
+	MOD_IQM
 } modtype_t;
 
 typedef struct model_s {
@@ -758,11 +918,26 @@
 	int			index;				// model = tr.models[model->index]
 
 	int			dataSize;			// just for listing purposes
-	bmodel_t	*bmodel;			// only if type == MOD_BRUSH
-	md3Header_t	*md3[MD3_MAX_LODS];	// only if type == MOD_MESH
-	void	*md4;				// only if type == (MOD_MD4 | MOD_MDR)
-
-	int			 numLods;
+	union {
+		struct {
+			// only if type == MOD_BRUSH
+			bmodel_t	*bmodel;
+		} brush;
+		struct {
+			// only if type == MOD_MESH
+			md3Header_t	*md3[MD3_MAX_LODS];
+			srfMD3Texture_t	*md3srf[MD3_MAX_LODS];
+		} md3;
+		struct {
+			// only if type == (MOD_MD4 | MOD_MDR)
+			void	*md4;
+		} md4;
+		struct {
+			// only if type == MOD_IQM
+			iqmData_t	*iqmData;
+		} iqm;
+	}			modelData;
+	int			numLods;
 } model_t;
 
 
@@ -803,11 +978,34 @@
 17-31 : sorted shader index
 7-16  : entity index
 2-6   : fog index
-0-1   : dlightmap index
+1     : dlightmap index
+0     : culled
 */
-#define	QSORT_SHADERNUM_SHIFT	17
-#define	QSORT_ENTITYNUM_SHIFT	7
-#define	QSORT_FOGNUM_SHIFT		2
+// sizes of the sort fields
+#define QSORT_SHADERNUM_BITS	15
+#define QSORT_ENTITYNUM_BITS	10
+#define QSORT_FOGNUM_BITS	5
+#define QSORT_DLIGHT_BITS	1
+#define QSORT_CULLED_BITS	1
+
+// derived shifts and masks
+#define QSORT_CULLED_SHIFT	0
+#define QSORT_DLIGHT_SHIFT	(QSORT_CULLED_SHIFT + QSORT_CULLED_BITS)
+#define QSORT_FOGNUM_SHIFT	(QSORT_DLIGHT_SHIFT + QSORT_DLIGHT_BITS)
+#define QSORT_ENTITYNUM_SHIFT	(QSORT_FOGNUM_SHIFT + QSORT_FOGNUM_BITS)
+#define QSORT_SHADERNUM_SHIFT	(QSORT_ENTITYNUM_SHIFT + QSORT_ENTITYNUM_BITS)
+
+#define QSORT_CULLED_MASK	((1 << QSORT_DLIGHT_SHIFT) - (1 << QSORT_CULLED_SHIFT))
+#define QSORT_DLIGHT_MASK	((1 << QSORT_FOGNUM_SHIFT) - (1 << QSORT_DLIGHT_SHIFT))
+#define QSORT_FOGNUM_MASK	((1 << QSORT_ENTITYNUM_SHIFT) - (1 << QSORT_FOGNUM_SHIFT))
+#define QSORT_ENTITYNUM_MASK	((1 << QSORT_SHADERNUM_SHIFT) - (1 << QSORT_ENTITYNUM_SHIFT))
+#define QSORT_SHADERNUM_MASK	(0xffffffff - (1 << QSORT_SHADERNUM_SHIFT) + 1)
+
+#define QSORT_CULLED(sort)	((sort & QSORT_CULLED_MASK) >> QSORT_CULLED_SHIFT)
+#define QSORT_DLIGHT(sort)	((sort & QSORT_DLIGHT_MASK) >> QSORT_DLIGHT_SHIFT)
+#define QSORT_FOGNUM(sort)	((sort & QSORT_FOGNUM_MASK) >> QSORT_FOGNUM_SHIFT)
+#define QSORT_ENTITYNUM(sort)	((sort & QSORT_ENTITYNUM_MASK) >> QSORT_ENTITYNUM_SHIFT)
+#define QSORT_SHADERNUM(sort)	((sort & QSORT_SHADERNUM_MASK) >> QSORT_SHADERNUM_SHIFT)
 
 extern	int			gl_filter_min, gl_filter_max;
 
@@ -833,14 +1031,65 @@
 
 // the renderer front end should never modify glstate_t
 typedef struct {
-	int			currenttextures[2];
-	int			currenttmu;
+	int			currenttextures[MAX_SHADER_STAGES];
+	qboolean	texEnabled[MAX_SHADER_STAGES];
 	qboolean	finishCalled;
-	int			texEnv[2];
+	int			texEnv[MAX_SHADER_STAGES];
 	int			faceCulling;
 	unsigned long	glStateBits;
+	GLuint		currentVBO, currentIBO;
+	GLSLprogram_t	*currentProgram;
+
+	struct {
+		enum {
+			attrIsUndefined = 0,
+			attrIsPointer,
+			attrIsValue
+		} attrStatus;
+		vec4_t	currentValues;
+		GLuint	vbo;
+		void	*ptr;
+	} glAttribute[ AL_NUMATTRIBUTES ];
 } glstate_t;
 
+// this struct holds all GL state data for a single render call (glDraw*)
+typedef struct {
+	enum {
+		RA_UNSPEC,
+		RA_POINTER,
+		RA_VEC
+	} attrType;
+	GLuint	VBO;
+	GLint	size;
+	GLenum	type;
+	GLsizei	stride;
+	void	*ptr;
+	vec4_t	vec;
+} glRenderAttrib_t;
+typedef struct {
+	unsigned long		stateBits;
+	int			faceCulling;
+	GLSLprogram_t		*program;
+	int			numImages;
+	image_t			*image[MAX_SHADER_STAGES];
+	glRenderAttrib_t	attrib[AL_NUMATTRIBUTES];
+} glRenderState_t;
+#define InitState( st ) Com_Memset( (st), 0, sizeof(glRenderState_t) )
+#define SetAttrPointer( st, ind, vbo, s, t, str, p ) \
+	(st)->attrib[ind].attrType = RA_POINTER;     \
+	(st)->attrib[ind].VBO = (vbo);               \
+	(st)->attrib[ind].size = s;                  \
+	(st)->attrib[ind].type = t;                  \
+	(st)->attrib[ind].stride = str;              \
+	(st)->attrib[ind].ptr = (p)
+#define SetAttrVec4f( st, ind, x, y, z, w )      \
+	(st)->attrib[ind].attrType = RA_VEC;     \
+	(st)->attrib[ind].vec[0] = (x);          \
+	(st)->attrib[ind].vec[1] = (y);          \
+	(st)->attrib[ind].vec[2] = (z);          \
+	(st)->attrib[ind].vec[3] = (w)
+#define SetAttrUnspec( st, ind )                 \
+	(st)->attrib[ind].attrType = RA_UNSPEC
 
 typedef struct {
 	int		c_surfaces, c_shaders, c_vertexes, c_indexes, c_totalIndexes;
@@ -872,6 +1121,14 @@
 	byte		color2D[4];
 	qboolean	vertexes2D;		// shader needs to be finished
 	trRefEntity_t	entity2D;	// currentEntity will point at this when doing 2D rendering
+
+	vboInfo_t	worldVBO;	// VBO containing all world vertexes
+	vboInfo_t	streamVBO;	// VBO for fast streaming of vertexes
+	vboInfo_t	*vboReserve;
+	int		vboReserveCount;
+
+	GLSLprogram_t	*normalProgram;  // GLSL program to render normals
+	GLSLprogram_t	*normalProgramMD3;  // GLSL program to render normals
 } backEndState_t;
 
 /*
@@ -899,6 +1156,8 @@
 	world_t					*world;
 
 	const byte				*externalVisData;	// from RE_SetWorldVisData, shared with CM_Load
+	mcluster_t				*clusters;
+	int					visCluster;
 
 	image_t					*defaultImage;
 	image_t					*scratchImage[32];
@@ -934,8 +1193,6 @@
 
 	trRefdef_t				refdef;
 
-	int						viewCluster;
-
 	vec3_t					sunLight;			// from the sky shader for this level
 	vec3_t					sunDirection;
 
@@ -960,6 +1217,10 @@
 	int						numShaders;
 	shader_t				*shaders[MAX_SHADERS];
 	shader_t				*sortedShaders[MAX_SHADERS];
+	int					numGLSLshaders;
+	GLSLshader_t				*GLSLshaders[2 * MAX_SHADERS];
+	int					numGLSLprograms;
+	GLSLprogram_t				*GLSLprograms[MAX_SHADERS];
 
 	int						numSkins;
 	skin_t					*skins[MAX_SKINS];
@@ -972,8 +1233,25 @@
 	float					fogTable[FOG_TABLE_SIZE];
 } trGlobals_t;
 
+// globals that are filled in InitOpenGL and should not be cleared in R_Init
+typedef struct {
+	qboolean	floatTextures;
+	qboolean	pixelBufferObjects;
+	GLint	maxTextureUnits;
+	GLint	maxTextureImageUnits;
+	GLint	maxVertexTextureImageUnits;
+	GLuint	timerQuery;
+	GLuint		PBO;
+	GLuint64EXT	timerResult;
+	qboolean	timerRunning;
+	int	portalBits, shadowBits;
+	GLuint	portalMask, shadowMask, portalLevels;
+} glGlobals_t;
+
+
 extern backEndState_t	backEnd;
 extern trGlobals_t	tr;
+extern glGlobals_t      glGlobals;
 extern glconfig_t	glConfig;		// outside of TR since it shouldn't be cleared during ref re-init
 extern glstate_t	glState;		// outside of TR since it shouldn't be cleared during ref re-init
 
@@ -981,6 +1259,7 @@
 //
 // cvars
 //
+extern cvar_t	*r_scratchmegs;
 extern cvar_t	*r_flareSize;
 extern cvar_t	*r_flareFade;
 // coefficient for the flare intensity falloff function.
@@ -1003,22 +1282,17 @@
 extern cvar_t	*r_depthbits;			// number of desired depth bits
 extern cvar_t	*r_colorbits;			// number of desired color bits, only relevant for fullscreen
 extern cvar_t	*r_texturebits;			// number of desired texture bits
+						// 0 = use framebuffer depth
+						// 16 = use 16-bit textures
+						// 32 = use 32-bit textures
+						// all else = error
 extern cvar_t	*r_ext_multisample;
-										// 0 = use framebuffer depth
-										// 16 = use 16-bit textures
-										// 32 = use 32-bit textures
-										// all else = error
 
 extern cvar_t	*r_measureOverdraw;		// enables stencil buffer overdraw measurement
 
 extern cvar_t	*r_lodbias;				// push/pull LOD transitions
 extern cvar_t	*r_lodscale;
 
-extern cvar_t	*r_primitives;			// "0" = based on compiled vertex array existance
-										// "1" = glDrawElemet tristrips
-										// "2" = glDrawElements triangles
-										// "-1" = no drawing
-
 extern cvar_t	*r_inGameVideo;				// controls whether in game video should be draw
 extern cvar_t	*r_fastsky;				// controls whether sky should be cleared or drawn
 extern cvar_t	*r_drawSun;				// controls drawing of sun quad
@@ -1053,6 +1327,19 @@
 
 extern cvar_t	*r_ext_texture_filter_anisotropic;
 extern cvar_t	*r_ext_max_anisotropy;
+extern cvar_t	*r_ext_texture_compression;
+extern cvar_t   *r_ext_vertex_buffer_object;
+extern cvar_t   *r_ext_pixel_buffer_object;
+extern cvar_t   *r_ext_vertex_shader;
+extern cvar_t   *r_ext_geometry_shader;
+extern cvar_t   *r_ext_framebuffer_object;
+extern cvar_t	*r_ext_occlusion_query;
+extern cvar_t	*r_ext_timer_query;
+extern cvar_t	*r_ext_instanced_arrays;
+extern cvar_t   *r_ext_texture_float;
+extern cvar_t	*r_ext_texture3D;
+extern cvar_t	*r_ext_separate_stencil;
+extern cvar_t	*r_ext_debug_output;
 
 extern	cvar_t	*r_nobind;						// turns off binding to appropriate textures
 extern	cvar_t	*r_singleShader;				// make most world faces use default shader
@@ -1113,6 +1400,12 @@
 
 extern cvar_t	*r_marksOnTriangleMeshes;
 
+extern	cvar_t	*r_flush;
+extern	cvar_t	*r_VBOminSize;
+extern	cvar_t	*r_depthPass;
+extern	cvar_t	*r_perPixelLighting;
+extern	cvar_t	*r_parallax;
+
 //====================================================================
 
 float R_NoiseGet4f( float x, float y, float z, float t );
@@ -1130,10 +1423,7 @@
 
 void R_AddPolygonSurfaces( void );
 
-void R_DecomposeSort( unsigned sort, int *entityNum, shader_t **shader, 
-					 int *fogNum, int *dlightMap );
-
-void R_AddDrawSurf( surfaceType_t *surface, shader_t *shader, int fogIndex, int dlightMap );
+void R_AddDrawSurf( surfaceType_t *surface, shader_t *shader, int fogIndex, int dlightMap, qboolean culled );
 
 
 #define	CULL_IN		0		// completely unclipped
@@ -1151,14 +1441,46 @@
 /*
 ** GL wrapper/helper functions
 */
-void	GL_Bind( image_t *image );
+void	GL_BindTexture( GLint texnum );
+void	GL_UnbindAllTextures( void );
 void	GL_SetDefaultState (void);
-void	GL_SelectTexture( int unit );
 void	GL_TextureMode( const char *string );
 void	GL_CheckErrors( void );
-void	GL_State( unsigned long stateVector );
-void	GL_TexEnv( int env );
-void	GL_Cull( int cullType );
+void	GL_CheckDebugLog( void );
+void	GL_VBO( GLuint vbo );
+void	GL_IBO( GLuint ibo );
+
+void	RB_InitScratchMemory( void );
+void	*RB_AllocScratch( size_t amount );
+void 	RB_FreeScratch( void *ptr );
+
+GLSLshader_t	*RB_CompileShader( GLenum type, const char **code, int parts );
+GLSLprogram_t	*RB_CompileProgram( const char *name,
+				    const char **VScode, int VSparts,
+				    const char **FScode, int FSparts,
+				    unsigned int attributes );
+GLSLprogram_t	*RB_CompileGSProgram( const char *name,
+				      const char **VScode, int VSparts,
+				      const char **GScode, int GSparts,
+				      int nVerticesOut, int inType, int outType,
+				      const char **FScode, int FSparts,
+				      unsigned int attributes );
+void	GL_Program( GLSLprogram_t *program );
+void	GL_TexEnv( int tmu, int env );
+
+#define QUERY_RUNNING_BIT 0x80000000
+#define QUERY_MASK        0x7fffffff
+#define QUERY_RESULT(q)   (*(q) & QUERY_MASK)
+
+void GL_StartQuery( GLuint query, GLuint *result );
+void GL_EndQuery( GLuint query, GLuint *result );
+void GL_GetQuery( GLuint query, GLuint *result );
+
+void	GL_DrawElements( glRenderState_t *state,
+			 int numIndexes, GLuint IBO, const void *indexes,
+			 GLuint start, GLuint end, GLuint max );
+void	GL_DrawArrays( glRenderState_t *state,
+		       GLenum mode, GLint first, GLuint count );
 
 #define GLS_SRCBLEND_ZERO						0x00000001
 #define GLS_SRCBLEND_ONE						0x00000002
@@ -1182,11 +1504,21 @@
 #define		GLS_DSTBLEND_BITS					0x000000f0
 
 #define GLS_DEPTHMASK_TRUE						0x00000100
+#define GLS_COLORMASK_FALSE						0x00000200
+#define GLS_POLYGON_OFFSET						0x00000400
 
 #define GLS_POLYMODE_LINE						0x00001000
 
-#define GLS_DEPTHTEST_DISABLE					0x00010000
+#define GLS_DEPTHTEST_DISABLE						0x00010000
 #define GLS_DEPTHFUNC_EQUAL						0x00020000
+#define GLS_DEPTHFUNC_ALWAYS						0x00040000
+#define GLS_DEPTHFUNC_BITS						0x00060000
+
+#define GLS_DEPTHRANGE_0_TO_1						0x00000000
+#define GLS_DEPTHRANGE_0_TO_0						0x00100000
+#define GLS_DEPTHRANGE_1_TO_1						0x00200000
+#define GLS_DEPTHRANGE_0_TO_03						0x00300000
+#define GLS_DEPTHRANGE_BITS						0x00300000
 
 #define GLS_ATEST_GT_0							0x10000000
 #define GLS_ATEST_LT_80							0x20000000
@@ -1212,9 +1544,8 @@
 
 void    	R_Init( void );
 image_t		*R_FindImageFile( const char *name, qboolean mipmap, qboolean allowPicmip, int glWrapClampMode );
-
-image_t		*R_CreateImage( const char *name, const byte *pic, int width, int height, qboolean mipmap,
-            qboolean allowPicmip, int wrapClampMode );
+image_t		*R_FindHeightMapFile( const char *name, qboolean mipmap, int glWrapClampMode );
+image_t		*R_CombineImages( int num, image_t **images );
 
 void		R_SetColorMappings( void );
 void		R_GammaCorrect( byte *buffer, int bufSize );
@@ -1249,6 +1580,7 @@
 shader_t	*R_GetShaderByHandle( qhandle_t hShader );
 shader_t	*R_GetShaderByState( int index, long *cycleTime );
 shader_t *R_FindShaderByName( const char *name );
+void		R_SortShaders( void );
 void		R_InitShaders( void );
 void		R_ShaderList_f( void );
 void    R_RemapShader(const char *oldShader, const char *newShader, const char *timeOffset);
@@ -1269,6 +1601,7 @@
 void		*GLimp_RendererSleep( void );
 void		GLimp_FrontEndSleep( void );
 void		GLimp_WakeRenderer( void *data );
+qboolean	GLimp_IsSMPActive( void );
 
 void		GLimp_LogComment( char *comment );
 
@@ -1326,15 +1659,23 @@
 
 extern	shaderCommands_t	tess;
 
+void RB_SetGL2D( glRenderState_t *state );
 void RB_BeginSurface(shader_t *shader, int fogNum );
 void RB_EndSurface(void);
-void RB_CheckOverflow( int verts, int indexes );
-#define RB_CHECKOVERFLOW(v,i) if (tess.numVertexes + (v) >= SHADER_MAX_VERTEXES || tess.numIndexes + (i) >= SHADER_MAX_INDEXES ) {RB_CheckOverflow(v,i);}
+void RB_ClearVertexBuffer( void );
+void RB_SetupVertexBuffer(shader_t *shader, vboInfo_t *vbo);
+void RB_FlushVertexBuffer( void );
+vboInfo_t *RB_CreateShaderVBO( vboInfo_t **root, int VBOkey );
+void RB_CopyVBO( vboInfo_t **root, int VBOkeyNew, int VBOkeyOld );
 
 void RB_StageIteratorGeneric( void );
 void RB_StageIteratorSky( void );
 void RB_StageIteratorVertexLitTexture( void );
 void RB_StageIteratorLightmappedMultitexture( void );
+void RB_StageIteratorGLSL( void );
+void RB_StageIteratorPreparePortal( void );
+void RB_StageIteratorFinalisePortal( void );
+void RB_LightSurface( void );
 
 void RB_AddQuadStamp( vec3_t origin, vec3_t left, vec3_t up, byte *color );
 void RB_AddQuadStampExt( vec3_t origin, vec3_t left, vec3_t up, byte *color, float s1, float t1, float s2, float t2 );
@@ -1485,11 +1826,17 @@
 
 // void R_MakeAnimModel( model_t *model );      haven't seen this one really, so not needed I guess.
 void R_AddAnimSurfaces( trRefEntity_t *ent );
-void RB_SurfaceAnim( md4Surface_t *surfType );
+void RB_SurfaceAnim( surfaceType_t *surfType );
 #ifdef RAVENMD4
 void R_MDRAddAnimSurfaces( trRefEntity_t *ent );
-void RB_MDRSurfaceAnim( md4Surface_t *surface );
+void RB_MDRSurfaceAnim( surfaceType_t *surface );
 #endif
+qboolean R_LoadIQM (model_t *mod, void *buffer, int filesize, const char *name );
+void R_AddIQMSurfaces( trRefEntity_t *ent );
+void RB_IQMSurfaceAnim( surfaceType_t *surface );
+int R_IQMLerpTag( orientation_t *tag, iqmData_t *data,
+		  int startFrame, int endFrame, 
+		  float frac, const char *tagName );
 
 /*
 =============================================================
@@ -1498,12 +1845,23 @@
 
 =============================================================
 */
+// image loaders may return several mipmap levels
+typedef struct {
+	GLenum	format;
+	int	numMipmaps;
+	byte	*data[32];
+	int	size[32];
+} texImage_t;
+
+void R_LoadBMP( const char *name, texImage_t *pic, int *width, int *height );
+void R_LoadJPG( const char *name, texImage_t *pic, int *width, int *height );
+void R_LoadPCX( const char *name, texImage_t *pic, int *width, int *height );
+void R_LoadPNG( const char *name, texImage_t *pic, int *width, int *height );
+void R_LoadTGA( const char *name, texImage_t *pic, int *width, int *height );
+void R_LoadDDS( const char *name, texImage_t *pic, int *width, int *height );
 
-void R_LoadBMP( const char *name, byte **pic, int *width, int *height );
-void R_LoadJPG( const char *name, byte **pic, int *width, int *height );
-void R_LoadPCX( const char *name, byte **pic, int *width, int *height );
-void R_LoadPNG( const char *name, byte **pic, int *width, int *height );
-void R_LoadTGA( const char *name, byte **pic, int *width, int *height );
+image_t	*R_CreateImage( const char *name, texImage_t *pic, int width, int height, qboolean mipmap,
+			qboolean allowPicmip, int wrapClampMode );
 
 /*
 =============================================================
@@ -1515,26 +1873,25 @@
 
 void	RB_DeformTessGeometry( void );
 
-void	RB_CalcEnvironmentTexCoords( float *dstTexCoords );
-void	RB_CalcFogTexCoords( float *dstTexCoords );
-void	RB_CalcScrollTexCoords( const float scroll[2], float *dstTexCoords );
-void	RB_CalcRotateTexCoords( float rotSpeed, float *dstTexCoords );
-void	RB_CalcScaleTexCoords( const float scale[2], float *dstTexCoords );
-void	RB_CalcTurbulentTexCoords( const waveForm_t *wf, float *dstTexCoords );
-void	RB_CalcTransformTexCoords( const texModInfo_t *tmi, float *dstTexCoords );
-void	RB_CalcModulateColorsByFog( unsigned char *dstColors );
-void	RB_CalcModulateAlphasByFog( unsigned char *dstColors );
-void	RB_CalcModulateRGBAsByFog( unsigned char *dstColors );
-void	RB_CalcWaveAlpha( const waveForm_t *wf, unsigned char *dstColors );
-void	RB_CalcWaveColor( const waveForm_t *wf, unsigned char *dstColors );
-void	RB_CalcAlphaFromEntity( unsigned char *dstColors );
-void	RB_CalcAlphaFromOneMinusEntity( unsigned char *dstColors );
-void	RB_CalcStretchTexCoords( const waveForm_t *wf, float *texCoords );
-void	RB_CalcColorFromEntity( unsigned char *dstColors );
-void	RB_CalcColorFromOneMinusEntity( unsigned char *dstColors );
-void	RB_CalcSpecularAlpha( unsigned char *alphas );
-void	RB_CalcDiffuseColor( unsigned char *colors );
-
+void	RB_CalcEnvironmentTexCoords( vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcFogTexCoords( vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcScrollTexCoords( const float scroll[2], vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcRotateTexCoords( float rotSpeed, vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcScaleTexCoords( const float scale[2], vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcTurbulentTexCoords( const waveForm_t *wf, vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcTransformTexCoords( const texModInfo_t *tmi, vec2_t *dstTexCoords, int numVertexes );
+void	RB_CalcModulateColorsByFog( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcModulateAlphasByFog( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcModulateRGBAsByFog( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcWaveAlpha( const waveForm_t *wf, color4ub_t *dstColors, int numVertexes );
+void	RB_CalcWaveColor( const waveForm_t *wf, color4ub_t *dstColors, int numVertexes );
+void	RB_CalcAlphaFromEntity( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcAlphaFromOneMinusEntity( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcStretchTexCoords( const waveForm_t *wf, vec2_t *texCoords, int numVertexes );
+void	RB_CalcColorFromEntity( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcColorFromOneMinusEntity( color4ub_t *dstColors, int numVertexes );
+void	RB_CalcSpecularAlpha( color4ub_t *alphas, int numVertexes );
+void	RB_CalcDiffuseColor( color4ub_t *colors, int numVertexes );
 /*
 =============================================================
 
@@ -1599,6 +1956,15 @@
 
 typedef struct {
 	int		commandId;
+	int	client;
+	float	x, y;
+	float	w, h;
+	float	s1, t1;
+	float	s2, t2;
+} stretchRawCommand_t;
+
+typedef struct {
+	int		commandId;
 	trRefdef_t	refdef;
 	viewParms_t	viewParms;
 	drawSurf_t *drawSurfs;
@@ -1640,6 +2006,7 @@
 	RC_END_OF_LIST,
 	RC_SET_COLOR,
 	RC_STRETCH_PIC,
+	RC_STRETCH_RAW,
 	RC_DRAW_SURFS,
 	RC_DRAW_BUFFER,
 	RC_SWAP_BUFFERS,
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_local.h.orig tremulous-ggp1-src/src/renderer/tr_local.h.orig
--- tremulous-ggp1-src.p/src/renderer/tr_local.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_local.h.orig	2012-07-19 04:25:20.311556052 +0200
@@ -0,0 +1,1711 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+
+
+#ifndef TR_LOCAL_H
+#define TR_LOCAL_H
+
+#include "../qcommon/q_shared.h"
+#include "../qcommon/qfiles.h"
+#include "../qcommon/qcommon.h"
+#include "tr_public.h"
+#include "qgl.h"
+
+#define GL_INDEX_TYPE		GL_UNSIGNED_INT
+typedef unsigned int glIndex_t;
+
+// fast float to int conversion
+#if id386 && !defined(__GNUC__)
+long myftol( float f );
+#else
+#define	myftol(x) ((int)(x))
+#endif
+
+
+// everything that is needed by the backend needs
+// to be double buffered to allow it to run in
+// parallel on a dual cpu machine
+#define	SMP_FRAMES		2
+
+// 12 bits
+// see QSORT_SHADERNUM_SHIFT
+#define	MAX_SHADERS				16384
+
+//#define MAX_SHADER_STATES 2048
+#define MAX_STATES_PER_SHADER 32
+#define MAX_STATE_NAME 32
+
+// can't be increased without changing bit packing for drawsurfs
+
+
+typedef struct dlight_s {
+	vec3_t	origin;
+	vec3_t	color;				// range from 0.0 to 1.0, should be color normalized
+	float	radius;
+
+	vec3_t	transformed;		// origin in local coordinate system
+	int		additive;			// texture detail is lost tho when the lightmap is dark
+} dlight_t;
+
+
+// a trRefEntity_t has all the information passed in by
+// the client game, as well as some locally derived info
+typedef struct {
+	refEntity_t	e;
+
+	float		axisLength;		// compensate for non-normalized axis
+
+	qboolean	needDlights;	// true for bmodels that touch a dlight
+	qboolean	lightingCalculated;
+	vec3_t		lightDir;		// normalized direction towards light
+	vec3_t		ambientLight;	// color normalized to 0-255
+	int			ambientLightInt;	// 32 bit rgba packed
+	vec3_t		directedLight;
+} trRefEntity_t;
+
+
+typedef struct {
+	vec3_t		origin;			// in world coordinates
+	vec3_t		axis[3];		// orientation in world
+	vec3_t		viewOrigin;		// viewParms->or.origin in local coordinates
+	float		modelMatrix[16];
+} orientationr_t;
+
+typedef struct image_s {
+	char		imgName[MAX_QPATH];		// game path, including extension
+	int			width, height;				// source image
+	int			uploadWidth, uploadHeight;	// after power of two and picmip but not including clamp to MAX_TEXTURE_SIZE
+	GLuint		texnum;					// gl texture binding
+
+	int			frameUsed;			// for texture usage in frame statistics
+
+	int			internalFormat;
+	int			TMU;				// only needed for voodoo2
+
+	qboolean	mipmap;
+	qboolean	allowPicmip;
+	int			wrapClampMode;		// GL_CLAMP_TO_EDGE or GL_REPEAT
+
+	struct image_s*	next;
+} image_t;
+
+//===============================================================================
+
+typedef enum {
+	SS_BAD,
+	SS_PORTAL,			// mirrors, portals, viewscreens
+	SS_ENVIRONMENT,		// sky box
+	SS_OPAQUE,			// opaque
+
+	SS_DECAL,			// scorch marks, etc.
+	SS_SEE_THROUGH,		// ladders, grates, grills that may have small blended edges
+						// in addition to alpha test
+	SS_BANNER,
+
+	SS_FOG,
+
+	SS_UNDERWATER,		// for items that should be drawn in front of the water plane
+
+	SS_BLEND0,			// regular transparency and filters
+	SS_BLEND1,			// generally only used for additive type effects
+	SS_BLEND2,
+	SS_BLEND3,
+
+	SS_BLEND6,
+	SS_STENCIL_SHADOW,
+	SS_ALMOST_NEAREST,	// gun smoke puffs
+
+	SS_NEAREST			// blood blobs
+} shaderSort_t;
+
+
+#define MAX_SHADER_STAGES 8
+
+typedef enum {
+	GF_NONE,
+
+	GF_SIN,
+	GF_SQUARE,
+	GF_TRIANGLE,
+	GF_SAWTOOTH, 
+	GF_INVERSE_SAWTOOTH, 
+
+	GF_NOISE
+
+} genFunc_t;
+
+
+typedef enum {
+	DEFORM_NONE,
+	DEFORM_WAVE,
+	DEFORM_NORMALS,
+	DEFORM_BULGE,
+	DEFORM_MOVE,
+	DEFORM_PROJECTION_SHADOW,
+	DEFORM_AUTOSPRITE,
+	DEFORM_AUTOSPRITE2,
+	DEFORM_TEXT0,
+	DEFORM_TEXT1,
+	DEFORM_TEXT2,
+	DEFORM_TEXT3,
+	DEFORM_TEXT4,
+	DEFORM_TEXT5,
+	DEFORM_TEXT6,
+	DEFORM_TEXT7
+} deform_t;
+
+typedef enum {
+	AGEN_IDENTITY,
+	AGEN_SKIP,
+	AGEN_ENTITY,
+	AGEN_ONE_MINUS_ENTITY,
+	AGEN_VERTEX,
+	AGEN_ONE_MINUS_VERTEX,
+	AGEN_LIGHTING_SPECULAR,
+	AGEN_WAVEFORM,
+	AGEN_PORTAL,
+	AGEN_CONST
+} alphaGen_t;
+
+typedef enum {
+	CGEN_BAD,
+	CGEN_IDENTITY_LIGHTING,	// tr.identityLight
+	CGEN_IDENTITY,			// always (1,1,1,1)
+	CGEN_ENTITY,			// grabbed from entity's modulate field
+	CGEN_ONE_MINUS_ENTITY,	// grabbed from 1 - entity.modulate
+	CGEN_EXACT_VERTEX,		// tess.vertexColors
+	CGEN_VERTEX,			// tess.vertexColors * tr.identityLight
+	CGEN_ONE_MINUS_VERTEX,
+	CGEN_WAVEFORM,			// programmatically generated
+	CGEN_LIGHTING_DIFFUSE,
+	CGEN_FOG,				// standard fog
+	CGEN_CONST				// fixed color
+} colorGen_t;
+
+typedef enum {
+	TCGEN_BAD,
+	TCGEN_IDENTITY,			// clear to 0,0
+	TCGEN_LIGHTMAP,
+	TCGEN_TEXTURE,
+	TCGEN_ENVIRONMENT_MAPPED,
+	TCGEN_FOG,
+	TCGEN_VECTOR			// S and T from world coordinates
+} texCoordGen_t;
+
+typedef enum {
+	ACFF_NONE,
+	ACFF_MODULATE_RGB,
+	ACFF_MODULATE_RGBA,
+	ACFF_MODULATE_ALPHA
+} acff_t;
+
+typedef struct {
+	genFunc_t	func;
+
+	float base;
+	float amplitude;
+	float phase;
+	float frequency;
+} waveForm_t;
+
+#define TR_MAX_TEXMODS 4
+
+typedef enum {
+	TMOD_NONE,
+	TMOD_TRANSFORM,
+	TMOD_TURBULENT,
+	TMOD_SCROLL,
+	TMOD_SCALE,
+	TMOD_STRETCH,
+	TMOD_ROTATE,
+	TMOD_ENTITY_TRANSLATE
+} texMod_t;
+
+#define	MAX_SHADER_DEFORMS	3
+typedef struct {
+	deform_t	deformation;			// vertex coordinate modification type
+
+	vec3_t		moveVector;
+	waveForm_t	deformationWave;
+	float		deformationSpread;
+
+	float		bulgeWidth;
+	float		bulgeHeight;
+	float		bulgeSpeed;
+} deformStage_t;
+
+
+typedef struct {
+	texMod_t		type;
+
+	// used for TMOD_TURBULENT and TMOD_STRETCH
+	waveForm_t		wave;
+
+	// used for TMOD_TRANSFORM
+	float			matrix[2][2];		// s' = s * m[0][0] + t * m[1][0] + trans[0]
+	float			translate[2];		// t' = s * m[0][1] + t * m[0][1] + trans[1]
+
+	// used for TMOD_SCALE
+	float			scale[2];			// s *= scale[0]
+	                                    // t *= scale[1]
+
+	// used for TMOD_SCROLL
+	float			scroll[2];			// s' = s + scroll[0] * time
+										// t' = t + scroll[1] * time
+
+	// + = clockwise
+	// - = counterclockwise
+	float			rotateSpeed;
+
+} texModInfo_t;
+
+
+#define	MAX_IMAGE_ANIMATIONS	8
+
+typedef struct {
+	image_t			*image[MAX_IMAGE_ANIMATIONS];
+	int				numImageAnimations;
+	float			imageAnimationSpeed;
+
+	texCoordGen_t	tcGen;
+	vec3_t			tcGenVectors[2];
+
+	int				numTexMods;
+	texModInfo_t	*texMods;
+
+	int				videoMapHandle;
+	qboolean		isLightmap;
+	qboolean		vertexLightmap;
+	qboolean		isVideoMap;
+} textureBundle_t;
+
+#define NUM_TEXTURE_BUNDLES 2
+
+typedef struct {
+	qboolean		active;
+	
+	textureBundle_t	bundle[NUM_TEXTURE_BUNDLES];
+
+	waveForm_t		rgbWave;
+	colorGen_t		rgbGen;
+
+	waveForm_t		alphaWave;
+	alphaGen_t		alphaGen;
+
+	byte			constantColor[4];			// for CGEN_CONST and AGEN_CONST
+
+	unsigned		stateBits;					// GLS_xxxx mask
+
+	acff_t			adjustColorsForFog;
+
+	qboolean		isDetail;
+} shaderStage_t;
+
+struct shaderCommands_s;
+
+// any change in the LIGHTMAP_* defines here MUST be reflected in
+// R_FindShader() in tr_bsp.c
+#define LIGHTMAP_2D         -4	// shader is for 2D rendering
+#define LIGHTMAP_BY_VERTEX  -3	// pre-lit triangle models
+#define LIGHTMAP_WHITEIMAGE -2
+#define LIGHTMAP_NONE       -1
+
+typedef enum {
+	CT_FRONT_SIDED,
+	CT_BACK_SIDED,
+	CT_TWO_SIDED
+} cullType_t;
+
+typedef enum {
+	FP_NONE,		// surface is translucent and will just be adjusted properly
+	FP_EQUAL,		// surface is opaque but possibly alpha tested
+	FP_LE			// surface is trnaslucent, but still needs a fog pass (fog surface)
+} fogPass_t;
+
+typedef struct {
+	float		cloudHeight;
+	image_t		*outerbox[6], *innerbox[6];
+} skyParms_t;
+
+typedef struct {
+	vec3_t	color;
+	float	depthForOpaque;
+} fogParms_t;
+
+
+typedef struct shader_s {
+	char		name[MAX_QPATH];		// game path, including extension
+	int			lightmapIndex;			// for a shader to match, both name and lightmapIndex must match
+
+	int			index;					// this shader == tr.shaders[index]
+	int			sortedIndex;			// this shader == tr.sortedShaders[sortedIndex]
+
+	float		sort;					// lower numbered shaders draw before higher numbered
+
+	qboolean	defaultShader;			// we want to return index 0 if the shader failed to
+										// load for some reason, but R_FindShader should
+										// still keep a name allocated for it, so if
+										// something calls RE_RegisterShader again with
+										// the same name, we don't try looking for it again
+
+	qboolean	explicitlyDefined;		// found in a .shader file
+
+	int			surfaceFlags;			// if explicitlyDefined, this will have SURF_* flags
+	int			contentFlags;
+
+	qboolean	entityMergable;			// merge across entites optimizable (smoke, blood)
+
+	qboolean	isSky;
+	skyParms_t	sky;
+	fogParms_t	fogParms;
+
+	float		portalRange;			// distance to fog out at
+
+	int			multitextureEnv;		// 0, GL_MODULATE, GL_ADD (FIXME: put in stage)
+
+	cullType_t	cullType;				// CT_FRONT_SIDED, CT_BACK_SIDED, or CT_TWO_SIDED
+	qboolean	polygonOffset;			// set for decals and other items that must be offset 
+	qboolean	noMipMaps;				// for console fonts, 2D elements, etc.
+	qboolean	noPicMip;				// for images that must always be full resolution
+
+	fogPass_t	fogPass;				// draw a blended pass, possibly with depth test equals
+
+	qboolean	needsNormal;			// not all shaders will need all data to be gathered
+	qboolean	needsST1;
+	qboolean	needsST2;
+	qboolean	needsColor;
+
+	int			numDeforms;
+	deformStage_t	deforms[MAX_SHADER_DEFORMS];
+
+	int			numUnfoggedPasses;
+	shaderStage_t	*stages[MAX_SHADER_STAGES];		
+
+	void		(*optimalStageIteratorFunc)( void );
+
+  float clampTime;                                  // time this shader is clamped to
+  float timeOffset;                                 // current time offset for this shader
+
+  int numStates;                                    // if non-zero this is a state shader
+  struct shader_s *currentShader;                   // current state if this is a state shader
+  struct shader_s *parentShader;                    // current state if this is a state shader
+  int currentState;                                 // current state index for cycle purposes
+  long expireTime;                                  // time in milliseconds this expires
+
+  struct shader_s *remappedShader;                  // current shader this one is remapped too
+
+  int shaderStates[MAX_STATES_PER_SHADER];          // index to valid shader states
+
+	struct	shader_s	*next;
+} shader_t;
+
+typedef struct shaderState_s {
+  char shaderName[MAX_QPATH];     // name of shader this state belongs to
+  char name[MAX_STATE_NAME];      // name of this state
+  char stateShader[MAX_QPATH];    // shader this name invokes
+  int cycleTime;                  // time this cycle lasts, <= 0 is forever
+  shader_t *shader;
+} shaderState_t;
+
+
+// trRefdef_t holds everything that comes in refdef_t,
+// as well as the locally generated scene information
+typedef struct {
+	int			x, y, width, height;
+	float		fov_x, fov_y;
+	vec3_t		vieworg;
+	vec3_t		viewaxis[3];		// transformation matrix
+
+	stereoFrame_t	stereoFrame;
+
+	int			time;				// time in milliseconds for shader effects and other time dependent rendering issues
+	int			rdflags;			// RDF_NOWORLDMODEL, etc
+
+	// 1 bits will prevent the associated area from rendering at all
+	byte		areamask[MAX_MAP_AREA_BYTES];
+	qboolean	areamaskModified;	// qtrue if areamask changed since last scene
+
+	float		floatTime;			// tr.refdef.time / 1000.0
+
+	// text messages for deform text shaders
+	char		text[MAX_RENDER_STRINGS][MAX_RENDER_STRING_LENGTH];
+
+	int			num_entities;
+	trRefEntity_t	*entities;
+
+	int			num_dlights;
+	struct dlight_s	*dlights;
+
+	int			numPolys;
+	struct srfPoly_s	*polys;
+
+	int			numDrawSurfs;
+	struct drawSurf_s	*drawSurfs;
+
+
+} trRefdef_t;
+
+
+//=================================================================================
+
+// skins allow models to be retextured without modifying the model file
+typedef struct {
+	char		name[MAX_QPATH];
+	shader_t	*shader;
+} skinSurface_t;
+
+typedef struct skin_s {
+	char		name[MAX_QPATH];		// game path, including extension
+	int			numSurfaces;
+	skinSurface_t	*surfaces[MD3_MAX_SURFACES];
+} skin_t;
+
+
+typedef struct {
+	int			originalBrushNumber;
+	vec3_t		bounds[2];
+
+	unsigned	colorInt;				// in packed byte format
+	float		tcScale;				// texture coordinate vector scales
+	fogParms_t	parms;
+
+	// for clipping distance in fog when outside
+	qboolean	hasSurface;
+	float		surface[4];
+} fog_t;
+
+typedef struct {
+	orientationr_t	or;
+	orientationr_t	world;
+	vec3_t		pvsOrigin;			// may be different than or.origin for portals
+	qboolean	isPortal;			// true if this view is through a portal
+	qboolean	isMirror;			// the portal is a mirror, invert the face culling
+	int			frameSceneNum;		// copied from tr.frameSceneNum
+	int			frameCount;			// copied from tr.frameCount
+	cplane_t	portalPlane;		// clip anything behind this if mirroring
+	int			viewportX, viewportY, viewportWidth, viewportHeight;
+	float		fovX, fovY;
+	float		projectionMatrix[16];
+	cplane_t	frustum[4];
+	vec3_t		visBounds[2];
+	float		zFar;
+	stereoFrame_t	stereoFrame;
+} viewParms_t;
+
+
+/*
+==============================================================================
+
+SURFACES
+
+==============================================================================
+*/
+
+// any changes in surfaceType must be mirrored in rb_surfaceTable[]
+typedef enum {
+	SF_BAD,
+	SF_SKIP,				// ignore
+	SF_FACE,
+	SF_GRID,
+	SF_TRIANGLES,
+	SF_POLY,
+	SF_MD3,
+	SF_MD4,
+#ifdef RAVENMD4
+	SF_MDR,
+#endif
+	SF_FLARE,
+	SF_ENTITY,				// beams, rails, lightning, etc that can be determined by entity
+	SF_DISPLAY_LIST,
+
+	SF_NUM_SURFACE_TYPES,
+	SF_MAX = 0x7fffffff			// ensures that sizeof( surfaceType_t ) == sizeof( int )
+} surfaceType_t;
+
+typedef struct drawSurf_s {
+	unsigned			sort;			// bit combination for fast compares
+	surfaceType_t		*surface;		// any of surface*_t
+} drawSurf_t;
+
+#define	MAX_FACE_POINTS		64
+
+#define	MAX_PATCH_SIZE		32			// max dimensions of a patch mesh in map file
+#define	MAX_GRID_SIZE		65			// max dimensions of a grid mesh in memory
+
+// when cgame directly specifies a polygon, it becomes a srfPoly_t
+// as soon as it is called
+typedef struct srfPoly_s {
+	surfaceType_t	surfaceType;
+	qhandle_t		hShader;
+	int				fogIndex;
+	int				numVerts;
+	polyVert_t		*verts;
+} srfPoly_t;
+
+typedef struct srfDisplayList_s {
+	surfaceType_t	surfaceType;
+	int				listNum;
+} srfDisplayList_t;
+
+
+typedef struct srfFlare_s {
+	surfaceType_t	surfaceType;
+	vec3_t			origin;
+	vec3_t			normal;
+	vec3_t			color;
+} srfFlare_t;
+
+typedef struct srfGridMesh_s {
+	surfaceType_t	surfaceType;
+
+	// dynamic lighting information
+	int				dlightBits[SMP_FRAMES];
+
+	// culling information
+	vec3_t			meshBounds[2];
+	vec3_t			localOrigin;
+	float			meshRadius;
+
+	// lod information, which may be different
+	// than the culling information to allow for
+	// groups of curves that LOD as a unit
+	vec3_t			lodOrigin;
+	float			lodRadius;
+	int				lodFixed;
+	int				lodStitched;
+
+	// vertexes
+	int				width, height;
+	float			*widthLodError;
+	float			*heightLodError;
+	drawVert_t		verts[1];		// variable sized
+} srfGridMesh_t;
+
+
+
+#define	VERTEXSIZE	8
+typedef struct {
+	surfaceType_t	surfaceType;
+	cplane_t	plane;
+
+	// dynamic lighting information
+	int			dlightBits[SMP_FRAMES];
+
+	// triangle definitions (no normals at points)
+	int			numPoints;
+	int			numIndices;
+	int			ofsIndices;
+	float		points[1][VERTEXSIZE];	// variable sized
+										// there is a variable length list of indices here also
+} srfSurfaceFace_t;
+
+
+// misc_models in maps are turned into direct geometry by q3map
+typedef struct {
+	surfaceType_t	surfaceType;
+
+	// dynamic lighting information
+	int				dlightBits[SMP_FRAMES];
+
+	// culling information (FIXME: use this!)
+	vec3_t			bounds[2];
+	vec3_t			localOrigin;
+	float			radius;
+
+	// triangle definitions
+	int				numIndexes;
+	int				*indexes;
+
+	int				numVerts;
+	drawVert_t		*verts;
+} srfTriangles_t;
+
+
+extern	void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])(void *);
+
+/*
+==============================================================================
+
+BRUSH MODELS
+
+==============================================================================
+*/
+
+
+//
+// in memory representation
+//
+
+#define	SIDE_FRONT	0
+#define	SIDE_BACK	1
+#define	SIDE_ON		2
+
+typedef struct msurface_s {
+	int					viewCount;		// if == tr.viewCount, already added
+	struct shader_s		*shader;
+	int					fogIndex;
+
+	surfaceType_t		*data;			// any of srf*_t
+} msurface_t;
+
+
+
+#define	CONTENTS_NODE		-1
+typedef struct mnode_s {
+	// common with leaf and node
+	int			contents;		// -1 for nodes, to differentiate from leafs
+	int			visframe;		// node needs to be traversed if current
+	vec3_t		mins, maxs;		// for bounding box culling
+	struct mnode_s	*parent;
+
+	// node specific
+	cplane_t	*plane;
+	struct mnode_s	*children[2];	
+
+	// leaf specific
+	int			cluster;
+	int			area;
+
+	msurface_t	**firstmarksurface;
+	int			nummarksurfaces;
+} mnode_t;
+
+typedef struct {
+	vec3_t		bounds[2];		// for culling
+	msurface_t	*firstSurface;
+	int			numSurfaces;
+} bmodel_t;
+
+typedef struct {
+	char		name[MAX_QPATH];		// ie: maps/tim_dm2.bsp
+	char		baseName[MAX_QPATH];	// ie: tim_dm2
+
+	int			dataSize;
+
+	int			numShaders;
+	dshader_t	*shaders;
+
+	bmodel_t	*bmodels;
+
+	int			numplanes;
+	cplane_t	*planes;
+
+	int			numnodes;		// includes leafs
+	int			numDecisionNodes;
+	mnode_t		*nodes;
+
+	int			numsurfaces;
+	msurface_t	*surfaces;
+
+	int			nummarksurfaces;
+	msurface_t	**marksurfaces;
+
+	int			numfogs;
+	fog_t		*fogs;
+
+	vec3_t		lightGridOrigin;
+	vec3_t		lightGridSize;
+	vec3_t		lightGridInverseSize;
+	int			lightGridBounds[3];
+	byte		*lightGridData;
+
+
+	int			numClusters;
+	int			clusterBytes;
+	const byte	*vis;			// may be passed in by CM_LoadMap to save space
+
+	byte		*novis;			// clusterBytes of 0xff
+
+	char		*entityString;
+	char		*entityParsePoint;
+} world_t;
+
+//======================================================================
+
+typedef enum {
+	MOD_BAD,
+	MOD_BRUSH,
+	MOD_MESH,
+	MOD_MD4,
+#ifdef RAVENMD4
+	MOD_MDR
+#endif
+} modtype_t;
+
+typedef struct model_s {
+	char		name[MAX_QPATH];
+	modtype_t	type;
+	int			index;				// model = tr.models[model->index]
+
+	int			dataSize;			// just for listing purposes
+	bmodel_t	*bmodel;			// only if type == MOD_BRUSH
+	md3Header_t	*md3[MD3_MAX_LODS];	// only if type == MOD_MESH
+	void	*md4;				// only if type == (MOD_MD4 | MOD_MDR)
+
+	int			 numLods;
+} model_t;
+
+
+#define	MAX_MOD_KNOWN	1024
+
+void		R_ModelInit (void);
+model_t		*R_GetModelByHandle( qhandle_t hModel );
+int			R_LerpTag( orientation_t *tag, qhandle_t handle, int startFrame, int endFrame, 
+					 float frac, const char *tagName );
+void		R_ModelBounds( qhandle_t handle, vec3_t mins, vec3_t maxs );
+
+void		R_Modellist_f (void);
+
+//====================================================
+extern	refimport_t		ri;
+
+#define	MAX_DRAWIMAGES			2048
+#define	MAX_SKINS				1024
+
+
+#define	MAX_DRAWSURFS			0x10000
+#define	DRAWSURF_MASK			(MAX_DRAWSURFS-1)
+
+/*
+
+the drawsurf sort data is packed into a single 32 bit value so it can be
+compared quickly during the qsorting process
+
+the bits are allocated as follows:
+
+21 - 31	: sorted shader index
+11 - 20	: entity index
+2 - 6	: fog index
+//2		: used to be clipped flag REMOVED - 03.21.00 rad
+0 - 1	: dlightmap index
+
+	TTimo - 1.32
+17-31 : sorted shader index
+7-16  : entity index
+2-6   : fog index
+0-1   : dlightmap index
+*/
+#define	QSORT_SHADERNUM_SHIFT	17
+#define	QSORT_ENTITYNUM_SHIFT	7
+#define	QSORT_FOGNUM_SHIFT		2
+
+extern	int			gl_filter_min, gl_filter_max;
+
+/*
+** performanceCounters_t
+*/
+typedef struct {
+	int		c_sphere_cull_patch_in, c_sphere_cull_patch_clip, c_sphere_cull_patch_out;
+	int		c_box_cull_patch_in, c_box_cull_patch_clip, c_box_cull_patch_out;
+	int		c_sphere_cull_md3_in, c_sphere_cull_md3_clip, c_sphere_cull_md3_out;
+	int		c_box_cull_md3_in, c_box_cull_md3_clip, c_box_cull_md3_out;
+
+	int		c_leafs;
+	int		c_dlightSurfaces;
+	int		c_dlightSurfacesCulled;
+} frontEndCounters_t;
+
+#define	FOG_TABLE_SIZE		256
+#define FUNCTABLE_SIZE		1024
+#define FUNCTABLE_SIZE2		10
+#define FUNCTABLE_MASK		(FUNCTABLE_SIZE-1)
+
+
+// the renderer front end should never modify glstate_t
+typedef struct {
+	int			currenttextures[2];
+	int			currenttmu;
+	qboolean	finishCalled;
+	int			texEnv[2];
+	int			faceCulling;
+	unsigned long	glStateBits;
+} glstate_t;
+
+
+typedef struct {
+	int		c_surfaces, c_shaders, c_vertexes, c_indexes, c_totalIndexes;
+	float	c_overDraw;
+	
+	int		c_dlightVertexes;
+	int		c_dlightIndexes;
+
+	int		c_flareAdds;
+	int		c_flareTests;
+	int		c_flareRenders;
+
+	int		msec;			// total msec for backend run
+} backEndCounters_t;
+
+// all state modified by the back end is seperated
+// from the front end state
+typedef struct {
+	int			smpFrame;
+	trRefdef_t	refdef;
+	viewParms_t	viewParms;
+	orientationr_t	or;
+	backEndCounters_t	pc;
+	qboolean	isHyperspace;
+	trRefEntity_t	*currentEntity;
+	qboolean	skyRenderedThisView;	// flag for drawing sun
+
+	qboolean	projection2D;	// if qtrue, drawstretchpic doesn't need to change modes
+	byte		color2D[4];
+	qboolean	vertexes2D;		// shader needs to be finished
+	trRefEntity_t	entity2D;	// currentEntity will point at this when doing 2D rendering
+} backEndState_t;
+
+/*
+** trGlobals_t 
+**
+** Most renderer globals are defined here.
+** backend functions should never modify any of these fields,
+** but may read fields that aren't dynamically modified
+** by the frontend.
+*/
+typedef struct {
+	qboolean				registered;		// cleared at shutdown, set at beginRegistration
+
+	int						visCount;		// incremented every time a new vis cluster is entered
+	int						frameCount;		// incremented every frame
+	int						sceneCount;		// incremented every scene
+	int						viewCount;		// incremented every view (twice a scene if portaled)
+											// and every R_MarkFragments call
+
+	int						smpFrame;		// toggles from 0 to 1 every endFrame
+
+	int						frameSceneNum;	// zeroed at RE_BeginFrame
+
+	qboolean				worldMapLoaded;
+	world_t					*world;
+
+	const byte				*externalVisData;	// from RE_SetWorldVisData, shared with CM_Load
+
+	image_t					*defaultImage;
+	image_t					*scratchImage[32];
+	image_t					*fogImage;
+	image_t					*dlightImage;	// inverse-quare highlight for projective adding
+	image_t					*flareImage;
+	image_t					*whiteImage;			// full of 0xff
+	image_t					*identityLightImage;	// full of tr.identityLightByte
+
+	shader_t				*defaultShader;
+	shader_t				*shadowShader;
+	shader_t				*projectionShadowShader;
+
+	shader_t				*flareShader;
+	shader_t				*sunShader;
+
+	int						numLightmaps;
+	image_t					**lightmaps;
+
+	trRefEntity_t			*currentEntity;
+	trRefEntity_t			worldEntity;		// point currentEntity at this when rendering world
+	int						currentEntityNum;
+	int						shiftedEntityNum;	// currentEntityNum << QSORT_ENTITYNUM_SHIFT
+	model_t					*currentModel;
+
+	viewParms_t				viewParms;
+
+	float					identityLight;		// 1.0 / ( 1 << overbrightBits )
+	int						identityLightByte;	// identityLight * 255
+	int						overbrightBits;		// r_overbrightBits->integer, but set to 0 if no hw gamma
+
+	orientationr_t			or;					// for current entity
+
+	trRefdef_t				refdef;
+
+	int						viewCluster;
+
+	vec3_t					sunLight;			// from the sky shader for this level
+	vec3_t					sunDirection;
+
+	frontEndCounters_t		pc;
+	int						frontEndMsec;		// not in pc due to clearing issue
+
+	vec4_t					clipRegion;			// 2D clipping region
+
+	//
+	// put large tables at the end, so most elements will be
+	// within the +/32K indexed range on risc processors
+	//
+	model_t					*models[MAX_MOD_KNOWN];
+	int						numModels;
+
+	int						numImages;
+	image_t					*images[MAX_DRAWIMAGES];
+
+	// shader indexes from other modules will be looked up in tr.shaders[]
+	// shader indexes from drawsurfs will be looked up in sortedShaders[]
+	// lower indexed sortedShaders must be rendered first (opaque surfaces before translucent)
+	int						numShaders;
+	shader_t				*shaders[MAX_SHADERS];
+	shader_t				*sortedShaders[MAX_SHADERS];
+
+	int						numSkins;
+	skin_t					*skins[MAX_SKINS];
+
+	float					sinTable[FUNCTABLE_SIZE];
+	float					squareTable[FUNCTABLE_SIZE];
+	float					triangleTable[FUNCTABLE_SIZE];
+	float					sawToothTable[FUNCTABLE_SIZE];
+	float					inverseSawToothTable[FUNCTABLE_SIZE];
+	float					fogTable[FOG_TABLE_SIZE];
+} trGlobals_t;
+
+extern backEndState_t	backEnd;
+extern trGlobals_t	tr;
+extern glconfig_t	glConfig;		// outside of TR since it shouldn't be cleared during ref re-init
+extern glstate_t	glState;		// outside of TR since it shouldn't be cleared during ref re-init
+
+
+//
+// cvars
+//
+extern cvar_t	*r_flareSize;
+extern cvar_t	*r_flareFade;
+// coefficient for the flare intensity falloff function.
+#define FLARE_STDCOEFF "150"
+extern cvar_t	*r_flareCoeff;
+
+extern cvar_t	*r_railWidth;
+extern cvar_t	*r_railCoreWidth;
+extern cvar_t	*r_railSegmentLength;
+
+extern cvar_t	*r_ignore;				// used for debugging anything
+extern cvar_t	*r_verbose;				// used for verbose debug spew
+extern cvar_t	*r_ignoreFastPath;		// allows us to ignore our Tess fast paths
+
+extern cvar_t	*r_znear;				// near Z clip plane
+extern cvar_t	*r_zproj;				// z distance of projection plane
+extern cvar_t	*r_stereoSeparation;			// separation of cameras for stereo rendering
+
+extern cvar_t	*r_stencilbits;			// number of desired stencil bits
+extern cvar_t	*r_depthbits;			// number of desired depth bits
+extern cvar_t	*r_colorbits;			// number of desired color bits, only relevant for fullscreen
+extern cvar_t	*r_texturebits;			// number of desired texture bits
+extern cvar_t	*r_ext_multisample;
+										// 0 = use framebuffer depth
+										// 16 = use 16-bit textures
+										// 32 = use 32-bit textures
+										// all else = error
+
+extern cvar_t	*r_measureOverdraw;		// enables stencil buffer overdraw measurement
+
+extern cvar_t	*r_lodbias;				// push/pull LOD transitions
+extern cvar_t	*r_lodscale;
+
+extern cvar_t	*r_primitives;			// "0" = based on compiled vertex array existance
+										// "1" = glDrawElemet tristrips
+										// "2" = glDrawElements triangles
+										// "-1" = no drawing
+
+extern cvar_t	*r_inGameVideo;				// controls whether in game video should be draw
+extern cvar_t	*r_fastsky;				// controls whether sky should be cleared or drawn
+extern cvar_t	*r_drawSun;				// controls drawing of sun quad
+extern cvar_t	*r_dynamiclight;		// dynamic lights enabled/disabled
+extern cvar_t	*r_dlightBacks;			// dlight non-facing surfaces for continuity
+
+extern	cvar_t	*r_norefresh;			// bypasses the ref rendering
+extern	cvar_t	*r_drawentities;		// disable/enable entity rendering
+extern	cvar_t	*r_drawworld;			// disable/enable world rendering
+extern	cvar_t	*r_speeds;				// various levels of information display
+extern  cvar_t	*r_detailTextures;		// enables/disables detail texturing stages
+extern	cvar_t	*r_novis;				// disable/enable usage of PVS
+extern	cvar_t	*r_nocull;
+extern	cvar_t	*r_facePlaneCull;		// enables culling of planar surfaces with back side test
+extern	cvar_t	*r_nocurves;
+extern	cvar_t	*r_showcluster;
+
+extern cvar_t	*r_width;
+extern cvar_t	*r_height;
+extern cvar_t	*r_pixelAspect;
+
+extern cvar_t	*r_fullscreen;
+extern cvar_t	*r_noborder;
+extern cvar_t	*r_gamma;
+extern cvar_t	*r_ignorehwgamma;		// overrides hardware gamma capabilities
+
+extern cvar_t	*r_allowExtensions;				// global enable/disable of OpenGL extensions
+extern cvar_t	*r_ext_compressed_textures;		// these control use of specific extensions
+extern cvar_t	*r_ext_multitexture;
+extern cvar_t	*r_ext_compiled_vertex_array;
+extern cvar_t	*r_ext_texture_env_add;
+
+extern cvar_t	*r_ext_texture_filter_anisotropic;
+extern cvar_t	*r_ext_max_anisotropy;
+
+extern	cvar_t	*r_nobind;						// turns off binding to appropriate textures
+extern	cvar_t	*r_singleShader;				// make most world faces use default shader
+extern	cvar_t	*r_roundImagesDown;
+extern	cvar_t	*r_colorMipLevels;				// development aid to see texture mip usage
+extern	cvar_t	*r_picmip;						// controls picmip values
+extern	cvar_t	*r_finish;
+extern	cvar_t	*r_drawBuffer;
+extern	cvar_t	*r_swapInterval;
+extern	cvar_t	*r_textureMode;
+extern	cvar_t	*r_offsetFactor;
+extern	cvar_t	*r_offsetUnits;
+
+extern	cvar_t	*r_fullbright;					// avoid lightmap pass
+extern	cvar_t	*r_lightmap;					// render lightmaps only
+extern	cvar_t	*r_vertexLight;					// vertex lighting mode for better performance
+extern	cvar_t	*r_uiFullScreen;				// ui is running fullscreen
+
+extern	cvar_t	*r_logFile;						// number of frames to emit GL logs
+extern	cvar_t	*r_showtris;					// enables wireframe rendering of the world
+extern	cvar_t	*r_showsky;						// forces sky in front of all surfaces
+extern	cvar_t	*r_shownormals;					// draws wireframe normals
+extern	cvar_t	*r_clear;						// force screen clear every frame
+
+extern	cvar_t	*r_shadows;						// controls shadows: 0 = none, 1 = blur, 2 = stencil, 3 = black planar projection
+extern	cvar_t	*r_flares;						// light flares
+
+extern	cvar_t	*r_intensity;
+
+extern	cvar_t	*r_lockpvs;
+extern	cvar_t	*r_noportals;
+extern	cvar_t	*r_portalOnly;
+
+extern	cvar_t	*r_subdivisions;
+extern	cvar_t	*r_lodCurveError;
+extern	cvar_t	*r_smp;
+extern	cvar_t	*r_showSmp;
+extern	cvar_t	*r_skipBackEnd;
+
+extern	cvar_t	*r_stereoEnabled;
+extern	cvar_t	*r_anaglyphMode;
+
+extern	cvar_t	*r_greyscale;
+
+extern	cvar_t	*r_ignoreGLErrors;
+
+extern	cvar_t	*r_overBrightBits;
+extern	cvar_t	*r_mapOverBrightBits;
+
+extern	cvar_t	*r_debugSurface;
+extern	cvar_t	*r_simpleMipMaps;
+
+extern	cvar_t	*r_showImages;
+extern	cvar_t	*r_debugSort;
+
+extern	cvar_t	*r_printShaders;
+extern	cvar_t	*r_saveFontData;
+
+extern cvar_t	*r_marksOnTriangleMeshes;
+
+//====================================================================
+
+float R_NoiseGet4f( float x, float y, float z, float t );
+void  R_NoiseInit( void );
+
+void R_SwapBuffers( int );
+
+void R_RenderView( viewParms_t *parms );
+
+void R_AddMD3Surfaces( trRefEntity_t *e );
+void R_AddNullModelSurfaces( trRefEntity_t *e );
+void R_AddBeamSurfaces( trRefEntity_t *e );
+void R_AddRailSurfaces( trRefEntity_t *e, qboolean isUnderwater );
+void R_AddLightningBoltSurfaces( trRefEntity_t *e );
+
+void R_AddPolygonSurfaces( void );
+
+void R_DecomposeSort( unsigned sort, int *entityNum, shader_t **shader, 
+					 int *fogNum, int *dlightMap );
+
+void R_AddDrawSurf( surfaceType_t *surface, shader_t *shader, int fogIndex, int dlightMap );
+
+
+#define	CULL_IN		0		// completely unclipped
+#define	CULL_CLIP	1		// clipped by one or more planes
+#define	CULL_OUT	2		// completely outside the clipping planes
+void R_LocalNormalToWorld (vec3_t local, vec3_t world);
+void R_LocalPointToWorld (vec3_t local, vec3_t world);
+int R_CullLocalBox (vec3_t bounds[2]);
+int R_CullPointAndRadius( vec3_t origin, float radius );
+int R_CullLocalPointAndRadius( vec3_t origin, float radius );
+
+void R_SetupProjection(viewParms_t *dest, float zProj, qboolean computeFrustum);
+void R_RotateForEntity( const trRefEntity_t *ent, const viewParms_t *viewParms, orientationr_t *or );
+
+/*
+** GL wrapper/helper functions
+*/
+void	GL_Bind( image_t *image );
+void	GL_SetDefaultState (void);
+void	GL_SelectTexture( int unit );
+void	GL_TextureMode( const char *string );
+void	GL_CheckErrors( void );
+void	GL_State( unsigned long stateVector );
+void	GL_TexEnv( int env );
+void	GL_Cull( int cullType );
+
+#define GLS_SRCBLEND_ZERO						0x00000001
+#define GLS_SRCBLEND_ONE						0x00000002
+#define GLS_SRCBLEND_DST_COLOR					0x00000003
+#define GLS_SRCBLEND_ONE_MINUS_DST_COLOR		0x00000004
+#define GLS_SRCBLEND_SRC_ALPHA					0x00000005
+#define GLS_SRCBLEND_ONE_MINUS_SRC_ALPHA		0x00000006
+#define GLS_SRCBLEND_DST_ALPHA					0x00000007
+#define GLS_SRCBLEND_ONE_MINUS_DST_ALPHA		0x00000008
+#define GLS_SRCBLEND_ALPHA_SATURATE				0x00000009
+#define		GLS_SRCBLEND_BITS					0x0000000f
+
+#define GLS_DSTBLEND_ZERO						0x00000010
+#define GLS_DSTBLEND_ONE						0x00000020
+#define GLS_DSTBLEND_SRC_COLOR					0x00000030
+#define GLS_DSTBLEND_ONE_MINUS_SRC_COLOR		0x00000040
+#define GLS_DSTBLEND_SRC_ALPHA					0x00000050
+#define GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA		0x00000060
+#define GLS_DSTBLEND_DST_ALPHA					0x00000070
+#define GLS_DSTBLEND_ONE_MINUS_DST_ALPHA		0x00000080
+#define		GLS_DSTBLEND_BITS					0x000000f0
+
+#define GLS_DEPTHMASK_TRUE						0x00000100
+
+#define GLS_POLYMODE_LINE						0x00001000
+
+#define GLS_DEPTHTEST_DISABLE					0x00010000
+#define GLS_DEPTHFUNC_EQUAL						0x00020000
+
+#define GLS_ATEST_GT_0							0x10000000
+#define GLS_ATEST_LT_80							0x20000000
+#define GLS_ATEST_GE_80							0x40000000
+#define		GLS_ATEST_BITS						0x70000000
+
+#define GLS_DEFAULT			GLS_DEPTHMASK_TRUE
+
+void	RE_StretchRaw (int x, int y, int w, int h, int cols, int rows, const byte *data, int client, qboolean dirty);
+void	RE_UploadCinematic (int w, int h, int cols, int rows, const byte *data, int client, qboolean dirty);
+
+void		RE_BeginFrame( stereoFrame_t stereoFrame );
+void		RE_BeginRegistration( glconfig_t *glconfig );
+void		RE_LoadWorldMap( const char *mapname );
+void		RE_SetWorldVisData( const byte *vis );
+qhandle_t	RE_RegisterModel( const char *name );
+qhandle_t	RE_RegisterSkin( const char *name );
+void		RE_Shutdown( qboolean destroyWindow );
+
+qboolean	R_GetEntityToken( char *buffer, int size );
+
+model_t		*R_AllocModel( void );
+
+void    	R_Init( void );
+image_t		*R_FindImageFile( const char *name, qboolean mipmap, qboolean allowPicmip, int glWrapClampMode );
+
+image_t		*R_CreateImage( const char *name, const byte *pic, int width, int height, qboolean mipmap,
+            qboolean allowPicmip, int wrapClampMode );
+
+void		R_SetColorMappings( void );
+void		R_GammaCorrect( byte *buffer, int bufSize );
+
+void	R_ImageList_f( void );
+void	R_SkinList_f( void );
+// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=516
+const void *RB_TakeScreenshotCmd( const void *data );
+void	R_ScreenShot_f( void );
+
+void	R_InitFogTable( void );
+float	R_FogFactor( float s, float t );
+void	R_InitImages( void );
+void	R_DeleteTextures( void );
+int		R_SumOfUsedImages( void );
+void	R_InitSkins( void );
+skin_t	*R_GetSkinByHandle( qhandle_t hSkin );
+
+int R_ComputeLOD( trRefEntity_t *ent );
+
+const void *RB_TakeVideoFrameCmd( const void *data );
+
+//
+// tr_shader.c
+//
+qhandle_t		 RE_RegisterShaderLightMap( const char *name, int lightmapIndex );
+qhandle_t		 RE_RegisterShader( const char *name );
+qhandle_t		 RE_RegisterShaderNoMip( const char *name );
+qhandle_t RE_RegisterShaderFromImage(const char *name, int lightmapIndex, image_t *image, qboolean mipRawImage);
+
+shader_t	*R_FindShader( const char *name, int lightmapIndex, qboolean mipRawImage );
+shader_t	*R_GetShaderByHandle( qhandle_t hShader );
+shader_t	*R_GetShaderByState( int index, long *cycleTime );
+shader_t *R_FindShaderByName( const char *name );
+void		R_InitShaders( void );
+void		R_ShaderList_f( void );
+void    R_RemapShader(const char *oldShader, const char *newShader, const char *timeOffset);
+
+/*
+====================================================================
+
+IMPLEMENTATION SPECIFIC FUNCTIONS
+
+====================================================================
+*/
+
+void		GLimp_Init( void );
+void		GLimp_Shutdown( void );
+void		GLimp_EndFrame( void );
+
+qboolean	GLimp_SpawnRenderThread( void (*function)( void ) );
+void		*GLimp_RendererSleep( void );
+void		GLimp_FrontEndSleep( void );
+void		GLimp_WakeRenderer( void *data );
+
+void		GLimp_LogComment( char *comment );
+
+// NOTE TTimo linux works with float gamma value, not the gamma table
+//   the params won't be used, getting the r_gamma cvar directly
+void		GLimp_SetGamma( unsigned char red[256], 
+						    unsigned char green[256],
+							unsigned char blue[256] );
+
+void		GL_ResolveHardwareType( void );
+
+/*
+====================================================================
+
+TESSELATOR/SHADER DECLARATIONS
+
+====================================================================
+*/
+typedef byte color4ub_t[4];
+
+typedef struct stageVars
+{
+	color4ub_t	colors[SHADER_MAX_VERTEXES];
+	vec2_t		texcoords[NUM_TEXTURE_BUNDLES][SHADER_MAX_VERTEXES];
+} stageVars_t;
+
+
+typedef struct shaderCommands_s 
+{
+	glIndex_t	indexes[SHADER_MAX_INDEXES] QALIGN(16);
+	vec4_t		xyz[SHADER_MAX_VERTEXES] QALIGN(16);
+	vec4_t		normal[SHADER_MAX_VERTEXES] QALIGN(16);
+	vec2_t		texCoords[SHADER_MAX_VERTEXES][2] QALIGN(16);
+	color4ub_t	vertexColors[SHADER_MAX_VERTEXES] QALIGN(16);
+	int			vertexDlightBits[SHADER_MAX_VERTEXES] QALIGN(16);
+
+	stageVars_t	svars QALIGN(16);
+
+	color4ub_t	constantColor255[SHADER_MAX_VERTEXES] QALIGN(16);
+
+	shader_t	*shader;
+	float		shaderTime;
+	int			fogNum;
+
+	int			dlightBits;	// or together of all vertexDlightBits
+
+	int			numIndexes;
+	int			numVertexes;
+
+	// info extracted from current shader
+	int			numPasses;
+	void		(*currentStageIteratorFunc)( void );
+	shaderStage_t	**xstages;
+} shaderCommands_t;
+
+extern	shaderCommands_t	tess;
+
+void RB_BeginSurface(shader_t *shader, int fogNum );
+void RB_EndSurface(void);
+void RB_CheckOverflow( int verts, int indexes );
+#define RB_CHECKOVERFLOW(v,i) if (tess.numVertexes + (v) >= SHADER_MAX_VERTEXES || tess.numIndexes + (i) >= SHADER_MAX_INDEXES ) {RB_CheckOverflow(v,i);}
+
+void RB_StageIteratorGeneric( void );
+void RB_StageIteratorSky( void );
+void RB_StageIteratorVertexLitTexture( void );
+void RB_StageIteratorLightmappedMultitexture( void );
+
+void RB_AddQuadStamp( vec3_t origin, vec3_t left, vec3_t up, byte *color );
+void RB_AddQuadStampExt( vec3_t origin, vec3_t left, vec3_t up, byte *color, float s1, float t1, float s2, float t2 );
+
+void RB_ShowImages( void );
+
+
+/*
+============================================================
+
+WORLD MAP
+
+============================================================
+*/
+
+void R_AddBrushModelSurfaces( trRefEntity_t *e );
+void R_AddWorldSurfaces( void );
+qboolean R_inPVS( const vec3_t p1, const vec3_t p2 );
+
+
+/*
+============================================================
+
+FLARES
+
+============================================================
+*/
+
+void R_ClearFlares( void );
+
+void RB_AddFlare( void *surface, int fogNum, vec3_t point, vec3_t color, vec3_t normal );
+void RB_AddDlightFlares( void );
+void RB_RenderFlares (void);
+
+/*
+============================================================
+
+LIGHTS
+
+============================================================
+*/
+
+void R_DlightBmodel( bmodel_t *bmodel );
+void R_SetupEntityLighting( const trRefdef_t *refdef, trRefEntity_t *ent );
+void R_TransformDlights( int count, dlight_t *dl, orientationr_t *or );
+int R_LightForPoint( vec3_t point, vec3_t ambientLight, vec3_t directedLight, vec3_t lightDir );
+
+
+/*
+============================================================
+
+SHADOWS
+
+============================================================
+*/
+
+void RB_ShadowTessEnd( void );
+void RB_ShadowFinish( void );
+void RB_ProjectionShadowDeform( void );
+
+/*
+============================================================
+
+SKIES
+
+============================================================
+*/
+
+void R_BuildCloudData( shaderCommands_t *shader );
+void R_InitSkyTexCoords( float cloudLayerHeight );
+void R_DrawSkyBox( shaderCommands_t *shader );
+void RB_DrawSun( void );
+void RB_ClipSkyPolygons( shaderCommands_t *shader );
+
+/*
+============================================================
+
+CURVE TESSELATION
+
+============================================================
+*/
+
+#define PATCH_STITCHING
+
+srfGridMesh_t *R_SubdividePatchToGrid( int width, int height,
+								drawVert_t points[MAX_PATCH_SIZE*MAX_PATCH_SIZE] );
+srfGridMesh_t *R_GridInsertColumn( srfGridMesh_t *grid, int column, int row, vec3_t point, float loderror );
+srfGridMesh_t *R_GridInsertRow( srfGridMesh_t *grid, int row, int column, vec3_t point, float loderror );
+void R_FreeSurfaceGridMesh( srfGridMesh_t *grid );
+
+/*
+============================================================
+
+MARKERS, POLYGON PROJECTION ON WORLD POLYGONS
+
+============================================================
+*/
+
+int R_MarkFragments( int numPoints, const vec3_t *points, const vec3_t projection,
+				   int maxPoints, vec3_t pointBuffer, int maxFragments, markFragment_t *fragmentBuffer );
+
+
+/*
+============================================================
+
+SCENE GENERATION
+
+============================================================
+*/
+
+void R_ToggleSmpFrame( void );
+
+void RE_ClearScene( void );
+void RE_AddRefEntityToScene( const refEntity_t *ent );
+void RE_AddPolyToScene( qhandle_t hShader , int numVerts, const polyVert_t *verts, int num );
+void RE_AddLightToScene( const vec3_t org, float intensity, float r, float g, float b );
+void RE_AddAdditiveLightToScene( const vec3_t org, float intensity, float r, float g, float b );
+void RE_RenderScene( const refdef_t *fd );
+
+#ifdef RAVENMD4
+/*
+=============================================================
+
+UNCOMPRESSING BONES
+
+=============================================================
+*/
+
+#define MC_BITS_X (16)
+#define MC_BITS_Y (16)
+#define MC_BITS_Z (16)
+#define MC_BITS_VECT (16)
+
+#define MC_SCALE_X (1.0f/64)
+#define MC_SCALE_Y (1.0f/64)
+#define MC_SCALE_Z (1.0f/64)
+
+void MC_UnCompress(float mat[3][4],const unsigned char * comp);
+#endif
+
+/*
+=============================================================
+
+ANIMATED MODELS
+
+=============================================================
+*/
+
+// void R_MakeAnimModel( model_t *model );      haven't seen this one really, so not needed I guess.
+void R_AddAnimSurfaces( trRefEntity_t *ent );
+void RB_SurfaceAnim( md4Surface_t *surfType );
+#ifdef RAVENMD4
+void R_MDRAddAnimSurfaces( trRefEntity_t *ent );
+void RB_MDRSurfaceAnim( md4Surface_t *surface );
+#endif
+
+/*
+=============================================================
+
+IMAGE LOADERS
+
+=============================================================
+*/
+
+void R_LoadBMP( const char *name, byte **pic, int *width, int *height );
+void R_LoadJPG( const char *name, byte **pic, int *width, int *height );
+void R_LoadPCX( const char *name, byte **pic, int *width, int *height );
+void R_LoadPNG( const char *name, byte **pic, int *width, int *height );
+void R_LoadTGA( const char *name, byte **pic, int *width, int *height );
+
+/*
+=============================================================
+=============================================================
+*/
+void	R_TransformModelToClip( const vec3_t src, const float *modelMatrix, const float *projectionMatrix,
+							vec4_t eye, vec4_t dst );
+void	R_TransformClipToWindow( const vec4_t clip, const viewParms_t *view, vec4_t normalized, vec4_t window );
+
+void	RB_DeformTessGeometry( void );
+
+void	RB_CalcEnvironmentTexCoords( float *dstTexCoords );
+void	RB_CalcFogTexCoords( float *dstTexCoords );
+void	RB_CalcScrollTexCoords( const float scroll[2], float *dstTexCoords );
+void	RB_CalcRotateTexCoords( float rotSpeed, float *dstTexCoords );
+void	RB_CalcScaleTexCoords( const float scale[2], float *dstTexCoords );
+void	RB_CalcTurbulentTexCoords( const waveForm_t *wf, float *dstTexCoords );
+void	RB_CalcTransformTexCoords( const texModInfo_t *tmi, float *dstTexCoords );
+void	RB_CalcModulateColorsByFog( unsigned char *dstColors );
+void	RB_CalcModulateAlphasByFog( unsigned char *dstColors );
+void	RB_CalcModulateRGBAsByFog( unsigned char *dstColors );
+void	RB_CalcWaveAlpha( const waveForm_t *wf, unsigned char *dstColors );
+void	RB_CalcWaveColor( const waveForm_t *wf, unsigned char *dstColors );
+void	RB_CalcAlphaFromEntity( unsigned char *dstColors );
+void	RB_CalcAlphaFromOneMinusEntity( unsigned char *dstColors );
+void	RB_CalcStretchTexCoords( const waveForm_t *wf, float *texCoords );
+void	RB_CalcColorFromEntity( unsigned char *dstColors );
+void	RB_CalcColorFromOneMinusEntity( unsigned char *dstColors );
+void	RB_CalcSpecularAlpha( unsigned char *alphas );
+void	RB_CalcDiffuseColor( unsigned char *colors );
+
+/*
+=============================================================
+
+RENDERER BACK END FUNCTIONS
+
+=============================================================
+*/
+
+void RB_RenderThread( void );
+void RB_ExecuteRenderCommands( const void *data );
+
+/*
+=============================================================
+
+RENDERER BACK END COMMAND QUEUE
+
+=============================================================
+*/
+
+#define	MAX_RENDER_COMMANDS	0x40000
+
+typedef struct {
+	byte	cmds[MAX_RENDER_COMMANDS];
+	int		used;
+} renderCommandList_t;
+
+typedef struct {
+	int		commandId;
+	float	color[4];
+} setColorCommand_t;
+
+typedef struct {
+	int		commandId;
+	int		buffer;
+} drawBufferCommand_t;
+
+typedef struct {
+	int		commandId;
+	image_t	*image;
+	int		width;
+	int		height;
+	void	*data;
+} subImageCommand_t;
+
+typedef struct {
+	int		commandId;
+} swapBuffersCommand_t;
+
+typedef struct {
+	int		commandId;
+	int		buffer;
+} endFrameCommand_t;
+
+typedef struct {
+	int		commandId;
+	shader_t	*shader;
+	float	x, y;
+	float	w, h;
+	float	s1, t1;
+	float	s2, t2;
+} stretchPicCommand_t;
+
+typedef struct {
+	int		commandId;
+	trRefdef_t	refdef;
+	viewParms_t	viewParms;
+	drawSurf_t *drawSurfs;
+	int		numDrawSurfs;
+} drawSurfsCommand_t;
+
+typedef struct {
+	int commandId;
+	int x;
+	int y;
+	int width;
+	int height;
+	char *fileName;
+	qboolean jpeg;
+} screenshotCommand_t;
+
+typedef struct {
+	int						commandId;
+	int						width;
+	int						height;
+	byte					*captureBuffer;
+	byte					*encodeBuffer;
+	qboolean			motionJpeg;
+} videoFrameCommand_t;
+
+typedef struct
+{
+	int commandId;
+
+	GLboolean rgba[4];
+} colorMaskCommand_t;
+
+typedef struct
+{
+	int commandId;
+} clearDepthCommand_t;
+
+typedef enum {
+	RC_END_OF_LIST,
+	RC_SET_COLOR,
+	RC_STRETCH_PIC,
+	RC_DRAW_SURFS,
+	RC_DRAW_BUFFER,
+	RC_SWAP_BUFFERS,
+	RC_SCREENSHOT,
+	RC_VIDEOFRAME,
+	RC_COLORMASK,
+	RC_CLEARDEPTH
+} renderCommand_t;
+
+
+// these are sort of arbitrary limits.
+// the limits apply to the sum of all scenes in a frame --
+// the main view, all the 3D icons, etc
+#define	MAX_POLYS		600
+#define	MAX_POLYVERTS	3000
+
+// all of the information needed by the back end must be
+// contained in a backEndData_t.  This entire structure is
+// duplicated so the front and back end can run in parallel
+// on an SMP machine
+typedef struct {
+	drawSurf_t	drawSurfs[MAX_DRAWSURFS];
+	dlight_t	dlights[MAX_DLIGHTS];
+	trRefEntity_t	entities[MAX_ENTITIES];
+	srfPoly_t	*polys;//[MAX_POLYS];
+	polyVert_t	*polyVerts;//[MAX_POLYVERTS];
+	renderCommandList_t	commands;
+} backEndData_t;
+
+extern	int		max_polys;
+extern	int		max_polyverts;
+
+extern	backEndData_t	*backEndData[SMP_FRAMES];	// the second one may not be allocated
+
+extern	volatile renderCommandList_t	*renderCommandList;
+
+extern	volatile qboolean	renderThreadActive;
+
+
+void *R_GetCommandBuffer( int bytes );
+void RB_ExecuteRenderCommands( const void *data );
+
+void R_InitCommandBuffers( void );
+void R_ShutdownCommandBuffers( void );
+
+void R_SyncRenderThread( void );
+
+void R_AddDrawSurfCmd( drawSurf_t *drawSurfs, int numDrawSurfs );
+
+void RE_SetColor( const float *rgba );
+void RE_SetClipRegion( const float *region );
+void RE_StretchPic ( float x, float y, float w, float h, 
+					  float s1, float t1, float s2, float t2, qhandle_t hShader );
+void RE_BeginFrame( stereoFrame_t stereoFrame );
+void RE_EndFrame( int *frontEndMsec, int *backEndMsec );
+void RE_SaveJPG(char * filename, int quality, int image_width, int image_height,
+                unsigned char *image_buffer, int padding);
+size_t RE_SaveJPGToBuffer(byte *buffer, size_t bufSize, int quality,
+		          int image_width, int image_height, byte *image_buffer, int padding);
+void RE_TakeVideoFrame( int width, int height,
+		byte *captureBuffer, byte *encodeBuffer, qboolean motionJpeg );
+
+// font stuff
+void R_InitFreeType( void );
+void R_DoneFreeType( void );
+void RE_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font);
+
+
+#endif //TR_LOCAL_H
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_local.h.rej tremulous-ggp1-src/src/renderer/tr_local.h.rej
--- tremulous-ggp1-src.p/src/renderer/tr_local.h.rej	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_local.h.rej	2012-07-19 04:25:52.021556447 +0200
@@ -0,0 +1,100 @@
+--- src/renderer/tr_local.h	(Revision 2062)
++++ src/renderer/tr_local.h	(Arbeitskopie)
+@@ -955,7 +1130,7 @@
+ extern	refimport_t		ri;
+ 
+ #define	MAX_DRAWIMAGES			2048
+-#define	MAX_LIGHTMAPS			256
++#define	MAX_LIGHTMAPS			512
+ #define	MAX_SKINS				1024
+ 
+ 
+@@ -1170,12 +1429,18 @@
+ 
+ 	shader_t				*defaultShader;
+ 	shader_t				*shadowShader;
++	shader_t				*preparePortalShader;
++	shader_t				*finalisePortalShader;
+ 	shader_t				*projectionShadowShader;
+ 
+ 	shader_t				*flareShader;
+ 	shader_t				*sunShader;
++	shader_t				*fogShader;
++	shader_t				*defaultMD3Shader;
+ 
+ 	int						numLightmaps;
++	qboolean				hasDeluxemaps;
++	float					deluxeOffset;
+ 	image_t					*lightmaps[MAX_LIGHTMAPS];
+ 
+ 	trRefEntity_t			*currentEntity;
+@@ -1624,37 +1963,43 @@
+ 
+ ====================================================================
+ */
+-typedef byte color4ub_t[4];
+ 
+ typedef struct stageVars
+ {
+-	color4ub_t	colors[SHADER_MAX_VERTEXES];
+-	vec2_t		texcoords[NUM_TEXTURE_BUNDLES][SHADER_MAX_VERTEXES];
++	color4ub_t	*colors;
++	vec2_t		*texcoords[NUM_TEXTURE_BUNDLES];
+ } stageVars_t;
+ 
++typedef union indexPtr_u {
++	GLushort	*p16;
++	GLuint		*p32;
++} indexPtr_t;
+ 
+ typedef struct shaderCommands_s 
+ {
+-	glIndex_t	indexes[SHADER_MAX_INDEXES] ALIGN(16);
+-	vec4_t		xyz[SHADER_MAX_VERTEXES] ALIGN(16);
+-	vec4_t		normal[SHADER_MAX_VERTEXES] ALIGN(16);
+-	vec2_t		texCoords[SHADER_MAX_VERTEXES][2] ALIGN(16);
+-	color4ub_t	vertexColors[SHADER_MAX_VERTEXES] ALIGN(16);
+-	int			vertexDlightBits[SHADER_MAX_VERTEXES] ALIGN(16);
++	indexPtr_t	indexPtr;
++	vaWord1_t	*vertexPtr1;
++	vaWord2_t	*vertexPtr2;
++	vaWord3_t	*vertexPtr3;
++	vaWord4_t	*vertexPtr4;
++	size_t		indexInc;
++	int		numIndexes;
++	int		numVertexes;
++	int		minIndex, maxIndex;
++	byte		*vertexBuffer, *vertexBufferEnd;
+ 
+-	stageVars_t	svars ALIGN(16);
++	int		dlightBits;	// or together of all vertexDlightBits
++	stageVars_t	svars;
+ 
+-	color4ub_t	constantColor255[SHADER_MAX_VERTEXES] ALIGN(16);
++	vboInfo_t	*streaming;
++	vboInfo_t	*firstVBO;
++	image_t		*dataTexture;
++	float		frameOffs, oldFrameOffs;
+ 
+ 	shader_t	*shader;
+-  float   shaderTime;
++	float			shaderTime;
+ 	int			fogNum;
+ 
+-	int			dlightBits;	// or together of all vertexDlightBits
+-
+-	int			numIndexes;
+-	int			numVertexes;
+-
+ 	// info extracted from current shader
+ 	int			numPasses;
+ 	void		(*currentStageIteratorFunc)( void );
+@@ -2065,7 +2444,7 @@
+ void RE_StretchPic ( float x, float y, float w, float h, 
+ 					  float s1, float t1, float s2, float t2, qhandle_t hShader );
+ void RE_BeginFrame( stereoFrame_t stereoFrame );
+-void RE_EndFrame( int *frontEndMsec, int *backEndMsec );
++void RE_EndFrame( int *frontEndMsec, int *backEndMsec, int *GLMsec );
+ void SaveJPG(char * filename, int quality, int image_width, int image_height, unsigned char *image_buffer);
+ int SaveJPGToBuffer( byte *buffer, int quality,
+ 		int image_width, int image_height,
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_main.c tremulous-ggp1-src/src/renderer/tr_main.c
--- tremulous-ggp1-src.p/src/renderer/tr_main.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_main.c	2012-07-19 04:25:52.031556446 +0200
@@ -27,6 +27,7 @@
 #include <string.h> // memcpy
 
 trGlobals_t		tr;
+glGlobals_t		glGlobals;
 
 static float	s_flipMatrix[16] = {
 	// convert from our coordinate system (looking down X)
@@ -454,6 +455,7 @@
 void R_SetupFrustum (viewParms_t *dest, float xmin, float xmax, float ymax, float zProj, float stereoSep)
 {
 	vec3_t ofsorigin;
+	vec3_t	corner[4];
 	float oppleg, adjleg, length;
 	int i;
 	
@@ -471,6 +473,13 @@
 
 		VectorScale(dest->or.axis[0], oppleg, dest->frustum[1].normal);
 		VectorMA(dest->frustum[1].normal, -adjleg, dest->or.axis[1], dest->frustum[1].normal);
+		
+		VectorScale(dest->or.axis[0], zProj, corner[0]);
+		VectorCopy(corner[0], corner[2]);
+		VectorMA(corner[0], xmax, dest->or.axis[1], corner[0]);
+		VectorCopy(corner[0], corner[1]);
+		VectorMA(corner[2], xmin, dest->or.axis[1], corner[2]);
+		VectorCopy(corner[2], corner[3]);
 	}
 	else
 	{
@@ -483,10 +492,18 @@
 		VectorScale(dest->or.axis[0], oppleg / length, dest->frustum[0].normal);
 		VectorMA(dest->frustum[0].normal, zProj / length, dest->or.axis[1], dest->frustum[0].normal);
 
+		VectorScale(dest->or.axis[0], zProj, corner[0]);
+		VectorCopy(corner[0], corner[2]);
+		VectorMA(corner[0], oppleg, dest->or.axis[1], corner[0]);
+		VectorCopy(corner[0], corner[1]);
+
 		oppleg = xmin + stereoSep;
 		length = sqrt(oppleg * oppleg + zProj * zProj);
 		VectorScale(dest->or.axis[0], -oppleg / length, dest->frustum[1].normal);
 		VectorMA(dest->frustum[1].normal, -zProj / length, dest->or.axis[1], dest->frustum[1].normal);
+
+		VectorMA(corner[2], oppleg, dest->or.axis[1], corner[2]);
+		VectorCopy(corner[2], corner[3]);
 	}
 
 	length = sqrt(ymax * ymax + zProj * zProj);
@@ -498,12 +515,100 @@
 
 	VectorScale(dest->or.axis[0], oppleg, dest->frustum[3].normal);
 	VectorMA(dest->frustum[3].normal, -adjleg, dest->or.axis[2], dest->frustum[3].normal);
+
+	VectorMA(corner[0], ymax, dest->or.axis[2], corner[0]);
+	VectorMA(corner[1], -ymax, dest->or.axis[2], corner[1]);
+	VectorMA(corner[2], ymax, dest->or.axis[2], corner[2]);
+	VectorMA(corner[3], -ymax, dest->or.axis[2], corner[3]);
 	
 	for (i=0 ; i<4 ; i++) {
 		dest->frustum[i].type = PLANE_NON_AXIAL;
 		dest->frustum[i].dist = DotProduct (ofsorigin, dest->frustum[i].normal);
 		SetPlaneSignbits( &dest->frustum[i] );
 	}
+	
+	if ( r_nocull->integer ) {
+		dest->frustPlanes = 0;
+		dest->frustType = 0;
+	} else if ( qglBindBufferARB && tr.clusters ) {
+		// Find main view direction and try to clip the opposite
+		// side. The distance is not known, it is added in
+		// R_AddWorldSurfaces.
+
+		if ( corner[0][0] >= 0 && corner[1][0] >= 0 &&
+		     corner[2][0] >= 0 && corner[3][0] >= 0 ) {
+			dest->frustum[4].type = PLANE_NON_AXIAL;
+			dest->frustum[4].normal[0] = 1.0f;
+			dest->frustum[4].normal[1] = 0.0f;
+			dest->frustum[4].normal[2] = 0.0f;
+
+			SetPlaneSignbits( &dest->frustum[4] );
+			
+			dest->frustPlanes = 31;
+			dest->frustType = 1;
+		} else if ( corner[0][0] <= 0 && corner[1][0] <= 0 &&
+			    corner[2][0] <= 0 && corner[3][0] <= 0 ) {
+			dest->frustum[4].type = PLANE_NON_AXIAL;
+			dest->frustum[4].normal[0] = -1.0f;
+			dest->frustum[4].normal[1] = 0.0f;
+			dest->frustum[4].normal[2] = 0.0f;
+
+			SetPlaneSignbits( &dest->frustum[4] );
+			
+			dest->frustPlanes = 31;
+			dest->frustType = 2;
+		} else if ( corner[0][1] >= 0 && corner[1][1] >= 0 &&
+			    corner[2][1] >= 0 && corner[3][1] >= 0 ) {
+			dest->frustum[4].type = PLANE_NON_AXIAL;
+			dest->frustum[4].normal[0] = 0.0f;
+			dest->frustum[4].normal[1] = 1.0f;
+			dest->frustum[4].normal[2] = 0.0f;
+
+			SetPlaneSignbits( &dest->frustum[4] );
+			
+			dest->frustPlanes = 31;
+			dest->frustType = 3;
+		} else if ( corner[0][1] <= 0 && corner[1][1] <= 0 &&
+			    corner[2][1] <= 0 && corner[3][1] <= 0 ) {
+			dest->frustum[4].type = PLANE_NON_AXIAL;
+			dest->frustum[4].normal[0] = 0.0f;
+			dest->frustum[4].normal[1] = -1.0f;
+			dest->frustum[4].normal[2] = 0.0f;
+
+			SetPlaneSignbits( &dest->frustum[4] );
+			
+			dest->frustPlanes = 31;
+			dest->frustType = 4;
+		} else if ( corner[0][2] >= 0 && corner[1][2] >= 0 &&
+			    corner[2][2] >= 0 && corner[3][2] >= 0 ) {
+			dest->frustum[4].type = PLANE_NON_AXIAL;
+			dest->frustum[4].normal[0] = 0.0f;
+			dest->frustum[4].normal[1] = 0.0f;
+			dest->frustum[4].normal[2] = 1.0f;
+
+			SetPlaneSignbits( &dest->frustum[4] );
+			
+			dest->frustPlanes = 31;
+			dest->frustType = 5;
+		} else if ( corner[0][2] <= 0 && corner[1][2] <= 0 &&
+			    corner[2][2] <= 0 && corner[3][2] <= 0 ) {
+			dest->frustum[4].type = PLANE_NON_AXIAL;
+			dest->frustum[4].normal[0] = 0.0f;
+			dest->frustum[4].normal[1] = 0.0f;
+			dest->frustum[4].normal[2] = -1.0f;
+
+			SetPlaneSignbits( &dest->frustum[4] );
+			
+			dest->frustPlanes = 31;
+			dest->frustType = 6;
+		} else {
+			dest->frustPlanes = 15;
+			dest->frustType = 0;
+		}
+	} else {
+		dest->frustPlanes = 15;
+		dest->frustType = 0;
+	}
 }
 
 /*
@@ -857,7 +962,8 @@
 	int numTriangles;
 	shader_t *shader;
 	int		fogNum;
-	int dlighted;
+	int		dlighted;
+	qboolean	culled;
 	vec4_t clip, eye;
 	int i;
 	unsigned int pointOr = 0;
@@ -869,18 +975,31 @@
 
 	R_RotateForViewer();
 
-	R_DecomposeSort( drawSurf->sort, &entityNum, &shader, &fogNum, &dlighted );
+	entityNum = QSORT_ENTITYNUM( drawSurf->sort );
+	shader = tr.shaders[ drawSurf->shaderIndex ];
+	fogNum = QSORT_FOGNUM( drawSurf->sort );
+	dlighted = QSORT_DLIGHT( drawSurf->sort );
+	culled = QSORT_CULLED( drawSurf->sort );
+
+	if( culled )
+		return qtrue;	// culled by RecursiveWorldNode
+
 	RB_BeginSurface( shader, fogNum );
+	
+	tess.indexPtr.p16 = NULL;
 	rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
 
 	assert( tess.numVertexes < 128 );
 
+	RB_SetupVertexBuffer( shader, NULL );
+	rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
+
 	for ( i = 0; i < tess.numVertexes; i++ )
 	{
 		int j;
 		unsigned int pointFlags = 0;
 
-		R_TransformModelToClip( tess.xyz[i], tr.or.modelMatrix, tr.viewParms.projectionMatrix, eye, clip );
+		R_TransformModelToClip( tess.vertexPtr2[i].xyz, tr.or.modelMatrix, tr.viewParms.projectionMatrix, eye, clip );
 
 		for ( j = 0; j < 3; j++ )
 		{
@@ -900,6 +1019,7 @@
 	// trivially reject
 	if ( pointAnd )
 	{
+		RB_ClearVertexBuffer( );
 		return qtrue;
 	}
 
@@ -912,11 +1032,11 @@
 
 	for ( i = 0; i < tess.numIndexes; i += 3 )
 	{
-		vec3_t normal;
+		vec3_t normal, vertexNormal;
 		float dot;
 		float len;
 
-		VectorSubtract( tess.xyz[tess.indexes[i]], tr.viewParms.or.origin, normal );
+		VectorSubtract( tess.vertexPtr2[tess.indexPtr.p16[i]].xyz, tr.viewParms.or.origin, normal );
 
 		len = VectorLengthSquared( normal );			// lose the sqrt
 		if ( len < shortest )
@@ -924,11 +1044,13 @@
 			shortest = len;
 		}
 
-		if ( ( dot = DotProduct( normal, tess.normal[tess.indexes[i]] ) ) >= 0 )
+		VectorCopy( tess.vertexPtr3[tess.indexPtr.p16[i]].normal, vertexNormal );
+		if ( ( dot = DotProduct( normal, vertexNormal ) ) >= 0 )
 		{
 			numTriangles--;
 		}
 	}
+	RB_ClearVertexBuffer( );
 	if ( !numTriangles )
 	{
 		return qtrue;
@@ -957,13 +1079,13 @@
 ========================
 */
 qboolean R_MirrorViewBySurface (drawSurf_t *drawSurf, int entityNum) {
-	vec4_t			clipDest[128];
-	viewParms_t		newParms;
-	viewParms_t		oldParms;
+	vec4_t		clipDest[128];
+	viewParms_t	newParms;
+	viewParms_t	oldParms;
 	orientation_t	surface, camera;
 
 	// don't recursively mirror
-	if (tr.viewParms.isPortal) {
+	if ( tr.viewParms.portalLevel >= glGlobals.portalLevels ) {
 		ri.Printf( PRINT_DEVELOPER, "WARNING: recursive mirror/portal found\n" );
 		return qfalse;
 	}
@@ -978,10 +1100,20 @@
 	}
 
 	// save old viewParms so we can return to it after the mirror view
+	tr.viewParms.noShadows = qtrue;
 	oldParms = tr.viewParms;
+	oldParms.isFirst = qfalse;
 
+	tr.currentEntityNum = entityNum;
+	tr.shiftedEntityNum = entityNum << QSORT_ENTITYNUM_SHIFT;
+	R_AddDrawSurf( drawSurf->surface, tr.preparePortalShader, 0, 0, qfalse );
+	R_AddDrawSurfCmd( tr.refdef.drawSurfs + tr.refdef.numDrawSurfs - 1, 1 );
+	
+	tr.viewParms.portalLevel++;
+	
 	newParms = tr.viewParms;
-	newParms.isPortal = qtrue;
+	newParms.isFirst = qfalse;
+	newParms.noShadows = qfalse;
 	if ( !R_GetPortalOrientations( drawSurf, entityNum, &surface, &camera, 
 		newParms.pvsOrigin, &newParms.isMirror ) ) {
 		return qfalse;		// bad portal, no portalentity
@@ -1002,6 +1134,12 @@
 	R_RenderView (&newParms);
 
 	tr.viewParms = oldParms;
+	tr.currentEntityNum = entityNum;
+	tr.shiftedEntityNum = entityNum << QSORT_ENTITYNUM_SHIFT;
+	R_AddDrawSurf( drawSurf->surface, tr.finalisePortalShader, 0, 0, qfalse );
+	R_AddDrawSurfCmd( tr.refdef.drawSurfs + tr.refdef.numDrawSurfs - 1, 1 );
+	
+	tr.viewParms.noShadows = qfalse;
 
 	return qtrue;
 }
@@ -1049,53 +1187,25 @@
 
 /*
 ===============
-R_Radix
+R_SortSurfaces
+
+Sort the drawSurfs by shader, surface, entity etc.
 ===============
 */
-static ID_INLINE void R_Radix( int byte, int size, drawSurf_t *source, drawSurf_t *dest )
+static int cmpSurfaces( const void *aa, const void *bb )
 {
-  int           count[ 256 ] = { 0 };
-  int           index[ 256 ];
-  int           i;
-  unsigned char *sortKey = NULL;
-  unsigned char *end = NULL;
-
-  sortKey = ( (unsigned char *)&source[ 0 ].sort ) + byte;
-  end = sortKey + ( size * sizeof( drawSurf_t ) );
-  for( ; sortKey < end; sortKey += sizeof( drawSurf_t ) )
-    ++count[ *sortKey ];
-
-  index[ 0 ] = 0;
-
-  for( i = 1; i < 256; ++i )
-    index[ i ] = index[ i - 1 ] + count[ i - 1 ];
-
-  sortKey = ( (unsigned char *)&source[ 0 ].sort ) + byte;
-  for( i = 0; i < size; ++i, sortKey += sizeof( drawSurf_t ) )
-    dest[ index[ *sortKey ]++ ] = source[ i ];
+  const drawSurf_t *a = aa;
+  const drawSurf_t *b = bb;
+  int diff;
+
+  diff = a->sort - b->sort;
+  if( !diff )
+    diff = (intptr_t)a->surface - (intptr_t)b->surface;
+  return diff;
 }
-
-/*
-===============
-R_RadixSort
-
-Radix sort with 4 byte size buckets
-===============
-*/
-static void R_RadixSort( drawSurf_t *source, int size )
+static void R_SortSurfaces( drawSurf_t *source, int size )
 {
-  static drawSurf_t scratch[ MAX_DRAWSURFS ];
-#ifdef Q3_LITTLE_ENDIAN
-  R_Radix( 0, size, source, scratch );
-  R_Radix( 1, size, scratch, source );
-  R_Radix( 2, size, source, scratch );
-  R_Radix( 3, size, scratch, source );
-#else
-  R_Radix( 3, size, source, scratch );
-  R_Radix( 2, size, scratch, source );
-  R_Radix( 1, size, source, scratch );
-  R_Radix( 0, size, scratch, source );
-#endif //Q3_LITTLE_ENDIAN
+  qsort( source, size, sizeof(drawSurf_t), cmpSurfaces );
 }
 
 //==========================================================================================
@@ -1106,7 +1216,7 @@
 =================
 */
 void R_AddDrawSurf( surfaceType_t *surface, shader_t *shader, 
-				   int fogIndex, int dlightMap ) {
+		    int fogIndex, int dlightMap, qboolean culled ) {
 	int			index;
 
 	// instead of checking for overflow, we just mask the index
@@ -1115,35 +1225,22 @@
 	// the sort data is packed into a single 32 bit value so it can be
 	// compared quickly during the qsorting process
 	tr.refdef.drawSurfs[index].sort = (shader->sortedIndex << QSORT_SHADERNUM_SHIFT) 
-		| tr.shiftedEntityNum | ( fogIndex << QSORT_FOGNUM_SHIFT ) | (int)dlightMap;
+		| tr.shiftedEntityNum | ( fogIndex << QSORT_FOGNUM_SHIFT )
+		| (dlightMap << QSORT_DLIGHT_SHIFT) | (culled ? 1 : 0);
+	tr.refdef.drawSurfs[index].shaderIndex = shader->index;
 	tr.refdef.drawSurfs[index].surface = surface;
 	tr.refdef.numDrawSurfs++;
 }
 
 /*
 =================
-R_DecomposeSort
-=================
-*/
-void R_DecomposeSort( unsigned sort, int *entityNum, shader_t **shader, 
-					 int *fogNum, int *dlightMap ) {
-	*fogNum = ( sort >> QSORT_FOGNUM_SHIFT ) & 31;
-	*shader = tr.sortedShaders[ ( sort >> QSORT_SHADERNUM_SHIFT ) & (MAX_SHADERS-1) ];
-	*entityNum = ( sort >> QSORT_ENTITYNUM_SHIFT ) & 1023;
-	*dlightMap = sort & 3;
-}
-
-/*
-=================
 R_SortDrawSurfs
 =================
 */
 void R_SortDrawSurfs( drawSurf_t *drawSurfs, int numDrawSurfs ) {
 	shader_t		*shader;
-	int				fogNum;
-	int				entityNum;
-	int				dlighted;
-	int				i;
+	int			entityNum;
+	int			i;
 
 	// it is possible for some views to not have any surfaces
 	if ( numDrawSurfs < 1 ) {
@@ -1160,12 +1257,12 @@
 	}
 
 	// sort the drawsurfs by sort type, then orientation, then shader
-	R_RadixSort( drawSurfs, numDrawSurfs );
+	R_SortSurfaces( drawSurfs, numDrawSurfs );
 
 	// check for any pass through drawing, which
 	// may cause another view to be rendered first
 	for ( i = 0 ; i < numDrawSurfs ; i++ ) {
-		R_DecomposeSort( (drawSurfs+i)->sort, &entityNum, &shader, &fogNum, &dlighted );
+		shader = tr.shaders[ (drawSurfs+i)->shaderIndex ];
 
 		if ( shader->sort > SS_PORTAL ) {
 			break;
@@ -1176,15 +1273,17 @@
 			ri.Error (ERR_DROP, "Shader '%s'with sort == SS_BAD", shader->name );
 		}
 
+		entityNum = QSORT_ENTITYNUM( (drawSurfs+i)->sort );
+
 		// if the mirror was completely clipped away, we may need to check another surface
 		if ( R_MirrorViewBySurface( (drawSurfs+i), entityNum) ) {
-			// this is a debug option to see exactly what is being mirrored
-			if ( r_portalOnly->integer ) {
-				return;
-			}
-			break;		// only one mirror view at a time
+			//break;		// only one mirror view at a time
 		}
 	}
+	// this is a debug option to see exactly what is being mirrored
+	if ( r_portalOnly->integer && !tr.viewParms.portalLevel ) {
+		return;
+	}
 
 	R_AddDrawSurfCmd( drawSurfs, numDrawSurfs );
 }
@@ -1217,7 +1316,7 @@
 		// we don't want the hacked weapon position showing in 
 		// mirrors, because the true body position will already be drawn
 		//
-		if ( (ent->e.renderfx & RF_FIRST_PERSON) && tr.viewParms.isPortal) {
+		if ( (ent->e.renderfx & RF_FIRST_PERSON) && tr.viewParms.portalLevel ) {
 			continue;
 		}
 
@@ -1233,11 +1332,11 @@
 			// self blood sprites, talk balloons, etc should not be drawn in the primary
 			// view.  We can't just do this check for all entities, because md3
 			// entities may still want to cast shadows from them
-			if ( (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.isPortal) {
+			if ( (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.portalLevel ) {
 				continue;
 			}
 			shader = R_GetShaderByHandle( ent->e.customShader );
-			R_AddDrawSurf( &entitySurface, shader, R_SpriteFogNum( ent ), 0 );
+			R_AddDrawSurf( &entitySurface, shader, R_SpriteFogNum( ent ), 0, qfalse );
 			break;
 
 		case RT_MODEL:
@@ -1246,7 +1345,7 @@
 
 			tr.currentModel = R_GetModelByHandle( ent->e.hModel );
 			if (!tr.currentModel) {
-				R_AddDrawSurf( &entitySurface, tr.defaultShader, 0, 0 );
+				R_AddDrawSurf( &entitySurface, tr.defaultShader, 0, 0, qfalse );
 			} else {
 				switch ( tr.currentModel->type ) {
 				case MOD_MESH:
@@ -1260,15 +1359,18 @@
 					R_MDRAddAnimSurfaces( ent );
 					break;
 #endif
+				case MOD_IQM:
+					R_AddIQMSurfaces( ent );
+					break;
 				case MOD_BRUSH:
 					R_AddBrushModelSurfaces( ent );
 					break;
 				case MOD_BAD:		// null model axis
-					if ( (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.isPortal) {
+					if ( (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.portalLevel ) {
 						break;
 					}
 					shader = R_GetShaderByHandle( ent->e.customShader );
-					R_AddDrawSurf( &entitySurface, tr.defaultShader, 0, 0 );
+					R_AddDrawSurf( &entitySurface, tr.defaultShader, 0, 0, qfalse );
 					break;
 				default:
 					ri.Error( ERR_DROP, "R_AddEntitySurfaces: Bad modeltype" );
@@ -1315,29 +1417,29 @@
 ================
 */
 void R_DebugPolygon( int color, int numPoints, float *points ) {
-	int		i;
+	glRenderState_t	state;
 
-	GL_State( GLS_DEPTHMASK_TRUE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE );
+	InitState( &state );
 
 	// draw solid shade
-
-	qglColor3f( color&1, (color>>1)&1, (color>>2)&1 );
-	qglBegin( GL_POLYGON );
-	for ( i = 0 ; i < numPoints ; i++ ) {
-		qglVertex3fv( points + i * 3 );
-	}
-	qglEnd();
+	state.stateBits = GLS_DEPTHMASK_TRUE |
+		GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE;
+	state.faceCulling = CT_FRONT_SIDED;
+
+	state.numImages = 1;
+	state.image[0] = tr.whiteImage;
+
+	SetAttrVec4f( &state, AL_COLOR, color&1, (color>>1)&1,
+		      (color>>2)&1, 1.0f );
+	SetAttrPointer( &state, AL_VERTEX, 0, 3, GL_FLOAT, 0, points );
+	GL_DrawArrays( &state, GL_POLYGON, 0, numPoints );
 
 	// draw wireframe outline
-	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE );
-	qglDepthRange( 0, 0 );
-	qglColor3f( 1, 1, 1 );
-	qglBegin( GL_POLYGON );
-	for ( i = 0 ; i < numPoints ; i++ ) {
-		qglVertex3fv( points + i * 3 );
-	}
-	qglEnd();
-	qglDepthRange( 0, 1 );
+	state.stateBits = GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE |
+		GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE |
+		GLS_DEPTHRANGE_0_TO_0;
+	SetAttrVec4f( &state, AL_COLOR, 1.0f, 1.0f, 1.0f, 1.0f );
+	GL_DrawArrays( &state, GL_POLYGON, 0, numPoints );
 }
 
 /*
@@ -1355,8 +1457,6 @@
 	// the render thread can't make callbacks to the main thread
 	R_SyncRenderThread();
 
-	GL_Bind( tr.whiteImage);
-	GL_Cull( CT_FRONT_SIDED );
 	ri.CM_DrawDebugSurface( R_DebugPolygon );
 }
 
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_marks.c tremulous-ggp1-src/src/renderer/tr_marks.c
--- tremulous-ggp1-src.p/src/renderer/tr_marks.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_marks.c	2012-07-19 04:25:52.021556447 +0200
@@ -164,7 +164,7 @@
 			surf->viewCount = tr.viewCount;
 		}
 		// extra check for surfaces to avoid list overflows
-		else if (*(surf->data) == SF_FACE) {
+		else if (surf->type == SF_FACE) {
 			// the face plane should go through the box
 			s = BoxOnPlaneSide( mins, maxs, &(( srfSurfaceFace_t * ) surf->data)->plane );
 			if (s == 1 || s == 2) {
@@ -174,8 +174,7 @@
 				surf->viewCount = tr.viewCount;
 			}
 		}
-		else if (*(surfaceType_t *) (surf->data) != SF_GRID &&
-			 *(surfaceType_t *) (surf->data) != SF_TRIANGLES)
+		else if (surf->type != SF_GRID)
 			surf->viewCount = tr.viewCount;
 		// check the viewCount because the surface may have
 		// already been added if it spans multiple leafs
@@ -266,6 +265,7 @@
 	vec3_t			clipPoints[2][MAX_VERTS_ON_POLY];
 	int				numClipPoints;
 	float			*v;
+	srfSurfaceFace_t *surf;
 	srfGridMesh_t	*cv;
 	drawVert_t		*dv;
 	vec3_t			normal;
@@ -401,8 +401,7 @@
 		}
 		else if (*surfaces[i] == SF_FACE) {
 
-			srfSurfaceFace_t *surf = ( srfSurfaceFace_t * ) surfaces[i];
-
+			surf = ( srfSurfaceFace_t * ) surfaces[i];
 			// check the normal of this face
 			if (DotProduct(surf->plane.normal, projectionDir) > -0.5) {
 				continue;
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_mesh.c tremulous-ggp1-src/src/renderer/tr_mesh.c
--- tremulous-ggp1-src.p/src/renderer/tr_mesh.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_mesh.c	2012-07-19 04:25:52.021556447 +0200
@@ -201,7 +201,7 @@
 		else
 #endif
 		{
-			frame = ( md3Frame_t * ) ( ( ( unsigned char * ) tr.currentModel->md3[0] ) + tr.currentModel->md3[0]->ofsFrames );
+			frame = ( md3Frame_t * ) ( ( ( unsigned char * ) tr.currentModel->modelData.md3.md3[0] ) + tr.currentModel->modelData.md3.md3[0]->ofsFrames );
 
 			frame += ent->e.frame;
 
@@ -298,11 +298,11 @@
 	qboolean		personalModel;
 
 	// don't add third_person objects if not in a portal
-	personalModel = (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.isPortal;
+	personalModel = (ent->e.renderfx & RF_THIRD_PERSON) && !tr.viewParms.portalLevel;
 
 	if ( ent->e.renderfx & RF_WRAP_FRAMES ) {
-		ent->e.frame %= tr.currentModel->md3[0]->numFrames;
-		ent->e.oldframe %= tr.currentModel->md3[0]->numFrames;
+		ent->e.frame %= tr.currentModel->modelData.md3.md3[0]->numFrames;
+		ent->e.oldframe %= tr.currentModel->modelData.md3.md3[0]->numFrames;
 	}
 
 	//
@@ -311,9 +311,9 @@
 	// when the surfaces are rendered, they don't need to be
 	// range checked again.
 	//
-	if ( (ent->e.frame >= tr.currentModel->md3[0]->numFrames) 
+	if ( (ent->e.frame >= tr.currentModel->modelData.md3.md3[0]->numFrames) 
 		|| (ent->e.frame < 0)
-		|| (ent->e.oldframe >= tr.currentModel->md3[0]->numFrames)
+		|| (ent->e.oldframe >= tr.currentModel->modelData.md3.md3[0]->numFrames)
 		|| (ent->e.oldframe < 0) ) {
 			ri.Printf( PRINT_DEVELOPER, "R_AddMD3Surfaces: no such frame %d to %d for '%s'\n",
 				ent->e.oldframe, ent->e.frame,
@@ -327,7 +327,7 @@
 	//
 	lod = R_ComputeLOD( ent );
 
-	header = tr.currentModel->md3[lod];
+	header = tr.currentModel->modelData.md3.md3[lod];
 
 	//
 	// cull the entire model if merged bounding box of both frames
@@ -354,8 +354,8 @@
 	// draw all surfaces
 	//
 	surface = (md3Surface_t *)( (byte *)header + header->ofsSurfaces );
+	
 	for ( i = 0 ; i < header->numSurfaces ; i++ ) {
-
 		if ( ent->e.customShader ) {
 			shader = R_GetShaderByHandle( ent->e.customShader );
 		} else if ( ent->e.customSkin > 0 && ent->e.customSkin < tr.numSkins ) {
@@ -396,7 +396,7 @@
 			&& fogNum == 0
 			&& !(ent->e.renderfx & ( RF_NOSHADOW | RF_DEPTHHACK ) ) 
 			&& shader->sort == SS_OPAQUE ) {
-			R_AddDrawSurf( (void *)surface, tr.shadowShader, 0, qfalse );
+			R_AddDrawSurf( (void *)surface, tr.shadowShader, 0, 0, qfalse );
 		}
 
 		// projection shadows work fine with personal models
@@ -404,16 +404,28 @@
 			&& fogNum == 0
 			&& (ent->e.renderfx & RF_SHADOW_PLANE )
 			&& shader->sort == SS_OPAQUE ) {
-			R_AddDrawSurf( (void *)surface, tr.projectionShadowShader, 0, qfalse );
+			R_AddDrawSurf( (void *)surface, tr.projectionShadowShader, 0, 0, qfalse );
 		}
 
 		// don't add third_person objects if not viewing through a portal
 		if ( !personalModel ) {
-			R_AddDrawSurf( (void *)surface, shader, fogNum, qfalse );
+			if( tr.currentModel->modelData.md3.md3srf[lod] &&
+			    shader->lightmapIndex == LIGHTMAP_MD3 &&
+			    shader->GLSLprogram ) {
+				srfMD3Texture_t *surf = &tr.currentModel->modelData.md3.md3srf[lod][i];
+				if( shader->depthShader ) {
+					R_AddDrawSurf( (void *)surf, shader->depthShader, 0, 0, qfalse );
+				}
+				R_AddDrawSurf( (void *)surf, shader, fogNum, 0, qfalse );
+			} else {
+				if( shader->depthShader ) {
+					R_AddDrawSurf( (void *)surface, shader->depthShader, 0, 0, qfalse );
+				}
+				R_AddDrawSurf( (void *)surface, shader, fogNum, 0, qfalse );
+			}
 		}
 
 		surface = (md3Surface_t *)( (byte *)surface + surface->ofsEnd );
 	}
-
 }
 
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_model.c tremulous-ggp1-src/src/renderer/tr_model.c
--- tremulous-ggp1-src.p/src/renderer/tr_model.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_model.c	2012-07-19 04:25:52.021556447 +0200
@@ -101,7 +101,7 @@
 	}
 
 	if ( strlen( name ) >= MAX_QPATH ) {
-		Com_Printf( "Model name exceeds MAX_QPATH\n" );
+		ri.Printf( PRINT_WARNING, "Model name exceeds MAX_QPATH\n" );
 		return 0;
 	}
 
@@ -180,6 +180,32 @@
 	}
 #endif
 
+	if(!Q_stricmp(fext, "iqm"))
+	{
+		int filesize;
+		
+		filesize = ri.FS_ReadFile(name, (void **) &buf.v);
+		if(!buf.u)
+		{
+			ri.Printf (PRINT_WARNING,"RE_RegisterModel: couldn't load %s\n", name);
+			mod->type = MOD_BAD;
+			return 0;
+		}
+		
+		loaded = R_LoadIQM(mod, buf.u, filesize, name);
+
+		ri.FS_FreeFile (buf.v);
+		
+		if(!loaded)
+		{
+			ri.Printf(PRINT_WARNING,"RE_RegisterModel: couldn't load iqm file %s\n", name);
+			mod->type = MOD_BAD;
+			return 0;
+		}
+		
+		return mod->index;
+	}
+
 	fext = defex;
 
 	for ( lod = MD3_MAX_LODS - 1 ; lod >= 0 ; lod-- ) {
@@ -232,7 +258,7 @@
 		// loaded, in case the user changes r_lodbias on the fly
 		for ( lod-- ; lod >= 0 ; lod-- ) {
 			mod->numLods++;
-			mod->md3[lod] = mod->md3[lod+1];
+			mod->modelData.md3.md3[lod] = mod->modelData.md3.md3[lod+1];
 		}
 
 		return mod->index;
@@ -257,9 +283,9 @@
 =================
 */
 static qboolean R_LoadMD3 (model_t *mod, int lod, void *buffer, const char *mod_name ) {
-	int					i, j;
+	int			i, j, k;
 	md3Header_t			*pinmodel;
-    md3Frame_t			*frame;
+	md3Frame_t			*frame;
 	md3Surface_t		*surf;
 	md3Shader_t			*shader;
 	md3Triangle_t		*tri;
@@ -268,6 +294,8 @@
 	md3Tag_t			*tag;
 	int					version;
 	int					size;
+	int 		numFrames;
+	trRefEntity_t	thisEntity, *oldEntity;
 
 	pinmodel = (md3Header_t *)buffer;
 
@@ -281,72 +309,64 @@
 	mod->type = MOD_MESH;
 	size = LittleLong(pinmodel->ofsEnd);
 	mod->dataSize += size;
-	mod->md3[lod] = ri.Hunk_Alloc( size, h_low );
+	mod->modelData.md3.md3[lod] = ri.Hunk_Alloc( size, h_low );
+	mod->modelData.md3.md3srf[lod] = NULL;
 
-	Com_Memcpy (mod->md3[lod], buffer, LittleLong(pinmodel->ofsEnd) );
+	Com_Memcpy (mod->modelData.md3.md3[lod], buffer, size );
 
-    LL(mod->md3[lod]->ident);
-    LL(mod->md3[lod]->version);
-    LL(mod->md3[lod]->numFrames);
-    LL(mod->md3[lod]->numTags);
-    LL(mod->md3[lod]->numSurfaces);
-    LL(mod->md3[lod]->ofsFrames);
-    LL(mod->md3[lod]->ofsTags);
-    LL(mod->md3[lod]->ofsSurfaces);
-    LL(mod->md3[lod]->ofsEnd);
+	LL(mod->modelData.md3.md3[lod]->ident);
+	LL(mod->modelData.md3.md3[lod]->version);
+	LL(mod->modelData.md3.md3[lod]->numFrames);
+	LL(mod->modelData.md3.md3[lod]->numTags);
+	LL(mod->modelData.md3.md3[lod]->numSurfaces);
+	LL(mod->modelData.md3.md3[lod]->ofsFrames);
+	LL(mod->modelData.md3.md3[lod]->ofsTags);
+	LL(mod->modelData.md3.md3[lod]->ofsSurfaces);
+	LL(mod->modelData.md3.md3[lod]->ofsEnd);
 
-	if ( mod->md3[lod]->numFrames < 1 ) {
+	numFrames = mod->modelData.md3.md3[lod]->numFrames;
+	if ( numFrames < 1 ) {
 		ri.Printf( PRINT_WARNING, "R_LoadMD3: %s has no frames\n", mod_name );
 		return qfalse;
 	}
     
 	// swap all the frames
-    frame = (md3Frame_t *) ( (byte *)mod->md3[lod] + mod->md3[lod]->ofsFrames );
-    for ( i = 0 ; i < mod->md3[lod]->numFrames ; i++, frame++) {
-    	frame->radius = LittleFloat( frame->radius );
-        for ( j = 0 ; j < 3 ; j++ ) {
-            frame->bounds[0][j] = LittleFloat( frame->bounds[0][j] );
-            frame->bounds[1][j] = LittleFloat( frame->bounds[1][j] );
-	    	frame->localOrigin[j] = LittleFloat( frame->localOrigin[j] );
-        }
+	frame = (md3Frame_t *) ( (byte *)mod->modelData.md3.md3[lod] + mod->modelData.md3.md3[lod]->ofsFrames );
+	for ( i = 0 ; i < numFrames ; i++, frame++) {
+		frame->radius = LittleFloat( frame->radius );
+		for ( j = 0 ; j < 3 ; j++ ) {
+			frame->bounds[0][j] = LittleFloat( frame->bounds[0][j] );
+			frame->bounds[1][j] = LittleFloat( frame->bounds[1][j] );
+			frame->localOrigin[j] = LittleFloat( frame->localOrigin[j] );
+		}
 	}
 
 	// swap all the tags
-    tag = (md3Tag_t *) ( (byte *)mod->md3[lod] + mod->md3[lod]->ofsTags );
-    for ( i = 0 ; i < mod->md3[lod]->numTags * mod->md3[lod]->numFrames ; i++, tag++) {
-        for ( j = 0 ; j < 3 ; j++ ) {
+	tag = (md3Tag_t *) ( (byte *)mod->modelData.md3.md3[lod] + mod->modelData.md3.md3[lod]->ofsTags );
+	for ( i = 0 ; i < mod->modelData.md3.md3[lod]->numTags * numFrames ; i++, tag++) {
+		for ( j = 0 ; j < 3 ; j++ ) {
 			tag->origin[j] = LittleFloat( tag->origin[j] );
 			tag->axis[0][j] = LittleFloat( tag->axis[0][j] );
 			tag->axis[1][j] = LittleFloat( tag->axis[1][j] );
 			tag->axis[2][j] = LittleFloat( tag->axis[2][j] );
-        }
+		}
 	}
 
 	// swap all the surfaces
-	surf = (md3Surface_t *) ( (byte *)mod->md3[lod] + mod->md3[lod]->ofsSurfaces );
-	for ( i = 0 ; i < mod->md3[lod]->numSurfaces ; i++) {
+	surf = (md3Surface_t *) ( (byte *)mod->modelData.md3.md3[lod] + mod->modelData.md3.md3[lod]->ofsSurfaces );
+	for ( i = 0 ; i < mod->modelData.md3.md3[lod]->numSurfaces ; i++) {
+		LL(surf->ident);
+		LL(surf->flags);
+		LL(surf->numFrames);
+		LL(surf->numShaders);
+		LL(surf->numTriangles);
+		LL(surf->ofsTriangles);
+		LL(surf->numVerts);
+		LL(surf->ofsShaders);
+		LL(surf->ofsSt);
+		LL(surf->ofsXyzNormals);
+		LL(surf->ofsEnd);
 
-        LL(surf->ident);
-        LL(surf->flags);
-        LL(surf->numFrames);
-        LL(surf->numShaders);
-        LL(surf->numTriangles);
-        LL(surf->ofsTriangles);
-        LL(surf->numVerts);
-        LL(surf->ofsShaders);
-        LL(surf->ofsSt);
-        LL(surf->ofsXyzNormals);
-        LL(surf->ofsEnd);
-		
-		if ( surf->numVerts > SHADER_MAX_VERTEXES ) {
-			ri.Error (ERR_DROP, "R_LoadMD3: %s has more than %i verts on a surface (%i)",
-				mod_name, SHADER_MAX_VERTEXES, surf->numVerts );
-		}
-		if ( surf->numTriangles*3 > SHADER_MAX_INDEXES ) {
-			ri.Error (ERR_DROP, "R_LoadMD3: %s has more than %i triangles on a surface (%i)",
-				mod_name, SHADER_MAX_INDEXES / 3, surf->numTriangles );
-		}
-	
 		// change to surface identifier
 		surf->ident = SF_MD3;
 
@@ -360,19 +380,6 @@
 			surf->name[j-2] = 0;
 		}
 
-        // register the shaders
-        shader = (md3Shader_t *) ( (byte *)surf + surf->ofsShaders );
-        for ( j = 0 ; j < surf->numShaders ; j++, shader++ ) {
-            shader_t	*sh;
-
-            sh = R_FindShader( shader->name, LIGHTMAP_NONE, qtrue );
-			if ( sh->defaultShader ) {
-				shader->shaderIndex = 0;
-			} else {
-				shader->shaderIndex = sh->index;
-			}
-        }
-
 		// swap all the triangles
 		tri = (md3Triangle_t *) ( (byte *)surf + surf->ofsTriangles );
 		for ( j = 0 ; j < surf->numTriangles ; j++, tri++ ) {
@@ -380,30 +387,251 @@
 			LL(tri->indexes[1]);
 			LL(tri->indexes[2]);
 		}
-
+		
 		// swap all the ST
-        st = (md3St_t *) ( (byte *)surf + surf->ofsSt );
-        for ( j = 0 ; j < surf->numVerts ; j++, st++ ) {
-            st->st[0] = LittleFloat( st->st[0] );
-            st->st[1] = LittleFloat( st->st[1] );
-        }
-
+		st = (md3St_t *) ( (byte *)surf + surf->ofsSt );
+		for ( j = 0 ; j < surf->numVerts ; j++, st++ ) {
+			st->st[0] = LittleFloat( st->st[0] );
+			st->st[1] = LittleFloat( st->st[1] );
+		}
+		
 		// swap all the XyzNormals
-        xyz = (md3XyzNormal_t *) ( (byte *)surf + surf->ofsXyzNormals );
-        for ( j = 0 ; j < surf->numVerts * surf->numFrames ; j++, xyz++ ) 
+		xyz = (md3XyzNormal_t *) ( (byte *)surf + surf->ofsXyzNormals );
+		for ( j = 0 ; j < surf->numVerts * surf->numFrames ; j++, xyz++ ) 
 		{
-            xyz->xyz[0] = LittleShort( xyz->xyz[0] );
-            xyz->xyz[1] = LittleShort( xyz->xyz[1] );
-            xyz->xyz[2] = LittleShort( xyz->xyz[2] );
-
-            xyz->normal = LittleShort( xyz->normal );
-        }
-
+			xyz->xyz[0] = LittleShort( xyz->xyz[0] );
+			xyz->xyz[1] = LittleShort( xyz->xyz[1] );
+			xyz->xyz[2] = LittleShort( xyz->xyz[2] );
+			
+			xyz->normal = LittleShort( xyz->normal );
+		}
+		surf = (md3Surface_t *)( (byte *)surf + surf->ofsEnd );
+	}
+	
+	// register shaders and create VBOs
+	surf = (md3Surface_t *) ( (byte *)mod->modelData.md3.md3[lod] + mod->modelData.md3.md3[lod]->ofsSurfaces );
+	for ( i = 0 ; i < mod->modelData.md3.md3[lod]->numSurfaces ; i++) {
+		int shadertype = LIGHTMAP_NONE;
+
+		shader = (md3Shader_t *) ( (byte *)surf + surf->ofsShaders );
+
+		if( qglCreateShader && qglGenBuffersARB && glGlobals.floatTextures ) {
+			if( !mod->modelData.md3.md3srf[lod] )
+				mod->modelData.md3.md3srf[lod] = ri.Hunk_Alloc( mod->modelData.md3.md3[lod]->numSurfaces * sizeof(srfMD3Texture_t), h_low );
+			
+			// the vertex coords and normals for all frames are
+			// put into a texture, and one VBO/IBO is
+			// created for the indexes and texture coords for
+			// the first frame.
+			int frameW = 1;
+			int frameH = 1;
+			int texW = 1;
+			int texH = 1;
+			
+			while( frameW * frameH < surf->numVerts ) {
+				frameH *= 2;
+				if( frameW * frameH >= surf->numVerts )
+					break;
+				frameW *= 2;
+			}
+			while( texW * texH < numFrames ) {
+				texW *= 2;
+				if( texW * texH >= numFrames )
+					break;
+				texH *= 2;
+			}
+
+			mod->modelData.md3.md3srf[lod][i].surfaceType = SF_MD3_TEXTURE;
+			mod->modelData.md3.md3srf[lod][i].framesPerRow = texW;
+			mod->modelData.md3.md3srf[lod][i].scaleX = 1.0f / texW;
+			mod->modelData.md3.md3srf[lod][i].scaleY = 1024.0f / texH;
+			RB_CreateShaderVBO( &mod->modelData.md3.md3srf[lod][i].VBO, VBOKEY_MD3TEX );
+			
+			oldEntity = backEnd.currentEntity;
+			backEnd.currentEntity = &thisEntity;
+			
+			qglGenBuffersARB( 1, &mod->modelData.md3.md3srf[lod][i].VBO->vbo );
+			qglGenBuffersARB( 1, &mod->modelData.md3.md3srf[lod][i].VBO->ibo );
+			
+			GL_VBO( mod->modelData.md3.md3srf[lod][i].VBO->vbo );
+			GL_IBO( mod->modelData.md3.md3srf[lod][i].VBO->ibo );
+			
+			// render first frame
+			thisEntity.e.frame = 0;
+			thisEntity.e.oldframe = 0;
+			thisEntity.e.backlerp = 0.0f;
+			tess.fogNum = 0;
+			
+			RB_ClearVertexBuffer( );
+			(*rb_surfaceTable[SF_MD3])((surfaceType_t *)surf);
+			
+			RB_SetupVertexBuffer( NULL, NULL );
+			
+			(*rb_surfaceTable[SF_MD3])((surfaceType_t *)surf);
+			
+			// build VBO, set 2nd texcoord (normally lightmap)
+			// to position of vertex in the data texture
+			float   scaleX = 1.0f / (frameW * texW);
+			float   scaleY = 1.0f / (frameH * texH);
+			for( j = 0; j < tess.numVertexes; j++ ) {
+				tess.vertexPtr1[j].tc2[0] = (0.5f + (j % frameW)) * scaleX ;
+				tess.vertexPtr1[j].tc2[1] = (0.5f + (j / frameW)) * scaleY ;
+			}
+			
+			qglBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB,
+					  tess.indexInc * tess.numIndexes,
+					  tess.indexPtr.p16,
+					  GL_STATIC_DRAW_ARB );
+			qglBufferDataARB( GL_ARRAY_BUFFER_ARB,
+					  sizeof(vaWord1_t) * tess.numVertexes,
+					  tess.vertexPtr1, GL_STATIC_DRAW_ARB );
+			mod->modelData.md3.md3srf[lod][i].VBO->offs1 = NULL;
+			mod->modelData.md3.md3srf[lod][i].VBO->offs2 = NULL;
+			mod->modelData.md3.md3srf[lod][i].VBO->offs3 = NULL;
+			mod->modelData.md3.md3srf[lod][i].VBO->offs4 = NULL;
+			mod->modelData.md3.md3srf[lod][i].VBO->offsIdx = NULL;
+			
+			mod->modelData.md3.md3srf[lod][i].VBO->numIndexes = tess.numIndexes;
+			mod->modelData.md3.md3srf[lod][i].VBO->minIndex = 0;
+			mod->modelData.md3.md3srf[lod][i].VBO->maxIndex = tess.numVertexes - 1;
+
+			// build (sub-)texture
+			image_t *image = R_CreateImage( surf->name, NULL,
+							frameW * texW, frameH * texH,
+							qfalse, qfalse, GL_REPEAT );
+			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+			qglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+			image->uploadWidth = texW * frameW;
+			image->uploadHeight = texH * frameH;
+			image->internalFormat = GL_RGB32F_ARB;
+			qglTexImage2D( GL_TEXTURE_2D, 0, GL_RGB32F_ARB,
+				       texW * frameW, texH * frameH,
+				       0, GL_RGB, GL_FLOAT, NULL );
+			// a float has 24 significant bits, and we have 4 floats
+			// per texel, so a total 96 bits are available. These
+			// store 3x16 bits for the vertex position and 3x8
+			// bits for the three normal vectors.
+			vec3_t *texData;
+			if( glGlobals.PBO ) {
+				qglBindBufferARB( GL_PIXEL_UNPACK_BUFFER_ARB, glGlobals.PBO );
+				qglBufferDataARB( GL_PIXEL_UNPACK_BUFFER_ARB, frameW * frameH * sizeof(vec3_t), NULL, GL_STREAM_DRAW_ARB );
+				texData = qglMapBufferARB( GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY_ARB );
+			} else {
+				texData = ri.Hunk_AllocateTempMemory(frameW * frameH * sizeof(vec3_t));
+				Com_Memset( texData, 0, frameW * frameH * sizeof(vec3_t) );
+			}
+			for( j = 0; j < tess.numVertexes; j++ ) {
+				vaWord2_t *ptr2 = &tess.vertexPtr2[j];
+				vaWord3_t *ptr3 = &tess.vertexPtr3[j];
+				unsigned short tmpX = (unsigned short)(ptr2->xyz[0] / MD3_XYZ_SCALE + 32768.0f);
+				unsigned short tmpY = (unsigned short)(ptr2->xyz[1] / MD3_XYZ_SCALE + 32768.0f);
+				unsigned short tmpZ = (unsigned short)(ptr2->xyz[2] / MD3_XYZ_SCALE + 32768.0f);
+				unsigned char nrmX = (unsigned char)(ptr3->normal[0] * 127 + 128);
+				unsigned char nrmY = (unsigned char)(ptr3->normal[1] * 127 + 128);
+				unsigned char nrmZ = (unsigned char)(ptr3->normal[2] * 127 + 128);
+				
+				unsigned int int1 = (nrmX << 16) | tmpX;
+				unsigned int int2 = (nrmY << 16) | tmpY;
+				unsigned int int3 = (nrmZ << 16) | tmpZ;
+				
+				texData[j][0] = ((float)int1) * (1.0f / 65536.0f);
+				texData[j][1] = ((float)int2) * (1.0f / 65536.0f);
+				texData[j][2] = ((float)int3) * (1.0f / 65536.0f);
+			}
+			if( glGlobals.PBO ) {
+				qglUnmapBufferARB( GL_PIXEL_UNPACK_BUFFER_ARB );
+				qglTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0,
+						  frameW, frameH,
+						  GL_RGB, GL_FLOAT,
+						  NULL );
+			} else {
+				qglTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0,
+						  frameW, frameH,
+						  GL_RGB, GL_FLOAT,
+						  texData );
+			}
+			RB_ClearVertexBuffer();
+			
+			// render further frames
+			for( k = 1; k < numFrames; k++ ) {
+				thisEntity.e.frame = k;
+				thisEntity.e.oldframe = k;
+				thisEntity.e.backlerp = 0.0f;
+				
+				(*rb_surfaceTable[SF_MD3])((surfaceType_t *)surf);
+				
+				RB_SetupVertexBuffer( NULL, NULL );
+				
+				(*rb_surfaceTable[SF_MD3])((surfaceType_t *)surf);
+				
+				if( glGlobals.PBO ) {
+					qglBufferDataARB( GL_PIXEL_UNPACK_BUFFER_ARB, frameW * frameH * sizeof(vec3_t), NULL, GL_STREAM_DRAW_ARB );
+					texData = qglMapBufferARB( GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY_ARB );
+				}
 
+				for( j = 0; j < tess.numVertexes; j++ ) {
+					vaWord2_t *ptr2 = &tess.vertexPtr2[j];
+					vaWord3_t *ptr3 = &tess.vertexPtr3[j];
+					unsigned short tmpX = (unsigned short)(ptr2->xyz[0] / MD3_XYZ_SCALE + 32768.0f);
+					unsigned short tmpY = (unsigned short)(ptr2->xyz[1] / MD3_XYZ_SCALE + 32768.0f);
+					unsigned short tmpZ = (unsigned short)(ptr2->xyz[2] / MD3_XYZ_SCALE + 32768.0f);
+					unsigned char nrmX = (unsigned char)(ptr3->normal[0] * 127 + 128);
+					unsigned char nrmY = (unsigned char)(ptr3->normal[1] * 127 + 128);
+					unsigned char nrmZ = (unsigned char)(ptr3->normal[2] * 127 + 128);
+
+					unsigned int int1 = (nrmX << 16) | tmpX;
+					unsigned int int2 = (nrmY << 16) | tmpY;
+					unsigned int int3 = (nrmZ << 16) | tmpZ;
+
+					texData[j][0] = ((float)int1) * (1.0f / 65536.0f);
+					texData[j][1] = ((float)int2) * (1.0f / 65536.0f);
+					texData[j][2] = ((float)int3) * (1.0f / 65536.0f);
+				}
+				if( glGlobals.PBO ) {
+					qglUnmapBufferARB( GL_PIXEL_UNPACK_BUFFER_ARB );
+					qglTexSubImage2D( GL_TEXTURE_2D, 0,
+							  (k % texW) * frameW,
+							  (k / texW) * frameH,
+							  frameW, frameH,
+							  GL_RGB, GL_FLOAT,
+							  NULL );
+				} else {
+					qglTexSubImage2D( GL_TEXTURE_2D, 0,
+							  (k % texW) * frameW,
+							  (k / texW) * frameH,
+							  frameW, frameH,
+							  GL_RGB, GL_FLOAT,
+							  texData );
+				}
+				RB_ClearVertexBuffer();
+			}
+			if( glGlobals.PBO ) {
+				qglBindBufferARB( GL_PIXEL_UNPACK_BUFFER_ARB, 0 );
+			} else {
+				ri.Hunk_FreeTempMemory( texData );
+			}
+			
+			mod->modelData.md3.md3srf[lod][i].image = image;
+			shadertype = LIGHTMAP_MD3;
+			backEnd.currentEntity = oldEntity;
+		}
+		
+		// register the shaders
+		for ( j = 0 ; j < surf->numShaders ; j++, shader++ ) {
+			shader_t	*sh;
+			
+			sh = R_FindShader( shader->name, shadertype, qtrue );
+			if ( sh->defaultShader ) {
+				shader->shaderIndex = 0;
+			} else {
+				shader->shaderIndex = sh->index;
+			}
+		}
+		
 		// find the next surface
 		surf = (md3Surface_t *)( (byte *)surf + surf->ofsEnd );
 	}
-    
+
 	return qtrue;
 }
 
@@ -471,7 +699,7 @@
 	}
 
 	mod->dataSize += size;
-	mod->md4 = mdr = ri.Hunk_Alloc( size, h_low );
+	mod->modelData.md4.md4 = mdr = ri.Hunk_Alloc( size, h_low );
 
 	// Copy all the values over from the file and fix endian issues in the process, if necessary.
 	
@@ -612,19 +840,6 @@
 			surf->numTriangles = LittleLong(cursurf->numTriangles);
 			// numBoneReferences and BoneReferences generally seem to be unused
 			
-			// now do the checks that may fail.
-			if ( surf->numVerts > SHADER_MAX_VERTEXES ) 
-			{
-				ri.Printf(PRINT_WARNING, "R_LoadMDR: %s has more than %i verts on a surface (%i)",
-					  mod_name, SHADER_MAX_VERTEXES, surf->numVerts );
-				return qfalse;
-			}
-			if ( surf->numTriangles*3 > SHADER_MAX_INDEXES ) 
-			{
-				ri.Printf(PRINT_WARNING, "R_LoadMDR: %s has more than %i triangles on a surface (%i)",
-					  mod_name, SHADER_MAX_INDEXES / 3, surf->numTriangles );
-				return qfalse;
-			}
 			// lowercase the surface name so skin compares are faster
 			Q_strlwr( surf->name );
 
@@ -780,7 +995,7 @@
 	mod->type = MOD_MD4;
 	size = LittleLong(pinmodel->ofsEnd);
 	mod->dataSize += size;
-	md4 = mod->md4 = ri.Hunk_Alloc( size, h_low );
+	md4 = mod->modelData.md4.md4 = ri.Hunk_Alloc( size, h_low );
 
 	Com_Memcpy(md4, buffer, size);
 
@@ -829,15 +1044,6 @@
 			LL(surf->ofsVerts);
 			LL(surf->ofsEnd);
 			
-			if ( surf->numVerts > SHADER_MAX_VERTEXES ) {
-				ri.Error (ERR_DROP, "R_LoadMD3: %s has more than %i verts on a surface (%i)",
-					mod_name, SHADER_MAX_VERTEXES, surf->numVerts );
-			}
-			if ( surf->numTriangles*3 > SHADER_MAX_INDEXES ) {
-				ri.Error (ERR_DROP, "R_LoadMD3: %s has more than %i triangles on a surface (%i)",
-					mod_name, SHADER_MAX_INDEXES / 3, surf->numTriangles );
-			}
-
 			// change to surface identifier
 			surf->ident = SF_MD4;
 
@@ -902,7 +1108,6 @@
 }
 
 
-
 //=============================================================================
 
 /*
@@ -916,7 +1121,7 @@
 
 	R_SyncRenderThread();
 
-	tr.viewCluster = -1;		// force markleafs to regenerate
+	tr.visCluster = -1;		// force markleafs to regenerate
 	R_ClearFlares();
 	RE_ClearScene();
 
@@ -961,9 +1166,12 @@
 	for ( i = 1 ; i < tr.numModels; i++ ) {
 		mod = tr.models[i];
 		lods = 1;
-		for ( j = 1 ; j < MD3_MAX_LODS ; j++ ) {
-			if ( mod->md3[j] && mod->md3[j] != mod->md3[j-1] ) {
-				lods++;
+		if( mod->type == MOD_MESH ) {
+			for ( j = 1 ; j < MD3_MAX_LODS ; j++ ) {
+				if ( mod->modelData.md3.md3[j] &&
+				     mod->modelData.md3.md3[j] != mod->modelData.md3.md3[j-1] ) {
+					lods++;
+				}
 			}
 		}
 		ri.Printf( PRINT_ALL, "%8i : (%i) %s\n",mod->dataSize, lods, mod->name );
@@ -1068,19 +1276,23 @@
 	model_t		*model;
 
 	model = R_GetModelByHandle( handle );
-	if ( !model->md3[0] )
+	if ( model->type != MOD_MESH )
 	{
 #ifdef RAVENMD4
-		if(model->md4)
+		if( model->type == MOD_MDR || model_>type == MOD_MD4 )
 		{
 			start = &start_space;
 			end = &end_space;
-			R_GetAnimTag((mdrHeader_t *) model->md4, startFrame, tagName, start);
-			R_GetAnimTag((mdrHeader_t *) model->md4, endFrame, tagName, end);
+			R_GetAnimTag((mdrHeader_t *) model->modelData.md4.md4, startFrame, tagName, start);
+			R_GetAnimTag((mdrHeader_t *) model->modelData.md4.md4, endFrame, tagName, end);
 		}
 		else
 #endif
-		{
+		if( model->type == MOD_IQM ) {
+			return R_IQMLerpTag( tag, model->modelData.iqm.iqmData,
+					     startFrame, endFrame,
+					     frac, tagName );
+		} else {
 
 			AxisClear( tag->axis );
 			VectorClear( tag->origin );
@@ -1090,8 +1302,8 @@
 	}
 	else
 	{
-		start = R_GetTag( model->md3[0], startFrame, tagName );
-		end = R_GetTag( model->md3[0], endFrame, tagName );
+		start = R_GetTag( model->modelData.md3.md3[0], startFrame, tagName );
+		end = R_GetTag( model->modelData.md3.md3[0], endFrame, tagName );
 		if ( !start || !end ) {
 			AxisClear( tag->axis );
 			VectorClear( tag->origin );
@@ -1127,19 +1339,19 @@
 
 	model = R_GetModelByHandle( handle );
 
-	if ( model->bmodel ) {
-		VectorCopy( model->bmodel->bounds[0], mins );
-		VectorCopy( model->bmodel->bounds[1], maxs );
+	if ( model->type == MOD_BRUSH ) {
+		VectorCopy( model->modelData.brush.bmodel->bounds[0], mins );
+		VectorCopy( model->modelData.brush.bmodel->bounds[1], maxs );
 		return;
 	}
 
-	if ( !model->md3[0] ) {
+	if ( model->type != MOD_MESH ) {
 		VectorClear( mins );
 		VectorClear( maxs );
 		return;
 	}
 
-	header = model->md3[0];
+	header = model->modelData.md3.md3[0];
 
 	frame = (md3Frame_t *)( (byte *)header + header->ofsFrames );
 
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_public.h tremulous-ggp1-src/src/renderer/tr_public.h
--- tremulous-ggp1-src.p/src/renderer/tr_public.h	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_public.h	2012-07-19 04:25:52.031556446 +0200
@@ -82,7 +82,7 @@
 	void	(*BeginFrame)( stereoFrame_t stereoFrame );
 
 	// if the pointers are not NULL, timing info will be returned
-	void	(*EndFrame)( int *frontEndMsec, int *backEndMsec );
+	void	(*EndFrame)( int *frontEndMsec, int *backEndMsec, int *GLMsec );
 
 
 	int		(*MarkFragments)( int numPoints, const vec3_t *points, const vec3_t projection,
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_scene.c tremulous-ggp1-src/src/renderer/tr_scene.c
--- tremulous-ggp1-src.p/src/renderer/tr_scene.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_scene.c	2012-07-19 04:25:52.031556446 +0200
@@ -106,7 +106,7 @@
 
 	for ( i = 0, poly = tr.refdef.polys; i < tr.refdef.numPolys ; i++, poly++ ) {
 		sh = R_GetShaderByHandle( poly->hShader );
-		R_AddDrawSurf( ( void * )poly, sh, poly->fogIndex, qfalse );
+		R_AddDrawSurf( ( void * )poly, sh, poly->fogIndex, 0, qfalse );
 	}
 }
 
@@ -206,6 +206,8 @@
 =====================
 */
 void RE_AddRefEntityToScene( const refEntity_t *ent ) {
+	trRefEntity_t		*trEnt;
+
 	if ( !tr.registered ) {
 		return;
 	}
@@ -216,7 +218,7 @@
 		static qboolean firstTime = qtrue;
 		if (firstTime) {
 			firstTime = qfalse;
-			Com_DPrintf(S_COLOR_YELLOW "WARNING: RE_AddRefEntityToScene passed a refEntity which has an origin with a NaN component\n");
+			ri.Printf(PRINT_WARNING, "RE_AddRefEntityToScene passed a refEntity which has an origin with a NaN component\n");
 		}
 		return;
 	}
@@ -224,8 +226,9 @@
 		ri.Error( ERR_DROP, "RE_AddRefEntityToScene: bad reType %i", ent->reType );
 	}
 
-	backEndData[tr.smpFrame]->entities[r_numentities].e = *ent;
-	backEndData[tr.smpFrame]->entities[r_numentities].lightingCalculated = qfalse;
+	trEnt = &backEndData[tr.smpFrame]->entities[r_numentities];
+	trEnt->e = *ent;
+	trEnt->lightingCalculated = qfalse;
 
 	r_numentities++;
 }
@@ -393,7 +396,8 @@
 	parms.viewportY = glConfig.vidHeight - ( tr.refdef.y + tr.refdef.height );
 	parms.viewportWidth = tr.refdef.width;
 	parms.viewportHeight = tr.refdef.height;
-	parms.isPortal = qfalse;
+	parms.portalLevel = 0;
+	parms.isFirst = qtrue;
 
 	parms.fovX = tr.refdef.fov_x;
 	parms.fovY = tr.refdef.fov_y;
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_shade.c tremulous-ggp1-src/src/renderer/tr_shade.c
--- tremulous-ggp1-src.p/src/renderer/tr_shade.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_shade.c	2012-07-19 04:25:52.041556450 +0200
@@ -34,171 +34,6 @@
   This file deals with applying shaders to surface data in the tess struct.
 */
 
-/*
-================
-R_ArrayElementDiscrete
-
-This is just for OpenGL conformance testing, it should never be the fastest
-================
-*/
-static void APIENTRY R_ArrayElementDiscrete( GLint index ) {
-	qglColor4ubv( tess.svars.colors[ index ] );
-	if ( glState.currenttmu ) {
-		qglMultiTexCoord2fARB( 0, tess.svars.texcoords[ 0 ][ index ][0], tess.svars.texcoords[ 0 ][ index ][1] );
-		qglMultiTexCoord2fARB( 1, tess.svars.texcoords[ 1 ][ index ][0], tess.svars.texcoords[ 1 ][ index ][1] );
-	} else {
-		qglTexCoord2fv( tess.svars.texcoords[ 0 ][ index ] );
-	}
-	qglVertex3fv( tess.xyz[ index ] );
-}
-
-/*
-===================
-R_DrawStripElements
-
-===================
-*/
-static int		c_vertexes;		// for seeing how long our average strips are
-static int		c_begins;
-static void R_DrawStripElements( int numIndexes, const glIndex_t *indexes, void ( APIENTRY *element )(GLint) ) {
-	int i;
-	int last[3] = { -1, -1, -1 };
-	qboolean even;
-
-	c_begins++;
-
-	if ( numIndexes <= 0 ) {
-		return;
-	}
-
-	qglBegin( GL_TRIANGLE_STRIP );
-
-	// prime the strip
-	element( indexes[0] );
-	element( indexes[1] );
-	element( indexes[2] );
-	c_vertexes += 3;
-
-	last[0] = indexes[0];
-	last[1] = indexes[1];
-	last[2] = indexes[2];
-
-	even = qfalse;
-
-	for ( i = 3; i < numIndexes; i += 3 )
-	{
-		// odd numbered triangle in potential strip
-		if ( !even )
-		{
-			// check previous triangle to see if we're continuing a strip
-			if ( ( indexes[i+0] == last[2] ) && ( indexes[i+1] == last[1] ) )
-			{
-				element( indexes[i+2] );
-				c_vertexes++;
-				assert( indexes[i+2] < tess.numVertexes );
-				even = qtrue;
-			}
-			// otherwise we're done with this strip so finish it and start
-			// a new one
-			else
-			{
-				qglEnd();
-
-				qglBegin( GL_TRIANGLE_STRIP );
-				c_begins++;
-
-				element( indexes[i+0] );
-				element( indexes[i+1] );
-				element( indexes[i+2] );
-
-				c_vertexes += 3;
-
-				even = qfalse;
-			}
-		}
-		else
-		{
-			// check previous triangle to see if we're continuing a strip
-			if ( ( last[2] == indexes[i+1] ) && ( last[0] == indexes[i+0] ) )
-			{
-				element( indexes[i+2] );
-				c_vertexes++;
-
-				even = qfalse;
-			}
-			// otherwise we're done with this strip so finish it and start
-			// a new one
-			else
-			{
-				qglEnd();
-
-				qglBegin( GL_TRIANGLE_STRIP );
-				c_begins++;
-
-				element( indexes[i+0] );
-				element( indexes[i+1] );
-				element( indexes[i+2] );
-				c_vertexes += 3;
-
-				even = qfalse;
-			}
-		}
-
-		// cache the last three vertices
-		last[0] = indexes[i+0];
-		last[1] = indexes[i+1];
-		last[2] = indexes[i+2];
-	}
-
-	qglEnd();
-}
-
-
-
-/*
-==================
-R_DrawElements
-
-Optionally performs our own glDrawElements that looks for strip conditions
-instead of using the single glDrawElements call that may be inefficient
-without compiled vertex arrays.
-==================
-*/
-static void R_DrawElements( int numIndexes, const glIndex_t *indexes ) {
-	int		primitives;
-
-	primitives = r_primitives->integer;
-
-	// default is to use triangles if compiled vertex arrays are present
-	if ( primitives == 0 ) {
-		if ( qglLockArraysEXT ) {
-			primitives = 2;
-		} else {
-			primitives = 1;
-		}
-	}
-
-
-	if ( primitives == 2 ) {
-		qglDrawElements( GL_TRIANGLES, 
-						numIndexes,
-						GL_INDEX_TYPE,
-						indexes );
-		return;
-	}
-
-	if ( primitives == 1 ) {
-		R_DrawStripElements( numIndexes,  indexes, qglArrayElement );
-		return;
-	}
-	
-	if ( primitives == 3 ) {
-		R_DrawStripElements( numIndexes,  indexes, R_ArrayElementDiscrete );
-		return;
-	}
-
-	// anything else will cause no drawing
-}
 
 
 /*
@@ -210,7 +45,6 @@
 */
 
 shaderCommands_t	tess;
-static qboolean	setArraysOnce;
 
 /*
 =================
@@ -218,7 +52,8 @@
 
 =================
 */
-static void R_BindAnimatedImage( textureBundle_t *bundle ) {
+static void R_GetAnimatedImage( textureBundle_t *bundle, qboolean combined,
+				image_t **pImage ) {
 	int		index;
 
 	if ( bundle->isVideoMap ) {
@@ -228,7 +63,12 @@
 	}
 
 	if ( bundle->numImageAnimations <= 1 ) {
-		GL_Bind( bundle->image[0] );
+		*pImage = bundle->image[0];
+		return;
+	}
+
+	if ( combined && bundle->combinedImage ) {
+		*pImage = bundle->combinedImage;
 		return;
 	}
 
@@ -242,7 +82,7 @@
 	}
 	index %= bundle->numImageAnimations;
 
-	GL_Bind( bundle->image[ index ] );
+	*pImage = bundle->image[ index ];
 }
 
 /*
@@ -250,32 +90,31 @@
 DrawTris
 
 Draws triangle outlines for debugging
+This requires that all vertex pointers etc. are still bound from the StageIterator
 ================
 */
-static void DrawTris (shaderCommands_t *input) {
-	GL_Bind( tr.whiteImage );
-	qglColor3f (1,1,1);
-
-	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
-	qglDepthRange( 0, 0 );
-
-	qglDisableClientState (GL_COLOR_ARRAY);
-	qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
-
-	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
-
-	if (qglLockArraysEXT) {
-		qglLockArraysEXT(0, input->numVertexes);
-		GLimp_LogComment( "glLockArraysEXT\n" );
-	}
-
-	R_DrawElements( input->numIndexes, input->indexes );
-
-	if (qglUnlockArraysEXT) {
-		qglUnlockArraysEXT();
-		GLimp_LogComment( "glUnlockArraysEXT\n" );
+static void DrawTris ( glRenderState_t *state,
+		       int numIndexes, GLuint IBO, const void *indexes,
+		       GLuint start, GLuint end, GLuint max,
+		       float r, float g, float b ) {
+	state->stateBits = GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE |
+		GLS_DEPTHRANGE_0_TO_0;
+
+	state->numImages = 1;
+	state->image[0] = tr.whiteImage;
+
+	if ( tess.currentStageIteratorFunc == RB_StageIteratorGLSL ) {
+		shader_t *shader = tr.defaultShader;
+		if( tess.dataTexture ) {
+			shader = tr.defaultMD3Shader;
+			state->numImages = 2;
+			state->image[1] = tess.dataTexture;
+		}
+		state->program = shader->GLSLprogram;
 	}
-	qglDepthRange( 0, 1 );
+	SetAttrVec4f( state, AL_COLOR, r, g, b, 1.0f );
+	
+	GL_DrawElements( state, numIndexes, IBO, indexes, start, end, max );
 }
 
 
@@ -286,24 +125,143 @@
 Draws vertex normals for debugging
 ================
 */
-static void DrawNormals (shaderCommands_t *input) {
+static void DrawNormals ( glRenderState_t *state ) {
 	int		i;
-	vec3_t	temp;
+	vec3_t		*temp;
+	vboInfo_t	*VBO;
 
-	GL_Bind( tr.whiteImage );
-	qglColor3f (1,1,1);
-	qglDepthRange( 0, 0 );	// never occluded
-	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
-
-	qglBegin (GL_LINES);
-	for (i = 0 ; i < input->numVertexes ; i++) {
-		qglVertex3fv (input->xyz[i]);
-		VectorMA (input->xyz[i], 2, input->normal[i], temp);
-		qglVertex3fv (temp);
-	}
-	qglEnd ();
+	if( backEnd.projection2D )
+		return;
+
+	if( backEnd.normalProgram && tess.currentStageIteratorFunc == RB_StageIteratorGLSL ) {
+		for( VBO = tess.firstVBO; VBO; VBO = VBO->next ) {
+			GLuint dataVBO;
+
+			if( VBO->vbo )
+				dataVBO = VBO->vbo;
+			else
+				dataVBO = backEnd.worldVBO.vbo;
+
+			if( backEnd.currentEntity->e.reType != RT_MODEL ) {
+				SetAttrVec4f( state, AL_TRANSX,
+					      1.0f, 0.0f, 0.0f, 0.0f );
+				SetAttrVec4f( state, AL_TRANSY,
+					      0.0f, 1.0f, 0.0f, 0.0f );
+				SetAttrVec4f( state, AL_TRANSZ,
+					      0.0f, 0.0f, 1.0f, 0.0f );
+			} else {
+				SetAttrVec4f( state, AL_TRANSX,
+					      backEnd.currentEntity->e.axis[0][0],
+					      backEnd.currentEntity->e.axis[1][0],
+					      backEnd.currentEntity->e.axis[2][0],
+					      backEnd.currentEntity->e.origin[0] );
+				SetAttrVec4f( state, AL_TRANSY,
+					      backEnd.currentEntity->e.axis[0][1],
+					      backEnd.currentEntity->e.axis[1][1],
+					      backEnd.currentEntity->e.axis[2][1],
+					      backEnd.currentEntity->e.origin[1] );
+				SetAttrVec4f( state, AL_TRANSZ,
+					      backEnd.currentEntity->e.axis[0][2],
+					      backEnd.currentEntity->e.axis[1][2],
+					      backEnd.currentEntity->e.axis[2][2],
+					      backEnd.currentEntity->e.origin[2] );
+			}
+
+			if( !tess.dataTexture ) {
+				state->program = backEnd.normalProgram;
+				SetAttrPointer( state, AL_NORMAL, dataVBO,
+						3, GL_FLOAT, sizeof(vaWord3_t),
+						&VBO->offs3->normal );
+			} else {
+				state->program = backEnd.normalProgramMD3;
+				state->numImages = 1;
+				state->image[0] = tess.dataTexture;
+				SetAttrVec4f( state, AL_TIMES,
+					      tess.shaderTime,
+					      backEnd.currentEntity->e.backlerp,
+					      tess.frameOffs,
+					      tess.oldFrameOffs );
+			}
+			state->stateBits = GLS_POLYMODE_LINE |
+				GLS_DEPTHMASK_TRUE |
+				GLS_DEPTHRANGE_0_TO_0;
+			SetAttrVec4f( state, AL_COLOR, 1.0f, 1.0f, 1.0f, 1.0f );
+
+			SetAttrPointer( state, AL_VERTEX, dataVBO,
+					4, GL_FLOAT, sizeof(vaWord2_t),
+					&VBO->offs2->xyz );
+			GL_DrawArrays( state, GL_POINTS, VBO->minIndex,
+				       VBO->maxIndex - VBO->minIndex + 1 );
+		}
+
+		if( tess.numVertexes > 0 ) {
+			state->program = backEnd.normalProgram;
+			state->numImages = 0;
+			SetAttrVec4f( state, AL_COLOR, 1.0f, 1.0f, 1.0f, 1.0f );
+			state->stateBits = GLS_POLYMODE_LINE |
+				GLS_DEPTHMASK_TRUE |
+				GLS_DEPTHRANGE_0_TO_0;
+
+			if( backEnd.currentEntity->e.reType != RT_MODEL ) {
+				SetAttrVec4f( state, AL_TRANSX,
+					      1.0f, 0.0f, 0.0f, 0.0f );
+				SetAttrVec4f( state, AL_TRANSY,
+					      0.0f, 1.0f, 0.0f, 0.0f );
+				SetAttrVec4f( state, AL_TRANSZ,
+					      0.0f, 0.0f, 1.0f, 0.0f );
+			} else {
+				SetAttrVec4f( state, AL_TRANSX,
+					      backEnd.currentEntity->e.axis[0][0],
+					      backEnd.currentEntity->e.axis[1][0],
+					      backEnd.currentEntity->e.axis[2][0],
+					      backEnd.currentEntity->e.origin[0] );
+				SetAttrVec4f( state, AL_TRANSY,
+					      backEnd.currentEntity->e.axis[0][1],
+					      backEnd.currentEntity->e.axis[1][1],
+					      backEnd.currentEntity->e.axis[2][1],
+					      backEnd.currentEntity->e.origin[1] );
+				SetAttrVec4f( state, AL_TRANSZ,
+					      backEnd.currentEntity->e.axis[0][2],
+					      backEnd.currentEntity->e.axis[1][2],
+					      backEnd.currentEntity->e.axis[2][2],
+					      backEnd.currentEntity->e.origin[2] );
+			}
+
+			SetAttrPointer( state, AL_NORMAL, 0,
+					3, GL_FLOAT, sizeof(vaWord3_t),
+					&tess.vertexPtr3->normal );
+			SetAttrPointer( state, AL_VERTEX, 0,
+					4, GL_FLOAT, sizeof(vaWord2_t),
+					&tess.vertexPtr2->xyz );
+			GL_DrawArrays( state, GL_POINTS, 0, tess.numVertexes );
+		}
+	} else {
+		if( tess.numVertexes > 0 ) {
+			temp = RB_AllocScratch( tess.numVertexes * 2 * sizeof(vec3_t) );
+			state->program = NULL;
+			state->numImages = 0;
+			SetAttrVec4f( state, AL_COLOR, 1.0f, 1.0f, 1.0f, 1.0f );
+			state->stateBits = GLS_POLYMODE_LINE |
+				GLS_DEPTHMASK_TRUE |
+				GLS_DEPTHRANGE_0_TO_0;
+
+			if( tess.currentStageIteratorFunc == RB_StageIteratorGLSL )
+				qglLoadMatrixf( backEnd.or.modelMatrix );
+
+			for (i = 0 ; i < tess.numVertexes ; i++) {
+				VectorCopy( tess.vertexPtr2[i].xyz, temp[2*i] );
+				VectorMA( tess.vertexPtr2[i].xyz, 2, tess.vertexPtr3[i].normal, temp[2*i+1] );
+			}
+			SetAttrPointer( state, AL_VERTEX, 0,
+					3, GL_FLOAT, sizeof(vec3_t),
+					temp );
+			GL_DrawArrays( state, GL_LINES, 0, 2 * tess.numVertexes );
+			RB_FreeScratch( temp );
 
-	qglDepthRange( 0, 1 );
+			if( tess.currentStageIteratorFunc == RB_StageIteratorGLSL )
+				qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
+		}
+	}
 }
 
 /*
@@ -320,7 +278,10 @@
 	shader_t *state = (shader->remappedShader) ? shader->remappedShader : shader;
 
 	tess.numIndexes = 0;
+	tess.minIndex = backEnd.worldVBO.maxIndex;
+	tess.maxIndex = 0;
 	tess.numVertexes = 0;
+	tess.firstVBO = NULL;
 	tess.shader = state;
 	tess.fogNum = fogNum;
 	tess.dlightBits = 0;		// will be OR'd in by surface functions
@@ -346,52 +307,48 @@
 t1 = most downstream according to spec
 ===================
 */
-static void DrawMultitextured( shaderCommands_t *input, int stage ) {
+static void DrawMultitextured( glRenderState_t *state,
+			       shaderCommands_t *input,
+			       int stage, GLuint max ) {
 	shaderStage_t	*pStage;
+	int		bundle;
 
 	pStage = tess.xstages[stage];
 
-	GL_State( pStage->stateBits );
+	state->program = NULL;
+	state->stateBits = pStage->stateBits;
 
 	// this is an ugly hack to work around a GeForce driver
 	// bug with multitexture and clip planes
-	if ( backEnd.viewParms.isPortal ) {
+	if ( backEnd.viewParms.portalLevel ) {
 		qglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
 	}
 
 	//
 	// base
 	//
-	GL_SelectTexture( 0 );
-	qglTexCoordPointer( 2, GL_FLOAT, 0, input->svars.texcoords[0] );
-	R_BindAnimatedImage( &pStage->bundle[0] );
+	state->numImages = 1;
+	R_GetAnimatedImage( &pStage->bundle[0], qfalse, &state->image[0] );
 
 	//
-	// lightmap/secondary pass
+	// lightmap/secondary passes
 	//
-	GL_SelectTexture( 1 );
-	qglEnable( GL_TEXTURE_2D );
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+	for ( bundle = 1; bundle < glConfig.numTextureUnits; bundle++ ) {
+		if ( !pStage->bundle[bundle].multitextureEnv )
+			break;
+		
+		if ( r_lightmap->integer ) {
+			GL_TexEnv( bundle, GL_REPLACE );
+		} else {
+			GL_TexEnv( bundle, pStage->bundle[bundle].multitextureEnv );
+		}
 
-	if ( r_lightmap->integer ) {
-		GL_TexEnv( GL_REPLACE );
-	} else {
-		GL_TexEnv( tess.shader->multitextureEnv );
+		R_GetAnimatedImage( &pStage->bundle[bundle], qfalse, &state->image[bundle] );
 	}
 
-	qglTexCoordPointer( 2, GL_FLOAT, 0, input->svars.texcoords[1] );
-
-	R_BindAnimatedImage( &pStage->bundle[1] );
-
-	R_DrawElements( input->numIndexes, input->indexes );
-
-	//
-	// disable texturing on TEXTURE1, then select TEXTURE0
-	//
-	//qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
-	qglDisable( GL_TEXTURE_2D );
-
-	GL_SelectTexture( 0 );
+	state->numImages = bundle;
+	GL_DrawElements( state, input->numIndexes, 0, input->indexPtr.p16,
+			 input->minIndex, input->maxIndex, max );
 }
 
 
@@ -404,7 +361,7 @@
 ===================
 */
 #if idppc_altivec
-static void ProjectDlightTexture_altivec( void ) {
+static void ProjectDlightTexture_altivec( glRenderState_t *state ) {
 	int		i, l;
 	vec_t	origin0, origin1, origin2;
 	float   texCoords0, texCoords1;
@@ -417,22 +374,28 @@
                                                0x00, 0x00, 0x00, 0xff,
                                                0x00, 0x00, 0x00, 0xff,
                                                0x00, 0x00, 0x00, 0xff);
-	float	*texCoords;
-	byte	*colors;
-	byte	clipBits[SHADER_MAX_VERTEXES];
-	float	texCoordsArray[SHADER_MAX_VERTEXES][2];
-	byte	colorArray[SHADER_MAX_VERTEXES][4];
-	unsigned	hitIndexes[SHADER_MAX_INDEXES];
+	vec2_t	*texCoords;
+	color4ub_t	*colors;
+	byte	*clipBits;
+	vec2_t	*texCoordsArray;
+	color4ub_t	*colorArray;
+	GLushort	*hitIndexes;
 	int		numIndexes;
 	float	scale;
 	float	radius;
 	vec3_t	floatColor;
 	float	modulate = 0.0f;
 
-	if ( !backEnd.refdef.num_dlights ) {
+	if ( !backEnd.refdef.num_dlights ||
+	     tess.numVertexes > 65535 ) { // to avoid GLushort overflow
 		return;
 	}
 
+	clipBits = RB_AllocScratch( sizeof(byte) * tess.numVertexes );
+	texCoordsArray = RB_AllocScratch( sizeof(vec2_t) * tess.numVertexes );
+	colorArray = RB_AllocScratch( sizeof(color4ub_t) * tess.numVertexes );
+	hitIndexes = RB_AllocScratch( sizeof(GLushort) * tess.numIndexes );
+
 	// There has to be a better way to do this so that floatColor
 	// and/or modulate are already 16-byte aligned.
 	floatColorVecPerm = vec_lvsl(0,(float *)floatColor);
@@ -446,8 +409,8 @@
 		if ( !( tess.dlightBits & ( 1 << l ) ) ) {
 			continue;	// this surface definately doesn't have any of this light
 		}
-		texCoords = texCoordsArray[0];
-		colors = colorArray[0];
+		texCoords = texCoordsArray;
+		colors = colorArray;
 
 		dl = &backEnd.refdef.dlights[l];
 		origin0 = dl->transformed[0];
@@ -481,13 +444,13 @@
 		floatColorVec0 = vec_ld(0, floatColor);
 		floatColorVec1 = vec_ld(11, floatColor);
 		floatColorVec0 = vec_perm(floatColorVec0,floatColorVec0,floatColorVecPerm);
-		for ( i = 0 ; i < tess.numVertexes ; i++, texCoords += 2, colors += 4 ) {
+		for ( i = 0 ; i < tess.numVertexes ; i++, texCoords++, colors++ ) {
 			int		clip = 0;
 			vec_t dist0, dist1, dist2;
 			
-			dist0 = origin0 - tess.xyz[i][0];
-			dist1 = origin1 - tess.xyz[i][1];
-			dist2 = origin2 - tess.xyz[i][2];
+			dist0 = origin0 - tess.vertexPtr2[i].xyz[0];
+			dist1 = origin1 - tess.vertexPtr2[i].xyz[1];
+			dist2 = origin2 - tess.vertexPtr2[i].xyz[2];
 
 			backEnd.pc.c_dlightVertexes++;
 
@@ -495,10 +458,10 @@
 			texCoords1 = 0.5f + dist1 * scale;
 
 			if( !r_dlightBacks->integer &&
-					// dist . tess.normal[i]
-					( dist0 * tess.normal[i][0] +
-					dist1 * tess.normal[i][1] +
-					dist2 * tess.normal[i][2] ) < 0.0f ) {
+			    // dist . tess.normal[i]
+			    ( dist0 * tess.vertexPtr3[i].normal[0] +
+			      dist1 * tess.vertexPtr3[i].normal[1] +
+			      dist2 * tess.vertexPtr3[i].normal[2] ) < 0.0f ) {
 				clip = 63;
 			} else {
 				if ( texCoords0 < 0.0f ) {
@@ -511,8 +474,8 @@
 				} else if ( texCoords1 > 1.0f ) {
 					clip |= 8;
 				}
-				texCoords[0] = texCoords0;
-				texCoords[1] = texCoords1;
+				(*texCoords)[0] = texCoords0;
+				(*texCoords)[1] = texCoords1;
 
 				// modulate the strength based on the height and color
 				if ( dist2 > radius ) {
@@ -545,11 +508,11 @@
 		// build a list of triangles that need light
 		numIndexes = 0;
 		for ( i = 0 ; i < tess.numIndexes ; i += 3 ) {
-			int		a, b, c;
+			GLushort	a, b, c;
 
-			a = tess.indexes[i];
-			b = tess.indexes[i+1];
-			c = tess.indexes[i+2];
+			a = tess.indexPtr.p16[i];
+			b = tess.indexPtr.p16[i+1];
+			c = tess.indexPtr.p16[i+2];
 			if ( clipBits[a] & clipBits[b] & clipBits[c] ) {
 				continue;	// not lighted
 			}
@@ -563,56 +526,74 @@
 			continue;
 		}
 
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglTexCoordPointer( 2, GL_FLOAT, 0, texCoordsArray[0] );
-
-		qglEnableClientState( GL_COLOR_ARRAY );
-		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, colorArray );
+		state->program = NULL;
+		GL_VBO( 0, 0 );
+		
+		SetAttrPointer( state, AL_TEXCOORD, 0,
+				2, GL_FLOAT, sizeof(vec2_t),
+				texCoordsArray );
+		SetAttrPointer( state, AL_COLOR, 0,
+				4, GL_UNSIGNED_BYTE, sizeof(color4ub_t),
+				colorArray );
 
-		GL_Bind( tr.dlightImage );
+		state->numImages = 1;
+		state->image[0] = tr.dlightImage;
 		// include GLS_DEPTHFUNC_EQUAL so alpha tested surfaces don't add light
 		// where they aren't rendered
 		if ( dl->additive ) {
-			GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
-		}
-		else {
-			GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
+			state->stateBits = GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE |
+				GLS_DEPTHFUNC_EQUAL;
+		} else {
+			state->stateBits = GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE |
+				GLS_DEPTHFUNC_EQUAL;
 		}
-		R_DrawElements( numIndexes, hitIndexes );
+		GL_DrawElements( state, numIndexes, 0, hitIndexes,
+				 0, tess.numVertexes-1, tess.numVertexes-1 );
 		backEnd.pc.c_totalIndexes += numIndexes;
 		backEnd.pc.c_dlightIndexes += numIndexes;
 	}
+
+	RB_FreeScratch( hitIndexes );
+	RB_FreeScratch( colorArray );
+	RB_FreeScratch( texCoordsArray );
+	RB_FreeScratch( clipBits );
 }
 #endif
 
 
-static void ProjectDlightTexture_scalar( void ) {
+static void ProjectDlightTexture_scalar( glRenderState_t *state ) {
 	int		i, l;
 	vec3_t	origin;
-	float	*texCoords;
-	byte	*colors;
-	byte	clipBits[SHADER_MAX_VERTEXES];
-	float	texCoordsArray[SHADER_MAX_VERTEXES][2];
-	byte	colorArray[SHADER_MAX_VERTEXES][4];
-	unsigned	hitIndexes[SHADER_MAX_INDEXES];
+	vec2_t	*texCoords;
+	color4ub_t	*colors;
+	byte	*clipBits;
+	vec2_t	*texCoordsArray;
+	color4ub_t	*colorArray;
+	GLushort	*hitIndexes;
 	int		numIndexes;
 	float	scale;
 	float	radius;
 	vec3_t	floatColor;
 	float	modulate = 0.0f;
 
-	if ( !backEnd.refdef.num_dlights ) {
+	if ( !backEnd.refdef.num_dlights ||
+	     tess.numVertexes > 65535 ) { // to avoid GLushort overflow
 		return;
 	}
 
+	clipBits = RB_AllocScratch( sizeof(byte) * tess.numVertexes );
+	texCoordsArray = RB_AllocScratch( sizeof(vec2_t) * tess.numVertexes );
+	colorArray = RB_AllocScratch( sizeof(color4ub_t) * tess.numVertexes );
+	hitIndexes = RB_AllocScratch( sizeof(GLushort) * tess.numIndexes );
+
 	for ( l = 0 ; l < backEnd.refdef.num_dlights ; l++ ) {
 		dlight_t	*dl;
 
 		if ( !( tess.dlightBits & ( 1 << l ) ) ) {
 			continue;	// this surface definately doesn't have any of this light
 		}
-		texCoords = texCoordsArray[0];
-		colors = colorArray[0];
+		texCoords = texCoordsArray;
+		colors = colorArray;
 
 		dl = &backEnd.refdef.dlights[l];
 		VectorCopy( dl->transformed, origin );
@@ -642,36 +623,34 @@
 			floatColor[2] = dl->color[2] * 255.0f;
 		}
 
-		for ( i = 0 ; i < tess.numVertexes ; i++, texCoords += 2, colors += 4 ) {
+		for ( i = 0 ; i < tess.numVertexes ; i++, texCoords++, colors++ ) {
 			int		clip = 0;
 			vec3_t	dist;
 			
-			VectorSubtract( origin, tess.xyz[i], dist );
+			VectorSubtract( origin, tess.vertexPtr2[i].xyz, dist );
 
 			backEnd.pc.c_dlightVertexes++;
 
-			texCoords[0] = 0.5f + dist[0] * scale;
-			texCoords[1] = 0.5f + dist[1] * scale;
+			(*texCoords)[0] = 0.5f + dist[0] * scale;
+			(*texCoords)[1] = 0.5f + dist[1] * scale;
 
 			if( !r_dlightBacks->integer &&
-					// dist . tess.normal[i]
-					( dist[0] * tess.normal[i][0] +
-					dist[1] * tess.normal[i][1] +
-					dist[2] * tess.normal[i][2] ) < 0.0f ) {
+			    // dist . tess.normal[i]
+			    ( dist[0] * tess.vertexPtr3[i].normal[0] +
+			      dist[1] * tess.vertexPtr3[i].normal[1] +
+			      dist[2] * tess.vertexPtr3[i].normal[2] ) < 0.0f ) {
 				clip = 63;
 			} else {
-				if ( texCoords[0] < 0.0f ) {
+				if ( (*texCoords)[0] < 0.0f ) {
 					clip |= 1;
-				} else if ( texCoords[0] > 1.0f ) {
+				} else if ( (*texCoords)[0] > 1.0f ) {
 					clip |= 2;
 				}
-				if ( texCoords[1] < 0.0f ) {
+				if ( (*texCoords)[1] < 0.0f ) {
 					clip |= 4;
-				} else if ( texCoords[1] > 1.0f ) {
+				} else if ( (*texCoords)[1] > 1.0f ) {
 					clip |= 8;
 				}
-				texCoords[0] = texCoords[0];
-				texCoords[1] = texCoords[1];
 
 				// modulate the strength based on the height and color
 				if ( dist[2] > radius ) {
@@ -690,20 +669,20 @@
 				}
 			}
 			clipBits[i] = clip;
-			colors[0] = myftol(floatColor[0] * modulate);
-			colors[1] = myftol(floatColor[1] * modulate);
-			colors[2] = myftol(floatColor[2] * modulate);
-			colors[3] = 255;
+			(*colors)[0] = myftol(floatColor[0] * modulate);
+			(*colors)[1] = myftol(floatColor[1] * modulate);
+			(*colors)[2] = myftol(floatColor[2] * modulate);
+			(*colors)[3] = 255;
 		}
 
 		// build a list of triangles that need light
 		numIndexes = 0;
 		for ( i = 0 ; i < tess.numIndexes ; i += 3 ) {
-			int		a, b, c;
+			GLushort		a, b, c;
 
-			a = tess.indexes[i];
-			b = tess.indexes[i+1];
-			c = tess.indexes[i+2];
+			a = tess.indexPtr.p16[i];
+			b = tess.indexPtr.p16[i+1];
+			c = tess.indexPtr.p16[i+2];
 			if ( clipBits[a] & clipBits[b] & clipBits[c] ) {
 				continue;	// not lighted
 			}
@@ -716,37 +695,52 @@
 		if ( !numIndexes ) {
 			continue;
 		}
-
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglTexCoordPointer( 2, GL_FLOAT, 0, texCoordsArray[0] );
-
-		qglEnableClientState( GL_COLOR_ARRAY );
-		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, colorArray );
-
-		GL_Bind( tr.dlightImage );
+		
+		state->program = tr.defaultShader->GLSLprogram;
+		
+		SetAttrPointer( state, AL_TEXCOORD, 0,
+				2, GL_FLOAT, sizeof(vec2_t),
+				texCoordsArray );
+		SetAttrPointer( state, AL_COLOR, 0,
+				4, GL_UNSIGNED_BYTE, sizeof(color4ub_t),
+				colorArray );
+
+		state->numImages = 1;
+		state->image[0] = tr.dlightImage;
+		state->stateBits = 0;
+		if ( tess.xstages[0] )
+			state->stateBits |= tess.xstages[0]->stateBits & GLS_POLYGON_OFFSET;
 		// include GLS_DEPTHFUNC_EQUAL so alpha tested surfaces don't add light
 		// where they aren't rendered
 		if ( dl->additive ) {
-			GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
-		}
-		else {
-			GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
+			state->stateBits |= GLS_DEPTHFUNC_EQUAL |
+				GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE;
+		} else {
+			state->stateBits |= GLS_DEPTHFUNC_EQUAL |
+				GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE;
 		}
-		R_DrawElements( numIndexes, hitIndexes );
+
+		GL_DrawElements( state, numIndexes, 0, hitIndexes,
+				 0, tess.numVertexes-1, tess.numVertexes-1 );
 		backEnd.pc.c_totalIndexes += numIndexes;
 		backEnd.pc.c_dlightIndexes += numIndexes;
 	}
+
+	RB_FreeScratch( hitIndexes );
+	RB_FreeScratch( colorArray );
+	RB_FreeScratch( texCoordsArray );
+	RB_FreeScratch( clipBits );
 }
 
-static void ProjectDlightTexture( void ) {
+static void ProjectDlightTexture( glRenderState_t *state ) {
 #if idppc_altivec
 	if (com_altivec->integer) {
 		// must be in a seperate function or G3 systems will crash.
-		ProjectDlightTexture_altivec();
+		ProjectDlightTexture_altivec( state );
 		return;
 	}
 #endif
-	ProjectDlightTexture_scalar();
+	ProjectDlightTexture_scalar( state );
 }
 
 
@@ -757,33 +751,46 @@
 Blends a fog texture on top of everything else
 ===================
 */
-static void RB_FogPass( void ) {
+static void RB_FogPass( glRenderState_t *state ) {
 	fog_t		*fog;
-	int			i;
 
-	qglEnableClientState( GL_COLOR_ARRAY );
-	qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
+	tess.svars.texcoords[0] = RB_AllocScratch( tess.numVertexes * sizeof(vec2_t) );
 
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
-	qglTexCoordPointer( 2, GL_FLOAT, 0, tess.svars.texcoords[0] );
-
-	fog = tr.world->fogs + tess.fogNum;
-
-	for ( i = 0; i < tess.numVertexes; i++ ) {
-		* ( int * )&tess.svars.colors[i] = fog->colorInt;
+	state->stateBits = GLS_DEFAULT;
+	if ( tess.xstages[0] )
+		state->stateBits |= tess.xstages[0]->stateBits & GLS_POLYGON_OFFSET;
+	if ( tess.shader->fogPass == FP_EQUAL )
+		state->stateBits |= GLS_DEPTHFUNC_EQUAL;
+
+	if ( tr.fogShader->GLSLprogram ) {
+		state->program = tr.fogShader->GLSLprogram;
+		state->stateBits |= GLS_SRCBLEND_ONE | GLS_DSTBLEND_SRC_ALPHA;
+	} else {
+		state->program = NULL;
+		state->stateBits |= GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA;
 	}
 
-	RB_CalcFogTexCoords( ( float * ) tess.svars.texcoords[0] );
+	fog = tr.world->fogs + tess.fogNum;
 
-	GL_Bind( tr.fogImage );
+	RB_CalcFogTexCoords( tess.svars.texcoords[0], tess.numVertexes );
 
-	if ( tess.shader->fogPass == FP_EQUAL ) {
-		GL_State( GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA | GLS_DEPTHFUNC_EQUAL );
-	} else {
-		GL_State( GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA );
-	}
+	SetAttrPointer( state, AL_TEXCOORD, 0,
+			2, GL_FLOAT, sizeof(vec2_t),
+			tess.svars.texcoords[0][0] );
+	SetAttrVec4f( state, AL_COLOR,
+		      fog->parms.color[0],
+		      fog->parms.color[1],
+		      fog->parms.color[2],
+		      1.0f );
+
+	state->numImages = 1;
+	state->image[0] = tr.fogImage;
+
+	GL_DrawElements( state, tess.numIndexes,
+			 0, tess.indexPtr.p16,
+			 0, tess.numVertexes-1, tess.numVertexes-1 );
 
-	R_DrawElements( tess.numIndexes, tess.indexes );
+	RB_FreeScratch( tess.svars.texcoords[0] );
 }
 
 /*
@@ -791,140 +798,223 @@
 ComputeColors
 ===============
 */
-static void ComputeColors( shaderStage_t *pStage )
+static void ComputeColors( glRenderState_t *state,
+			   vboInfo_t *VBO,
+			   shaderStage_t *pStage,
+			   qboolean skipFog )
 {
 	int		i;
+	alphaGen_t	aGen = pStage->alphaGen;
+	colorGen_t	rgbGen = pStage->rgbGen;
+	color4ub_t	color;
+	fog_t		*fog;
+	qboolean	constRGB, constA;
+	
+	// get rid of AGEN_SKIP
+	if ( aGen == AGEN_SKIP ) {
+		if ( rgbGen == CGEN_EXACT_VERTEX ||
+		     rgbGen == CGEN_VERTEX ) {
+			aGen = AGEN_VERTEX;
+		} else {
+			aGen = AGEN_IDENTITY;
+		}
+	}
+	
+	// no need to multiply by 1
+	if ( tr.identityLight == 1 && rgbGen == CGEN_VERTEX ) {
+		rgbGen = CGEN_EXACT_VERTEX;
+	}
+
+	// check for constant RGB
+	switch( rgbGen ) {
+	case CGEN_IDENTITY_LIGHTING:
+		color[0] = color[1] = color[2] = tr.identityLightByte;
+		constRGB = qtrue;
+		break;
+	case CGEN_IDENTITY:
+		color[0] = color[1] = color[2] = 255;
+		constRGB = qtrue;
+		break;
+	case CGEN_ENTITY:
+		RB_CalcColorFromEntity( &color, 1 );
+		constRGB = qtrue;
+		break;
+	case CGEN_ONE_MINUS_ENTITY:
+		RB_CalcColorFromOneMinusEntity( &color, 1 );
+		constRGB = qtrue;
+		break;
+	case CGEN_WAVEFORM:
+		RB_CalcWaveColor( &pStage->rgbWave, &color, 1 );
+		constRGB = qtrue;
+		break;
+	case CGEN_FOG:
+		fog = tr.world->fogs + tess.fogNum;
+		*(int *)(&color) = fog->colorInt;
+		constRGB = qtrue;
+		break;
+	case CGEN_CONST:
+		*(int *)(&color) = *(int *)pStage->constantColor;		
+		constRGB = qtrue;
+		break;
+	default:
+		constRGB = qfalse;
+		break;
+	}
+
+	// check for constant ALPHA
+	switch( aGen ) {
+	case AGEN_IDENTITY:
+		color[3] = 255;
+		constA = qtrue;
+		break;
+	case AGEN_ENTITY:
+		RB_CalcAlphaFromEntity( &color, 1 );
+		constA = qtrue;
+		break;
+	case AGEN_ONE_MINUS_ENTITY:
+		RB_CalcAlphaFromOneMinusEntity( &color, 1 );
+		constA = qtrue;
+		break;
+	case AGEN_WAVEFORM:
+		RB_CalcWaveAlpha( &pStage->alphaWave, &color, 1 );
+		constA = qtrue;
+		break;
+	case AGEN_CONST:
+		color[3] = pStage->constantColor[3];
+		constA = qtrue;
+		break;
+	default:
+		constA = qfalse;
+		break;
+	}
+
+	if ( !r_greyscale->integer &&
+	     (skipFog || !tess.fogNum || pStage->adjustColorsForFog == ACFF_NONE) ) {
+		// if RGB and ALPHA are constant, just set the GL color
+		if ( constRGB && constA ) {
+			SetAttrVec4f( state, AL_COLOR,
+				      color[0] / 255.0f,
+				      color[1] / 255.0f,
+				      color[2] / 255.0f,
+				      color[3] / 255.0f );
+			tess.svars.colors = NULL;
+			return;
+		}
+		
+		// if RGB and ALPHA are identical to vertex data, bind that
+		if ( aGen == AGEN_VERTEX && rgbGen == CGEN_EXACT_VERTEX ) {
+			if( VBO && VBO->vbo ) {
+				SetAttrPointer( state, AL_COLOR, VBO->vbo,
+						4, GL_UNSIGNED_BYTE, sizeof(vaWord4_t),
+						&VBO->offs4->color );
+			} else if( !tess.vertexPtr4 ) {
+				SetAttrPointer( state, AL_COLOR, backEnd.worldVBO.vbo,
+						4, GL_UNSIGNED_BYTE, sizeof(vaWord4_t),
+						&backEnd.worldVBO.offs4->color );
+			} else {
+				SetAttrPointer( state, AL_COLOR, 0,
+						4, GL_UNSIGNED_BYTE, sizeof(vaWord4_t),
+						&tess.vertexPtr4->color );
+			}
+			tess.svars.colors = NULL;
+			return;
+		}
+	}
+	
+	// we have to allocate a per-Vertex color value
+	tess.svars.colors = RB_AllocScratch( tess.numVertexes * sizeof(color4ub_t) );
 
 	//
 	// rgbGen
 	//
-	switch ( pStage->rgbGen )
+	switch ( rgbGen )
 	{
-		case CGEN_IDENTITY:
-			Com_Memset( tess.svars.colors, 0xff, tess.numVertexes * 4 );
-			break;
-		default:
-		case CGEN_IDENTITY_LIGHTING:
-			Com_Memset( tess.svars.colors, tr.identityLightByte, tess.numVertexes * 4 );
-			break;
-		case CGEN_LIGHTING_DIFFUSE:
-			RB_CalcDiffuseColor( ( unsigned char * ) tess.svars.colors );
-			break;
-		case CGEN_EXACT_VERTEX:
-			Com_Memcpy( tess.svars.colors, tess.vertexColors, tess.numVertexes * sizeof( tess.vertexColors[0] ) );
-			break;
-		case CGEN_CONST:
-			for ( i = 0; i < tess.numVertexes; i++ ) {
-				*(int *)tess.svars.colors[i] = *(int *)pStage->constantColor;
-			}
-			break;
-		case CGEN_VERTEX:
-			if ( tr.identityLight == 1 )
-			{
-				Com_Memcpy( tess.svars.colors, tess.vertexColors, tess.numVertexes * sizeof( tess.vertexColors[0] ) );
-			}
-			else
-			{
-				for ( i = 0; i < tess.numVertexes; i++ )
-				{
-					tess.svars.colors[i][0] = tess.vertexColors[i][0] * tr.identityLight;
-					tess.svars.colors[i][1] = tess.vertexColors[i][1] * tr.identityLight;
-					tess.svars.colors[i][2] = tess.vertexColors[i][2] * tr.identityLight;
-					tess.svars.colors[i][3] = tess.vertexColors[i][3];
-				}
-			}
-			break;
-		case CGEN_ONE_MINUS_VERTEX:
-			if ( tr.identityLight == 1 )
-			{
-				for ( i = 0; i < tess.numVertexes; i++ )
-				{
-					tess.svars.colors[i][0] = 255 - tess.vertexColors[i][0];
-					tess.svars.colors[i][1] = 255 - tess.vertexColors[i][1];
-					tess.svars.colors[i][2] = 255 - tess.vertexColors[i][2];
-				}
-			}
-			else
+	case CGEN_BAD:
+	case CGEN_IDENTITY_LIGHTING:
+	case CGEN_IDENTITY:
+	case CGEN_ENTITY:
+	case CGEN_ONE_MINUS_ENTITY:
+	case CGEN_WAVEFORM:
+	case CGEN_FOG:
+	case CGEN_CONST:
+		for ( i = 0; i < tess.numVertexes; i++ ) {
+			*(int *)tess.svars.colors[i] = *(int *)(&color);
+		}
+		break;
+	case CGEN_LIGHTING_DIFFUSE:
+		RB_CalcDiffuseColor( tess.svars.colors, tess.numVertexes );
+		break;
+	case CGEN_EXACT_VERTEX:
+		for ( i = 0; i < tess.numVertexes; i++ )
+		{
+			tess.svars.colors[i][0] = tess.vertexPtr4[i].color[0];
+			tess.svars.colors[i][1] = tess.vertexPtr4[i].color[1];
+			tess.svars.colors[i][2] = tess.vertexPtr4[i].color[2];
+			tess.svars.colors[i][3] = tess.vertexPtr4[i].color[3];
+		}
+		break;
+	case CGEN_VERTEX:
+		for ( i = 0; i < tess.numVertexes; i++ )
+		{
+			tess.svars.colors[i][0] = tess.vertexPtr4[i].color[0] * tr.identityLight;
+			tess.svars.colors[i][1] = tess.vertexPtr4[i].color[1] * tr.identityLight;
+			tess.svars.colors[i][2] = tess.vertexPtr4[i].color[2] * tr.identityLight;
+			tess.svars.colors[i][3] = tess.vertexPtr4[i].color[3];
+		}
+		break;
+	case CGEN_ONE_MINUS_VERTEX:
+		if ( tr.identityLight == 1 )
+		{
+			for ( i = 0; i < tess.numVertexes; i++ )
 			{
-				for ( i = 0; i < tess.numVertexes; i++ )
-				{
-					tess.svars.colors[i][0] = ( 255 - tess.vertexColors[i][0] ) * tr.identityLight;
-					tess.svars.colors[i][1] = ( 255 - tess.vertexColors[i][1] ) * tr.identityLight;
-					tess.svars.colors[i][2] = ( 255 - tess.vertexColors[i][2] ) * tr.identityLight;
-				}
+				tess.svars.colors[i][0] = 255 - tess.vertexPtr4[i].color[0];
+				tess.svars.colors[i][1] = 255 - tess.vertexPtr4[i].color[1];
+				tess.svars.colors[i][2] = 255 - tess.vertexPtr4[i].color[2];
 			}
-			break;
-		case CGEN_FOG:
+		}
+		else
+		{
+			for ( i = 0; i < tess.numVertexes; i++ )
 			{
-				fog_t		*fog;
-
-				fog = tr.world->fogs + tess.fogNum;
-
-				for ( i = 0; i < tess.numVertexes; i++ ) {
-					* ( int * )&tess.svars.colors[i] = fog->colorInt;
-				}
+				tess.svars.colors[i][0] = ( 255 - tess.vertexPtr4[i].color[0] ) * tr.identityLight;
+				tess.svars.colors[i][1] = ( 255 - tess.vertexPtr4[i].color[1] ) * tr.identityLight;
+				tess.svars.colors[i][2] = ( 255 - tess.vertexPtr4[i].color[2] ) * tr.identityLight;
 			}
-			break;
-		case CGEN_WAVEFORM:
-			RB_CalcWaveColor( &pStage->rgbWave, ( unsigned char * ) tess.svars.colors );
-			break;
-		case CGEN_ENTITY:
-			RB_CalcColorFromEntity( ( unsigned char * ) tess.svars.colors );
-			break;
-		case CGEN_ONE_MINUS_ENTITY:
-			RB_CalcColorFromOneMinusEntity( ( unsigned char * ) tess.svars.colors );
-			break;
+		}
+		break;
 	}
 
 	//
 	// alphaGen
 	//
-	switch ( pStage->alphaGen )
+	switch ( aGen )
 	{
 	case AGEN_SKIP:
-		break;
 	case AGEN_IDENTITY:
-		if ( pStage->rgbGen != CGEN_IDENTITY ) {
-			if ( ( pStage->rgbGen == CGEN_VERTEX && tr.identityLight != 1 ) ||
-				 pStage->rgbGen != CGEN_VERTEX ) {
-				for ( i = 0; i < tess.numVertexes; i++ ) {
-					tess.svars.colors[i][3] = 0xff;
-				}
-			}
-		}
-		break;
+	case AGEN_ENTITY:
+	case AGEN_ONE_MINUS_ENTITY:
+	case AGEN_WAVEFORM:
 	case AGEN_CONST:
-		if ( pStage->rgbGen != CGEN_CONST ) {
-			for ( i = 0; i < tess.numVertexes; i++ ) {
-				tess.svars.colors[i][3] = pStage->constantColor[3];
-			}
+		for ( i = 0; i < tess.numVertexes; i++ ) {
+			tess.svars.colors[i][3] = color[3];
 		}
 		break;
-	case AGEN_WAVEFORM:
-		RB_CalcWaveAlpha( &pStage->alphaWave, ( unsigned char * ) tess.svars.colors );
-		break;
 	case AGEN_LIGHTING_SPECULAR:
-		RB_CalcSpecularAlpha( ( unsigned char * ) tess.svars.colors );
-		break;
-	case AGEN_ENTITY:
-		RB_CalcAlphaFromEntity( ( unsigned char * ) tess.svars.colors );
+		RB_CalcSpecularAlpha( tess.svars.colors, tess.numVertexes );
 		break;
-	case AGEN_ONE_MINUS_ENTITY:
-		RB_CalcAlphaFromOneMinusEntity( ( unsigned char * ) tess.svars.colors );
-		break;
-    case AGEN_VERTEX:
+	case AGEN_VERTEX:
 		if ( pStage->rgbGen != CGEN_VERTEX ) {
 			for ( i = 0; i < tess.numVertexes; i++ ) {
-				tess.svars.colors[i][3] = tess.vertexColors[i][3];
+				tess.svars.colors[i][3] = tess.vertexPtr4[i].color[3];
 			}
 		}
-        break;
-    case AGEN_ONE_MINUS_VERTEX:
-        for ( i = 0; i < tess.numVertexes; i++ )
-        {
-			tess.svars.colors[i][3] = 255 - tess.vertexColors[i][3];
-        }
-        break;
+		break;
+	case AGEN_ONE_MINUS_VERTEX:
+		for ( i = 0; i < tess.numVertexes; i++ )
+		{
+			tess.svars.colors[i][3] = 255 - tess.vertexPtr4[i].color[3];
+		}
+		break;
 	case AGEN_PORTAL:
 		{
 			unsigned char alpha;
@@ -934,7 +1024,7 @@
 				float len;
 				vec3_t v;
 
-				VectorSubtract( tess.xyz[i], backEnd.viewParms.or.origin, v );
+				VectorSubtract( tess.vertexPtr2[i].xyz, backEnd.viewParms.or.origin, v );
 				len = VectorLength( v );
 
 				len /= tess.shader->portalRange;
@@ -966,13 +1056,13 @@
 		switch ( pStage->adjustColorsForFog )
 		{
 		case ACFF_MODULATE_RGB:
-			RB_CalcModulateColorsByFog( ( unsigned char * ) tess.svars.colors );
+			RB_CalcModulateColorsByFog( tess.svars.colors, tess.numVertexes );
 			break;
 		case ACFF_MODULATE_ALPHA:
-			RB_CalcModulateAlphasByFog( ( unsigned char * ) tess.svars.colors );
+			RB_CalcModulateAlphasByFog( tess.svars.colors, tess.numVertexes );
 			break;
 		case ACFF_MODULATE_RGBA:
-			RB_CalcModulateRGBAsByFog( ( unsigned char * ) tess.svars.colors );
+			RB_CalcModulateRGBAsByFog( tess.svars.colors, tess.numVertexes );
 			break;
 		case ACFF_NONE:
 			break;
@@ -1001,6 +1091,10 @@
 			tess.svars.colors[i][2] = LERP(tess.svars.colors[i][2], scale, r_greyscale->value);
 		}
 	}
+
+	SetAttrPointer( state, AL_COLOR, 0,
+			4, GL_UNSIGNED_BYTE, sizeof(color4ub_t),
+			tess.svars.colors );
 }
 
 /*
@@ -1008,44 +1102,92 @@
 ComputeTexCoords
 ===============
 */
-static void ComputeTexCoords( shaderStage_t *pStage ) {
+static void ComputeTexCoords( glRenderState_t *state,
+			      vboInfo_t *VBO,
+			      shaderStage_t *pStage ) {
 	int		i;
 	int		b;
-
+	qboolean	noTexMods;
+	
 	for ( b = 0; b < NUM_TEXTURE_BUNDLES; b++ ) {
 		int tm;
 
-		//
-		// generate the texture coordinates
-		//
-		switch ( pStage->bundle[b].tcGen )
-		{
-		case TCGEN_IDENTITY:
-			Com_Memset( tess.svars.texcoords[b], 0, sizeof( float ) * 2 * tess.numVertexes );
-			break;
-		case TCGEN_TEXTURE:
-			for ( i = 0 ; i < tess.numVertexes ; i++ ) {
-				tess.svars.texcoords[b][i][0] = tess.texCoords[i][0][0];
-				tess.svars.texcoords[b][i][1] = tess.texCoords[i][0][1];
-			}
-			break;
+		noTexMods = (pStage->bundle[b].numTexMods == 0) ||
+			(pStage->bundle[b].texMods[0].type == TMOD_NONE);
+		
+		if ( noTexMods && pStage->bundle[b].tcGen == TCGEN_BAD ) {
+			SetAttrUnspec( state, AL_TEXCOORD + b );
+			continue;
+		}
+
+		if ( noTexMods && pStage->bundle[b].tcGen == TCGEN_TEXTURE ) {
+			if( VBO && VBO->vbo ) {
+				SetAttrPointer( state, AL_TEXCOORD + b, VBO->vbo,
+						2, GL_FLOAT, sizeof(vaWord1_t),
+						&VBO->offs1->tc1);
+			} else if( tess.vertexPtr1 == NULL ) {
+				SetAttrPointer( state, AL_TEXCOORD + b, backEnd.worldVBO.vbo,
+						2, GL_FLOAT, sizeof(vaWord1_t),
+						&backEnd.worldVBO.offs1->tc1);
+			} else {
+				SetAttrPointer( state, AL_TEXCOORD + b, 0,
+						2, GL_FLOAT, sizeof(vaWord1_t),
+						&tess.vertexPtr1->tc1 );
+			}
+			tess.svars.texcoords[b] = NULL;
+			continue;
+		}
+
+		if ( noTexMods && pStage->bundle[b].tcGen == TCGEN_LIGHTMAP ) {
+			if( VBO && VBO->vbo ) {
+				SetAttrPointer( state, AL_TEXCOORD + b, VBO->vbo,
+						2, GL_FLOAT, sizeof(vaWord1_t),
+						&VBO->offs1->tc2);
+			} else if( tess.vertexPtr1 == NULL ) {
+				SetAttrPointer( state, AL_TEXCOORD + b, backEnd.worldVBO.vbo,
+						2, GL_FLOAT, sizeof(vaWord1_t),
+						&backEnd.worldVBO.offs1->tc2);
+			} else {
+				SetAttrPointer( state, AL_TEXCOORD + b, 0,
+						2, GL_FLOAT, sizeof(vaWord1_t),
+						&tess.vertexPtr1->tc2 );
+			}
+			tess.svars.texcoords[b] = NULL;
+			continue;
+		}
+
+		tess.svars.texcoords[b] = RB_AllocScratch( tess.numVertexes * sizeof(vec2_t) );
+		//
+		// generate the texture coordinates
+		//
+		switch ( pStage->bundle[b].tcGen )
+		{
+		case TCGEN_IDENTITY:
+			Com_Memset( tess.svars.texcoords[b], 0, sizeof( vec2_t ) * tess.numVertexes );
+			break;
+		case TCGEN_TEXTURE:
+			for ( i = 0 ; i < tess.numVertexes ; i++ ) {
+				tess.svars.texcoords[b][i][0] = tess.vertexPtr1[i].tc1[0];
+				tess.svars.texcoords[b][i][1] = tess.vertexPtr1[i].tc1[1];
+			}
+			break;
 		case TCGEN_LIGHTMAP:
 			for ( i = 0 ; i < tess.numVertexes ; i++ ) {
-				tess.svars.texcoords[b][i][0] = tess.texCoords[i][1][0];
-				tess.svars.texcoords[b][i][1] = tess.texCoords[i][1][1];
+				tess.svars.texcoords[b][i][0] = tess.vertexPtr1[i].tc2[0];
+				tess.svars.texcoords[b][i][1] = tess.vertexPtr1[i].tc2[1];
 			}
 			break;
 		case TCGEN_VECTOR:
 			for ( i = 0 ; i < tess.numVertexes ; i++ ) {
-				tess.svars.texcoords[b][i][0] = DotProduct( tess.xyz[i], pStage->bundle[b].tcGenVectors[0] );
-				tess.svars.texcoords[b][i][1] = DotProduct( tess.xyz[i], pStage->bundle[b].tcGenVectors[1] );
+				tess.svars.texcoords[b][i][0] = DotProduct( tess.vertexPtr2[i].xyz, pStage->bundle[b].tcGenVectors[0] );
+				tess.svars.texcoords[b][i][1] = DotProduct( tess.vertexPtr2[i].xyz, pStage->bundle[b].tcGenVectors[1] );
 			}
 			break;
 		case TCGEN_FOG:
-			RB_CalcFogTexCoords( ( float * ) tess.svars.texcoords[b] );
+			RB_CalcFogTexCoords( tess.svars.texcoords[b], tess.numVertexes );
 			break;
 		case TCGEN_ENVIRONMENT_MAPPED:
-			RB_CalcEnvironmentTexCoords( ( float * ) tess.svars.texcoords[b] );
+			RB_CalcEnvironmentTexCoords( tess.svars.texcoords[b], tess.numVertexes );
 			break;
 		case TCGEN_BAD:
 			return;
@@ -1063,37 +1205,37 @@
 
 			case TMOD_TURBULENT:
 				RB_CalcTurbulentTexCoords( &pStage->bundle[b].texMods[tm].wave, 
-						                 ( float * ) tess.svars.texcoords[b] );
+							   tess.svars.texcoords[b], tess.numVertexes );
 				break;
 
 			case TMOD_ENTITY_TRANSLATE:
 				RB_CalcScrollTexCoords( backEnd.currentEntity->e.shaderTexCoord,
-									 ( float * ) tess.svars.texcoords[b] );
+							tess.svars.texcoords[b], tess.numVertexes );
 				break;
 
 			case TMOD_SCROLL:
 				RB_CalcScrollTexCoords( pStage->bundle[b].texMods[tm].scroll,
-										 ( float * ) tess.svars.texcoords[b] );
+							tess.svars.texcoords[b], tess.numVertexes );
 				break;
 
 			case TMOD_SCALE:
 				RB_CalcScaleTexCoords( pStage->bundle[b].texMods[tm].scale,
-									 ( float * ) tess.svars.texcoords[b] );
+						       tess.svars.texcoords[b], tess.numVertexes );
 				break;
 			
 			case TMOD_STRETCH:
 				RB_CalcStretchTexCoords( &pStage->bundle[b].texMods[tm].wave, 
-						               ( float * ) tess.svars.texcoords[b] );
+							 tess.svars.texcoords[b], tess.numVertexes );
 				break;
 
 			case TMOD_TRANSFORM:
 				RB_CalcTransformTexCoords( &pStage->bundle[b].texMods[tm],
-						                 ( float * ) tess.svars.texcoords[b] );
+							   tess.svars.texcoords[b], tess.numVertexes );
 				break;
 
 			case TMOD_ROTATE:
 				RB_CalcRotateTexCoords( pStage->bundle[b].texMods[tm].rotateSpeed,
-										( float * ) tess.svars.texcoords[b] );
+							tess.svars.texcoords[b], tess.numVertexes );
 				break;
 
 			default:
@@ -1101,15 +1243,21 @@
 				break;
 			}
 		}
+		SetAttrPointer( state, AL_TEXCOORD + b, 0,
+				2, GL_FLOAT, sizeof(vec2_t),
+				tess.svars.texcoords[b] );
 	}
 }
 
 /*
 ** RB_IterateStagesGeneric
 */
-static void RB_IterateStagesGeneric( shaderCommands_t *input )
+static void RB_IterateStagesGenericVBO( glRenderState_t *state,
+					vboInfo_t *VBO, GLuint max,
+					qboolean skipDetail )
 {
 	int stage;
+	int bundle;
 
 	for ( stage = 0; stage < MAX_SHADER_STAGES; stage++ )
 	{
@@ -1120,46 +1268,120 @@
 			break;
 		}
 
-		ComputeColors( pStage );
-		ComputeTexCoords( pStage );
+		// if the surface was invisible in the last frame, skip
+		// all detail stages
+		if ( skipDetail && pStage->isDetail )
+			continue;
+
+		state->stateBits = pStage->stateBits;
 
-		if ( !setArraysOnce )
+		ComputeColors( state, VBO, pStage, qtrue );
+		ComputeTexCoords( state, VBO, pStage );
+
+		//
+		// set state
+		//
+		state->numImages = 1;
+		if ( pStage->bundle[0].vertexLightmap && ( (r_vertexLight->integer && !r_uiFullScreen->integer) || glConfig.hardwareType == GLHW_PERMEDIA2 ) && r_lightmap->integer )
+		{
+			state->image[0] = tr.whiteImage;
+		}
+		else 
+			R_GetAnimatedImage( &pStage->bundle[0], qfalse, &state->image[0] );
+		
+		//
+		// do multitexture
+		//
+		for ( bundle = 1; bundle < glConfig.numTextureUnits; bundle++ ) {
+			if ( !pStage->bundle[bundle].multitextureEnv )
+				break;
+
+			// this is an ugly hack to work around a GeForce driver
+			// bug with multitexture and clip planes
+			if ( backEnd.viewParms.portalLevel ) {
+				qglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
+			}
+			
+			if ( r_lightmap->integer ) {
+				GL_TexEnv( bundle, GL_REPLACE );
+			} else {
+				GL_TexEnv( bundle, pStage->bundle[bundle].multitextureEnv );
+			}
+			R_GetAnimatedImage( &pStage->bundle[bundle], qfalse, &state->image[bundle] );
+		}
+		state->numImages = bundle;
+
+		GL_DrawElements( state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				 VBO->minIndex, VBO->maxIndex, max );
+		
+		// allow skipping out to show just lightmaps during development
+		if ( r_lightmap->integer && ( pStage->bundle[0].isLightmap || pStage->bundle[1].isLightmap || pStage->bundle[0].vertexLightmap ) )
 		{
-			qglEnableClientState( GL_COLOR_ARRAY );
-			qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, input->svars.colors );
+			break;
 		}
+	}
+}
+static void RB_IterateStagesGeneric( glRenderState_t *state,
+				     shaderCommands_t *input,
+				     GLuint max, qboolean skipDetail )
+{
+	int stage, b;
+
+	for ( stage = 0; stage < MAX_SHADER_STAGES; stage++ )
+	{
+		shaderStage_t *pStage = tess.xstages[stage];
+
+		if ( !pStage )
+		{
+			break;
+		}
+
+		if ( skipDetail && pStage->isDetail )
+			continue;
+
+		ComputeColors( state, NULL, pStage, (tess.vertexPtr1 == NULL) );
+		ComputeTexCoords( state, NULL, pStage );
 
 		//
 		// do multitexture
 		//
 		if ( pStage->bundle[1].image[0] != 0 )
 		{
-			DrawMultitextured( input, stage );
+			DrawMultitextured( state, input, stage, max );
 		}
 		else
 		{
-			if ( !setArraysOnce )
-			{
-				qglTexCoordPointer( 2, GL_FLOAT, 0, input->svars.texcoords[0] );
-			}
-
 			//
 			// set state
 			//
+			state->stateBits = pStage->stateBits;
+			state->numImages = 1;
 			if ( pStage->bundle[0].vertexLightmap && ( (r_vertexLight->integer && !r_uiFullScreen->integer) || glConfig.hardwareType == GLHW_PERMEDIA2 ) && r_lightmap->integer )
 			{
-				GL_Bind( tr.whiteImage );
+				state->image[0] = tr.whiteImage;
 			}
 			else 
-				R_BindAnimatedImage( &pStage->bundle[0] );
-
-			GL_State( pStage->stateBits );
+				R_GetAnimatedImage( &pStage->bundle[0], qfalse, &state->image[0] );
 
 			//
 			// draw
 			//
-			R_DrawElements( input->numIndexes, input->indexes );
+			GL_DrawElements( state, input->numIndexes,
+					 0, input->indexPtr.p16,
+					 input->minIndex, input->maxIndex, max );
+		}
+
+		for ( b = NUM_TEXTURE_BUNDLES - 1; b >= 0; b-- ) {
+			if ( input->svars.texcoords[b] != NULL ) {
+				RB_FreeScratch( input->svars.texcoords[b] );
+				input->svars.texcoords[b] = NULL;
+			}
 		}
+		if ( input->svars.colors != NULL ) {
+			RB_FreeScratch( input->svars.colors );
+			input->svars.colors = NULL;
+		}
+
 		// allow skipping out to show just lightmaps during development
 		if ( r_lightmap->integer && ( pStage->bundle[0].isLightmap || pStage->bundle[1].isLightmap || pStage->bundle[0].vertexLightmap ) )
 		{
@@ -1175,6 +1397,11 @@
 void RB_StageIteratorGeneric( void )
 {
 	shaderCommands_t *input;
+	GLuint            max;
+	vboInfo_t        *VBO;
+	glRenderState_t   state;
+	GLuint            glQueryID = 0, *glQueryResult = NULL;
+	qboolean          skipDetails = qfalse;
 
 	input = &tess;
 
@@ -1190,95 +1417,97 @@
 		GLimp_LogComment( va("--- RB_StageIteratorGeneric( %s ) ---\n", tess.shader->name) );
 	}
 
-	//
-	// set face culling appropriately
-	//
-	GL_Cull( input->shader->cullType );
-
-	// set polygon offset if necessary
-	if ( input->shader->polygonOffset )
-	{
-		qglEnable( GL_POLYGON_OFFSET_FILL );
-		qglPolygonOffset( r_offsetFactor->value, r_offsetUnits->value );
-	}
+	InitState( &state );
 
 	//
-	// if there is only a single pass then we can enable color
-	// and texture arrays before we compile, otherwise we need
-	// to avoid compiling those arrays since they will change
-	// during multipass rendering
+	// set face culling appropriately
 	//
-	if ( tess.numPasses > 1 || input->shader->multitextureEnv )
-	{
-		setArraysOnce = qfalse;
-		qglDisableClientState (GL_COLOR_ARRAY);
-		qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
-	}
-	else
-	{
-		setArraysOnce = qtrue;
-
-		qglEnableClientState( GL_COLOR_ARRAY);
-		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
+	state.faceCulling = input->shader->cullType;
 
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
-		qglTexCoordPointer( 2, GL_FLOAT, 0, tess.svars.texcoords[0] );
+	if( qglBeginQueryARB &&
+	    !backEnd.viewParms.portalLevel ) {
+		if ( backEnd.currentEntity == &tr.worldEntity ) {
+			glQueryID = tess.shader->QueryID;
+			glQueryResult = &tess.shader->QueryResult;
+		}
 	}
-
-	//
-	// lock XYZ
-	//
-	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
-	if (qglLockArraysEXT)
-	{
-		qglLockArraysEXT(0, input->numVertexes);
-		GLimp_LogComment( "glLockArraysEXT\n" );
+	
+	if( glQueryID ) {
+		GL_GetQuery( glQueryID, glQueryResult );
+		GL_StartQuery( glQueryID, glQueryResult );
+		skipDetails = (QUERY_RESULT(glQueryResult) == 0);
 	}
 
-	//
-	// enable color and texcoord arrays after the lock if necessary
-	//
-	if ( !setArraysOnce )
-	{
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglEnableClientState( GL_COLOR_ARRAY );
-	}
+	for( VBO = tess.firstVBO; VBO; VBO = VBO->next ) {
+		vec3_t		*vertexes;
+		vboInfo_t	*dataVBO;
+		
+		if ( VBO->vbo ) {
+			dataVBO = VBO;
+			max = VBO->maxIndex;
+			vertexes = &VBO->offs2->xyz;
+		} else {
+			dataVBO = &backEnd.worldVBO;
+			max = backEnd.worldVBO.maxIndex;
+			vertexes = &backEnd.worldVBO.offs2->xyz;
+		}
 
-	//
-	// call shader function
-	//
-	RB_IterateStagesGeneric( input );
+		SetAttrPointer( &state, AL_VERTEX, dataVBO->vbo,
+				3, GL_FLOAT, sizeof(vaWord2_t),
+				&dataVBO->offs2->xyz );
 
-	// 
-	// now do any dynamic lighting needed
-	//
-	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE
-		&& !(tess.shader->surfaceFlags & (SURF_NODLIGHT | SURF_SKY) ) ) {
-		ProjectDlightTexture();
-	}
+		RB_IterateStagesGenericVBO( &state, VBO, max, skipDetails );
 
-	//
-	// now do fog
-	//
-	if ( tess.fogNum && tess.shader->fogPass ) {
-		RB_FogPass();
+		if ( r_showtris->integer && !input->shader->isDepth ) {
+			DrawTris( &state, VBO->numIndexes, 
+				  VBO->ibo, VBO->offsIdx,
+				  VBO->minIndex,
+				  VBO->maxIndex, max,
+				  1.0f, 1.0f, 0.0f );
+		}
+		if ( r_shownormals->integer ) {
+			DrawNormals( &state );
+		}
 	}
 
-	// 
-	// unlock arrays
-	//
-	if (qglUnlockArraysEXT) 
-	{
-		qglUnlockArraysEXT();
-		GLimp_LogComment( "glUnlockArraysEXT\n" );
+	if ( tess.numIndexes > 0 ) {
+		vec3_t	*vertexes;
+		GLuint	dataVBO;
+		
+		if ( input->vertexPtr1 ) {
+			dataVBO = 0;
+			max = tess.numIndexes-1;
+			vertexes = &input->vertexPtr2[0].xyz;
+		} else {
+			dataVBO = backEnd.worldVBO.vbo;
+			max = backEnd.worldVBO.maxIndex;
+			vertexes = &backEnd.worldVBO.offs2->xyz;
+		}
+		//
+		// lock XYZ
+		//
+		SetAttrPointer( &state, AL_VERTEX, dataVBO,
+				3, GL_FLOAT, sizeof(vaWord2_t),
+				vertexes );
+		
+		//
+		// call shader function
+		//
+		RB_IterateStagesGeneric( &state, input, max, skipDetails );
+		
+		if ( r_showtris->integer && !input->shader->isDepth ) {
+			DrawTris( &state, tess.numIndexes,
+				  0, tess.indexPtr.p16,
+				  tess.minIndex, tess.maxIndex, max,
+				  1.0f, 0.0f, 0.0f );
+		}
+		if ( r_shownormals->integer ) {
+			DrawNormals( &state );
+		}
 	}
 
-	//
-	// reset polygon offset
-	//
-	if ( input->shader->polygonOffset )
-	{
-		qglDisable( GL_POLYGON_OFFSET_FILL );
+	if( glQueryID ) {
+		GL_EndQuery( glQueryID, glQueryResult );
 	}
 }
 
@@ -1290,17 +1519,16 @@
 {
 	shaderCommands_t *input;
 	shader_t		*shader;
+	GLuint            max;
+	vboInfo_t        *VBO;
+	glRenderState_t  state;
+	GLuint            glQueryID = 0, *glQueryResult = NULL;
 
 	input = &tess;
 
 	shader = input->shader;
 
 	//
-	// compute colors
-	//
-	RB_CalcDiffuseColor( ( unsigned char * ) tess.svars.colors );
-
-	//
 	// log this call
 	//
 	if ( r_logFile->integer ) 
@@ -1310,65 +1538,138 @@
 		GLimp_LogComment( va("--- RB_StageIteratorVertexLitTexturedUnfogged( %s ) ---\n", tess.shader->name) );
 	}
 
-	//
-	// set face culling appropriately
-	//
-	GL_Cull( input->shader->cullType );
+	InitState( &state );
 
 	//
-	// set arrays and lock
+	// set face culling appropriately
 	//
-	qglEnableClientState( GL_COLOR_ARRAY);
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
+	state.stateBits = tess.xstages[0]->stateBits;
+	state.faceCulling = input->shader->cullType;
 
-	qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
-	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
-	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);
+	state.numImages = 1;
+	R_GetAnimatedImage( &tess.xstages[0]->bundle[0], qfalse, &state.image[0] );
 
-	if ( qglLockArraysEXT )
-	{
-		qglLockArraysEXT(0, input->numVertexes);
-		GLimp_LogComment( "glLockArraysEXT\n" );
+	if( qglBeginQueryARB &&
+	    !backEnd.viewParms.portalLevel ) {
+		if ( backEnd.currentEntity == &tr.worldEntity ) {
+			glQueryID = tess.shader->QueryID;
+			glQueryResult = &tess.shader->QueryResult;
+		}
+	}
+	
+	if( glQueryID ) {
+		GL_StartQuery( glQueryID, glQueryResult );
 	}
 
 	//
-	// call special shade routine
+	// set arrays and lock
 	//
-	R_BindAnimatedImage( &tess.xstages[0]->bundle[0] );
-	GL_State( tess.xstages[0]->stateBits );
-	R_DrawElements( input->numIndexes, input->indexes );
+	for( VBO = input->firstVBO; VBO; VBO = VBO->next ) {
+		vboInfo_t	*dataVBO;
+		
+		if ( VBO->vbo ) {
+			dataVBO = VBO;
+			max = VBO->maxIndex;
+		} else {
+			dataVBO = &backEnd.worldVBO;
+			max = backEnd.worldVBO.maxIndex;
+		}
 
-	// 
-	// now do any dynamic lighting needed
-	//
-	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
-		ProjectDlightTexture();
+		SetAttrPointer( &state, AL_COLOR, dataVBO->vbo,
+				4, GL_UNSIGNED_BYTE, sizeof(vaWord4_t),
+				&dataVBO->offs4->color );
+		SetAttrPointer( &state, AL_TEXCOORD, dataVBO->vbo,
+				2, GL_FLOAT, sizeof(vaWord1_t),
+				&dataVBO->offs1->tc1 );
+		SetAttrPointer( &state, AL_VERTEX, dataVBO->vbo,
+				3, GL_FLOAT, sizeof(vaWord2_t),
+				&dataVBO->offs2->xyz );
+		
+		//
+		// call special shade routine
+		//
+		GL_DrawElements( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx, 
+				 VBO->minIndex, VBO->maxIndex, max );
+		
+		if ( r_showtris->integer && !input->shader->isDepth ) {
+			DrawTris( &state, VBO->numIndexes,
+				  VBO->ibo, VBO->offsIdx,
+				  VBO->minIndex,
+				  VBO->maxIndex, max,
+				  1.0f, 1.0f, 0.0f );
+		}
+		if ( r_shownormals->integer ) {
+			DrawNormals( &state );
+		}
 	}
+	if ( input->numIndexes > 0 ) {
+		vec3_t		*vertexes;
+		vec2_t		*tcs;
+		GLuint		dataVBO;
 
-	//
-	// now do fog
-	//
-	if ( tess.fogNum && tess.shader->fogPass ) {
-		RB_FogPass();
+		//
+		// compute colors
+		//
+		tess.svars.colors = RB_AllocScratch( tess.numVertexes * sizeof(color4ub_t) );
+		RB_CalcDiffuseColor( tess.svars.colors, tess.numVertexes );
+
+		if ( input->vertexPtr1 ) {
+			dataVBO = 0;
+			max = tess.numVertexes-1;
+			vertexes = &input->vertexPtr2[0].xyz;
+			tcs = &input->vertexPtr1[0].tc1;
+		} else {
+			dataVBO = backEnd.worldVBO.vbo;
+			max = backEnd.worldVBO.maxIndex;
+			vertexes = &backEnd.worldVBO.offs2->xyz;
+			tcs = &backEnd.worldVBO.offs1->tc1;
+		}
+		
+		SetAttrPointer( &state, AL_COLOR, 0,
+				4, GL_UNSIGNED_BYTE, sizeof(color4ub_t),
+				tess.svars.colors );
+		SetAttrPointer( &state, AL_TEXCOORD, dataVBO,
+				2, GL_FLOAT, sizeof(vaWord1_t),
+				tcs );
+		SetAttrPointer( &state, AL_VERTEX, dataVBO,
+				3, GL_FLOAT, sizeof(vaWord2_t),
+				vertexes );
+		
+		//
+		// call special shade routine
+		//
+		GL_DrawElements( &state, input->numIndexes,
+				 0, input->indexPtr.p16,
+				 input->minIndex, input->maxIndex, max );
+
+		if ( r_showtris->integer && !input->shader->isDepth ) {
+			DrawTris( &state, input->numIndexes,
+				  0, input->indexPtr.p16,
+				  input->minIndex, input->maxIndex, max,
+				  1.0f, 0.0f, 0.0f );
+		}
+		if ( r_shownormals->integer ) {
+			DrawNormals( &state );
+		}
+		RB_FreeScratch( tess.svars.colors );
 	}
 
-	// 
-	// unlock arrays
-	//
-	if (qglUnlockArraysEXT) 
-	{
-		qglUnlockArraysEXT();
-		GLimp_LogComment( "glUnlockArraysEXT\n" );
+	if( glQueryID ) {
+		GL_EndQuery( glQueryID, glQueryResult );
 	}
 }
 
-//define	REPLACE_MODE
-
 void RB_StageIteratorLightmappedMultitexture( void ) {
 	shaderCommands_t *input;
+	GLuint            max;
+	vboInfo_t        *VBO;
+	glRenderState_t   state;
+	GLuint            glQueryID = 0, *glQueryResult = NULL;
 
 	input = &tess;
 
+	InitState( &state );
+
 	//
 	// log this call
 	//
@@ -1381,88 +1682,657 @@
 	//
 	// set face culling appropriately
 	//
-	GL_Cull( input->shader->cullType );
+	state.stateBits = GLS_DEFAULT;
+	state.faceCulling = input->shader->cullType;
 
-	//
-	// set color, pointers, and lock
-	//
-	GL_State( GLS_DEFAULT );
-	qglVertexPointer( 3, GL_FLOAT, 16, input->xyz );
-
-#ifdef REPLACE_MODE
-	qglDisableClientState( GL_COLOR_ARRAY );
-	qglColor3f( 1, 1, 1 );
-	qglShadeModel( GL_FLAT );
-#else
-	qglEnableClientState( GL_COLOR_ARRAY );
-	qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.constantColor255 );
-#endif
-
-	//
-	// select base stage
-	//
-	GL_SelectTexture( 0 );
+	SetAttrVec4f( &state, AL_COLOR, 1.0f, 1.0f, 1.0f, 1.0f );
 
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-	R_BindAnimatedImage( &tess.xstages[0]->bundle[0] );
-	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
+	state.numImages = 2;
+	R_GetAnimatedImage( &tess.xstages[0]->bundle[0], qfalse, &state.image[0] );
+	R_GetAnimatedImage( &tess.xstages[0]->bundle[1], qfalse, &state.image[1] );
 
-	//
-	// configure second stage
-	//
-	GL_SelectTexture( 1 );
-	qglEnable( GL_TEXTURE_2D );
 	if ( r_lightmap->integer ) {
-		GL_TexEnv( GL_REPLACE );
+		GL_TexEnv( 1, GL_REPLACE );
 	} else {
-		GL_TexEnv( GL_MODULATE );
+		GL_TexEnv( 1, GL_MODULATE );
 	}
-	R_BindAnimatedImage( &tess.xstages[0]->bundle[1] );
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][1] );
 
-	//
-	// lock arrays
-	//
-	if ( qglLockArraysEXT ) {
-		qglLockArraysEXT(0, input->numVertexes);
-		GLimp_LogComment( "glLockArraysEXT\n" );
+	if( qglBeginQueryARB &&
+	    !backEnd.viewParms.portalLevel ) {
+		if ( backEnd.currentEntity == &tr.worldEntity ) {
+			glQueryID = tess.shader->QueryID;
+			glQueryResult = &tess.shader->QueryResult;
+		}
+	}
+	
+	if( glQueryID ) {
+		GL_StartQuery( glQueryID, glQueryResult );
 	}
 
-	R_DrawElements( input->numIndexes, input->indexes );
+	for( VBO = tess.firstVBO; VBO; VBO = VBO->next ) {
+		vboInfo_t	*dataVBO;
+		
+		if ( VBO->vbo ) {
+			dataVBO = VBO;
+			max = VBO->maxIndex;
+		} else {
+			dataVBO = &backEnd.worldVBO;
+			max = backEnd.worldVBO.maxIndex;
+		}
+		//
+		// set color, pointers, and lock
+		//
+		SetAttrPointer( &state, AL_VERTEX, dataVBO->vbo,
+				3, GL_FLOAT, sizeof(vaWord2_t),
+				&dataVBO->offs2->xyz );
+		
+		//
+		// select base stage
+		//
+		SetAttrPointer( &state, AL_TEXCOORD, dataVBO->vbo,
+				2, GL_FLOAT, sizeof(vaWord1_t),
+				&dataVBO->offs1->tc1 );
+		
+		//
+		// configure second stage
+		//
+		SetAttrPointer( &state, AL_TEXCOORD2, dataVBO->vbo,
+				2, GL_FLOAT, sizeof(vaWord1_t),
+				&dataVBO->offs1->tc2 );
+		
+		GL_DrawElements( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				 VBO->minIndex, VBO->maxIndex, max );
+		
+		if ( r_showtris->integer && !input->shader->isDepth ) {
+			DrawTris( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				  VBO->minIndex,
+				  VBO->maxIndex, max,
+				  1.0f, 1.0f, 0.0f );
+		}
+		if ( r_shownormals->integer ) {
+			DrawNormals( &state );
+		}
+	}
+	if ( tess.numIndexes > 0 ) {
+		vec3_t	*vertexes;
+		vec2_t	*tcs1, *tcs2;
+		GLuint   dataVBO;
+
+		if ( tess.vertexPtr1 ) {
+			dataVBO = 0;
+			max = tess.numVertexes-1;
+			vertexes = &input->vertexPtr2[0].xyz;
+			tcs1 = &input->vertexPtr1[0].tc1;
+			tcs2 = &input->vertexPtr1[0].tc2;
+		} else {
+			dataVBO = backEnd.worldVBO.vbo;
+			max = backEnd.worldVBO.maxIndex;
+			vertexes = &backEnd.worldVBO.offs2->xyz;
+			tcs1 = &backEnd.worldVBO.offs1->tc1;
+			tcs2 = &backEnd.worldVBO.offs1->tc2;
+		}
 
-	//
-	// disable texturing on TEXTURE1, then select TEXTURE0
-	//
-	qglDisable( GL_TEXTURE_2D );
-	qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
+		//
+		// set color, pointers, and lock
+		//
+		SetAttrPointer( &state, AL_VERTEX, dataVBO,
+				3, GL_FLOAT, sizeof(vaWord2_t),
+				vertexes );
 
-	GL_SelectTexture( 0 );
-#ifdef REPLACE_MODE
-	GL_TexEnv( GL_MODULATE );
-	qglShadeModel( GL_SMOOTH );
-#endif
+		
+		//
+		// select base stage
+		//
+		SetAttrPointer( &state, AL_TEXCOORD, dataVBO,
+				2, GL_FLOAT, sizeof(vaWord1_t),
+				tcs1 );
+		
+		//
+		// configure second stage
+		//
+		SetAttrPointer( &state, AL_TEXCOORD2, dataVBO,
+				2, GL_FLOAT, sizeof(vaWord1_t),
+				tcs2 );
+		
+		GL_DrawElements( &state, input->numIndexes,
+				 0, input->indexPtr.p16,
+				 input->minIndex, input->maxIndex, max );
 
-	// 
-	// now do any dynamic lighting needed
-	//
-	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
-		ProjectDlightTexture();
+		if ( r_showtris->integer && !input->shader->isDepth ) {
+			DrawTris( &state, input->numIndexes,
+				  0, input->indexPtr.p16,
+				  input->minIndex, input->maxIndex, max,
+				  1.0f, 0.0f, 0.0f );
+		}
+		if ( r_shownormals->integer ) {
+			DrawNormals( &state );
+		}
 	}
 
+	if( glQueryID ) {
+		GL_EndQuery( glQueryID, glQueryResult );
+	}
+}
+
+/*
+** RB_StageIteratorGLSL
+*/
+void RB_StageIteratorGLSL( void ) {
+	shaderCommands_t	*input = &tess;
+	shader_t		*shader = input->shader;
+	GLuint			max;
+	int			i;
+	vboInfo_t		*VBO;
+	glRenderState_t		state;
+	GLuint            glQueryID = 0, *glQueryResult = NULL;
+
 	//
-	// now do fog
+	// log this call
 	//
-	if ( tess.fogNum && tess.shader->fogPass ) {
-		RB_FogPass();
+	if ( r_logFile->integer ) 
+	{
+		// don't just call LogComment, or we will get
+		// a call to va() every frame!
+		GLimp_LogComment( va("--- RB_StageIteratorGLSL( %s ) ---\n", shader->name) );
 	}
 
+	InitState( &state );
 	//
-	// unlock arrays
+	// set face culling appropriately
 	//
-	if ( qglUnlockArraysEXT ) {
-		qglUnlockArraysEXT();
-		GLimp_LogComment( "glUnlockArraysEXT\n" );
+	state.stateBits = shader->stages[0]->stateBits;
+	state.faceCulling = shader->cullType;
+	state.program = shader->GLSLprogram;
+	state.numImages = shader->numUnfoggedPasses;
+
+	// bind all required textures
+	for( i = 0; i < state.numImages; i++ ) {
+		if( !shader->stages[i] )
+			break;
+		
+		R_GetAnimatedImage( &shader->stages[i]->bundle[0], qtrue, &state.image[i] );
+	}
+	if( tess.dataTexture ) {
+		// bind data texture
+		state.image[state.numImages++] = tess.dataTexture;
+	}
+	
+	// bind attributes
+	SetAttrVec4f( &state, AL_CAMERAPOS,
+		      backEnd.viewParms.or.origin[0],
+		      backEnd.viewParms.or.origin[1],
+		      backEnd.viewParms.or.origin[2],
+		      0.0f );
+	if( backEnd.currentEntity->e.reType == RT_SPRITE ) {
+		SetAttrPointer( &state, AL_TIMES, 0,
+				3, GL_FLOAT, sizeof(vaWord3_t),
+				tess.vertexPtr3[0].normal );
+	} else {
+		SetAttrVec4f( &state, AL_TIMES,
+			      tess.shaderTime,
+			      backEnd.currentEntity->e.backlerp,
+			      tess.frameOffs,
+			      tess.oldFrameOffs );
+	}
+
+	if( backEnd.currentEntity->e.reType != RT_MODEL ) {
+		SetAttrVec4f( &state, AL_TRANSX,
+			      1.0f, 0.0f, 0.0f, 0.0f );
+		SetAttrVec4f( &state, AL_TRANSY,
+			      0.0f, 1.0f, 0.0f, 0.0f );
+		SetAttrVec4f( &state, AL_TRANSZ,
+			      0.0f, 0.0f, 1.0f, 0.0f );
+	} else {
+		SetAttrVec4f( &state, AL_TRANSX,
+			      backEnd.currentEntity->e.axis[0][0],
+			      backEnd.currentEntity->e.axis[1][0],
+			      backEnd.currentEntity->e.axis[2][0],
+			      backEnd.currentEntity->e.origin[0] );
+		SetAttrVec4f( &state, AL_TRANSY,
+			      backEnd.currentEntity->e.axis[0][1],
+			      backEnd.currentEntity->e.axis[1][1],
+			      backEnd.currentEntity->e.axis[2][1],
+			      backEnd.currentEntity->e.origin[1] );
+		SetAttrVec4f( &state, AL_TRANSZ,
+			      backEnd.currentEntity->e.axis[0][2],
+			      backEnd.currentEntity->e.axis[1][2],
+			      backEnd.currentEntity->e.axis[2][2],
+			      backEnd.currentEntity->e.origin[2] );
+	}
+	SetAttrVec4f( &state, AL_AMBIENTLIGHT,
+		      backEnd.currentEntity->ambientLight[0] / 255.0f,
+		      backEnd.currentEntity->ambientLight[1] / 255.0f,
+		      backEnd.currentEntity->ambientLight[2] / 255.0f,
+		      1.0f );
+	SetAttrVec4f( &state, AL_DIRECTEDLIGHT,
+		      backEnd.currentEntity->directedLight[0] / 255.0f,
+		      backEnd.currentEntity->directedLight[1] / 255.0f,
+		      backEnd.currentEntity->directedLight[2] / 255.0f,
+		      1.0f );
+	if( backEnd.currentEntity == &tr.worldEntity ||
+	    !backEnd.currentEntity->lightingCalculated ) {
+		SetAttrVec4f( &state, AL_LIGHTDIR,
+			      tr.sunDirection[0],
+			      tr.sunDirection[1],
+			      tr.sunDirection[2],
+			      tr.deluxeOffset );
+	} else {
+		SetAttrVec4f( &state, AL_LIGHTDIR,
+			      backEnd.currentEntity->lightDir[0],
+			      backEnd.currentEntity->lightDir[1],
+			      backEnd.currentEntity->lightDir[2],
+			      tr.deluxeOffset );
+	}
+	
+	if( qglBeginQueryARB &&
+	    !backEnd.viewParms.portalLevel ) {
+		if ( backEnd.currentEntity == &tr.worldEntity ) {
+			glQueryID = tess.shader->QueryID;
+			glQueryResult = &tess.shader->QueryResult;
+		}
+	}
+	
+	if( glQueryID ) {
+		GL_StartQuery( glQueryID, glQueryResult );
+	}
+
+	for( VBO = input->firstVBO; VBO; VBO = VBO->next ) {
+		int		minIndex, maxIndex;
+		vaWord1_t	*word1;
+		vaWord2_t	*word2;
+		vaWord3_t	*word3;
+		vaWord4_t	*word4;
+		vboInfo_t	*dataVBO;
+
+		if ( VBO->vbo ) {
+			dataVBO = VBO;
+		} else {
+			dataVBO = &backEnd.worldVBO;
+		}
+
+		max = dataVBO->maxIndex;
+		word1 = dataVBO->offs1;
+		word2 = dataVBO->offs2;
+		word3 = dataVBO->offs3;
+		word4 = dataVBO->offs4;
+			
+		if( shader->lightmapIndex == LIGHTMAP_MD3 ) {
+			minIndex = 0;
+			maxIndex = max;
+			
+			SetAttrPointer( &state, AL_VERTEX, dataVBO->vbo,
+					4, GL_FLOAT, sizeof(vaWord2_t),
+					&word2->xyz );
+			SetAttrVec4f( &state, AL_NORMAL,
+				      0.0f, 0.0f, 0.0f, 0.0f );
+			SetAttrVec4f( &state, AL_TEXCOORD,
+				      0.0f, 0.0f, 0.0f, 0.0f );
+			SetAttrVec4f( &state, AL_COLOR,
+				      1.0f, 1.0f, 1.0f, 1.0f );
+		} else {
+			minIndex = VBO->minIndex;
+			maxIndex = VBO->maxIndex;
+			
+			SetAttrPointer( &state, AL_VERTEX, dataVBO->vbo,
+					4, GL_FLOAT, sizeof(vaWord2_t),
+					&word2->xyz );
+			SetAttrPointer( &state, AL_NORMAL, dataVBO->vbo,
+					3, GL_FLOAT, sizeof(vaWord3_t),
+					&word3->normal );
+			
+			if( !backEnd.currentEntity->e.shaderRGBA[3] ) {
+				SetAttrPointer( &state, AL_COLOR, dataVBO->vbo,
+						4, GL_UNSIGNED_BYTE, sizeof(vaWord4_t),
+						&word4->color );
+			} else {
+				SetAttrVec4f( &state, AL_COLOR,
+					      backEnd.currentEntity->e.shaderRGBA[0] / 255.0f,
+					      backEnd.currentEntity->e.shaderRGBA[1] / 255.0f,
+					      backEnd.currentEntity->e.shaderRGBA[2] / 255.0f,
+					      backEnd.currentEntity->e.shaderRGBA[3] / 255.0f );
+			}
+			SetAttrPointer( &state, AL_TEXCOORD, dataVBO->vbo,
+					4, GL_FLOAT, sizeof(vaWord1_t),
+					&word1->tc1[0] );
+		
+		}
+		
+		GL_DrawElements( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				 minIndex, maxIndex, max );
+	}
+
+	if ( input->numIndexes > 0 ) {
+		vaWord1_t	*word1;
+		vaWord2_t	*word2;
+		vaWord3_t	*word3;
+		vaWord4_t	*word4;
+		GLuint		dataVBO;
+		
+		if ( input->vertexPtr1 ) {
+			dataVBO = 0;
+			max = input->numIndexes-1;
+			word1 = input->vertexPtr1;
+			word2 = input->vertexPtr2;
+			word3 = input->vertexPtr3;
+			word4 = input->vertexPtr4;
+		} else {
+			dataVBO = backEnd.worldVBO.vbo;
+			max = backEnd.worldVBO.maxIndex;
+			word1 = backEnd.worldVBO.offs1;
+			word2 = backEnd.worldVBO.offs2;
+			word3 = backEnd.worldVBO.offs3;
+			word4 = backEnd.worldVBO.offs4;
+		}
+
+		SetAttrPointer( &state, AL_NORMAL, dataVBO,
+				3, GL_FLOAT, sizeof(vaWord3_t),
+				&word3->normal );
+		
+		SetAttrPointer( &state, AL_VERTEX, dataVBO,
+				4, GL_FLOAT, sizeof(vaWord2_t),
+				&word2->xyz );
+
+		if( !backEnd.currentEntity->e.shaderRGBA[3] ) {
+			SetAttrPointer( &state, AL_COLOR, dataVBO,
+					4, GL_UNSIGNED_BYTE, sizeof(vaWord4_t),
+					&word4->color );
+		} else {
+			SetAttrVec4f( &state, AL_COLOR,
+				      backEnd.currentEntity->e.shaderRGBA[0] / 255.0f,
+				      backEnd.currentEntity->e.shaderRGBA[1] / 255.0f,
+				      backEnd.currentEntity->e.shaderRGBA[2] / 255.0f,
+				      backEnd.currentEntity->e.shaderRGBA[3] / 255.0f );
+		}
+		SetAttrPointer( &state, AL_TEXCOORD, dataVBO,
+				4, GL_FLOAT, sizeof(vaWord1_t),
+				&word1->tc1[0] );
+
+		//
+		// call shader function
+		//
+		GL_DrawElements( &state, input->numIndexes,
+				 0, input->indexPtr.p16,
+				 input->minIndex, input->maxIndex, max );
+	}
+	
+	if ( r_showtris->integer && !shader->isDepth ) {
+		for( VBO = input->firstVBO; VBO; VBO = VBO->next ) {
+			int		minIndex, maxIndex;
+			vboInfo_t	*dataVBO;
+			
+			if ( VBO->vbo ) {
+				dataVBO = VBO;
+			} else {
+				dataVBO = &backEnd.worldVBO;
+			}
+			
+			if( shader->lightmapIndex == LIGHTMAP_MD3 ) {
+				minIndex = 0;
+				maxIndex = dataVBO->maxIndex;
+			} else {
+				minIndex = VBO->minIndex;
+				maxIndex = VBO->maxIndex;
+			}
+			SetAttrPointer( &state, AL_VERTEX, dataVBO->vbo,
+					4, GL_FLOAT, sizeof(vaWord2_t),
+					&dataVBO->offs2->xyz );
+			
+			DrawTris( &state, VBO->numIndexes,
+				  VBO->ibo, VBO->offsIdx,
+				  VBO->minIndex,
+				  VBO->maxIndex, dataVBO->maxIndex,
+				  0.0f, 0.0f, 1.0f );
+		}
+		
+		if ( input->numIndexes > 0 ) {
+			vaWord2_t	*word2;
+			GLuint		dataVBO;
+
+			if ( input->vertexPtr1 ) {
+				dataVBO = 0;
+				max = input->numIndexes-1;
+				word2 = input->vertexPtr2;
+			} else {
+				dataVBO = backEnd.worldVBO.vbo;
+				max = backEnd.worldVBO.maxIndex;
+				word2 = backEnd.worldVBO.offs2;
+			}
+
+			SetAttrPointer( &state, AL_VERTEX, dataVBO,
+					4, GL_FLOAT, sizeof(vaWord2_t),
+					&word2->xyz );
+
+			DrawTris( &state, input->numIndexes,
+				  0, input->indexPtr.p16,
+				  input->minIndex, input->maxIndex, max,
+				  0.0f, 1.0f, 0.0f );
+		}
+	}
+	if ( r_shownormals->integer ) {
+		DrawNormals( &state );
+	}
+
+	if( glQueryID ) {
+		GL_EndQuery( glQueryID, glQueryResult );
+	}
+}
+
+/*
+** RB_StageIteratorPreparePortal
+*/
+void RB_StageIteratorPreparePortal( void ) {
+	vboInfo_t	*VBO;
+	int		level;
+	GLuint		stencilVal, stencilMask;
+	glRenderState_t state;
+	
+	InitState( &state );
+
+	// render mirror area to stencil buffer (depth test enabled)
+	state.stateBits = GLS_COLORMASK_FALSE;
+	state.faceCulling = CT_FRONT_SIDED;
+	level = backEnd.viewParms.portalLevel + 1;
+
+	SetAttrVec4f( &state, AL_COLOR,
+		      (level&4)?1.0f:0.0f,
+		      (level&2)?1.0f:0.0f,
+		      (level&1)?1.0f:0.0f,
+		      1.0f );
+
+	if( !backEnd.viewParms.portalLevel && !r_measureOverdraw->integer ) {
+		qglEnable( GL_STENCIL_TEST );
+	}
+	
+	stencilMask = (level - 1) << glGlobals.shadowBits;
+	stencilVal = (level ^ (level >> 1)) << glGlobals.shadowBits;
+	
+	qglStencilMask( glGlobals.portalMask );
+	qglStencilFunc( GL_EQUAL, stencilVal, stencilMask );
+	qglStencilOp( GL_KEEP, GL_KEEP, GL_REPLACE );
+	
+	for( VBO = tess.firstVBO; VBO; VBO = VBO->next ) {
+		int	max;
+
+		if ( VBO->vbo ) {
+			SetAttrPointer( &state, AL_VERTEX, VBO->vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&VBO->offs2->xyz );
+			max = VBO->maxIndex;
+		} else {
+			SetAttrPointer( &state, AL_VERTEX, backEnd.worldVBO.vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&backEnd.worldVBO.offs2->xyz );
+			max = backEnd.worldVBO.maxIndex;
+		}
+
+		SetAttrVec4f( &state, AL_TEXCOORD, 0.0f, 0.0f, 0.0f, 0.0f );
+		
+		GL_DrawElements( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				 VBO->minIndex, VBO->maxIndex, max );
+	}
+	
+	if ( tess.numIndexes > 0 ) {
+		int	max;
+
+		if ( tess.vertexPtr1 ) {
+			SetAttrPointer( &state, AL_VERTEX, 0,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&tess.vertexPtr2[0].xyz );
+			max = tess.numIndexes-1;
+		} else {
+			SetAttrPointer( &state, AL_VERTEX, backEnd.worldVBO.vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&backEnd.worldVBO.offs2->xyz );
+			max = backEnd.worldVBO.maxIndex;
+		}
+		SetAttrVec4f( &state, AL_TEXCOORD, 0.0f, 0.0f, 0.0f, 0.0f );
+		
+		//
+		// call shader function
+		//
+		GL_DrawElements( &state, tess.numIndexes, 0, tess.indexPtr.p16,
+				 tess.minIndex, tess.maxIndex, max );
+	}
+	
+	// set depth to max on mirror area (depth test disabled)
+	state.stateBits = GLS_COLORMASK_FALSE | GLS_DEPTHMASK_TRUE |
+		GLS_DEPTHRANGE_1_TO_1 | GLS_DEPTHFUNC_ALWAYS;
+
+	if( r_measureOverdraw->integer ) {
+		qglStencilMask( glGlobals.shadowMask );
+		qglStencilFunc( GL_EQUAL, stencilVal, glGlobals.portalMask );
+		qglStencilOp( GL_KEEP, GL_INCR, GL_INCR );
+	} else {
+		qglStencilFunc( GL_EQUAL, stencilVal, glGlobals.portalMask );
+		qglStencilOp( GL_KEEP, GL_KEEP, GL_KEEP );
+	}
+	
+	for( VBO = tess.firstVBO; VBO; VBO = VBO->next ) {
+		int	max;
+
+		if ( VBO->vbo ) {
+			SetAttrPointer( &state, AL_VERTEX, VBO->vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&VBO->offs2->xyz );
+			max = VBO->maxIndex;
+		} else {
+			SetAttrPointer( &state, AL_VERTEX, backEnd.worldVBO.vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&backEnd.worldVBO.offs2->xyz );
+			max = backEnd.worldVBO.maxIndex;
+		}
+
+		GL_DrawElements( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				 VBO->minIndex, VBO->maxIndex, max );
+	}
+	
+	if ( tess.numIndexes > 0 ) {
+		int	max;
+
+		if ( tess.vertexPtr1 ) {
+			SetAttrPointer( &state, AL_VERTEX, 0,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&tess.vertexPtr2[0].xyz );
+			max = tess.numIndexes-1;
+		} else {
+			SetAttrPointer( &state, AL_VERTEX, backEnd.worldVBO.vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&backEnd.worldVBO.offs2->xyz );
+			max = backEnd.worldVBO.maxIndex;
+		}
+		
+		//
+		// call shader function
+		//
+		GL_DrawElements( &state, tess.numIndexes, 0, tess.indexPtr.p16,
+				 tess.minIndex, tess.maxIndex, max );
+	}
+	// keep stencil test enabled !
+}
+
+/*
+** RB_StageIteratorFinalisePortal
+*/
+void RB_StageIteratorFinalisePortal( void ) {
+	vboInfo_t	*VBO;
+	int		level;
+	GLuint		stencilVal, stencilMask;
+	glRenderState_t state;
+
+	InitState( &state );
+	
+	// clear stencil bits
+	state.stateBits = GLS_COLORMASK_FALSE | GLS_DEPTHMASK_TRUE |
+		GLS_DEPTHRANGE_1_TO_1 | GLS_DEPTHFUNC_ALWAYS;
+	state.faceCulling = CT_FRONT_SIDED;
+	SetAttrVec4f( &state, AL_COLOR, 0.0f, 0.0f, 0.0f, 0.0f );
+	SetAttrVec4f( &state, AL_TEXCOORD, 0.0f, 0.0f, 0.0f, 0.0f );
+	
+	level = backEnd.viewParms.portalLevel;
+	stencilMask = level << glGlobals.shadowBits;
+	stencilVal = (level ^ (level >> 1)) << glGlobals.shadowBits;
+	
+	qglStencilMask( glGlobals.portalMask );
+	qglStencilFunc( GL_EQUAL, stencilVal, stencilMask );
+	qglStencilOp( GL_KEEP, GL_KEEP, GL_REPLACE );
+	
+	for( VBO = tess.firstVBO; VBO; VBO = VBO->next ) {
+		int	max;
+
+		if ( VBO->vbo ) {
+			SetAttrPointer( &state, AL_VERTEX, VBO->vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&VBO->offs2->xyz );
+			max = VBO->maxIndex;
+		} else {
+			SetAttrPointer( &state, AL_VERTEX, backEnd.worldVBO.vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&backEnd.worldVBO.offs2->xyz );
+			max = backEnd.worldVBO.maxIndex;
+		}
+
+		GL_DrawElements( &state, VBO->numIndexes, VBO->ibo, VBO->offsIdx,
+				 VBO->minIndex, VBO->maxIndex, max );
+	}
+	
+	if ( tess.numIndexes > 0 ) {
+		int	max;
+
+		if ( tess.vertexPtr1 ) {
+			SetAttrPointer( &state, AL_VERTEX, 0,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&tess.vertexPtr2[0].xyz );
+			max = tess.numIndexes-1;
+		} else {
+			SetAttrPointer( &state, AL_VERTEX, backEnd.worldVBO.vbo,
+					3, GL_FLOAT, sizeof(vaWord2_t),
+					&backEnd.worldVBO.offs2->xyz );
+			max = backEnd.worldVBO.maxIndex;
+		}
+		
+		//
+		// call shader function
+		//
+		GL_DrawElements( &state, tess.numIndexes, 0, tess.indexPtr.p16,
+				 tess.minIndex, tess.maxIndex, max );
+	}
+
+	if( !backEnd.viewParms.portalLevel ) {
+		if( r_measureOverdraw->integer ) {
+			qglStencilMask( glGlobals.shadowMask );
+			qglStencilFunc( GL_ALWAYS, 0, 0 );
+			qglStencilOp( GL_KEEP, GL_INCR, GL_INCR );
+		} else {
+			qglDisable( GL_STENCIL_TEST );
+		}
+	} else {
+		qglStencilFunc( GL_EQUAL, stencilVal, glGlobals.portalMask );
+		if( r_measureOverdraw->integer ) {
+			qglStencilMask( glGlobals.shadowMask );
+			qglStencilOp( GL_KEEP, GL_INCR, GL_INCR );
+		} else {
+			qglStencilOp( GL_KEEP, GL_KEEP, GL_KEEP );
+		}
 	}
 }
 
@@ -1474,15 +2344,14 @@
 
 	input = &tess;
 
-	if (input->numIndexes == 0) {
+	RB_FlushVertexBuffer( );
+
+	if (input->numIndexes == 0 && !input->firstVBO ) {
 		return;
 	}
-
-	if (input->indexes[SHADER_MAX_INDEXES-1] != 0) {
-		ri.Error (ERR_DROP, "RB_EndSurface() - SHADER_MAX_INDEXES hit");
-	}	
-	if (input->xyz[SHADER_MAX_VERTEXES-1][0] != 0) {
-		ri.Error (ERR_DROP, "RB_EndSurface() - SHADER_MAX_VERTEXES hit");
+	
+	if ( !tess.shader ) {
+		return;
 	}
 
 	if ( tess.shader == tr.shadowShader ) {
@@ -1508,18 +2377,78 @@
 	//
 	tess.currentStageIteratorFunc();
 
+	if ( r_flush->integer ) {
+		qglFlush();
+	}
+
+	// clear shader so we can tell we don't have any unclosed surfaces
+	tess.numIndexes = 0;
+	tess.firstVBO = NULL;
+
+	GLimp_LogComment( "----------\n" );
+}
+
+/*
+** RB_LightSurface
+*/
+void RB_LightSurface( void ) {
+	shaderCommands_t *input;
+	glRenderState_t   state;
+
+	input = &tess;
+
+	if (input->numIndexes == 0) {
+		return;
+	}
+
+	// for debugging of sort order issues, stop rendering after a given sort value
+	if ( r_debugSort->integer && r_debugSort->integer < tess.shader->sort ) {
+		return;
+	}
+
+	RB_DeformTessGeometry();
+
 	//
-	// draw debugging stuff
+	// log this call
 	//
-	if ( r_showtris->integer ) {
-		DrawTris (input);
+	if ( r_logFile->integer ) 
+	{
+		// don't just call LogComment, or we will get
+		// a call to va() every frame!
+		GLimp_LogComment( va("--- RB_LightSurface( %s ) ---\n", tess.shader->name) );
 	}
-	if ( r_shownormals->integer ) {
-		DrawNormals (input);
+
+	InitState( &state );
+	//
+	// set face culling appropriately
+	//
+	state.faceCulling = input->shader->cullType;
+
+	SetAttrPointer( &state, AL_VERTEX, 0, 3, GL_FLOAT, sizeof(vaWord2_t),
+			input->vertexPtr2[0].xyz);
+
+	// 
+	// now do any dynamic lighting needed
+	//
+	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE
+	     && !(tess.shader->surfaceFlags & (SURF_NODLIGHT | SURF_SKY) ) ) {
+		ProjectDlightTexture( &state );
 	}
+	
+	//
+	// now do fog
+	//
+	if ( tess.fogNum && tess.shader->fogPass ) {
+		RB_FogPass( &state );
+	}
+
+	if ( r_flush->integer ) {
+		qglFlush();
+	}
+
 	// clear shader so we can tell we don't have any unclosed surfaces
 	tess.numIndexes = 0;
+	tess.firstVBO = NULL;
 
 	GLimp_LogComment( "----------\n" );
 }
-
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_shade_calc.c tremulous-ggp1-src/src/renderer/tr_shade_calc.c
--- tremulous-ggp1-src.p/src/renderer/tr_shade_calc.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_shade_calc.c	2012-07-19 04:25:52.021556447 +0200
@@ -87,7 +87,7 @@
 /*
 ** RB_CalcStretchTexCoords
 */
-void RB_CalcStretchTexCoords( const waveForm_t *wf, float *st )
+void RB_CalcStretchTexCoords( const waveForm_t *wf, vec2_t *st, int numVertexes )
 {
 	float p;
 	texModInfo_t tmi;
@@ -102,7 +102,7 @@
 	tmi.matrix[1][1] = p;
 	tmi.translate[1] = 0.5f - 0.5f * p;
 
-	RB_CalcTransformTexCoords( &tmi, st );
+	RB_CalcTransformTexCoords( &tmi, st, numVertexes );
 }
 
 /*
@@ -122,43 +122,44 @@
 void RB_CalcDeformVertexes( deformStage_t *ds )
 {
 	int i;
+	vec3_t	*normal;
 	vec3_t	offset;
 	float	scale;
-	float	*xyz = ( float * ) tess.xyz;
-	float	*normal = ( float * ) tess.normal;
 	float	*table;
 
 	if ( ds->deformationWave.frequency == 0 )
 	{
 		scale = EvalWaveForm( &ds->deformationWave );
 
-		for ( i = 0; i < tess.numVertexes; i++, xyz += 4, normal += 4 )
+		for ( i = 0; i < tess.numVertexes; i++ )
 		{
-			VectorScale( normal, scale, offset );
+			normal = &tess.vertexPtr3[i].normal;
+			VectorScale( *normal, scale, offset );
 			
-			xyz[0] += offset[0];
-			xyz[1] += offset[1];
-			xyz[2] += offset[2];
+			tess.vertexPtr2[i].xyz[0] += offset[0];
+			tess.vertexPtr2[i].xyz[1] += offset[1];
+			tess.vertexPtr2[i].xyz[2] += offset[2];
 		}
 	}
 	else
 	{
 		table = TableForFunc( ds->deformationWave.func );
 
-		for ( i = 0; i < tess.numVertexes; i++, xyz += 4, normal += 4 )
+		for ( i = 0; i < tess.numVertexes; i++ )
 		{
-			float off = ( xyz[0] + xyz[1] + xyz[2] ) * ds->deformationSpread;
+			float off = ( tess.vertexPtr2[i].xyz[0] + tess.vertexPtr2[i].xyz[1] + tess.vertexPtr2[i].xyz[2] ) * ds->deformationSpread;
 
 			scale = WAVEVALUE( table, ds->deformationWave.base, 
 				ds->deformationWave.amplitude,
 				ds->deformationWave.phase + off,
 				ds->deformationWave.frequency );
 
-			VectorScale( normal, scale, offset );
+			normal = &tess.vertexPtr3[i].normal;
+			VectorScale( *normal, scale, offset );
 			
-			xyz[0] += offset[0];
-			xyz[1] += offset[1];
-			xyz[2] += offset[2];
+			tess.vertexPtr2[i].xyz[0] += offset[0];
+			tess.vertexPtr2[i].xyz[1] += offset[1];
+			tess.vertexPtr2[i].xyz[2] += offset[2];
 		}
 	}
 }
@@ -173,26 +174,25 @@
 void RB_CalcDeformNormals( deformStage_t *ds ) {
 	int i;
 	float	scale;
-	float	*xyz = ( float * ) tess.xyz;
-	float	*normal = ( float * ) tess.normal;
+	vec3_t	*normal;
+
+	for ( i = 0; i < tess.numVertexes; i++ ) {
+		normal = &tess.vertexPtr3[i].normal;
 
-	for ( i = 0; i < tess.numVertexes; i++, xyz += 4, normal += 4 ) {
 		scale = 0.98f;
-		scale = R_NoiseGet4f( xyz[0] * scale, xyz[1] * scale, xyz[2] * scale,
+		scale = R_NoiseGet4f( tess.vertexPtr2[i].xyz[0] * scale, tess.vertexPtr2[i].xyz[1] * scale, tess.vertexPtr2[i].xyz[2] * scale,
 			tess.shaderTime * ds->deformationWave.frequency );
-		normal[ 0 ] += ds->deformationWave.amplitude * scale;
+		(*normal)[ 0 ] += ds->deformationWave.amplitude * scale;
 
 		scale = 0.98f;
-		scale = R_NoiseGet4f( 100 + xyz[0] * scale, xyz[1] * scale, xyz[2] * scale,
+		scale = R_NoiseGet4f( 100 + tess.vertexPtr2[i].xyz[0] * scale, tess.vertexPtr2[i].xyz[1] * scale, tess.vertexPtr2[i].xyz[2] * scale,
 			tess.shaderTime * ds->deformationWave.frequency );
-		normal[ 1 ] += ds->deformationWave.amplitude * scale;
+		(*normal)[ 1 ] += ds->deformationWave.amplitude * scale;
 
 		scale = 0.98f;
-		scale = R_NoiseGet4f( 200 + xyz[0] * scale, xyz[1] * scale, xyz[2] * scale,
+		scale = R_NoiseGet4f( 200 + tess.vertexPtr2[i].xyz[0] * scale, tess.vertexPtr2[i].xyz[1] * scale, tess.vertexPtr2[i].xyz[2] * scale,
 			tess.shaderTime * ds->deformationWave.frequency );
-		normal[ 2 ] += ds->deformationWave.amplitude * scale;
-
-		VectorNormalizeFast( normal );
+		(*normal)[ 2 ] += ds->deformationWave.amplitude * scale;
 	}
 }
 
@@ -204,24 +204,23 @@
 */
 void RB_CalcBulgeVertexes( deformStage_t *ds ) {
 	int i;
-	const float *st = ( const float * ) tess.texCoords[0];
-	float		*xyz = ( float * ) tess.xyz;
-	float		*normal = ( float * ) tess.normal;
 	float		now;
 
 	now = backEnd.refdef.time * ds->bulgeSpeed * 0.001f;
 
-	for ( i = 0; i < tess.numVertexes; i++, xyz += 4, st += 4, normal += 4 ) {
+	for ( i = 0; i < tess.numVertexes; i++ ) {
 		int		off;
 		float scale;
+		vec3_t	*normal;
 
-		off = (float)( FUNCTABLE_SIZE / (M_PI*2) ) * ( st[0] * ds->bulgeWidth + now );
+		off = (float)( FUNCTABLE_SIZE / (M_PI*2) ) * ( tess.vertexPtr1[i].tc1[0] * ds->bulgeWidth + now );
 
 		scale = tr.sinTable[ off & FUNCTABLE_MASK ] * ds->bulgeHeight;
-			
-		xyz[0] += normal[0] * scale;
-		xyz[1] += normal[1] * scale;
-		xyz[2] += normal[2] * scale;
+		
+		normal = &tess.vertexPtr3[i].normal;
+		tess.vertexPtr2[i].xyz[0] += (*normal)[0] * scale;
+		tess.vertexPtr2[i].xyz[1] += (*normal)[1] * scale;
+		tess.vertexPtr2[i].xyz[2] += (*normal)[2] * scale;
 	}
 }
 
@@ -235,7 +234,6 @@
 */
 void RB_CalcMoveVertexes( deformStage_t *ds ) {
 	int			i;
-	float		*xyz;
 	float		*table;
 	float		scale;
 	vec3_t		offset;
@@ -249,9 +247,8 @@
 
 	VectorScale( ds->moveVector, scale, offset );
 
-	xyz = ( float * ) tess.xyz;
-	for ( i = 0; i < tess.numVertexes; i++, xyz += 4 ) {
-		VectorAdd( xyz, offset, xyz );
+	for ( i = 0; i < tess.numVertexes; i++ ) {
+		VectorAdd( tess.vertexPtr2[i].xyz, offset, tess.vertexPtr2[i].xyz );
 	}
 }
 
@@ -266,6 +263,7 @@
 void DeformText( const char *text ) {
 	int		i;
 	vec3_t	origin, width, height;
+	vec3_t	*normal;
 	int		len;
 	int		ch;
 	byte	color[4];
@@ -275,19 +273,20 @@
 	height[0] = 0;
 	height[1] = 0;
 	height[2] = -1;
-	CrossProduct( tess.normal[0], height, width );
+	normal = &tess.vertexPtr3[0].normal;
+	CrossProduct( *normal, height, width );
 
 	// find the midpoint of the box
 	VectorClear( mid );
 	bottom = 999999;
 	top = -999999;
 	for ( i = 0 ; i < 4 ; i++ ) {
-		VectorAdd( tess.xyz[i], mid, mid );
-		if ( tess.xyz[i][2] < bottom ) {
-			bottom = tess.xyz[i][2];
+		VectorAdd( tess.vertexPtr2[i].xyz, mid, mid );
+		if ( tess.vertexPtr2[i].xyz[2] < bottom ) {
+			bottom = tess.vertexPtr2[i].xyz[2];
 		}
-		if ( tess.xyz[i][2] > top ) {
-			top = tess.xyz[i][2];
+		if ( tess.vertexPtr2[i].xyz[2] > top ) {
+			top = tess.vertexPtr2[i].xyz[2];
 		}
 	}
 	VectorScale( mid, 0.25f, origin );
@@ -353,7 +352,6 @@
 static void AutospriteDeform( void ) {
 	int		i;
 	int		oldVerts;
-	float	*xyz;
 	vec3_t	mid, delta;
 	float	radius;
 	vec3_t	left, up;
@@ -380,13 +378,11 @@
 
 	for ( i = 0 ; i < oldVerts ; i+=4 ) {
 		// find the midpoint
-		xyz = tess.xyz[i];
-
-		mid[0] = 0.25f * (xyz[0] + xyz[4] + xyz[8] + xyz[12]);
-		mid[1] = 0.25f * (xyz[1] + xyz[5] + xyz[9] + xyz[13]);
-		mid[2] = 0.25f * (xyz[2] + xyz[6] + xyz[10] + xyz[14]);
+		mid[0] = 0.25f * (tess.vertexPtr2[i].xyz[0] + tess.vertexPtr2[i+1].xyz[0] + tess.vertexPtr2[i+2].xyz[0] + tess.vertexPtr2[i+3].xyz[0]);
+		mid[1] = 0.25f * (tess.vertexPtr2[i].xyz[1] + tess.vertexPtr2[i+1].xyz[1] + tess.vertexPtr2[i+2].xyz[1] + tess.vertexPtr2[i+3].xyz[1]);
+		mid[2] = 0.25f * (tess.vertexPtr2[i].xyz[2] + tess.vertexPtr2[i+1].xyz[2] + tess.vertexPtr2[i+2].xyz[2] + tess.vertexPtr2[i+3].xyz[2]);
 
-		VectorSubtract( xyz, mid, delta );
+		VectorSubtract( tess.vertexPtr2[i].xyz, mid, delta );
 		radius = VectorLength( delta ) * 0.707f;		// / sqrt(2)
 
 		VectorScale( leftDir, radius, left );
@@ -396,20 +392,20 @@
 			VectorSubtract( vec3_origin, left, left );
 		}
 
-	  // compensate for scale in the axes if necessary
-  	if ( backEnd.currentEntity->e.nonNormalizedAxes ) {
-      float axisLength;
-		  axisLength = VectorLength( backEnd.currentEntity->e.axis[0] );
-  		if ( !axisLength ) {
-	  		axisLength = 0;
-  		} else {
-	  		axisLength = 1.0f / axisLength;
-  		}
-      VectorScale(left, axisLength, left);
-      VectorScale(up, axisLength, up);
-    }
-
-		RB_AddQuadStamp( mid, left, up, tess.vertexColors[i] );
+		// compensate for scale in the axes if necessary
+		if ( backEnd.currentEntity->e.nonNormalizedAxes ) {
+			float axisLength;
+			axisLength = VectorLength( backEnd.currentEntity->e.axis[0] );
+			if ( !axisLength ) {
+				axisLength = 0;
+			} else {
+				axisLength = 1.0f / axisLength;
+			}
+			VectorScale(left, axisLength, left);
+			VectorScale(up, axisLength, up);
+		}
+		
+		RB_AddQuadStamp( mid, left, up, tess.vertexPtr4[i].color );
 	}
 }
 
@@ -433,7 +429,6 @@
 static void Autosprite2Deform( void ) {
 	int		i, j, k;
 	int		indexes;
-	float	*xyz;
 	vec3_t	forward;
 
 	if ( tess.numVertexes & 3 ) {
@@ -457,10 +452,7 @@
 		int		nums[2];
 		vec3_t	mid[2];
 		vec3_t	major, minor;
-		float	*v1, *v2;
-
-		// find the midpoint
-		xyz = tess.xyz[i];
+		vec3_t	*v1, *v2;
 
 		// identify the two shortest edges
 		nums[0] = nums[1] = 0;
@@ -470,8 +462,8 @@
 			float	l;
 			vec3_t	temp;
 
-			v1 = xyz + 4 * edgeVerts[j][0];
-			v2 = xyz + 4 * edgeVerts[j][1];
+			v1 = &tess.vertexPtr2[edgeVerts[j][0]].xyz;
+			v2 = &tess.vertexPtr2[edgeVerts[j][1]].xyz;
 
 			VectorSubtract( v1, v2, temp );
 			
@@ -488,12 +480,12 @@
 		}
 
 		for ( j = 0 ; j < 2 ; j++ ) {
-			v1 = xyz + 4 * edgeVerts[nums[j]][0];
-			v2 = xyz + 4 * edgeVerts[nums[j]][1];
+			v1 = &tess.vertexPtr2[edgeVerts[j][0]].xyz;
+			v2 = &tess.vertexPtr2[edgeVerts[j][1]].xyz;
 
-			mid[j][0] = 0.5f * (v1[0] + v2[0]);
-			mid[j][1] = 0.5f * (v1[1] + v2[1]);
-			mid[j][2] = 0.5f * (v1[2] + v2[2]);
+			mid[j][0] = 0.5f * ((*v1)[0] + (*v2)[0]);
+			mid[j][1] = 0.5f * ((*v1)[1] + (*v2)[1]);
+			mid[j][2] = 0.5f * ((*v1)[2] + (*v2)[2]);
 		}
 
 		// find the vector of the major axis
@@ -507,26 +499,26 @@
 		for ( j = 0 ; j < 2 ; j++ ) {
 			float	l;
 
-			v1 = xyz + 4 * edgeVerts[nums[j]][0];
-			v2 = xyz + 4 * edgeVerts[nums[j]][1];
+			v1 = &tess.vertexPtr2[edgeVerts[j][0]].xyz;
+			v2 = &tess.vertexPtr2[edgeVerts[j][1]].xyz;
 
 			l = 0.5 * sqrt( lengths[j] );
 			
 			// we need to see which direction this edge
 			// is used to determine direction of projection
 			for ( k = 0 ; k < 5 ; k++ ) {
-				if ( tess.indexes[ indexes + k ] == i + edgeVerts[nums[j]][0]
-					&& tess.indexes[ indexes + k + 1 ] == i + edgeVerts[nums[j]][1] ) {
+				if ( tess.indexPtr.p16[ indexes + k ] == i + edgeVerts[nums[j]][0]
+					&& tess.indexPtr.p16[ indexes + k + 1 ] == i + edgeVerts[nums[j]][1] ) {
 					break;
 				}
 			}
 
 			if ( k == 5 ) {
-				VectorMA( mid[j], l, minor, v1 );
-				VectorMA( mid[j], -l, minor, v2 );
+				VectorMA( mid[j], l, minor, *v1 );
+				VectorMA( mid[j], -l, minor, *v2 );
 			} else {
-				VectorMA( mid[j], -l, minor, v1 );
-				VectorMA( mid[j], l, minor, v2 );
+				VectorMA( mid[j], -l, minor, *v1 );
+				VectorMA( mid[j], l, minor, *v2 );
 			}
 		}
 	}
@@ -547,8 +539,8 @@
 		ds = &tess.shader->deforms[ i ];
 
 		switch ( ds->deformation ) {
-        case DEFORM_NONE:
-            break;
+		case DEFORM_NONE:
+			break;
 		case DEFORM_NORMALS:
 			RB_CalcDeformNormals( ds );
 			break;
@@ -596,7 +588,7 @@
 /*
 ** RB_CalcColorFromEntity
 */
-void RB_CalcColorFromEntity( unsigned char *dstColors )
+void RB_CalcColorFromEntity( color4ub_t *dstColors, int numVertexes )
 {
 	int	i;
 	int *pColors = ( int * ) dstColors;
@@ -607,7 +599,7 @@
 
 	c = * ( int * ) backEnd.currentEntity->e.shaderRGBA;
 
-	for ( i = 0; i < tess.numVertexes; i++, pColors++ )
+	for ( i = 0; i < numVertexes; i++, pColors++ )
 	{
 		*pColors = c;
 	}
@@ -616,7 +608,7 @@
 /*
 ** RB_CalcColorFromOneMinusEntity
 */
-void RB_CalcColorFromOneMinusEntity( unsigned char *dstColors )
+void RB_CalcColorFromOneMinusEntity( color4ub_t *dstColors, int numVertexes )
 {
 	int	i;
 	int *pColors = ( int * ) dstColors;
@@ -633,7 +625,7 @@
 
 	c = * ( int * ) invModulate;
 
-	for ( i = 0; i < tess.numVertexes; i++, pColors++ )
+	for ( i = 0; i < numVertexes; i++, pColors++ )
 	{
 		*pColors = * ( int * ) invModulate;
 	}
@@ -642,52 +634,48 @@
 /*
 ** RB_CalcAlphaFromEntity
 */
-void RB_CalcAlphaFromEntity( unsigned char *dstColors )
+void RB_CalcAlphaFromEntity( color4ub_t *dstColors, int numVertexes )
 {
 	int	i;
 
 	if ( !backEnd.currentEntity )
 		return;
 
-	dstColors += 3;
-
-	for ( i = 0; i < tess.numVertexes; i++, dstColors += 4 )
+	for ( i = 0; i < numVertexes; i++, dstColors++ )
 	{
-		*dstColors = backEnd.currentEntity->e.shaderRGBA[3];
+		(*dstColors)[3] = backEnd.currentEntity->e.shaderRGBA[3];
 	}
 }
 
 /*
 ** RB_CalcAlphaFromOneMinusEntity
 */
-void RB_CalcAlphaFromOneMinusEntity( unsigned char *dstColors )
+void RB_CalcAlphaFromOneMinusEntity( color4ub_t *dstColors, int numVertexes )
 {
 	int	i;
 
 	if ( !backEnd.currentEntity )
 		return;
 
-	dstColors += 3;
-
-	for ( i = 0; i < tess.numVertexes; i++, dstColors += 4 )
+	for ( i = 0; i < numVertexes; i++, dstColors++ )
 	{
-		*dstColors = 0xff - backEnd.currentEntity->e.shaderRGBA[3];
+		(*dstColors)[3] = 0xff - backEnd.currentEntity->e.shaderRGBA[3];
 	}
 }
 
 /*
 ** RB_CalcWaveColor
 */
-void RB_CalcWaveColor( const waveForm_t *wf, unsigned char *dstColors )
+void RB_CalcWaveColor( const waveForm_t *wf, color4ub_t *dstColors, int numVertexes )
 {
 	int i;
 	int v;
 	float glow;
 	int *colors = ( int * ) dstColors;
-	byte	color[4];
+	color4ub_t	color;
 
 
-  if ( wf->func == GF_NOISE ) {
+	if ( wf->func == GF_NOISE ) {
 		glow = wf->base + R_NoiseGet4f( 0, 0, 0, ( tess.shaderTime + wf->phase ) * wf->frequency ) * wf->amplitude;
 	} else {
 		glow = EvalWaveForm( wf ) * tr.identityLight;
@@ -705,7 +693,7 @@
 	color[3] = 255;
 	v = *(int *)color;
 	
-	for ( i = 0; i < tess.numVertexes; i++, colors++ ) {
+	for ( i = 0; i < numVertexes; i++, colors++ ) {
 		*colors = v;
 	}
 }
@@ -713,7 +701,7 @@
 /*
 ** RB_CalcWaveAlpha
 */
-void RB_CalcWaveAlpha( const waveForm_t *wf, unsigned char *dstColors )
+void RB_CalcWaveAlpha( const waveForm_t *wf, color4ub_t *dstColors, int numVertexes )
 {
 	int i;
 	int v;
@@ -723,69 +711,75 @@
 
 	v = 255 * glow;
 
-	for ( i = 0; i < tess.numVertexes; i++, dstColors += 4 )
+	for ( i = 0; i < numVertexes; i++, dstColors++ )
 	{
-		dstColors[3] = v;
+		(*dstColors)[3] = v;
 	}
 }
 
 /*
 ** RB_CalcModulateColorsByFog
 */
-void RB_CalcModulateColorsByFog( unsigned char *colors ) {
+void RB_CalcModulateColorsByFog( color4ub_t *colors, int numVertexes ) {
 	int		i;
-	float	texCoords[SHADER_MAX_VERTEXES][2];
+	vec2_t	*texCoords;
 
 	// calculate texcoords so we can derive density
 	// this is not wasted, because it would only have
 	// been previously called if the surface was opaque
-	RB_CalcFogTexCoords( texCoords[0] );
+	texCoords = RB_AllocScratch( sizeof(vec2_t) * numVertexes );
+	RB_CalcFogTexCoords( texCoords, numVertexes );
 
-	for ( i = 0; i < tess.numVertexes; i++, colors += 4 ) {
+	for ( i = 0; i < numVertexes; i++, colors++ ) {
 		float f = 1.0 - R_FogFactor( texCoords[i][0], texCoords[i][1] );
-		colors[0] *= f;
-		colors[1] *= f;
-		colors[2] *= f;
+		(*colors)[0] *= f;
+		(*colors)[1] *= f;
+		(*colors)[2] *= f;
 	}
+	RB_FreeScratch( texCoords );
 }
 
 /*
 ** RB_CalcModulateAlphasByFog
 */
-void RB_CalcModulateAlphasByFog( unsigned char *colors ) {
+void RB_CalcModulateAlphasByFog( color4ub_t *colors, int numVertexes ) {
 	int		i;
-	float	texCoords[SHADER_MAX_VERTEXES][2];
+	vec2_t	*texCoords;
 
 	// calculate texcoords so we can derive density
 	// this is not wasted, because it would only have
 	// been previously called if the surface was opaque
-	RB_CalcFogTexCoords( texCoords[0] );
+	texCoords = RB_AllocScratch( sizeof(vec2_t) * numVertexes );
+	RB_CalcFogTexCoords( texCoords, numVertexes );
 
-	for ( i = 0; i < tess.numVertexes; i++, colors += 4 ) {
+	for ( i = 0; i < numVertexes; i++, colors++ ) {
 		float f = 1.0 - R_FogFactor( texCoords[i][0], texCoords[i][1] );
-		colors[3] *= f;
+		(*colors)[3] *= f;
 	}
+	RB_FreeScratch( texCoords );
 }
 
 /*
 ** RB_CalcModulateRGBAsByFog
 */
-void RB_CalcModulateRGBAsByFog( unsigned char *colors ) {
+void RB_CalcModulateRGBAsByFog( color4ub_t *colors, int numVertexes ) {
 	int		i;
-	float	texCoords[SHADER_MAX_VERTEXES][2];
+	vec2_t	*texCoords;
 
 	// calculate texcoords so we can derive density
 	// this is not wasted, because it would only have
 	// been previously called if the surface was opaque
-	RB_CalcFogTexCoords( texCoords[0] );
+	texCoords = RB_AllocScratch( sizeof(vec2_t) * numVertexes );
+	RB_CalcFogTexCoords( texCoords, numVertexes );
 
-	for ( i = 0; i < tess.numVertexes; i++, colors += 4 ) {
+	for ( i = 0; i < numVertexes; i++, colors++ ) {
 		float f = 1.0 - R_FogFactor( texCoords[i][0], texCoords[i][1] );
-		colors[0] *= f;
-		colors[1] *= f;
-		colors[2] *= f;
-		colors[3] *= f;
+		(*colors)[0] *= f;
+		(*colors)[1] *= f;
+		(*colors)[2] *= f;
+		(*colors)[3] *= f;
 	}
+	RB_FreeScratch( texCoords );
 }
 
 
@@ -806,9 +800,8 @@
 doesn't fit our shader data.
 ========================
 */
-void RB_CalcFogTexCoords( float *st ) {
+void RB_CalcFogTexCoords( vec2_t *st, int numVertexes ) {
 	int			i;
-	float		*v;
 	float		s, t;
 	float		eyeT;
 	qboolean	eyeOutside;
@@ -858,10 +851,10 @@
 	fogDistanceVector[3] += 1.0/512;
 
 	// calculate density for each point
-	for (i = 0, v = tess.xyz[0] ; i < tess.numVertexes ; i++, v += 4) {
+	for (i = 0 ; i < numVertexes ; i++, st++ ) {
 		// calculate the length in fog
-		s = DotProduct( v, fogDistanceVector ) + fogDistanceVector[3];
-		t = DotProduct( v, fogDepthVector ) + fogDepthVector[3];
+		s = DotProduct( tess.vertexPtr2[i].xyz, fogDistanceVector ) + fogDistanceVector[3];
+		t = DotProduct( tess.vertexPtr2[i].xyz, fogDepthVector ) + fogDepthVector[3];
 
 		// partially clipped fogs use the T axis		
 		if ( eyeOutside ) {
@@ -878,9 +871,8 @@
 			}
 		}
 
-		st[0] = s;
-		st[1] = t;
-		st += 2;
+		(*st)[0] = s;
+		(*st)[1] = t;
 	}
 }
 
@@ -889,70 +881,68 @@
 /*
 ** RB_CalcEnvironmentTexCoords
 */
-void RB_CalcEnvironmentTexCoords( float *st ) 
+void RB_CalcEnvironmentTexCoords( vec2_t *st, int numVertexes )
 {
-	int			i;
-	float		*v, *normal;
+	int		i;
+	vec3_t		*normal;
 	vec3_t		viewer, reflected;
 	float		d;
 
-	v = tess.xyz[0];
-	normal = tess.normal[0];
-
-	for (i = 0 ; i < tess.numVertexes ; i++, v += 4, normal += 4, st += 2 ) 
+	for (i = 0 ; i < numVertexes ; i++, st++ ) 
 	{
-		VectorSubtract (backEnd.or.viewOrigin, v, viewer);
+		VectorSubtract (backEnd.or.viewOrigin, tess.vertexPtr2[i].xyz, viewer);
 		VectorNormalizeFast (viewer);
 
-		d = DotProduct (normal, viewer);
+		normal = &tess.vertexPtr3[i].normal;
+		d = DotProduct (*normal, viewer);
 
-		reflected[0] = normal[0]*2*d - viewer[0];
-		reflected[1] = normal[1]*2*d - viewer[1];
-		reflected[2] = normal[2]*2*d - viewer[2];
+		reflected[0] = (*normal[0])*2*d - viewer[0];
+		reflected[1] = (*normal[1])*2*d - viewer[1];
+		reflected[2] = (*normal[2])*2*d - viewer[2];
 
-		st[0] = 0.5 + reflected[1] * 0.5;
-		st[1] = 0.5 - reflected[2] * 0.5;
+		(*st)[0] = 0.5 + reflected[1] * 0.5;
+		(*st)[1] = 0.5 - reflected[2] * 0.5;
 	}
 }
 
 /*
 ** RB_CalcTurbulentTexCoords
 */
-void RB_CalcTurbulentTexCoords( const waveForm_t *wf, float *st )
+void RB_CalcTurbulentTexCoords( const waveForm_t *wf, vec2_t *st, int numVertexes )
 {
 	int i;
 	float now;
 
 	now = ( wf->phase + tess.shaderTime * wf->frequency );
 
-	for ( i = 0; i < tess.numVertexes; i++, st += 2 )
+	for ( i = 0; i < numVertexes; i++, st++ )
 	{
-		float s = st[0];
-		float t = st[1];
+		float s = (*st)[0];
+		float t = (*st)[1];
 
-		st[0] = s + tr.sinTable[ ( ( int ) ( ( ( tess.xyz[i][0] + tess.xyz[i][2] )* 1.0/128 * 0.125 + now ) * FUNCTABLE_SIZE ) ) & ( FUNCTABLE_MASK ) ] * wf->amplitude;
-		st[1] = t + tr.sinTable[ ( ( int ) ( ( tess.xyz[i][1] * 1.0/128 * 0.125 + now ) * FUNCTABLE_SIZE ) ) & ( FUNCTABLE_MASK ) ] * wf->amplitude;
+		(*st)[0] = s + tr.sinTable[ ( ( int ) ( ( ( tess.vertexPtr2[i].xyz[0] + tess.vertexPtr2[i].xyz[2] )* 1.0/128 * 0.125 + now ) * FUNCTABLE_SIZE ) ) & ( FUNCTABLE_MASK ) ] * wf->amplitude;
+		(*st)[1] = t + tr.sinTable[ ( ( int ) ( ( tess.vertexPtr2[i].xyz[1] * 1.0/128 * 0.125 + now ) * FUNCTABLE_SIZE ) ) & ( FUNCTABLE_MASK ) ] * wf->amplitude;
 	}
 }
 
 /*
 ** RB_CalcScaleTexCoords
 */
-void RB_CalcScaleTexCoords( const float scale[2], float *st )
+void RB_CalcScaleTexCoords( const float scale[2], vec2_t *st, int numVertexes )
 {
 	int i;
 
-	for ( i = 0; i < tess.numVertexes; i++, st += 2 )
+	for ( i = 0; i < numVertexes; i++, st++ )
 	{
-		st[0] *= scale[0];
-		st[1] *= scale[1];
+		(*st)[0] *= scale[0];
+		(*st)[1] *= scale[1];
 	}
 }
 
 /*
 ** RB_CalcScrollTexCoords
 */
-void RB_CalcScrollTexCoords( const float scrollSpeed[2], float *st )
+void RB_CalcScrollTexCoords( const float scrollSpeed[2], vec2_t *st, int numVertexes )
 {
 	int i;
 	float timeScale = tess.shaderTime;
@@ -966,34 +956,34 @@
 	adjustedScrollS = adjustedScrollS - floor( adjustedScrollS );
 	adjustedScrollT = adjustedScrollT - floor( adjustedScrollT );
 
-	for ( i = 0; i < tess.numVertexes; i++, st += 2 )
+	for ( i = 0; i < numVertexes; i++, st++ )
 	{
-		st[0] += adjustedScrollS;
-		st[1] += adjustedScrollT;
+		(*st)[0] += adjustedScrollS;
+		(*st)[1] += adjustedScrollT;
 	}
 }
 
 /*
 ** RB_CalcTransformTexCoords
 */
-void RB_CalcTransformTexCoords( const texModInfo_t *tmi, float *st  )
+void RB_CalcTransformTexCoords( const texModInfo_t *tmi, vec2_t *st, int numVertexes )
 {
 	int i;
 
-	for ( i = 0; i < tess.numVertexes; i++, st += 2 )
+	for ( i = 0; i < numVertexes; i++, st++ )
 	{
-		float s = st[0];
-		float t = st[1];
+		float s = (*st)[0];
+		float t = (*st)[1];
 
-		st[0] = s * tmi->matrix[0][0] + t * tmi->matrix[1][0] + tmi->translate[0];
-		st[1] = s * tmi->matrix[0][1] + t * tmi->matrix[1][1] + tmi->translate[1];
+		(*st)[0] = s * tmi->matrix[0][0] + t * tmi->matrix[1][0] + tmi->translate[0];
+		(*st)[1] = s * tmi->matrix[0][1] + t * tmi->matrix[1][1] + tmi->translate[1];
 	}
 }
 
 /*
 ** RB_CalcRotateTexCoords
 */
-void RB_CalcRotateTexCoords( float degsPerSecond, float *st )
+void RB_CalcRotateTexCoords( float degsPerSecond, vec2_t *st, int numVertexes )
 {
 	float timeScale = tess.shaderTime;
 	float degs;
@@ -1015,7 +1005,7 @@
 	tmi.matrix[1][1] = cosValue;
 	tmi.translate[1] = 0.5 - 0.5 * sinValue - 0.5 * cosValue;
 
-	RB_CalcTransformTexCoords( &tmi, st );
+	RB_CalcTransformTexCoords( &tmi, st, numVertexes );
 }
 
 
@@ -1041,39 +1031,33 @@
 */
 vec3_t lightOrigin = { -960, 1980, 96 };		// FIXME: track dynamically
 
-void RB_CalcSpecularAlpha( unsigned char *alphas ) {
+void RB_CalcSpecularAlpha( color4ub_t *alphas, int numVertexes ) {
 	int			i;
-	float		*v, *normal;
+	vec3_t		*normal;
 	vec3_t		viewer,  reflected;
 	float		l, d;
 	int			b;
 	vec3_t		lightDir;
-	int			numVertexes;
-
-	v = tess.xyz[0];
-	normal = tess.normal[0];
-
-	alphas += 3;
 
-	numVertexes = tess.numVertexes;
-	for (i = 0 ; i < numVertexes ; i++, v += 4, normal += 4, alphas += 4) {
+	for (i = 0 ; i < numVertexes ; i++, alphas++) {
 		float ilength;
 
-		VectorSubtract( lightOrigin, v, lightDir );
+		VectorSubtract( lightOrigin, tess.vertexPtr2[i].xyz, lightDir );
 //		ilength = Q_rsqrt( DotProduct( lightDir, lightDir ) );
 		VectorNormalizeFast( lightDir );
 
 		// calculate the specular color
-		d = DotProduct (normal, lightDir);
+		normal = &tess.vertexPtr3[i].normal;
+		d = DotProduct (*normal, lightDir);
 //		d *= ilength;
 
 		// we don't optimize for the d < 0 case since this tends to
 		// cause visual artifacts such as faceted "snapping"
-		reflected[0] = normal[0]*2*d - lightDir[0];
-		reflected[1] = normal[1]*2*d - lightDir[1];
-		reflected[2] = normal[2]*2*d - lightDir[2];
+		reflected[0] = (*normal)[0]*2*d - lightDir[0];
+		reflected[1] = (*normal)[1]*2*d - lightDir[1];
+		reflected[2] = (*normal)[2]*2*d - lightDir[2];
 
-		VectorSubtract (backEnd.or.viewOrigin, v, viewer);
+		VectorSubtract (backEnd.or.viewOrigin, tess.vertexPtr2[i].xyz, viewer);
 		ilength = Q_rsqrt( DotProduct( viewer, viewer ) );
 		l = DotProduct (reflected, viewer);
 		l *= ilength;
@@ -1089,7 +1073,7 @@
 			}
 		}
 
-		*alphas = b;
+		(*alphas)[3] = b;
 	}
 }
 
@@ -1099,14 +1083,12 @@
 ** The basic vertex lighting calc
 */
 #if idppc_altivec
-static void RB_CalcDiffuseColor_altivec( unsigned char *colors )
+static void RB_CalcDiffuseColor_altivec( color4ub_t *colors, int numVertexes )
 {
 	int				i;
-	float			*v, *normal;
 	trRefEntity_t	*ent;
 	int				ambientLightInt;
 	vec3_t			lightDir;
-	int				numVertexes;
 	vector unsigned char vSel = VECCONST_UINT8(0x00, 0x00, 0x00, 0xff,
                                                0x00, 0x00, 0x00, 0xff,
                                                0x00, 0x00, 0x00, 0xff,
@@ -1142,14 +1124,10 @@
 	zero = (vector float)vec_splat_s8(0);
 	VectorCopy( ent->lightDir, lightDir );
 
-	v = tess.xyz[0];
-	normal = tess.normal[0];
-
-	normalPerm = vec_lvsl(0,normal);
-	numVertexes = tess.numVertexes;
-	for (i = 0 ; i < numVertexes ; i++, v += 4, normal += 4) {
-		normalVec0 = vec_ld(0,(vector float *)normal);
-		normalVec1 = vec_ld(11,(vector float *)normal);
+	normalPerm = vec_lvsl(0,&tess.vertexPtr3[0].normal);
+	for (i = 0 ; i < numVertexes ; i++) {
+		normalVec0 = vec_ld(0,(vector float *)&tess.vertexPtr3[i].normal);
+		normalVec1 = vec_ld(11,(vector float *)&tess.vertexPtr3[i].normal);
 		normalVec0 = vec_perm(normalVec0,normalVec1,normalPerm);
 		incomingVec0 = vec_madd(normalVec0, lightDirVec, zero);
 		incomingVec1 = vec_sld(incomingVec0,incomingVec0,4);
@@ -1164,69 +1142,65 @@
 		jVecShort = vec_pack(jVecInt,jVecInt);		// RGBxRGBx
 		jVecChar = vec_packsu(jVecShort,jVecShort);	// RGBxRGBxRGBxRGBx
 		jVecChar = vec_sel(jVecChar,vSel,vSel);		// RGBARGBARGBARGBA replace alpha with 255
-		vec_ste((vector unsigned int)jVecChar,0,(unsigned int *)&colors[i*4]);	// store color
+		vec_ste((vector unsigned int)jVecChar,0,(unsigned int *)&colors[i]);	// store color
 	}
 }
 #endif
 
-static void RB_CalcDiffuseColor_scalar( unsigned char *colors )
+static void RB_CalcDiffuseColor_scalar( color4ub_t *colors, int numVertexes )
 {
 	int				i, j;
-	float			*v, *normal;
 	float			incoming;
 	trRefEntity_t	*ent;
 	int				ambientLightInt;
+	vec3_t			*normal;
 	vec3_t			ambientLight;
 	vec3_t			lightDir;
 	vec3_t			directedLight;
-	int				numVertexes;
 	ent = backEnd.currentEntity;
 	ambientLightInt = ent->ambientLightInt;
 	VectorCopy( ent->ambientLight, ambientLight );
 	VectorCopy( ent->directedLight, directedLight );
 	VectorCopy( ent->lightDir, lightDir );
 
-	v = tess.xyz[0];
-	normal = tess.normal[0];
-
-	numVertexes = tess.numVertexes;
-	for (i = 0 ; i < numVertexes ; i++, v += 4, normal += 4) {
-		incoming = DotProduct (normal, lightDir);
+	for (i = 0 ; i < numVertexes ; i++) {
+		normal = &tess.vertexPtr3[i].normal;
+		incoming = DotProduct (*normal, lightDir);
 		if ( incoming <= 0 ) {
-			*(int *)&colors[i*4] = ambientLightInt;
-			continue;
-		} 
-		j = myftol( ambientLight[0] + incoming * directedLight[0] );
-		if ( j > 255 ) {
-			j = 255;
-		}
-		colors[i*4+0] = j;
-
-		j = myftol( ambientLight[1] + incoming * directedLight[1] );
-		if ( j > 255 ) {
-			j = 255;
-		}
-		colors[i*4+1] = j;
-
-		j = myftol( ambientLight[2] + incoming * directedLight[2] );
-		if ( j > 255 ) {
-			j = 255;
+			*(int *)&colors[i] = ambientLightInt;
+		} else {
+			j = myftol( ambientLight[0] + incoming * directedLight[0] );
+			if ( j > 255 ) {
+				j = 255;
+			}
+			colors[i][0] = j;
+			
+			j = myftol( ambientLight[1] + incoming * directedLight[1] );
+			if ( j > 255 ) {
+				j = 255;
+			}
+			colors[i][1] = j;
+			
+			j = myftol( ambientLight[2] + incoming * directedLight[2] );
+			if ( j > 255 ) {
+				j = 255;
+			}
+			colors[i][2] = j;
+			
+			colors[i][3] = 255;
 		}
-		colors[i*4+2] = j;
-
-		colors[i*4+3] = 255;
 	}
 }
 
-void RB_CalcDiffuseColor( unsigned char *colors )
+void RB_CalcDiffuseColor( color4ub_t *colors, int numVertexes )
 {
 #if idppc_altivec
 	if (com_altivec->integer) {
 		// must be in a seperate function or G3 systems will crash.
-		RB_CalcDiffuseColor_altivec( colors );
+	  RB_CalcDiffuseColor_altivec( colors, numVertexes );
 		return;
 	}
 #endif
-	RB_CalcDiffuseColor_scalar( colors );
+	RB_CalcDiffuseColor_scalar( colors, numVertexes );
 }
 
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_shade.c.orig tremulous-ggp1-src/src/renderer/tr_shade.c.orig
--- tremulous-ggp1-src.p/src/renderer/tr_shade.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_shade.c.orig	2012-07-19 04:25:20.321556051 +0200
@@ -0,0 +1,1525 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+// tr_shade.c
+
+#include "tr_local.h" 
+#if idppc_altivec && !defined(MACOS_X)
+#include <altivec.h>
+#endif
+
+/*
+
+  THIS ENTIRE FILE IS BACK END
+
+  This file deals with applying shaders to surface data in the tess struct.
+*/
+
+/*
+================
+R_ArrayElementDiscrete
+
+This is just for OpenGL conformance testing, it should never be the fastest
+================
+*/
+static void APIENTRY R_ArrayElementDiscrete( GLint index ) {
+	qglColor4ubv( tess.svars.colors[ index ] );
+	if ( glState.currenttmu ) {
+		qglMultiTexCoord2fARB( 0, tess.svars.texcoords[ 0 ][ index ][0], tess.svars.texcoords[ 0 ][ index ][1] );
+		qglMultiTexCoord2fARB( 1, tess.svars.texcoords[ 1 ][ index ][0], tess.svars.texcoords[ 1 ][ index ][1] );
+	} else {
+		qglTexCoord2fv( tess.svars.texcoords[ 0 ][ index ] );
+	}
+	qglVertex3fv( tess.xyz[ index ] );
+}
+
+/*
+===================
+R_DrawStripElements
+
+===================
+*/
+static int		c_vertexes;		// for seeing how long our average strips are
+static int		c_begins;
+static void R_DrawStripElements( int numIndexes, const glIndex_t *indexes, void ( APIENTRY *element )(GLint) ) {
+	int i;
+	int last[3] = { -1, -1, -1 };
+	qboolean even;
+
+	c_begins++;
+
+	if ( numIndexes <= 0 ) {
+		return;
+	}
+
+	qglBegin( GL_TRIANGLE_STRIP );
+
+	// prime the strip
+	element( indexes[0] );
+	element( indexes[1] );
+	element( indexes[2] );
+	c_vertexes += 3;
+
+	last[0] = indexes[0];
+	last[1] = indexes[1];
+	last[2] = indexes[2];
+
+	even = qfalse;
+
+	for ( i = 3; i < numIndexes; i += 3 )
+	{
+		// odd numbered triangle in potential strip
+		if ( !even )
+		{
+			// check previous triangle to see if we're continuing a strip
+			if ( ( indexes[i+0] == last[2] ) && ( indexes[i+1] == last[1] ) )
+			{
+				element( indexes[i+2] );
+				c_vertexes++;
+				assert( indexes[i+2] < tess.numVertexes );
+				even = qtrue;
+			}
+			// otherwise we're done with this strip so finish it and start
+			// a new one
+			else
+			{
+				qglEnd();
+
+				qglBegin( GL_TRIANGLE_STRIP );
+				c_begins++;
+
+				element( indexes[i+0] );
+				element( indexes[i+1] );
+				element( indexes[i+2] );
+
+				c_vertexes += 3;
+
+				even = qfalse;
+			}
+		}
+		else
+		{
+			// check previous triangle to see if we're continuing a strip
+			if ( ( last[2] == indexes[i+1] ) && ( last[0] == indexes[i+0] ) )
+			{
+				element( indexes[i+2] );
+				c_vertexes++;
+
+				even = qfalse;
+			}
+			// otherwise we're done with this strip so finish it and start
+			// a new one
+			else
+			{
+				qglEnd();
+
+				qglBegin( GL_TRIANGLE_STRIP );
+				c_begins++;
+
+				element( indexes[i+0] );
+				element( indexes[i+1] );
+				element( indexes[i+2] );
+				c_vertexes += 3;
+
+				even = qfalse;
+			}
+		}
+
+		// cache the last three vertices
+		last[0] = indexes[i+0];
+		last[1] = indexes[i+1];
+		last[2] = indexes[i+2];
+	}
+
+	qglEnd();
+}
+
+
+
+/*
+==================
+R_DrawElements
+
+Optionally performs our own glDrawElements that looks for strip conditions
+instead of using the single glDrawElements call that may be inefficient
+without compiled vertex arrays.
+==================
+*/
+static void R_DrawElements( int numIndexes, const glIndex_t *indexes ) {
+	int		primitives;
+
+	primitives = r_primitives->integer;
+
+	// default is to use triangles if compiled vertex arrays are present
+	if ( primitives == 0 ) {
+		if ( qglLockArraysEXT ) {
+			primitives = 2;
+		} else {
+			primitives = 1;
+		}
+	}
+
+
+	if ( primitives == 2 ) {
+		qglDrawElements( GL_TRIANGLES, 
+						numIndexes,
+						GL_INDEX_TYPE,
+						indexes );
+		return;
+	}
+
+	if ( primitives == 1 ) {
+		R_DrawStripElements( numIndexes,  indexes, qglArrayElement );
+		return;
+	}
+	
+	if ( primitives == 3 ) {
+		R_DrawStripElements( numIndexes,  indexes, R_ArrayElementDiscrete );
+		return;
+	}
+
+	// anything else will cause no drawing
+}
+
+
+/*
+=============================================================
+
+SURFACE SHADERS
+
+=============================================================
+*/
+
+shaderCommands_t	tess;
+static qboolean	setArraysOnce;
+
+/*
+=================
+R_BindAnimatedImage
+
+=================
+*/
+static void R_BindAnimatedImage( textureBundle_t *bundle ) {
+	int		index;
+
+	if ( bundle->isVideoMap ) {
+		ri.CIN_RunCinematic(bundle->videoMapHandle);
+		ri.CIN_UploadCinematic(bundle->videoMapHandle);
+		return;
+	}
+
+	if ( bundle->numImageAnimations <= 1 ) {
+		GL_Bind( bundle->image[0] );
+		return;
+	}
+
+	// it is necessary to do this messy calc to make sure animations line up
+	// exactly with waveforms of the same frequency
+	index = myftol( tess.shaderTime * bundle->imageAnimationSpeed * FUNCTABLE_SIZE );
+	index >>= FUNCTABLE_SIZE2;
+
+	if ( index < 0 ) {
+		index = 0;	// may happen with shader time offsets
+	}
+	index %= bundle->numImageAnimations;
+
+	GL_Bind( bundle->image[ index ] );
+}
+
+/*
+================
+DrawTris
+
+Draws triangle outlines for debugging
+================
+*/
+static void DrawTris (shaderCommands_t *input) {
+	GL_Bind( tr.whiteImage );
+	qglColor3f (1,1,1);
+
+	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
+	qglDepthRange( 0, 0 );
+
+	qglDisableClientState (GL_COLOR_ARRAY);
+	qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
+
+	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
+
+	if (qglLockArraysEXT) {
+		qglLockArraysEXT(0, input->numVertexes);
+		GLimp_LogComment( "glLockArraysEXT\n" );
+	}
+
+	R_DrawElements( input->numIndexes, input->indexes );
+
+	if (qglUnlockArraysEXT) {
+		qglUnlockArraysEXT();
+		GLimp_LogComment( "glUnlockArraysEXT\n" );
+	}
+	qglDepthRange( 0, 1 );
+}
+
+
+/*
+================
+DrawNormals
+
+Draws vertex normals for debugging
+================
+*/
+static void DrawNormals (shaderCommands_t *input) {
+	int		i;
+	vec3_t	temp;
+
+	GL_Bind( tr.whiteImage );
+	qglColor3f (1,1,1);
+	qglDepthRange( 0, 0 );	// never occluded
+	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
+
+	qglBegin (GL_LINES);
+	for (i = 0 ; i < input->numVertexes ; i++) {
+		qglVertex3fv (input->xyz[i]);
+		VectorMA (input->xyz[i], 2, input->normal[i], temp);
+		qglVertex3fv (temp);
+	}
+	qglEnd ();
+
+	qglDepthRange( 0, 1 );
+}
+
+/*
+==============
+RB_BeginSurface
+
+We must set some things up before beginning any tesselation,
+because a surface may be forced to perform a RB_End due
+to overflow.
+==============
+*/
+void RB_BeginSurface( shader_t *shader, int fogNum ) {
+
+	shader_t *state = (shader->remappedShader) ? shader->remappedShader : shader;
+
+	tess.numIndexes = 0;
+	tess.numVertexes = 0;
+	tess.shader = state;
+	tess.fogNum = fogNum;
+	tess.dlightBits = 0;		// will be OR'd in by surface functions
+	tess.xstages = state->stages;
+	tess.numPasses = state->numUnfoggedPasses;
+	tess.currentStageIteratorFunc = state->optimalStageIteratorFunc;
+
+	tess.shaderTime = backEnd.refdef.floatTime - tess.shader->timeOffset;
+	if (tess.shader->clampTime && tess.shaderTime >= tess.shader->clampTime) {
+		tess.shaderTime = tess.shader->clampTime;
+	}
+
+
+}
+
+/*
+===================
+DrawMultitextured
+
+output = t0 * t1 or t0 + t1
+
+t0 = most upstream according to spec
+t1 = most downstream according to spec
+===================
+*/
+static void DrawMultitextured( shaderCommands_t *input, int stage ) {
+	shaderStage_t	*pStage;
+
+	pStage = tess.xstages[stage];
+
+	GL_State( pStage->stateBits );
+
+	// this is an ugly hack to work around a GeForce driver
+	// bug with multitexture and clip planes
+	if ( backEnd.viewParms.isPortal ) {
+		qglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
+	}
+
+	//
+	// base
+	//
+	GL_SelectTexture( 0 );
+	qglTexCoordPointer( 2, GL_FLOAT, 0, input->svars.texcoords[0] );
+	R_BindAnimatedImage( &pStage->bundle[0] );
+
+	//
+	// lightmap/secondary pass
+	//
+	GL_SelectTexture( 1 );
+	qglEnable( GL_TEXTURE_2D );
+	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+
+	if ( r_lightmap->integer ) {
+		GL_TexEnv( GL_REPLACE );
+	} else {
+		GL_TexEnv( tess.shader->multitextureEnv );
+	}
+
+	qglTexCoordPointer( 2, GL_FLOAT, 0, input->svars.texcoords[1] );
+
+	R_BindAnimatedImage( &pStage->bundle[1] );
+
+	R_DrawElements( input->numIndexes, input->indexes );
+
+	//
+	// disable texturing on TEXTURE1, then select TEXTURE0
+	//
+	//qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
+	qglDisable( GL_TEXTURE_2D );
+
+	GL_SelectTexture( 0 );
+}
+
+
+
+/*
+===================
+ProjectDlightTexture
+
+Perform dynamic lighting with another rendering pass
+===================
+*/
+#if idppc_altivec
+static void ProjectDlightTexture_altivec( void ) {
+	int		i, l;
+	vec_t	origin0, origin1, origin2;
+	float   texCoords0, texCoords1;
+	vector float floatColorVec0, floatColorVec1;
+	vector float modulateVec, colorVec, zero;
+	vector short colorShort;
+	vector signed int colorInt;
+	vector unsigned char floatColorVecPerm, modulatePerm, colorChar;
+	vector unsigned char vSel = VECCONST_UINT8(0x00, 0x00, 0x00, 0xff,
+                                               0x00, 0x00, 0x00, 0xff,
+                                               0x00, 0x00, 0x00, 0xff,
+                                               0x00, 0x00, 0x00, 0xff);
+	float	*texCoords;
+	byte	*colors;
+	byte	clipBits[SHADER_MAX_VERTEXES];
+	float	texCoordsArray[SHADER_MAX_VERTEXES][2];
+	byte	colorArray[SHADER_MAX_VERTEXES][4];
+	unsigned	hitIndexes[SHADER_MAX_INDEXES];
+	int		numIndexes;
+	float	scale;
+	float	radius;
+	vec3_t	floatColor;
+	float	modulate = 0.0f;
+
+	if ( !backEnd.refdef.num_dlights ) {
+		return;
+	}
+
+	// There has to be a better way to do this so that floatColor
+	// and/or modulate are already 16-byte aligned.
+	floatColorVecPerm = vec_lvsl(0,(float *)floatColor);
+	modulatePerm = vec_lvsl(0,(float *)&modulate);
+	modulatePerm = (vector unsigned char)vec_splat((vector unsigned int)modulatePerm,0);
+	zero = (vector float)vec_splat_s8(0);
+
+	for ( l = 0 ; l < backEnd.refdef.num_dlights ; l++ ) {
+		dlight_t	*dl;
+
+		if ( !( tess.dlightBits & ( 1 << l ) ) ) {
+			continue;	// this surface definately doesn't have any of this light
+		}
+		texCoords = texCoordsArray[0];
+		colors = colorArray[0];
+
+		dl = &backEnd.refdef.dlights[l];
+		origin0 = dl->transformed[0];
+		origin1 = dl->transformed[1];
+		origin2 = dl->transformed[2];
+		radius = dl->radius;
+		scale = 1.0f / radius;
+
+		if(r_greyscale->integer)
+		{
+			float luminance;
+			
+			luminance = LUMA(dl->color[0], dl->color[1], dl->color[2]) * 255.0f;
+			floatColor[0] = floatColor[1] = floatColor[2] = luminance;
+		}
+		else if(r_greyscale->value)
+		{
+			float luminance;
+			
+			luminance = LUMA(dl->color[0], dl->color[1], dl->color[2]) * 255.0f;
+			floatColor[0] = LERP(dl->color[0] * 255.0f, luminance, r_greyscale->value);
+			floatColor[1] = LERP(dl->color[1] * 255.0f, luminance, r_greyscale->value);
+			floatColor[2] = LERP(dl->color[2] * 255.0f, luminance, r_greyscale->value);
+		}
+		else
+		{
+			floatColor[0] = dl->color[0] * 255.0f;
+			floatColor[1] = dl->color[1] * 255.0f;
+			floatColor[2] = dl->color[2] * 255.0f;
+		}
+		floatColorVec0 = vec_ld(0, floatColor);
+		floatColorVec1 = vec_ld(11, floatColor);
+		floatColorVec0 = vec_perm(floatColorVec0,floatColorVec0,floatColorVecPerm);
+		for ( i = 0 ; i < tess.numVertexes ; i++, texCoords += 2, colors += 4 ) {
+			int		clip = 0;
+			vec_t dist0, dist1, dist2;
+			
+			dist0 = origin0 - tess.xyz[i][0];
+			dist1 = origin1 - tess.xyz[i][1];
+			dist2 = origin2 - tess.xyz[i][2];
+
+			backEnd.pc.c_dlightVertexes++;
+
+			texCoords0 = 0.5f + dist0 * scale;
+			texCoords1 = 0.5f + dist1 * scale;
+
+			if( !r_dlightBacks->integer &&
+					// dist . tess.normal[i]
+					( dist0 * tess.normal[i][0] +
+					dist1 * tess.normal[i][1] +
+					dist2 * tess.normal[i][2] ) < 0.0f ) {
+				clip = 63;
+			} else {
+				if ( texCoords0 < 0.0f ) {
+					clip |= 1;
+				} else if ( texCoords0 > 1.0f ) {
+					clip |= 2;
+				}
+				if ( texCoords1 < 0.0f ) {
+					clip |= 4;
+				} else if ( texCoords1 > 1.0f ) {
+					clip |= 8;
+				}
+				texCoords[0] = texCoords0;
+				texCoords[1] = texCoords1;
+
+				// modulate the strength based on the height and color
+				if ( dist2 > radius ) {
+					clip |= 16;
+					modulate = 0.0f;
+				} else if ( dist2 < -radius ) {
+					clip |= 32;
+					modulate = 0.0f;
+				} else {
+					dist2 = Q_fabs(dist2);
+					if ( dist2 < radius * 0.5f ) {
+						modulate = 1.0f;
+					} else {
+						modulate = 2.0f * (radius - dist2) * scale;
+					}
+				}
+			}
+			clipBits[i] = clip;
+
+			modulateVec = vec_ld(0,(float *)&modulate);
+			modulateVec = vec_perm(modulateVec,modulateVec,modulatePerm);
+			colorVec = vec_madd(floatColorVec0,modulateVec,zero);
+			colorInt = vec_cts(colorVec,0);	// RGBx
+			colorShort = vec_pack(colorInt,colorInt);		// RGBxRGBx
+			colorChar = vec_packsu(colorShort,colorShort);	// RGBxRGBxRGBxRGBx
+			colorChar = vec_sel(colorChar,vSel,vSel);		// RGBARGBARGBARGBA replace alpha with 255
+			vec_ste((vector unsigned int)colorChar,0,(unsigned int *)colors);	// store color
+		}
+
+		// build a list of triangles that need light
+		numIndexes = 0;
+		for ( i = 0 ; i < tess.numIndexes ; i += 3 ) {
+			int		a, b, c;
+
+			a = tess.indexes[i];
+			b = tess.indexes[i+1];
+			c = tess.indexes[i+2];
+			if ( clipBits[a] & clipBits[b] & clipBits[c] ) {
+				continue;	// not lighted
+			}
+			hitIndexes[numIndexes] = a;
+			hitIndexes[numIndexes+1] = b;
+			hitIndexes[numIndexes+2] = c;
+			numIndexes += 3;
+		}
+
+		if ( !numIndexes ) {
+			continue;
+		}
+
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+		qglTexCoordPointer( 2, GL_FLOAT, 0, texCoordsArray[0] );
+
+		qglEnableClientState( GL_COLOR_ARRAY );
+		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, colorArray );
+
+		GL_Bind( tr.dlightImage );
+		// include GLS_DEPTHFUNC_EQUAL so alpha tested surfaces don't add light
+		// where they aren't rendered
+		if ( dl->additive ) {
+			GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
+		}
+		else {
+			GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
+		}
+		R_DrawElements( numIndexes, hitIndexes );
+		backEnd.pc.c_totalIndexes += numIndexes;
+		backEnd.pc.c_dlightIndexes += numIndexes;
+	}
+}
+#endif
+
+
+static void ProjectDlightTexture_scalar( void ) {
+	int		i, l;
+	vec3_t	origin;
+	float	*texCoords;
+	byte	*colors;
+	byte	clipBits[SHADER_MAX_VERTEXES];
+	float	texCoordsArray[SHADER_MAX_VERTEXES][2];
+	byte	colorArray[SHADER_MAX_VERTEXES][4];
+	unsigned	hitIndexes[SHADER_MAX_INDEXES];
+	int		numIndexes;
+	float	scale;
+	float	radius;
+	vec3_t	floatColor;
+	float	modulate = 0.0f;
+
+	if ( !backEnd.refdef.num_dlights ) {
+		return;
+	}
+
+	for ( l = 0 ; l < backEnd.refdef.num_dlights ; l++ ) {
+		dlight_t	*dl;
+
+		if ( !( tess.dlightBits & ( 1 << l ) ) ) {
+			continue;	// this surface definately doesn't have any of this light
+		}
+		texCoords = texCoordsArray[0];
+		colors = colorArray[0];
+
+		dl = &backEnd.refdef.dlights[l];
+		VectorCopy( dl->transformed, origin );
+		radius = dl->radius;
+		scale = 1.0f / radius;
+
+		if(r_greyscale->integer)
+		{
+			float luminance;
+
+			luminance = LUMA(dl->color[0], dl->color[1], dl->color[2]) * 255.0f;
+			floatColor[0] = floatColor[1] = floatColor[2] = luminance;
+		}
+		else if(r_greyscale->value)
+		{
+			float luminance;
+			
+			luminance = LUMA(dl->color[0], dl->color[1], dl->color[2]) * 255.0f;
+			floatColor[0] = LERP(dl->color[0] * 255.0f, luminance, r_greyscale->value);
+			floatColor[1] = LERP(dl->color[1] * 255.0f, luminance, r_greyscale->value);
+			floatColor[2] = LERP(dl->color[2] * 255.0f, luminance, r_greyscale->value);
+		}
+		else
+		{
+			floatColor[0] = dl->color[0] * 255.0f;
+			floatColor[1] = dl->color[1] * 255.0f;
+			floatColor[2] = dl->color[2] * 255.0f;
+		}
+
+		for ( i = 0 ; i < tess.numVertexes ; i++, texCoords += 2, colors += 4 ) {
+			int		clip = 0;
+			vec3_t	dist;
+			
+			VectorSubtract( origin, tess.xyz[i], dist );
+
+			backEnd.pc.c_dlightVertexes++;
+
+			texCoords[0] = 0.5f + dist[0] * scale;
+			texCoords[1] = 0.5f + dist[1] * scale;
+
+			if( !r_dlightBacks->integer &&
+					// dist . tess.normal[i]
+					( dist[0] * tess.normal[i][0] +
+					dist[1] * tess.normal[i][1] +
+					dist[2] * tess.normal[i][2] ) < 0.0f ) {
+				clip = 63;
+			} else {
+				if ( texCoords[0] < 0.0f ) {
+					clip |= 1;
+				} else if ( texCoords[0] > 1.0f ) {
+					clip |= 2;
+				}
+				if ( texCoords[1] < 0.0f ) {
+					clip |= 4;
+				} else if ( texCoords[1] > 1.0f ) {
+					clip |= 8;
+				}
+				texCoords[0] = texCoords[0];
+				texCoords[1] = texCoords[1];
+
+				// modulate the strength based on the height and color
+				if ( dist[2] > radius ) {
+					clip |= 16;
+					modulate = 0.0f;
+				} else if ( dist[2] < -radius ) {
+					clip |= 32;
+					modulate = 0.0f;
+				} else {
+					dist[2] = Q_fabs(dist[2]);
+					if ( dist[2] < radius * 0.5f ) {
+						modulate = 1.0f;
+					} else {
+						modulate = 2.0f * (radius - dist[2]) * scale;
+					}
+				}
+			}
+			clipBits[i] = clip;
+			colors[0] = myftol(floatColor[0] * modulate);
+			colors[1] = myftol(floatColor[1] * modulate);
+			colors[2] = myftol(floatColor[2] * modulate);
+			colors[3] = 255;
+		}
+
+		// build a list of triangles that need light
+		numIndexes = 0;
+		for ( i = 0 ; i < tess.numIndexes ; i += 3 ) {
+			int		a, b, c;
+
+			a = tess.indexes[i];
+			b = tess.indexes[i+1];
+			c = tess.indexes[i+2];
+			if ( clipBits[a] & clipBits[b] & clipBits[c] ) {
+				continue;	// not lighted
+			}
+			hitIndexes[numIndexes] = a;
+			hitIndexes[numIndexes+1] = b;
+			hitIndexes[numIndexes+2] = c;
+			numIndexes += 3;
+		}
+
+		if ( !numIndexes ) {
+			continue;
+		}
+
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+		qglTexCoordPointer( 2, GL_FLOAT, 0, texCoordsArray[0] );
+
+		qglEnableClientState( GL_COLOR_ARRAY );
+		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, colorArray );
+
+		GL_Bind( tr.dlightImage );
+		// include GLS_DEPTHFUNC_EQUAL so alpha tested surfaces don't add light
+		// where they aren't rendered
+		if ( dl->additive ) {
+			GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
+		}
+		else {
+			GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
+		}
+		R_DrawElements( numIndexes, hitIndexes );
+		backEnd.pc.c_totalIndexes += numIndexes;
+		backEnd.pc.c_dlightIndexes += numIndexes;
+	}
+}
+
+static void ProjectDlightTexture( void ) {
+#if idppc_altivec
+	if (com_altivec->integer) {
+		// must be in a seperate function or G3 systems will crash.
+		ProjectDlightTexture_altivec();
+		return;
+	}
+#endif
+	ProjectDlightTexture_scalar();
+}
+
+
+/*
+===================
+RB_FogPass
+
+Blends a fog texture on top of everything else
+===================
+*/
+static void RB_FogPass( void ) {
+	fog_t		*fog;
+	int			i;
+
+	qglEnableClientState( GL_COLOR_ARRAY );
+	qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
+
+	qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
+	qglTexCoordPointer( 2, GL_FLOAT, 0, tess.svars.texcoords[0] );
+
+	fog = tr.world->fogs + tess.fogNum;
+
+	for ( i = 0; i < tess.numVertexes; i++ ) {
+		* ( int * )&tess.svars.colors[i] = fog->colorInt;
+	}
+
+	RB_CalcFogTexCoords( ( float * ) tess.svars.texcoords[0] );
+
+	GL_Bind( tr.fogImage );
+
+	if ( tess.shader->fogPass == FP_EQUAL ) {
+		GL_State( GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA | GLS_DEPTHFUNC_EQUAL );
+	} else {
+		GL_State( GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA );
+	}
+
+	R_DrawElements( tess.numIndexes, tess.indexes );
+}
+
+/*
+===============
+ComputeColors
+===============
+*/
+static void ComputeColors( shaderStage_t *pStage )
+{
+	int		i;
+
+	//
+	// rgbGen
+	//
+	switch ( pStage->rgbGen )
+	{
+		case CGEN_IDENTITY:
+			Com_Memset( tess.svars.colors, 0xff, tess.numVertexes * 4 );
+			break;
+		default:
+		case CGEN_IDENTITY_LIGHTING:
+			Com_Memset( tess.svars.colors, tr.identityLightByte, tess.numVertexes * 4 );
+			break;
+		case CGEN_LIGHTING_DIFFUSE:
+			RB_CalcDiffuseColor( ( unsigned char * ) tess.svars.colors );
+			break;
+		case CGEN_EXACT_VERTEX:
+			Com_Memcpy( tess.svars.colors, tess.vertexColors, tess.numVertexes * sizeof( tess.vertexColors[0] ) );
+			break;
+		case CGEN_CONST:
+			for ( i = 0; i < tess.numVertexes; i++ ) {
+				*(int *)tess.svars.colors[i] = *(int *)pStage->constantColor;
+			}
+			break;
+		case CGEN_VERTEX:
+			if ( tr.identityLight == 1 )
+			{
+				Com_Memcpy( tess.svars.colors, tess.vertexColors, tess.numVertexes * sizeof( tess.vertexColors[0] ) );
+			}
+			else
+			{
+				for ( i = 0; i < tess.numVertexes; i++ )
+				{
+					tess.svars.colors[i][0] = tess.vertexColors[i][0] * tr.identityLight;
+					tess.svars.colors[i][1] = tess.vertexColors[i][1] * tr.identityLight;
+					tess.svars.colors[i][2] = tess.vertexColors[i][2] * tr.identityLight;
+					tess.svars.colors[i][3] = tess.vertexColors[i][3];
+				}
+			}
+			break;
+		case CGEN_ONE_MINUS_VERTEX:
+			if ( tr.identityLight == 1 )
+			{
+				for ( i = 0; i < tess.numVertexes; i++ )
+				{
+					tess.svars.colors[i][0] = 255 - tess.vertexColors[i][0];
+					tess.svars.colors[i][1] = 255 - tess.vertexColors[i][1];
+					tess.svars.colors[i][2] = 255 - tess.vertexColors[i][2];
+				}
+			}
+			else
+			{
+				for ( i = 0; i < tess.numVertexes; i++ )
+				{
+					tess.svars.colors[i][0] = ( 255 - tess.vertexColors[i][0] ) * tr.identityLight;
+					tess.svars.colors[i][1] = ( 255 - tess.vertexColors[i][1] ) * tr.identityLight;
+					tess.svars.colors[i][2] = ( 255 - tess.vertexColors[i][2] ) * tr.identityLight;
+				}
+			}
+			break;
+		case CGEN_FOG:
+			{
+				fog_t		*fog;
+
+				fog = tr.world->fogs + tess.fogNum;
+
+				for ( i = 0; i < tess.numVertexes; i++ ) {
+					* ( int * )&tess.svars.colors[i] = fog->colorInt;
+				}
+			}
+			break;
+		case CGEN_WAVEFORM:
+			RB_CalcWaveColor( &pStage->rgbWave, ( unsigned char * ) tess.svars.colors );
+			break;
+		case CGEN_ENTITY:
+			RB_CalcColorFromEntity( ( unsigned char * ) tess.svars.colors );
+			break;
+		case CGEN_ONE_MINUS_ENTITY:
+			RB_CalcColorFromOneMinusEntity( ( unsigned char * ) tess.svars.colors );
+			break;
+	}
+
+	//
+	// alphaGen
+	//
+	switch ( pStage->alphaGen )
+	{
+	case AGEN_SKIP:
+		break;
+	case AGEN_IDENTITY:
+		if ( pStage->rgbGen != CGEN_IDENTITY ) {
+			if ( ( pStage->rgbGen == CGEN_VERTEX && tr.identityLight != 1 ) ||
+				 pStage->rgbGen != CGEN_VERTEX ) {
+				for ( i = 0; i < tess.numVertexes; i++ ) {
+					tess.svars.colors[i][3] = 0xff;
+				}
+			}
+		}
+		break;
+	case AGEN_CONST:
+		if ( pStage->rgbGen != CGEN_CONST ) {
+			for ( i = 0; i < tess.numVertexes; i++ ) {
+				tess.svars.colors[i][3] = pStage->constantColor[3];
+			}
+		}
+		break;
+	case AGEN_WAVEFORM:
+		RB_CalcWaveAlpha( &pStage->alphaWave, ( unsigned char * ) tess.svars.colors );
+		break;
+	case AGEN_LIGHTING_SPECULAR:
+		RB_CalcSpecularAlpha( ( unsigned char * ) tess.svars.colors );
+		break;
+	case AGEN_ENTITY:
+		RB_CalcAlphaFromEntity( ( unsigned char * ) tess.svars.colors );
+		break;
+	case AGEN_ONE_MINUS_ENTITY:
+		RB_CalcAlphaFromOneMinusEntity( ( unsigned char * ) tess.svars.colors );
+		break;
+    case AGEN_VERTEX:
+		if ( pStage->rgbGen != CGEN_VERTEX ) {
+			for ( i = 0; i < tess.numVertexes; i++ ) {
+				tess.svars.colors[i][3] = tess.vertexColors[i][3];
+			}
+		}
+        break;
+    case AGEN_ONE_MINUS_VERTEX:
+        for ( i = 0; i < tess.numVertexes; i++ )
+        {
+			tess.svars.colors[i][3] = 255 - tess.vertexColors[i][3];
+        }
+        break;
+	case AGEN_PORTAL:
+		{
+			unsigned char alpha;
+
+			for ( i = 0; i < tess.numVertexes; i++ )
+			{
+				float len;
+				vec3_t v;
+
+				VectorSubtract( tess.xyz[i], backEnd.viewParms.or.origin, v );
+				len = VectorLength( v );
+
+				len /= tess.shader->portalRange;
+
+				if ( len < 0 )
+				{
+					alpha = 0;
+				}
+				else if ( len > 1 )
+				{
+					alpha = 0xff;
+				}
+				else
+				{
+					alpha = len * 0xff;
+				}
+
+				tess.svars.colors[i][3] = alpha;
+			}
+		}
+		break;
+	}
+
+	//
+	// fog adjustment for colors to fade out as fog increases
+	//
+	if ( tess.fogNum )
+	{
+		switch ( pStage->adjustColorsForFog )
+		{
+		case ACFF_MODULATE_RGB:
+			RB_CalcModulateColorsByFog( ( unsigned char * ) tess.svars.colors );
+			break;
+		case ACFF_MODULATE_ALPHA:
+			RB_CalcModulateAlphasByFog( ( unsigned char * ) tess.svars.colors );
+			break;
+		case ACFF_MODULATE_RGBA:
+			RB_CalcModulateRGBAsByFog( ( unsigned char * ) tess.svars.colors );
+			break;
+		case ACFF_NONE:
+			break;
+		}
+	}
+	
+	// if in greyscale rendering mode turn all color values into greyscale.
+	if(r_greyscale->integer)
+	{
+		int scale;
+		for(i = 0; i < tess.numVertexes; i++)
+		{
+			scale = LUMA(tess.svars.colors[i][0], tess.svars.colors[i][1], tess.svars.colors[i][2]);
+ 			tess.svars.colors[i][0] = tess.svars.colors[i][1] = tess.svars.colors[i][2] = scale;
+		}
+	}
+	else if(r_greyscale->value)
+	{
+		float scale;
+		
+		for(i = 0; i < tess.numVertexes; i++)
+		{
+			scale = LUMA(tess.svars.colors[i][0], tess.svars.colors[i][1], tess.svars.colors[i][2]);
+			tess.svars.colors[i][0] = LERP(tess.svars.colors[i][0], scale, r_greyscale->value);
+			tess.svars.colors[i][1] = LERP(tess.svars.colors[i][1], scale, r_greyscale->value);
+			tess.svars.colors[i][2] = LERP(tess.svars.colors[i][2], scale, r_greyscale->value);
+		}
+	}
+}
+
+/*
+===============
+ComputeTexCoords
+===============
+*/
+static void ComputeTexCoords( shaderStage_t *pStage ) {
+	int		i;
+	int		b;
+
+	for ( b = 0; b < NUM_TEXTURE_BUNDLES; b++ ) {
+		int tm;
+
+		//
+		// generate the texture coordinates
+		//
+		switch ( pStage->bundle[b].tcGen )
+		{
+		case TCGEN_IDENTITY:
+			Com_Memset( tess.svars.texcoords[b], 0, sizeof( float ) * 2 * tess.numVertexes );
+			break;
+		case TCGEN_TEXTURE:
+			for ( i = 0 ; i < tess.numVertexes ; i++ ) {
+				tess.svars.texcoords[b][i][0] = tess.texCoords[i][0][0];
+				tess.svars.texcoords[b][i][1] = tess.texCoords[i][0][1];
+			}
+			break;
+		case TCGEN_LIGHTMAP:
+			for ( i = 0 ; i < tess.numVertexes ; i++ ) {
+				tess.svars.texcoords[b][i][0] = tess.texCoords[i][1][0];
+				tess.svars.texcoords[b][i][1] = tess.texCoords[i][1][1];
+			}
+			break;
+		case TCGEN_VECTOR:
+			for ( i = 0 ; i < tess.numVertexes ; i++ ) {
+				tess.svars.texcoords[b][i][0] = DotProduct( tess.xyz[i], pStage->bundle[b].tcGenVectors[0] );
+				tess.svars.texcoords[b][i][1] = DotProduct( tess.xyz[i], pStage->bundle[b].tcGenVectors[1] );
+			}
+			break;
+		case TCGEN_FOG:
+			RB_CalcFogTexCoords( ( float * ) tess.svars.texcoords[b] );
+			break;
+		case TCGEN_ENVIRONMENT_MAPPED:
+			RB_CalcEnvironmentTexCoords( ( float * ) tess.svars.texcoords[b] );
+			break;
+		case TCGEN_BAD:
+			return;
+		}
+
+		//
+		// alter texture coordinates
+		//
+		for ( tm = 0; tm < pStage->bundle[b].numTexMods ; tm++ ) {
+			switch ( pStage->bundle[b].texMods[tm].type )
+			{
+			case TMOD_NONE:
+				tm = TR_MAX_TEXMODS;		// break out of for loop
+				break;
+
+			case TMOD_TURBULENT:
+				RB_CalcTurbulentTexCoords( &pStage->bundle[b].texMods[tm].wave, 
+						                 ( float * ) tess.svars.texcoords[b] );
+				break;
+
+			case TMOD_ENTITY_TRANSLATE:
+				RB_CalcScrollTexCoords( backEnd.currentEntity->e.shaderTexCoord,
+									 ( float * ) tess.svars.texcoords[b] );
+				break;
+
+			case TMOD_SCROLL:
+				RB_CalcScrollTexCoords( pStage->bundle[b].texMods[tm].scroll,
+										 ( float * ) tess.svars.texcoords[b] );
+				break;
+
+			case TMOD_SCALE:
+				RB_CalcScaleTexCoords( pStage->bundle[b].texMods[tm].scale,
+									 ( float * ) tess.svars.texcoords[b] );
+				break;
+			
+			case TMOD_STRETCH:
+				RB_CalcStretchTexCoords( &pStage->bundle[b].texMods[tm].wave, 
+						               ( float * ) tess.svars.texcoords[b] );
+				break;
+
+			case TMOD_TRANSFORM:
+				RB_CalcTransformTexCoords( &pStage->bundle[b].texMods[tm],
+						                 ( float * ) tess.svars.texcoords[b] );
+				break;
+
+			case TMOD_ROTATE:
+				RB_CalcRotateTexCoords( pStage->bundle[b].texMods[tm].rotateSpeed,
+										( float * ) tess.svars.texcoords[b] );
+				break;
+
+			default:
+				ri.Error( ERR_DROP, "ERROR: unknown texmod '%d' in shader '%s'\n", pStage->bundle[b].texMods[tm].type, tess.shader->name );
+				break;
+			}
+		}
+	}
+}
+
+/*
+** RB_IterateStagesGeneric
+*/
+static void RB_IterateStagesGeneric( shaderCommands_t *input )
+{
+	int stage;
+
+	for ( stage = 0; stage < MAX_SHADER_STAGES; stage++ )
+	{
+		shaderStage_t *pStage = tess.xstages[stage];
+
+		if ( !pStage )
+		{
+			break;
+		}
+
+		ComputeColors( pStage );
+		ComputeTexCoords( pStage );
+
+		if ( !setArraysOnce )
+		{
+			qglEnableClientState( GL_COLOR_ARRAY );
+			qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, input->svars.colors );
+		}
+
+		//
+		// do multitexture
+		//
+		if ( pStage->bundle[1].image[0] != 0 )
+		{
+			DrawMultitextured( input, stage );
+		}
+		else
+		{
+			if ( !setArraysOnce )
+			{
+				qglTexCoordPointer( 2, GL_FLOAT, 0, input->svars.texcoords[0] );
+			}
+
+			//
+			// set state
+			//
+			if ( pStage->bundle[0].vertexLightmap && ( (r_vertexLight->integer && !r_uiFullScreen->integer) || glConfig.hardwareType == GLHW_PERMEDIA2 ) && r_lightmap->integer )
+			{
+				GL_Bind( tr.whiteImage );
+			}
+			else 
+				R_BindAnimatedImage( &pStage->bundle[0] );
+
+			GL_State( pStage->stateBits );
+
+			//
+			// draw
+			//
+			R_DrawElements( input->numIndexes, input->indexes );
+		}
+		// allow skipping out to show just lightmaps during development
+		if ( r_lightmap->integer && ( pStage->bundle[0].isLightmap || pStage->bundle[1].isLightmap || pStage->bundle[0].vertexLightmap ) )
+		{
+			break;
+		}
+	}
+}
+
+
+/*
+** RB_StageIteratorGeneric
+*/
+void RB_StageIteratorGeneric( void )
+{
+	shaderCommands_t *input;
+
+	input = &tess;
+
+	RB_DeformTessGeometry();
+
+	//
+	// log this call
+	//
+	if ( r_logFile->integer ) 
+	{
+		// don't just call LogComment, or we will get
+		// a call to va() every frame!
+		GLimp_LogComment( va("--- RB_StageIteratorGeneric( %s ) ---\n", tess.shader->name) );
+	}
+
+	//
+	// set face culling appropriately
+	//
+	GL_Cull( input->shader->cullType );
+
+	// set polygon offset if necessary
+	if ( input->shader->polygonOffset )
+	{
+		qglEnable( GL_POLYGON_OFFSET_FILL );
+		qglPolygonOffset( r_offsetFactor->value, r_offsetUnits->value );
+	}
+
+	//
+	// if there is only a single pass then we can enable color
+	// and texture arrays before we compile, otherwise we need
+	// to avoid compiling those arrays since they will change
+	// during multipass rendering
+	//
+	if ( tess.numPasses > 1 || input->shader->multitextureEnv )
+	{
+		setArraysOnce = qfalse;
+		qglDisableClientState (GL_COLOR_ARRAY);
+		qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
+	}
+	else
+	{
+		setArraysOnce = qtrue;
+
+		qglEnableClientState( GL_COLOR_ARRAY);
+		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
+
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
+		qglTexCoordPointer( 2, GL_FLOAT, 0, tess.svars.texcoords[0] );
+	}
+
+	//
+	// lock XYZ
+	//
+	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
+	if (qglLockArraysEXT)
+	{
+		qglLockArraysEXT(0, input->numVertexes);
+		GLimp_LogComment( "glLockArraysEXT\n" );
+	}
+
+	//
+	// enable color and texcoord arrays after the lock if necessary
+	//
+	if ( !setArraysOnce )
+	{
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+		qglEnableClientState( GL_COLOR_ARRAY );
+	}
+
+	//
+	// call shader function
+	//
+	RB_IterateStagesGeneric( input );
+
+	// 
+	// now do any dynamic lighting needed
+	//
+	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE
+		&& !(tess.shader->surfaceFlags & (SURF_NODLIGHT | SURF_SKY) ) ) {
+		ProjectDlightTexture();
+	}
+
+	//
+	// now do fog
+	//
+	if ( tess.fogNum && tess.shader->fogPass ) {
+		RB_FogPass();
+	}
+
+	// 
+	// unlock arrays
+	//
+	if (qglUnlockArraysEXT) 
+	{
+		qglUnlockArraysEXT();
+		GLimp_LogComment( "glUnlockArraysEXT\n" );
+	}
+
+	//
+	// reset polygon offset
+	//
+	if ( input->shader->polygonOffset )
+	{
+		qglDisable( GL_POLYGON_OFFSET_FILL );
+	}
+}
+
+
+/*
+** RB_StageIteratorVertexLitTexture
+*/
+void RB_StageIteratorVertexLitTexture( void )
+{
+	shaderCommands_t *input;
+	shader_t		*shader;
+
+	input = &tess;
+
+	shader = input->shader;
+
+	//
+	// compute colors
+	//
+	RB_CalcDiffuseColor( ( unsigned char * ) tess.svars.colors );
+
+	//
+	// log this call
+	//
+	if ( r_logFile->integer ) 
+	{
+		// don't just call LogComment, or we will get
+		// a call to va() every frame!
+		GLimp_LogComment( va("--- RB_StageIteratorVertexLitTexturedUnfogged( %s ) ---\n", tess.shader->name) );
+	}
+
+	//
+	// set face culling appropriately
+	//
+	GL_Cull( input->shader->cullType );
+
+	//
+	// set arrays and lock
+	//
+	qglEnableClientState( GL_COLOR_ARRAY);
+	qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
+
+	qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
+	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
+	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);
+
+	if ( qglLockArraysEXT )
+	{
+		qglLockArraysEXT(0, input->numVertexes);
+		GLimp_LogComment( "glLockArraysEXT\n" );
+	}
+
+	//
+	// call special shade routine
+	//
+	R_BindAnimatedImage( &tess.xstages[0]->bundle[0] );
+	GL_State( tess.xstages[0]->stateBits );
+	R_DrawElements( input->numIndexes, input->indexes );
+
+	// 
+	// now do any dynamic lighting needed
+	//
+	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
+		ProjectDlightTexture();
+	}
+
+	//
+	// now do fog
+	//
+	if ( tess.fogNum && tess.shader->fogPass ) {
+		RB_FogPass();
+	}
+
+	// 
+	// unlock arrays
+	//
+	if (qglUnlockArraysEXT) 
+	{
+		qglUnlockArraysEXT();
+		GLimp_LogComment( "glUnlockArraysEXT\n" );
+	}
+}
+
+//define	REPLACE_MODE
+
+void RB_StageIteratorLightmappedMultitexture( void ) {
+	shaderCommands_t *input;
+
+	input = &tess;
+
+	//
+	// log this call
+	//
+	if ( r_logFile->integer ) {
+		// don't just call LogComment, or we will get
+		// a call to va() every frame!
+		GLimp_LogComment( va("--- RB_StageIteratorLightmappedMultitexture( %s ) ---\n", tess.shader->name) );
+	}
+
+	//
+	// set face culling appropriately
+	//
+	GL_Cull( input->shader->cullType );
+
+	//
+	// set color, pointers, and lock
+	//
+	GL_State( GLS_DEFAULT );
+	qglVertexPointer( 3, GL_FLOAT, 16, input->xyz );
+
+#ifdef REPLACE_MODE
+	qglDisableClientState( GL_COLOR_ARRAY );
+	qglColor3f( 1, 1, 1 );
+	qglShadeModel( GL_FLAT );
+#else
+	qglEnableClientState( GL_COLOR_ARRAY );
+	qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.constantColor255 );
+#endif
+
+	//
+	// select base stage
+	//
+	GL_SelectTexture( 0 );
+
+	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+	R_BindAnimatedImage( &tess.xstages[0]->bundle[0] );
+	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
+
+	//
+	// configure second stage
+	//
+	GL_SelectTexture( 1 );
+	qglEnable( GL_TEXTURE_2D );
+	if ( r_lightmap->integer ) {
+		GL_TexEnv( GL_REPLACE );
+	} else {
+		GL_TexEnv( GL_MODULATE );
+	}
+	R_BindAnimatedImage( &tess.xstages[0]->bundle[1] );
+	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][1] );
+
+	//
+	// lock arrays
+	//
+	if ( qglLockArraysEXT ) {
+		qglLockArraysEXT(0, input->numVertexes);
+		GLimp_LogComment( "glLockArraysEXT\n" );
+	}
+
+	R_DrawElements( input->numIndexes, input->indexes );
+
+	//
+	// disable texturing on TEXTURE1, then select TEXTURE0
+	//
+	qglDisable( GL_TEXTURE_2D );
+	qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
+
+	GL_SelectTexture( 0 );
+#ifdef REPLACE_MODE
+	GL_TexEnv( GL_MODULATE );
+	qglShadeModel( GL_SMOOTH );
+#endif
+
+	// 
+	// now do any dynamic lighting needed
+	//
+	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
+		ProjectDlightTexture();
+	}
+
+	//
+	// now do fog
+	//
+	if ( tess.fogNum && tess.shader->fogPass ) {
+		RB_FogPass();
+	}
+
+	//
+	// unlock arrays
+	//
+	if ( qglUnlockArraysEXT ) {
+		qglUnlockArraysEXT();
+		GLimp_LogComment( "glUnlockArraysEXT\n" );
+	}
+}
+
+/*
+** RB_EndSurface
+*/
+void RB_EndSurface( void ) {
+	shaderCommands_t *input;
+
+	input = &tess;
+
+	if (input->numIndexes == 0) {
+		return;
+	}
+
+	if (input->indexes[SHADER_MAX_INDEXES-1] != 0) {
+		ri.Error (ERR_DROP, "RB_EndSurface() - SHADER_MAX_INDEXES hit");
+	}	
+	if (input->xyz[SHADER_MAX_VERTEXES-1][0] != 0) {
+		ri.Error (ERR_DROP, "RB_EndSurface() - SHADER_MAX_VERTEXES hit");
+	}
+
+	if ( tess.shader == tr.shadowShader ) {
+		RB_ShadowTessEnd();
+		return;
+	}
+
+	// for debugging of sort order issues, stop rendering after a given sort value
+	if ( r_debugSort->integer && r_debugSort->integer < tess.shader->sort ) {
+		return;
+	}
+
+	//
+	// update performance counters
+	//
+	backEnd.pc.c_shaders++;
+	backEnd.pc.c_vertexes += tess.numVertexes;
+	backEnd.pc.c_indexes += tess.numIndexes;
+	backEnd.pc.c_totalIndexes += tess.numIndexes * tess.numPasses;
+
+	//
+	// call off to shader specific tess end function
+	//
+	tess.currentStageIteratorFunc();
+
+	//
+	// draw debugging stuff
+	//
+	if ( r_showtris->integer ) {
+		DrawTris (input);
+	}
+	if ( r_shownormals->integer ) {
+		DrawNormals (input);
+	}
+	// clear shader so we can tell we don't have any unclosed surfaces
+	tess.numIndexes = 0;
+
+	GLimp_LogComment( "----------\n" );
+}
+
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_shader.c tremulous-ggp1-src/src/renderer/tr_shader.c
--- tremulous-ggp1-src.p/src/renderer/tr_shader.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_shader.c	2012-07-19 04:25:52.031556446 +0200
@@ -696,6 +696,10 @@
 					stage->bundle[0].numImageAnimations++;
 				}
 			}
+			if( stage->bundle[0].numImageAnimations > 1 ) {
+				stage->bundle[0].combinedImage = R_CombineImages(stage->bundle[0].numImageAnimations,
+										 stage->bundle[0].image);
+			}
 		}
 		else if ( !Q_stricmp( token, "videoMap" ) )
 		{
@@ -834,7 +838,10 @@
 			}
 			else if ( !Q_stricmp( token, "identityLighting" ) )
 			{
-				stage->rgbGen = CGEN_IDENTITY_LIGHTING;
+				if ( r_overBrightBits->integer == 0 )
+					stage->rgbGen = CGEN_IDENTITY;
+				else
+					stage->rgbGen = CGEN_IDENTITY_LIGHTING;
 			}
 			else if ( !Q_stricmp( token, "entity" ) )
 			{
@@ -1009,6 +1016,43 @@
 		}
 	}
 
+	// I assume DST_ALPHA is always 1, so I just replace it with GL_ONE
+	if ( blendSrcBits == GLS_SRCBLEND_DST_ALPHA )
+		blendSrcBits = GLS_SRCBLEND_ONE;
+	else if ( blendSrcBits == GLS_SRCBLEND_ONE_MINUS_DST_ALPHA )
+		blendSrcBits = GLS_SRCBLEND_ZERO;
+
+	if ( blendDstBits == GLS_DSTBLEND_DST_ALPHA )
+		blendDstBits = GLS_DSTBLEND_ONE;
+	else if ( blendDstBits == GLS_DSTBLEND_ONE_MINUS_DST_ALPHA )
+		blendDstBits = GLS_DSTBLEND_ZERO;
+
+	// If the image has no (real) alpha channel, we can do the same
+	// for SRC_ALPHA
+	if ( !stage->bundle[0].image[0]->hasAlpha &&
+	     stage->alphaGen == AGEN_IDENTITY) {
+		if ( blendSrcBits == GLS_SRCBLEND_SRC_ALPHA )
+			blendSrcBits = GLS_SRCBLEND_ONE;
+		else if ( blendSrcBits == GLS_SRCBLEND_ONE_MINUS_SRC_ALPHA )
+			blendSrcBits = GLS_SRCBLEND_ZERO;
+		
+		if ( blendDstBits == GLS_DSTBLEND_SRC_ALPHA )
+			blendDstBits = GLS_DSTBLEND_ONE;
+		else if ( blendDstBits == GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA )
+			blendDstBits = GLS_DSTBLEND_ZERO;
+
+		// also alphaFunc makes no sense without alpha
+		atestBits = 0;
+	} else {
+		// image has alpha, if we use alpha blending we can optimise
+		// alphafunc NONE to alphafunc GT0
+		if ( blendSrcBits == GLS_SRCBLEND_SRC_ALPHA &&
+		     blendDstBits == GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA &&
+		     atestBits == 0 ) {
+			atestBits = GLS_ATEST_GT_0;
+		}
+	}
+
 	//
 	// if cgen isn't explicitly specified, use either identity or identitylighting
 	//
@@ -1022,7 +1066,6 @@
 		}
 	}
 
-
 	//
 	// implicitly assume that a GL_ONE GL_ZERO blend mask disables blending
 	//
@@ -1402,6 +1445,7 @@
 {
 	char *token;
 	int s;
+	qboolean	polygonOffset = qfalse;
 
 	s = 0;
 
@@ -1517,7 +1561,7 @@
 		// polygonOffset
 		else if ( !Q_stricmp( token, "polygonOffset" ) )
 		{
-			shader.polygonOffset = qtrue;
+			polygonOffset = qtrue;
 			continue;
 		}
 		// entityMergable, allowing sprite surfaces from multiple entities
@@ -1610,6 +1654,13 @@
 		return qfalse;
 	}
 
+	if ( polygonOffset ) {
+		int i;
+		for( i = 0; i < s; i++ ) {
+			stages[i].stateBits |= GLS_POLYGON_OFFSET;
+		}
+	}
+
 	shader.explicitlyDefined = qtrue;
 
 	return qtrue;
@@ -1633,6 +1684,11 @@
 */
 static void ComputeStageIteratorFunc( void )
 {
+	int stage;
+	int units = glConfig.numTextureUnits;
+
+	if (!units) units = 1;
+	
 	shader.optimalStageIteratorFunc = RB_StageIteratorGeneric;
 
 	//
@@ -1644,6 +1700,137 @@
 		goto done;
 	}
 
+	if ( qglGenBuffersARB &&
+	     !r_greyscale->integer &&
+	     shader.lightmapIndex != LIGHTMAP_2D ) {
+		shader.useVBO = qtrue;
+	}
+	
+	// check all deformation stages
+	for ( stage = 0; stage < shader.numDeforms; stage ++ ) {
+		switch ( shader.deforms[stage].deformation ) {
+		case DEFORM_NONE:
+			break;
+		case DEFORM_WAVE:
+		case DEFORM_NORMALS:
+		case DEFORM_BULGE:
+			shader.useVBO = qfalse;
+			break;
+		case DEFORM_MOVE:
+		case DEFORM_PROJECTION_SHADOW:
+		case DEFORM_AUTOSPRITE:
+		case DEFORM_AUTOSPRITE2:
+		case DEFORM_TEXT0:
+		case DEFORM_TEXT1:
+		case DEFORM_TEXT2:
+		case DEFORM_TEXT3:
+		case DEFORM_TEXT4:
+		case DEFORM_TEXT5:
+		case DEFORM_TEXT6:
+		case DEFORM_TEXT7:
+			shader.useVBO = qfalse;
+			break;
+		}
+	}
+	
+	// check all shader stages
+	for ( stage = 0; stage < MAX_SHADER_STAGES; stage++ )
+	{
+		shaderStage_t *pStage = &stages[stage];
+		int           bundle;
+		
+		if ( !pStage->active )
+		{
+			break;
+		}
+		
+		switch ( pStage->rgbGen ) {
+		case CGEN_IDENTITY_LIGHTING:
+		case CGEN_IDENTITY:
+		case CGEN_ENTITY:
+		case CGEN_ONE_MINUS_ENTITY:
+		case CGEN_CONST:
+		case CGEN_WAVEFORM:
+			// constant color, VBO possible
+			break;
+		case CGEN_EXACT_VERTEX:
+		case CGEN_VERTEX:
+			// vertex colors, VBO possible
+			break;
+		case CGEN_LIGHTING_DIFFUSE:
+			// normals needed, no VBO possible
+			shader.useVBO = qfalse;
+			break;
+		case CGEN_ONE_MINUS_VERTEX:
+			// vertex colors needed, no VBO
+			shader.useVBO = qfalse;
+			break;
+		case CGEN_BAD:
+		case CGEN_FOG:
+			// no vertex colors needed, no VBO
+			shader.useVBO = qfalse;
+			break;
+		}
+
+		switch ( pStage->alphaGen ) {
+		case AGEN_SKIP:
+			break;
+		case AGEN_IDENTITY:
+		case AGEN_ENTITY:
+		case AGEN_ONE_MINUS_ENTITY:
+		case AGEN_CONST:
+		case AGEN_WAVEFORM:
+			if ( pStage->rgbGen == CGEN_VERTEX ||
+			     pStage->rgbGen == CGEN_EXACT_VERTEX ) {
+				// cannot combine const alpha with vertex color
+				shader.useVBO = qfalse;
+			}
+			break;
+		case AGEN_VERTEX:
+			if ( pStage->rgbGen != CGEN_VERTEX &&
+			     pStage->rgbGen != CGEN_EXACT_VERTEX ) {
+				// cannot combine vertex alpha with const color
+				shader.useVBO = qfalse;
+			}
+			break;
+		case AGEN_ONE_MINUS_VERTEX:
+			shader.useVBO = qfalse;
+			break;
+		case AGEN_LIGHTING_SPECULAR:
+		case AGEN_PORTAL:
+			shader.useVBO = qfalse;
+			break;
+		}
+		
+		for ( bundle = 0; bundle < units; bundle++ ) {
+			if ( bundle > 0 && !pStage->bundle[bundle].multitextureEnv )
+				break;
+			
+			switch ( pStage->bundle[bundle].tcGen ) {
+			case TCGEN_BAD:
+				break;
+			case TCGEN_IDENTITY:
+			case TCGEN_VECTOR:
+			case TCGEN_FOG:
+				shader.useVBO = qfalse;
+				break;
+			case TCGEN_LIGHTMAP:
+				break;
+			case TCGEN_TEXTURE:
+				break;
+			case TCGEN_ENVIRONMENT_MAPPED:
+				shader.useVBO = qfalse;
+				break;
+			}
+			if ( pStage->bundle[bundle].numTexMods > 0 )
+				shader.useVBO = qfalse;
+		}
+	}
+
+	// no VBOs for 0-stage shaders (fog)
+	if ( stage == 0 )
+		shader.useVBO = qfalse;
+
 	if ( r_ignoreFastPath->integer )
 	{
 		return;
@@ -1660,15 +1847,12 @@
 			{
 				if ( stages[0].bundle[0].tcGen == TCGEN_TEXTURE )
 				{
-					if ( !shader.polygonOffset )
+					if ( !stages[0].bundle[1].multitextureEnv )
 					{
-						if ( !shader.multitextureEnv )
+						if ( !shader.numDeforms )
 						{
-							if ( !shader.numDeforms )
-							{
-								shader.optimalStageIteratorFunc = RB_StageIteratorVertexLitTexture;
-								goto done;
-							}
+							shader.optimalStageIteratorFunc = RB_StageIteratorVertexLitTexture;
+							goto done;
 						}
 					}
 				}
@@ -1686,15 +1870,12 @@
 			if ( stages[0].bundle[0].tcGen == TCGEN_TEXTURE && 
 				stages[0].bundle[1].tcGen == TCGEN_LIGHTMAP )
 			{
-				if ( !shader.polygonOffset )
+				if ( !shader.numDeforms )
 				{
-					if ( !shader.numDeforms )
+					if ( stages[0].bundle[1].multitextureEnv )
 					{
-						if ( shader.multitextureEnv )
-						{
-							shader.optimalStageIteratorFunc = RB_StageIteratorLightmappedMultitexture;
-							goto done;
-						}
+						shader.optimalStageIteratorFunc = RB_StageIteratorLightmappedMultitexture;
+						goto done;
 					}
 				}
 			}
@@ -2016,8 +2197,20 @@
 			Com_Memcpy( newShader->stages[i]->bundle[b].texMods, stages[i].bundle[b].texMods, size );
 		}
 	}
+	if( shader.optimalStageIteratorFunc == RB_StageIteratorGLSL ) {
+		newShader->stages[0]->stateBits &= ~GLS_ATEST_BITS;
+	}
 
-	SortNewShader();
+	R_SortShaders();
+
+	// prepare occlusion queries for shaders that write to depth buffer
+	if ( qglGenQueriesARB && !newShader->isDepth &&
+	     newShader->stages[0] &&
+	     (newShader->stages[0]->stateBits & GLS_DEPTHMASK_TRUE) &&
+	     !(newShader->stages[0]->stateBits & GLS_COLORMASK_FALSE) ) {
+		qglGenQueriesARB( 1, &newShader->QueryID );
+		newShader->QueryResult = 0;
+	}
 
 	hash = generateHashValue(newShader->name, FILE_HASH_SIZE);
 	newShader->next = hashTable[hash];
@@ -2028,6 +2221,1593 @@
 
 /*
 =================
+CollapseGLSL
+
+Try to compile a GLSL vertex and fragment shader that
+computes the same effect as a multipass fixed function shader.
+=================
+*/
+static unsigned short GLSLversion = 0x0000;
+static char GLSLTexNames[MAX_SHADER_STAGES][6];
+static int CollapseGLSL( void ) {
+	enum VSFeatures {
+		vsfShaderTime = 0x00000001,
+		vsfNormal     = 0x00000002,
+		vsfColor      = 0x00000004,
+		vsfTexCoord   = 0x00000008,
+		vsfCameraPos  = 0x00000010,
+		vsfEntLight   = 0x00000080,
+		vsfLightDir   = 0x00000100,
+		vsfGenSin     = 0x00001000,
+		vsfGenSquare  = 0x00002000,
+		vsfGenTri     = 0x00004000,
+		vsfGenSaw     = 0x00008000,
+		vsfGenInvSaw  = 0x00010000,
+		vsfGenNoise   = 0x00020000
+	} vsFeatures = 0;
+	enum FSFeatures {
+		fsfShaderTime = 0x00000001,
+		fsfVertex     = 0x00000002,
+		fsfReflView   = 0x00000004,
+		fsfLightDir   = 0x00000008,
+		fsfNormal     = 0x00000100,
+		fsfTangents   = 0x00000200,
+		fsfDiffuse    = 0x00000400,
+		fsfSpecular   = 0x00000800,
+		fsfGenSin     = 0x00001000,
+		fsfGenSquare  = 0x00002000,
+		fsfGenTri     = 0x00004000,
+		fsfGenSaw     = 0x00008000,
+		fsfGenInvSaw  = 0x00010000,
+		fsfGenNoise   = 0x00020000,
+		fsfGenRotate  = 0x00040000,
+		fsfCameraPos  = 0x00080000
+	} fsFeatures = 0;
+	unsigned int attributes = (1 << AL_VERTEX) |
+		(1 << AL_TRANSX) | (1 << AL_TRANSY) | (1 << AL_TRANSZ);
+
+	const char *VS[1000];
+	const char *FS[1000];
+	byte        constantColor[MAX_SHADER_STAGES][4];
+	int         texIndex[MAX_SHADER_STAGES];
+	char        shaderConsts[100][20];
+	int         VSidx = 0;
+	int         FSidx = 0;
+	int         constidx = 0;
+	int         i, j;
+	int         lightmapStage = -1;
+	int         normalStage = -1;
+	int         materialStage = -1;
+	alphaGen_t  aGen;
+	enum {
+		REPLACE,
+		BLEND,
+		FILTER
+	} blendMode;
+
+	// helper macros to build the Vertex and Fragment Shaders
+#define VSText(text) VS[VSidx++] = text
+#define VSConst(format, value) VS[VSidx++] = shaderConsts[constidx]; Com_sprintf( shaderConsts[constidx++], sizeof(shaderConsts[0]), format, value)
+
+#define FSText(text) FS[FSidx++] = text
+#define FSConst(format, value) FS[FSidx++] = shaderConsts[constidx]; Com_sprintf( shaderConsts[constidx++], sizeof(shaderConsts[0]), format, value)
+#define FSGenFunc(wave) FSText("(");					\
+			FSConst("%f", wave.base);			\
+			FSText(" + ");					\
+			FSConst("%f", wave.amplitude);			\
+			switch( wave.func ) {				\
+			case GF_NONE:					\
+				return qfalse;				\
+			case GF_SIN:					\
+				FSText(" * genFuncSin(");		\
+				break;					\
+			case GF_SQUARE:					\
+				FSText(" * genFuncSquare(");		\
+				break;					\
+			case GF_TRIANGLE:				\
+				FSText(" * genFuncTriangle(");		\
+				break;					\
+			case GF_SAWTOOTH:				\
+				FSText(" * genFuncSawtooth(");		\
+				break;					\
+			case GF_INVERSE_SAWTOOTH:			\
+				FSText(" * genFuncInverseSawtooth(");	\
+				break;					\
+			case GF_NOISE:					\
+				FSText(" * genFuncNoise(");		\
+				break;					\
+			}						\
+			FSConst("%f", wave.phase);			\
+			FSText(" + ");					\
+			FSConst("%f", wave.frequency);			\
+			FSText("* vShadertime))");
+
+	if( !(qglCreateShader && stages[0].active) || shader.isSky ) {
+		// single stage can be rendered without GLSL
+		return qfalse;
+	}
+
+	if( shader.lightmapIndex == LIGHTMAP_MD3 && !qglGenBuffersARB ) {
+		// frame interpolation requires VBOs
+		return qfalse;
+	}
+
+	if( !GLSLversion ) {
+		const char *GLSLString = (const char *)glGetString( GL_SHADING_LANGUAGE_VERSION_ARB );
+		int major, minor;
+
+		sscanf( GLSLString, "%d.%d", &major, &minor );
+		GLSLversion = (unsigned short)(major << 8 | minor);
+		
+		for( i = 0; i < MAX_SHADER_STAGES; i++ ) {
+			Com_sprintf( GLSLTexNames[i], sizeof(GLSLTexNames[i]),
+				     "tex%02d", i );
+		}
+	}
+	
+#ifdef HACK_MEDISTAT_SHADER
+	if( (stages[0].stateBits & GLS_SRCBLEND_BITS) == GLS_SRCBLEND_ONE_MINUS_DST_COLOR &&
+	    (stages[0].stateBits & GLS_DSTBLEND_BITS) == GLS_DSTBLEND_ONE) {
+		stages[0].stateBits &= ~GLS_SRCBLEND_BITS;
+		stages[0].stateBits |= GLS_SRCBLEND_ONE;
+	}
+#endif
+
+	// *** compute required features ***
+	if( (stages[0].stateBits & GLS_SRCBLEND_BITS) == GLS_SRCBLEND_ONE_MINUS_DST_COLOR ||
+	    (stages[0].stateBits & GLS_DSTBLEND_BITS) == GLS_DSTBLEND_ONE_MINUS_SRC_COLOR ) {
+		return qfalse;
+	} else if( (stages[0].stateBits & GLS_SRCBLEND_BITS) == GLS_SRCBLEND_DST_COLOR ) {
+		blendMode = FILTER;
+	} else if( (stages[0].stateBits & GLS_DSTBLEND_BITS) == 0 ||
+		   (stages[0].stateBits & GLS_DSTBLEND_BITS) == GLS_DSTBLEND_ZERO ) {
+		blendMode = REPLACE;
+	} else {
+		blendMode = BLEND;
+	}
+
+	// deforms
+	for( i = 0; i < shader.numDeforms; i++ ) {
+		switch( shader.deforms[i].deformation ) {
+		case DEFORM_NONE:
+			break;
+		case DEFORM_WAVE:
+			vsFeatures |= vsfNormal;
+			// fall through
+		case DEFORM_MOVE:
+			switch( shader.deforms[i].deformationWave.func ) {
+			case GF_NONE:
+				return qfalse;
+			case GF_SIN:
+				vsFeatures |= vsfShaderTime | vsfGenSin;
+				break;
+			case GF_SQUARE:
+				vsFeatures |= vsfShaderTime | vsfGenSquare;
+				break;
+			case GF_TRIANGLE:
+				vsFeatures |= vsfShaderTime | vsfGenTri;
+				break;
+			case GF_SAWTOOTH:
+				vsFeatures |= vsfShaderTime | vsfGenSaw;
+				break;
+			case GF_INVERSE_SAWTOOTH:
+				vsFeatures |= vsfShaderTime | vsfGenInvSaw;
+				break;
+			case GF_NOISE:
+				vsFeatures |= vsfShaderTime | vsfGenNoise;
+				break;
+			}
+			break;
+		case DEFORM_NORMALS:
+			vsFeatures |= vsfShaderTime;
+			break;
+		case DEFORM_BULGE:
+			vsFeatures |= vsfTexCoord | vsfNormal | vsfShaderTime;
+			break;
+		default:
+			return qfalse;
+		}
+	}
+	// textures
+	for( i = 0; i < MAX_SHADER_STAGES; i++ ) {
+		shaderStage_t *pStage = &stages[i];
+		
+		if( !pStage->active ) {
+			break;
+		}
+
+		if( pStage->bundle[0].isLightmap ) {
+			lightmapStage = i;
+		}
+
+		if( (pStage->stateBits & GLS_SRCBLEND_BITS) == GLS_SRCBLEND_DST_COLOR &&
+		    (blendMode == BLEND) ) {
+			//return qfalse;
+		} else if( blendMode == FILTER &&
+			   (pStage->stateBits & GLS_SRCBLEND_BITS) != GLS_SRCBLEND_DST_COLOR ) {
+			return qfalse;
+		}
+		
+		// this is called before CollapseMultitexture,
+		// so each stages has at most one bundle
+		switch( pStage->bundle[0].tcGen ) {
+		case TCGEN_IDENTITY:
+			break;
+		case TCGEN_LIGHTMAP:
+			vsFeatures |= vsfTexCoord;
+			break;
+		case TCGEN_TEXTURE:
+			vsFeatures |= vsfTexCoord;
+			break;
+		case TCGEN_ENVIRONMENT_MAPPED:
+			vsFeatures |= vsfNormal | vsfCameraPos;
+			fsFeatures |= fsfNormal | fsfReflView | fsfCameraPos;
+			break;
+		case TCGEN_FOG:
+			return qfalse;
+		case TCGEN_VECTOR:
+			fsFeatures |= fsfVertex;
+			break;
+		default:
+			return qfalse;
+		}
+		
+		for( j = 0; j < pStage->bundle[0].numTexMods; j++ ) {
+			texModInfo_t *pTexMod = &(pStage->bundle[0].texMods[j]);
+			
+			switch( pTexMod->type ) {
+			case TMOD_NONE:
+				break;
+			case TMOD_TRANSFORM:
+				break;
+			case TMOD_TURBULENT:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfVertex;
+				break;
+			case TMOD_SCROLL:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime;
+				break;
+			case TMOD_SCALE:
+				break;
+			case TMOD_STRETCH:
+				switch( pTexMod->wave.func ) {
+				case GF_NONE:
+					return qfalse;
+				case GF_SIN:
+					vsFeatures |= vsfShaderTime;
+					fsFeatures |= fsfShaderTime | fsfGenSin;
+					break;
+				case GF_SQUARE:
+					vsFeatures |= vsfShaderTime;
+					fsFeatures |= fsfShaderTime | fsfGenSquare;
+					break;
+				case GF_TRIANGLE:
+					vsFeatures |= vsfShaderTime;
+					fsFeatures |= fsfShaderTime | fsfGenTri;
+					break;
+				case GF_SAWTOOTH:
+					vsFeatures |= vsfShaderTime;
+					fsFeatures |= fsfShaderTime | fsfGenSaw;
+					break;
+				case GF_INVERSE_SAWTOOTH:
+					vsFeatures |= vsfShaderTime;
+					fsFeatures |= fsfShaderTime | fsfGenInvSaw;
+					break;
+				case GF_NOISE:
+					vsFeatures |= vsfShaderTime;
+					fsFeatures |= fsfShaderTime | fsfGenNoise;
+					break;
+				}
+				break;
+			case TMOD_ROTATE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenRotate;
+				break;
+			case TMOD_ENTITY_TRANSLATE:
+				return qfalse;
+			default:
+				return qfalse;
+			}
+		}
+		if( pStage->bundle[0].combinedImage ) {
+			vsFeatures |= vsfShaderTime;
+			fsFeatures |= fsfShaderTime;
+		}
+
+		switch( pStage->rgbGen ) {
+		case CGEN_IDENTITY_LIGHTING:
+			constantColor[i][0] =
+			constantColor[i][1] =
+			constantColor[i][2] = tr.identityLightByte;
+			aGen = AGEN_IDENTITY;
+			break;
+		case CGEN_IDENTITY:
+			constantColor[i][0] =
+			constantColor[i][1] =
+			constantColor[i][2] = 255;
+			aGen = AGEN_IDENTITY;
+			break;
+		case CGEN_ENTITY:
+			aGen = AGEN_ENTITY;
+			vsFeatures |= vsfColor;
+			break;
+		case CGEN_ONE_MINUS_ENTITY:
+			aGen = AGEN_ONE_MINUS_ENTITY;
+			vsFeatures |= vsfColor;
+			break;
+		case CGEN_EXACT_VERTEX:
+			aGen = AGEN_VERTEX;
+			vsFeatures |= vsfColor;
+			break;
+		case CGEN_VERTEX:
+			aGen = AGEN_VERTEX;
+			vsFeatures |= vsfColor;
+			break;
+		case CGEN_ONE_MINUS_VERTEX:
+			aGen = AGEN_ONE_MINUS_VERTEX;
+			vsFeatures |= vsfColor;
+			break;
+		case CGEN_WAVEFORM:
+			switch( pStage->rgbWave.func ) {
+			case GF_NONE:
+				return qfalse;
+			case GF_SIN:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenSin;
+				break;
+			case GF_SQUARE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenSquare;
+				break;
+			case GF_TRIANGLE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenTri;
+				break;
+			case GF_SAWTOOTH:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenSaw;
+				break;
+			case GF_INVERSE_SAWTOOTH:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenInvSaw;
+				break;
+			case GF_NOISE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenNoise;
+				break;
+			};
+			aGen = AGEN_IDENTITY;
+			break;
+		case CGEN_LIGHTING_DIFFUSE:
+			aGen = AGEN_IDENTITY;
+			vsFeatures |= vsfEntLight | vsfLightDir | vsfNormal;
+			fsFeatures |= fsfLightDir | fsfNormal | fsfDiffuse;
+			break;
+		case CGEN_FOG:
+			aGen = AGEN_IDENTITY;
+			return qfalse;
+		case CGEN_CONST:
+			constantColor[i][0] = pStage->constantColor[0];
+			constantColor[i][1] = pStage->constantColor[1];
+			constantColor[i][2] = pStage->constantColor[2];
+			aGen = AGEN_IDENTITY;
+			break;
+		default:
+			return qfalse;
+		}
+
+		if ( pStage->alphaGen == AGEN_SKIP )
+			pStage->alphaGen = aGen;
+
+		switch( pStage->alphaGen ) {
+		case AGEN_IDENTITY:
+			constantColor[i][3] = 255;
+			break;
+		case AGEN_ENTITY:
+			vsFeatures |= vsfColor;
+			break;
+		case AGEN_ONE_MINUS_ENTITY:
+			vsFeatures |= vsfColor;
+			break;
+		case AGEN_VERTEX:
+			vsFeatures |= vsfColor;
+			break;
+		case AGEN_ONE_MINUS_VERTEX:
+			vsFeatures |= vsfColor;
+			break;
+		case AGEN_LIGHTING_SPECULAR:
+			vsFeatures |= vsfNormal | vsfLightDir | vsfCameraPos;
+			fsFeatures |= fsfNormal | fsfReflView | fsfCameraPos | fsfSpecular | fsfLightDir;
+			break;
+		case AGEN_WAVEFORM:
+			switch( pStage->alphaWave.func ) {
+			case GF_NONE:
+				return qfalse;
+			case GF_SIN:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenSin;
+				break;
+			case GF_SQUARE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenSquare;
+				break;
+			case GF_TRIANGLE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenTri;
+				break;
+			case GF_SAWTOOTH:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenSaw;
+				break;
+			case GF_INVERSE_SAWTOOTH:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenInvSaw;
+				break;
+			case GF_NOISE:
+				vsFeatures |= vsfShaderTime;
+				fsFeatures |= fsfShaderTime | fsfGenNoise;
+				break;
+			};
+			break;
+		case AGEN_PORTAL:
+			vsFeatures |= vsfCameraPos | vsfNormal;
+			fsFeatures |= fsfCameraPos;
+			break;
+		case AGEN_CONST:
+			constantColor[i][3] = pStage->constantColor[3];
+			break;
+		default:
+
+			return qfalse;
+		}
+	}
+	if( stages[0].bundle[0].isLightmap ) {
+		j = 1;
+	} else {
+		j = 0;
+	}
+	if( i < MAX_SHADER_STAGES &&
+	    r_perPixelLighting->integer &&
+	    stages[j].active &&
+	    stages[j].bundle[0].tcGen == TCGEN_TEXTURE &&
+	    stages[j].bundle[0].numTexMods == 0 &&
+	    stages[j].bundle[0].image[0] &&
+	    *stages[j].bundle[0].image[0]->imgName > '/' ) {
+		// check if a normal/bump map exists, skip if
+		// the base texture has texture mods (rotation etc.)
+		char name[MAX_QPATH];
+		if( stages[0].bundle[0].isLightmap ) {
+			COM_StripExtension( stages[1].bundle[0].image[0]->imgName, name, sizeof(name) );
+		} else {
+			COM_StripExtension( stages[0].bundle[0].image[0]->imgName, name, sizeof(name) );
+		}
+		strcat( name, "_nm" );
+		stages[i].bundle[0].image[0] = R_FindHeightMapFile( name, qtrue, GL_REPEAT );
+		if( stages[i].bundle[0].image[0] ) {
+			normalStage = i++;
+			stages[normalStage].active = qtrue;
+			stages[normalStage].bundle[0].tcGen = TCGEN_TEXTURE;
+			vsFeatures |= vsfNormal | vsfCameraPos;
+			fsFeatures |= fsfVertex | fsfNormal | fsfTangents | fsfCameraPos;
+		}
+	}
+	if( i < MAX_SHADER_STAGES &&
+	    stages[j].active &&
+	    stages[j].bundle[0].tcGen == TCGEN_TEXTURE &&
+	    stages[j].bundle[0].numTexMods == 0 &&
+	    stages[j].bundle[0].image[0] &&
+	    *stages[j].bundle[0].image[0]->imgName > '/' ) {
+		// check if a material map exists, skip if
+		// the base texture has texture mods (rotation etc.)
+		char name[MAX_QPATH];
+		if( stages[0].bundle[0].isLightmap ) {
+			COM_StripExtension( stages[1].bundle[0].image[0]->imgName, name, sizeof(name) );
+		} else {
+			COM_StripExtension( stages[0].bundle[0].image[0]->imgName, name, sizeof(name) );
+		}
+		strcat( name, "_mat" );
+		stages[i].bundle[0].image[0] = R_FindImageFile( name, qtrue, qtrue, GL_REPEAT );
+		if( stages[i].bundle[0].image[0] ) {
+			materialStage = i++;
+			stages[materialStage].active = qtrue;
+			stages[materialStage].bundle[0].tcGen = TCGEN_TEXTURE;
+			vsFeatures |= vsfNormal | vsfLightDir | vsfCameraPos;
+			fsFeatures |= fsfNormal | fsfReflView | fsfCameraPos | fsfSpecular | fsfLightDir;
+		}
+	}
+
+	// *** assemble shader fragments ***
+	// version pragma
+	if ( GLSLversion < 0x010a ) {
+		return qfalse;
+	}
+	VSText("#version 110\n"
+	       "\n");
+	//VSText("/*");VSText(shader.name);VSText("*/\n");
+	FSText("#version 110\n"
+	       "\n"
+	       "const vec3 constants = vec3( 0.0, 1.0, ");
+	FSConst("%f", tr.identityLight );
+	FSText(" );\n\n");
+	
+	// attributes
+	VSText("// attribute vec4 aVertex;\n"
+	       "#define aVertex gl_Vertex\n");
+	if( vsFeatures & vsfTexCoord ) {
+		VSText("//attribute vec4 aTexCoord;\n"
+		       "#define aTexCoord gl_MultiTexCoord0\n");
+	}
+	if( vsFeatures & vsfColor ) {
+		VSText("// attribute vec4 aColor;\n"
+		       "#define aColor gl_Color\n");
+	}
+	if( shader.lightmapIndex == LIGHTMAP_MD3 ||
+	    (vsFeatures & vsfShaderTime) ) {
+		VSText("attribute vec4  aTimes;\n");
+	}
+	
+	if( shader.lightmapIndex != LIGHTMAP_MD3 ) {
+		if( vsFeatures & vsfNormal ) {
+			VSText("// attribute vec3 aNormal;\n"
+			       "#define aNormal gl_Normal\n");
+		}
+	}
+	VSText("attribute vec4 aTransX, aTransY, aTransZ;\n");
+	if( vsFeatures & vsfEntLight ) {
+		VSText("attribute vec3 aAmbientLight;\n");
+		VSText("attribute vec3 aDirectedLight;\n");
+	}
+	if( vsFeatures & vsfLightDir ) {
+		VSText("attribute vec4 aLightDir;\n");
+	}
+	if( vsFeatures & vsfCameraPos ) {
+		VSText("\nattribute vec3 aCameraPos;\n");
+	}
+	
+	// varyings
+	if( vsFeatures & vsfTexCoord ) {
+		VSText("varying vec4 vTexCoord;\n");
+		FSText("varying vec4 vTexCoord;\n");
+	}
+	if( vsFeatures & vsfColor ) {
+		VSText("varying vec4 vColor;\n");
+		FSText("varying vec4 vColor;\n");
+	}
+	if( fsFeatures & fsfVertex ) {
+		VSText("varying vec3 vVertex;\n");
+		FSText("varying vec3 vVertex;\n");
+	}
+	if( fsFeatures & fsfNormal ) {
+		VSText("varying vec3 vNormal;\n");
+		FSText("varying vec3 vNormal;\n");
+	}
+	if( fsFeatures & fsfLightDir ) {
+		if( r_perPixelLighting->integer ) {
+			VSText("varying vec4 vLightDir;\n");
+			FSText("varying vec4 vLightDir;\n");
+			if( fsFeatures & fsfDiffuse ) {
+				// per pixel diffuse light
+				VSText("varying vec3 vAmbientLight, vDirectedLight;\n");
+				FSText("varying vec3 vAmbientLight, vDirectedLight;\n");
+			}
+		} else {
+			if( fsFeatures & fsfDiffuse ) {
+				// interpolated diffuse
+				VSText("varying vec3 vDiffuse;\n");
+				FSText("varying vec3 vDiffuse;\n");
+			}
+			if( fsFeatures & fsfSpecular ) {
+				// interpolated specular
+				VSText("varying float vSpecular;\n");
+				FSText("varying float vSpecular;\n");
+			}
+		}
+	}
+	if( fsFeatures & fsfReflView ) {
+		if( r_perPixelLighting->integer ) {
+			// calculated in fragment shader
+		} else {
+			// interpolated
+			VSText("varying vec3 vReflView;\n");
+			FSText("varying vec3 vReflView;\n");
+		}
+	}
+	if( fsFeatures & fsfShaderTime ) {
+		VSText("varying float vShadertime;\n");
+		FSText("varying float vShadertime;\n");
+	}
+	if( fsFeatures & fsfCameraPos ) {
+		VSText("varying vec3 vCameraPos;\n");
+		FSText("varying vec3 vCameraPos;\n");
+	}
+	
+	// uniforms
+	if( shader.lightmapIndex == LIGHTMAP_MD3 ) {
+		VSText("uniform sampler2D texData;\n");
+	}
+	for( i = 0; i < MAX_SHADER_STAGES; i++ ) {
+		shaderStage_t *pStage = &stages[i];
+		
+		if( !pStage->active )
+			break;
+		
+		for( j = 0; j < i; j++ ) {
+			if( pStage->bundle[0].image[0] == stages[j].bundle[0].image[0] )
+				break;
+		}
+		if( j < i ) {
+			texIndex[i] = j;
+		} else {
+			texIndex[i] = i;
+			FSText("uniform sampler2D ");
+			FSText(GLSLTexNames[i]);
+			FSText(";\n");
+		}
+	}
+	if( normalStage >= 0 ) {
+		FSText("const int HMLevels = ");
+		FSConst("%d", stages[normalStage].bundle[0].image[0]->maxMipLevel);
+		FSText(";\n"
+		       "const float HMSize = ");
+		FSConst("%f", (float)stages[normalStage].bundle[0].image[0]->uploadWidth);
+		FSText(";\n"
+		       "\n");
+	}
+	
+	// functions
+	VSText("\n"
+	       "vec3 transform3(vec3 vector) {\n"
+	       "  return vec3( dot( aTransX.xyz, vector ),\n"
+	       "               dot( aTransY.xyz, vector ),\n"
+	       "               dot( aTransZ.xyz, vector ) );\n"
+	       "}\n"
+	       "vec3 transform4(vec4 point) {\n"
+	       "  return vec3( dot( aTransX, point ),\n"
+	       "               dot( aTransY, point ),\n"
+	       "               dot( aTransZ, point ) );\n"
+	       "}\n");
+
+	if( vsFeatures & vsfGenSin ) {
+		VSText("float genFuncSin(in float x) {\n"
+		       "  return sin(6.283185308 * x);\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenSin ) {
+		FSText("float genFuncSin(in float x) {\n"
+		       "  return sin(6.283185308 * x);\n"
+		       "}\n\n");
+	}
+	if( vsFeatures & vsfGenSquare ) {
+		VSText("float genFuncSquare(in float x) {\n"
+		       "  return sign(fract(x) - 0.5);\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenSquare ) {
+		FSText("float genFuncSquare(in float x) {\n"
+		       "  return sign(fract(x) - 0.5);\n"
+		       "}\n\n");
+	}
+	if( vsFeatures & vsfGenTri ) {
+		VSText("float genFuncTriangle(in float x) {\n"
+		       "  return 4.0 * abs(fract(x - 0.25) - 0.5) - 1.0;\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenTri ) {
+		FSText("float genFuncTriangle(in float x) {\n"
+		       "  return 4.0 * abs(fract(x - 0.25) - 0.5) - 1.0;\n"
+		       "}\n\n");
+	}
+	if( vsFeatures & vsfGenSaw ) {
+		VSText("float genFuncSawtooth(in float x) {\n"
+		       "  return fract(x);\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenSaw ) {
+		FSText("float genFuncSawtooth(in float x) {\n"
+		       "  return fract(x);\n"
+		       "}\n\n");
+	}
+	if( vsFeatures & vsfGenInvSaw ) {
+		VSText("float genFuncInverseSawtooth(in float x) {\n"
+		       "  return 1.0 - fract(x);\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenInvSaw ) {
+		FSText("float genFuncInverseSawtooth(in float x) {\n"
+		       "  return 1.0 - fract(x);\n"
+		       "}\n\n");
+	}
+	if( vsFeatures & vsfGenNoise ) {
+		VSText("float genFuncNoise(in float x) {\n"
+		       "  return noise1(x);\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenNoise ) {
+		FSText("float genFuncNoise(in float x) {\n"
+		       "  return noise1(x);\n"
+		       "}\n\n");
+	}
+	if( fsFeatures & fsfGenRotate ) {
+		FSText("mat2 genFuncRotate(in float x) {\n"
+		       "  vec2 sincos = sin(6.283185308 / 360.0 * vec2(x, x + 90.0));\n"
+		       "  return mat2(sincos.y, -sincos.x, sincos.x, sincos.y);\n"
+		       "}\n\n");
+	}
+	if( normalStage >= 0 && r_parallax->integer == 1 ) {
+		FSText("vec3 intersectHeightMap(const vec3 startPos, const vec3 traceVec) {\n"
+		       "  vec3 tracePos = startPos;\n"
+		       "  vec4 sample = texture2D(");
+		FSText(GLSLTexNames[texIndex[normalStage]]);
+		FSText(", tracePos.xy);\n"
+		       "  float depth = 1.0 - sample.a;\n"
+		       "  tracePos = startPos + traceVec * depth;\n"
+		       "  sample = texture2D(");
+		FSText(GLSLTexNames[texIndex[normalStage]]);
+		FSText(", tracePos.xy);\n"
+		       "  depth = mix(depth, 1.0 - sample.a, 0.5);\n"
+		       "  tracePos = startPos + traceVec * depth;\n"
+		       "  sample = texture2D(");
+		FSText(GLSLTexNames[texIndex[normalStage]]);
+		FSText(", tracePos.xy);\n"
+		       "  depth = mix(depth, 1.0 - sample.a, 0.5);\n"
+		       "  tracePos = startPos + traceVec * depth;\n"
+		       "  return tracePos;\n"
+		       "}\n\n");
+	}
+	if( normalStage >= 0 && r_parallax->integer == 2 ) {
+		FSText("float getHMLevel(const vec2 tc, const float scale, const float invScale) {\n"
+		       "  vec2 texel = (floor(tc * scale) + 0.5) * invScale;\n"
+		       "  if( scale < HMSize * 0.75 ) texel -= 0.5 / HMSize;\n"
+		       "  vec4 tmp = texture2D(");
+		FSText(GLSLTexNames[texIndex[normalStage]]);
+		FSText(", texel);\n"
+		       "  if( scale >= HMSize * 0.75 )\n"
+		       "    return tmp.w;\n"
+		       "  else\n"
+		       "    return tmp.z;\n"
+		       "}\n"
+		       "\n"
+		       "vec3 intersectHeightMap(const vec3 startPos, const vec3 traceVec) {\n"
+		       "  vec3 tracePos = startPos;\n"
+		       "  vec2 border = (sign(traceVec.xy) + 1.0 ) * 0.5;\n"
+		       "  vec2 slope = 1.0 / traceVec.xy;\n"
+		       "  int level = HMLevels, crossings = 20;\n"
+		       "  float scale = 1.0;\n"
+		       "  float invScale = 1.0;\n"
+		       "  \n"
+		       "  vec2 crossPos;\n"
+		       "  float crossDepth;\n"
+		       "  \n"
+		       "  while( level >= 0 ) {\n"
+		       "    float h = getHMLevel(tracePos.xy, scale, invScale);\n"
+		       "    crossPos = 1.0 - (floor(scale * tracePos.xy + border) * invScale - startPos.xy) * slope;\n"
+		       "    crossDepth = max(crossPos.x, crossPos.y);\n"
+		       "    if( h < crossDepth ) {\n"
+		       "      h = crossDepth - 0.0001;\n"
+		       "      tracePos = startPos + (1.0 - h) * traceVec;\n"
+		       "      if( --crossings == 0 ) break;\n"  // just to prevent infinite loops
+		       "    } else {\n"
+		       "      if( h < tracePos.z )\n"
+		       "        tracePos = startPos + (1.0 - h) * traceVec;\n"
+		       "      scale *= 2.0;\n"
+		       "      invScale *= 0.5;\n"
+		       "      level--;\n"
+		       "    }\n"
+		       "  }\n"
+		       "  \n"
+		       "  vec2 posIn  = 1.0 - (floor(tracePos.xy * scale + 1.0 - border) * invScale - startPos.xy) * slope;\n"
+		       "  vec2 posOut = 1.0 - (floor(tracePos.xy * scale + border) * invScale - startPos.xy) * slope;\n"
+		       "  float depthIn  = min(posIn.x, posIn.y);\n"
+		       "  float depthOut = max(posOut.x, posOut.y);\n"
+		       "  float h1 = texture2D(");
+		FSText(GLSLTexNames[texIndex[normalStage]]);
+		FSText(", startPos.xy + (1.0 - depthIn) * traceVec.xy).w;\n"
+		       "  float h2 = texture2D(");
+		FSText(GLSLTexNames[texIndex[normalStage]]);
+		FSText(", startPos.xy + (1.0 - depthOut) * traceVec.xy).w;\n"
+		       "  float h = (depthIn * h1 + depthOut * h2) / (depthIn - depthOut + h1 + h2);\n"
+		       "  tracePos = startPos + (1.0 - h) * traceVec;\n"
+		       "  return tracePos;\n"
+		       "}\n\n");
+	}
+	if( shader.lightmapIndex == LIGHTMAP_MD3 ) {
+		if( vsFeatures & vsfNormal ) {
+			VSText("vec4 fetchVertex(const float frameNo, const vec2 offset,\n"
+			       "                 out vec4 normal) {\n"
+			       "  vec2 tc = vec2(fract(frameNo), floor(frameNo)/1024.0) + offset;\n"
+			       "  vec4 data = texture2D(texData, tc);\n"
+			       "  vec4 lo = fract(data);\n"
+			       "  vec4 hi = floor(data);\n"
+			       "  normal = vec4((hi.xyz - 128.0) / 127.0, 0.0);\n"
+			       "  return vec4(lo.xyz * 1024.0 - 512.0,\n"
+			       "              1.0);\n"
+			       "}\n\n");
+		} else {
+			VSText("vec4 fetchVertex(const float frameNo, const vec2 offset) {\n"
+			       "  vec2 tc = vec2(fract(frameNo), floor(frameNo)/1024.0) + offset;\n"
+			       "  vec4 data = texture2D(texData, tc);\n"
+			       "  vec4 lo = fract(data);\n"
+			       "  return vec4(lo.xyz * 1024.0 - 512.0,\n"
+			       "              1.0);\n"
+			       "}\n\n");
+		}
+	}
+	
+	// main
+	VSText("\n"
+	       "void main() {\n"
+	       "  vec4 vertex;\n");
+	if( vsFeatures & vsfNormal ) {
+		VSText("  vec4 normal;\n");
+	}
+	if( shader.lightmapIndex == LIGHTMAP_MD3 ) {
+		// interpolate position and normal from two frames
+		if( vsFeatures & vsfNormal ) {
+			VSText("  vec4 normal1, normal2;\n"
+			       "  vertex = mix(fetchVertex(aTimes.z, aVertex.zw, normal1),\n"
+			       "               fetchVertex(aTimes.w, aVertex.zw, normal2),\n"
+			       "               aTimes.y);\n"
+			       "  normal = normalize(mix(normal1, normal2, aTimes.y));\n");
+		} else {
+			VSText("  vertex = mix(fetchVertex(aTimes.z, aVertex.zw),\n"
+			       "               fetchVertex(aTimes.w, aVertex.zw),\n"
+			       "               aTimes.y);\n");
+		}
+		if( vsFeatures & vsfTexCoord ) {
+			VSText("  vTexCoord = aVertex.xyxy;\n");
+		}
+		if( vsFeatures & vsfColor ) {
+			VSText("  vColor = aColor;\n");
+		}
+	} else {
+		VSText("  \n"
+		       "  vertex = vec4(aVertex.xyz, 1.0);\n");
+		if( vsFeatures & vsfNormal ) {
+			VSText("  normal = vec4(aNormal, 0.0);\n");
+		}
+		if( vsFeatures & vsfTexCoord ) {
+			VSText("  vTexCoord = aTexCoord;\n");
+		}
+		if( vsFeatures & vsfColor ) {
+			VSText("  vColor = aColor;\n");
+		}
+	}
+	if( fsFeatures & fsfShaderTime ) {
+		VSText("  \n"
+		       "  vShadertime = aTimes.x;\n");
+	}
+	
+	// apply deforms
+	for( i = 0; i < shader.numDeforms; i++ ) {
+		switch ( shader.deforms[i].deformation ) {
+		case DEFORM_NONE:
+			break;
+		case DEFORM_WAVE:
+			VSText("  \n"
+			       "  vertex += (");
+			VSConst("%f", shader.deforms[i].deformationWave.base);
+			VSText(" + ");
+			VSConst("%f", shader.deforms[i].deformationWave.amplitude);
+			switch( shader.deforms[i].deformationWave.func ) {
+			case GF_NONE:
+				return qfalse;
+			case GF_SIN:
+				VSText(" * genFuncSin(");
+				break;
+			case GF_SQUARE:
+				VSText(" * genFuncSquare(");
+				break;
+			case GF_TRIANGLE:
+				VSText(" * genFuncTriangle(");
+				break;
+			case GF_SAWTOOTH:
+				VSText(" * genFuncSawtooth(");
+				break;
+			case GF_INVERSE_SAWTOOTH:
+				VSText(" * genFuncInverseSawtooth(");
+				break;
+			case GF_NOISE:
+				VSText(" * genFuncNoise(");
+				break;
+			}
+			VSConst("%f", shader.deforms[i].deformationWave.phase);
+			VSText(" + dot(vertex.xyz, vec3(");
+			VSConst("%f", shader.deforms[i].deformationSpread);
+			VSText(")) + ");
+			VSConst("%f", shader.deforms[i].deformationWave.frequency);
+			VSText(" * aTimes.x)) * normal;\n");
+			break;
+		case DEFORM_NORMALS:
+			VSText("  \n"
+			       "  normal.xyz = normalize(normal.xyz + 0.98*noise3(vec4(vertex.xyz, aTimes.x * ");
+			VSConst("%f", shader.deforms[i].deformationWave.frequency);
+			VSText("));\n");
+			break;
+		case DEFORM_BULGE:
+			VSText("  \n"
+			       "  vertex += (");
+			VSConst("%f", shader.deforms[i].bulgeHeight);
+			VSText(" * sin(aTexCoord.x * ");
+			VSConst("%f", shader.deforms[i].bulgeWidth);
+			VSText(" + aTimes.x * ");
+			VSConst("%f", shader.deforms[i].bulgeSpeed * 0.001f);
+			VSText(")) * normal;\n");
+			break;
+		case DEFORM_MOVE:
+			VSText("  \n"
+			       "  vertex.xyz += (");
+			VSConst("%f", shader.deforms[i].deformationWave.base);
+			VSText(" + ");
+			VSConst("%f", shader.deforms[i].deformationWave.amplitude);
+			switch( shader.deforms[i].deformationWave.func ) {
+			case GF_NONE:
+				return qfalse;
+			case GF_SIN:
+				VSText(" * genFuncSin(");
+				break;
+			case GF_SQUARE:
+				VSText(" * genFuncSquare(");
+				break;
+			case GF_TRIANGLE:
+				VSText(" * genFuncTriangle(");
+				break;
+			case GF_SAWTOOTH:
+				VSText(" * genFuncSawtooth(");
+				break;
+			case GF_INVERSE_SAWTOOTH:
+				VSText(" * genFuncInverseSawtooth(");
+				break;
+			case GF_NOISE:
+				VSText(" * genFuncNoise(");
+				break;
+			}
+			VSConst("%f", shader.deforms[i].deformationWave.phase);
+			VSText(" + ");
+			VSConst("%f", shader.deforms[i].deformationWave.frequency);
+			VSText(" * aTimes.x)) * vec3(");
+			VSConst("%f", shader.deforms[i].moveVector[0]);
+			VSText(", ");
+			VSConst("%f", shader.deforms[i].moveVector[1]);
+			VSText(", ");
+			VSConst("%f", shader.deforms[i].moveVector[2]);
+			VSText(");\n");
+			break;
+		default:
+			return qfalse;
+		}
+	}
+	VSText("  vertex = vec4(transform4(vertex), 1.0);\n");
+	if( vsFeatures & vsfNormal ) {
+		VSText("  normal = vec4( transform3( normal.xyz ), 0.0 );\n");
+	}
+	if( fsFeatures & fsfVertex ) {
+		VSText("  vVertex = vertex.xyz;\n");
+	}
+	if( fsFeatures & fsfNormal ) {
+		VSText("  \n"
+		       "  vNormal = normal.xyz;\n");
+	}
+	if( fsFeatures & fsfCameraPos ) {
+		VSText("  vCameraPos = vertex.xyz - aCameraPos.xyz;\n");
+	}
+	if( fsFeatures & fsfLightDir ) {
+		VSText("  vec3 lightDir = normalize(transform3(aLightDir.xyz));\n");
+		if( r_perPixelLighting->integer ) {
+			VSText("  vLightDir = vec4(lightDir, aLightDir.w);\n" );
+		}
+	}
+	
+	if( fsFeatures & fsfDiffuse ) {
+		if( r_perPixelLighting->integer ) {
+			VSText("  \n"
+			       "  vAmbientLight  = aAmbientLight;\n"
+			       "  vDirectedLight = aDirectedLight;\n");
+		} else {
+			VSText("  \n"
+			       "  float diffuse = max(0.0, dot(normal.xyz, lightDir.xyz));\n"
+			       "  vDiffuse = clamp(aAmbientLight + diffuse * aDirectedLight, 0.0, 1.0);\n");
+		}
+	}
+	if( fsFeatures & fsfReflView ) {
+		if( r_perPixelLighting->integer ) {
+		} else {
+			VSText("  \n"
+			       "  vReflView = reflect(vertex.xyz - aCameraPos, normalize(normal.xyz));\n");
+		}
+	}
+	if( fsFeatures & fsfSpecular ) {
+		if( r_perPixelLighting->integer ) {
+		} else {
+			VSText("  vSpecular = max(0.0, 4.0 * dot(lightDir.xyz, normalize(vReflView)) - 3.0);\n"
+			       "  vSpecular *= vSpecular; vSpecular *= vSpecular; vSpecular *= vSpecular;\n");
+		}
+	}
+	VSText("  gl_Position = gl_ModelViewProjectionMatrix * vertex;\n"
+	       "}\n");
+	
+	FSText("void main() {\n"
+	       "  vec4  srcColor = constants.xxxx, dstColor;\n"
+	       "  vec2  tc;\n"
+	       "  vec4  genColor;\n");
+	if( vsFeatures & vsfTexCoord ) {
+		FSText("  vec2  baseTC = vTexCoord.st;\n");
+	}
+
+	if( fsFeatures & fsfNormal ) {
+		FSText("  vec3 normal = normalize(vNormal);\n");
+	}
+	if( fsFeatures & fsfTangents ) {
+		FSText("  vec3 dpx = dFdx(vVertex);\n"
+		       "  vec3 dpy = dFdy(vVertex);\n"
+		       "  vec2 dtx = dFdx(vTexCoord.xy);\n"
+		       "  vec2 dty = dFdy(vTexCoord.xy);\n"
+		       "  float scale = sign(dty.y*dtx.x - dtx.y*dty.x);\n"
+		       "  vec3 uTangent =  dpx * dty.y - dpy * dtx.y;\n"
+		       "  vec3 vTangent = -dpx * dty.x + dpy * dtx.x;\n"
+		//       "  uTangent -= vNormal * dot( uTangent, vNormal );\n"
+		//       "  vTangent -= vNormal * dot( vTangent, vNormal );\n"
+		       "  uTangent = normalize( scale*uTangent );\n"
+		       "  vTangent = normalize( scale*vTangent );\n" );
+	}
+	if( normalStage >= 0 ) {
+		// parallax calculation
+		switch( r_parallax->integer) {
+		case 1:	// simple parallax offset, fast but looks bad
+		case 2: // quadtree displacement mapping, best quality but
+			// requires dynamic branching
+
+			// implementation is in intersectHeightMap function
+
+			// z coord is scaled by 8.0
+			FSText("  vec3 traceVec = vec3(dot(vCameraPos, uTangent),\n"
+			       "                       dot(vCameraPos, vTangent),\n"
+			       "                       dot(vCameraPos, normal) * 8.0);\n"
+			       "  traceVec /= -traceVec.z;\n"
+			       // supersample to smooth out numeric instability...
+			       "  vec3 tracePos = constants.xxx;\n"
+			       // sample 1
+			       "  tracePos += intersectHeightMap(vec3(baseTC + 0.5 * dtx, 1.0), traceVec);\n"
+			       // sample 2
+			       "  tracePos += intersectHeightMap(vec3(baseTC - 0.25 * dtx - 0.433 * dty, 1.0), traceVec);\n"
+			       // sample 3
+			       "  tracePos += intersectHeightMap(vec3(baseTC - 0.25 * dtx + 0.433 * dty, 1.0), traceVec);\n"
+			       // average
+			       "  tracePos *= 1.0/3.0;\n"
+			       "  baseTC = tracePos.xy;\n");
+			break;
+		default:
+			// no parallax
+			FSText("  vec3 tracePos = vec3(fract(baseTC), 1.0);\n");
+			break;
+		}
+	}
+	
+	// normal mapping
+	if( fsFeatures & fsfNormal ) {
+		if( normalStage >= 0 ) {
+			FSText("  vec3 n = texture2D(");
+			FSText(GLSLTexNames[texIndex[normalStage]]);
+			FSText(", baseTC).xyz * 2.0 - 1.0;\n"
+			       "  n.z = sqrt(1.0 - dot(n.xy, n.xy));\n"
+			       "  normal = normalize(n.x * uTangent + n.y * vTangent + n.z * normal);\n");
+		}
+	}
+	if( fsFeatures & fsfLightDir ) {
+		if( r_perPixelLighting->integer ) {
+			if( tr.hasDeluxemaps && lightmapStage >= 0 ) {
+				FSText("  vec3 lightDir = normalize(texture2D(");
+				FSText(GLSLTexNames[texIndex[lightmapStage]]);
+				FSText(", vec2(vTexCoord.p + vLightDir.w, vTexCoord.q)).xyz * 2.0 - 1.0);\n");
+			} else {
+				FSText("  vec3 lightDir = normalize(vLightDir.xyz);\n");
+			}
+		}
+	}
+	if( fsFeatures & fsfDiffuse ) {
+		if( r_perPixelLighting->integer ) {
+			FSText("  float diffuse = max(0.0, dot(normal, lightDir));\n");
+		}
+	}
+	if( fsFeatures & fsfReflView ) {
+		if( r_perPixelLighting->integer ) {
+			FSText("  vec3 reflView = normalize(reflect(vCameraPos, normal));\n");
+		} else {
+			FSText("  vec3 reflView = normalize(vReflView);\n");
+		}
+	}
+	if( fsFeatures & fsfSpecular ) {
+		if( r_perPixelLighting->integer ) {
+			FSText("  float specular = max(0.0, 4.0 * dot(lightDir, reflView) - 3.0);\n"
+			       "  specular *= specular; specular *= specular; specular *= specular;\n");
+		} else {
+			FSText("  float specular = vSpecular;\n");
+		}
+	}
+
+	if( materialStage >= 0 && r_perPixelLighting->integer ) {
+		FSText("  vec4 material = texture2D(");
+		FSText(GLSLTexNames[texIndex[materialStage]]);
+		FSText(", baseTC);\n"
+		       "  vec3 viewVec = normalize(-vCameraPos);\n"
+		       "  vec3 halfVec = normalize(lightDir + viewVec);\n"
+		       "  float HdotN = max(0.0, dot(halfVec, normal));\n"
+		       "  float HdotV = max(0.0, dot(halfVec, viewVec));\n"
+		       "  float VdotN = max(0.0, dot(viewVec, normal));\n"
+		       "  vec2 specs = 1.0 / (0.0001 + material.xy * material.xy);\n"
+		       "  specs = (1.0 + specs) * pow(vec2(HdotN), specs);\n"
+		       "  float fresnel = pow(1.0 - VdotN, 5.0) * material.w;\n");
+	}
+
+	if( blendMode == FILTER ) {
+		FSText("  dstColor = constants.yyyy;\n");
+	} else {
+		FSText("  dstColor = constants.xxxy;\n");
+	}
+
+	for( i = 0; i < MAX_SHADER_STAGES; i++ ) {
+		shaderStage_t *pStage = &stages[i];
+
+		if( !pStage->active || i == normalStage || i == materialStage )
+			break;
+
+		if( pStage->bundle[0].image[0] != tr.whiteImage &&
+		    pStage->bundle[0].image[0] != tr.identityLightImage ) {
+			switch( pStage->bundle[0].tcGen ) {
+			case TCGEN_IDENTITY:
+				FSText("  tc = constants.xx;\n");
+				break;
+			case TCGEN_LIGHTMAP:
+				FSText("  tc = vTexCoord.pq;\n");
+				break;
+			case TCGEN_TEXTURE:
+				FSText("  tc = baseTC;\n");
+				break;
+			case TCGEN_ENVIRONMENT_MAPPED:
+				FSText("  tc = vec2(0.5) + 0.5 * normalize(reflView).yz;\n");
+				break;
+			case TCGEN_FOG:
+				return qfalse;
+			case TCGEN_VECTOR:
+				FSText("  tc = vec2(dot(vVertex, vec3(");
+				FSConst("%f", pStage->bundle[0].tcGenVectors[0][0]);
+				FSText(", ");
+				FSConst("%f", pStage->bundle[0].tcGenVectors[0][1]);
+				FSText(", ");
+				FSConst("%f", pStage->bundle[0].tcGenVectors[0][2]);
+				FSText(")),\n");
+				FSText("            dot(vVertex, vec3(");
+				FSConst("%f", pStage->bundle[0].tcGenVectors[1][0]);
+				FSText(", ");
+				FSConst("%f", pStage->bundle[0].tcGenVectors[1][1]);
+				FSText(", ");
+				FSConst("%f", pStage->bundle[0].tcGenVectors[1][2]);
+				FSText(")));\n");
+				break;
+			default:
+				return qfalse;
+			}
+			for( j = 0; j < pStage->bundle[0].numTexMods; j++ ) {
+				texModInfo_t *pTexMod = &(pStage->bundle[0].texMods[j]);
+				
+				switch( pTexMod->type ) {
+				case TMOD_NONE:
+					break;
+				case TMOD_TRANSFORM:
+					FSText("  tc = tc.s * vec2(");
+					FSConst("%f", pTexMod->matrix[0][0]);
+					FSText(", ");
+					FSConst("%f", pTexMod->matrix[0][1]);
+					FSText(") + tc.t * vec2(");
+					FSConst("%f", pTexMod->matrix[1][0]);
+					FSText(", ");
+					FSConst("%f", pTexMod->matrix[1][1]);
+					FSText(") + vec2(");
+					FSConst("%f", pTexMod->translate[0]);
+					FSText(", ");
+					FSConst("%f", pTexMod->translate[1]);
+					FSText(");\n");
+					break;
+				case TMOD_TURBULENT:
+					FSText("  tc += ");
+					FSConst("%f", pTexMod->wave.amplitude);
+					FSText(" * sin(6.283185308 * (0.000976563 * vVertex.xy + vec2(");
+					FSConst("%f", pTexMod->wave.phase);
+					FSText(" + ");
+					FSConst("%f", pTexMod->wave.frequency);
+					FSText("* vShadertime)));\n");
+					break;
+				case TMOD_SCROLL:
+					FSText("  tc += vShadertime * vec2(");
+					FSConst("%f", pTexMod->scroll[0]);
+					FSText(", ");
+					FSConst("%f", pTexMod->scroll[1]);
+					FSText(");\n");
+					break;
+				case TMOD_SCALE:
+					FSText("  tc *= vec2(");
+					FSConst("%f", pTexMod->scale[0]);
+					FSText(", ");
+					FSConst("%f", pTexMod->scale[1]);
+					FSText(");\n");
+					break;
+				case TMOD_STRETCH:
+					FSText(" tc = vec2(0.5) - 0.5 / ");
+					FSGenFunc(pTexMod->wave);
+					FSText(" * tc;\n");
+					break;
+				case TMOD_ROTATE:
+					FSText("  tc = vec2(0.5) + genFuncRotate(");
+					FSConst("%f", pTexMod->rotateSpeed);
+					FSText(" * vShadertime) * (tc - vec2(0.5));\n");
+					break;
+				case TMOD_ENTITY_TRANSLATE:
+					return qfalse;
+				default:
+					return qfalse;
+				}
+			}
+			// adjust for combined image
+			if ( pStage->bundle[0].combinedImage ) {
+				float xScale = (float)pStage->bundle[0].image[0]->uploadWidth /
+					(float)pStage->bundle[0].combinedImage->uploadWidth;
+				FSText("  tc.x = (tc.x + mod(floor(vShadertime * ");
+				FSConst("%f", pStage->bundle[0].imageAnimationSpeed);
+				FSText("), ");
+				FSConst("%f", (float)pStage->bundle[0].numImageAnimations);
+				FSText(")) * ");
+				FSConst("%f", xScale);
+				FSText(";\n");
+			}
+		}
+
+		if ( materialStage >= 0 &&
+		     ((i == 0 && lightmapStage > 0) ||
+		      (i == 1 && lightmapStage == 0) ) ) {
+			FSText("  srcColor = texture2D(");
+			FSText(GLSLTexNames[texIndex[i]]);
+			FSText(", tc);\n"
+			       "  srcColor.a = mix(srcColor.a, 1.0, fresnel);\n");
+			if( fsFeatures & fsfDiffuse ) {
+				FSText("  srcColor.rgb = vAmbientLight * srcColor.rgb + (diffuse * vDirectedLight) * (0.04 * specs.x\n"   // outer reflection
+				       "                 + srcColor.rgb * (1.0 - 0.04) * specs.y);\n");  // inner reflection
+			} else if( lightmapStage >= 0 ) {
+				// arbitrary split lightmap into 70% ambient, 30% diffuse
+				FSText("  srcColor.rgb = texture2D(");
+				FSText(GLSLTexNames[texIndex[lightmapStage]]);
+				FSText(", vTexCoord.pq).rgb * (0.7 * srcColor.rgb + 0.3* (0.04 * specs.x\n");
+				FSText("                 + srcColor.rgb * (1.0 - 0.04) * specs.y));\n");
+			} else {
+				// no lightmap, no diffuse light ???
+			}
+		} else {
+			switch( pStage->rgbGen ) {
+			case CGEN_IDENTITY_LIGHTING:
+			case CGEN_IDENTITY:
+			case CGEN_CONST:
+				FSText("  genColor = vec4(");
+				FSConst( "%f", constantColor[i][0] / 255.0 );
+				FSText(", ");
+				FSConst( "%f", constantColor[i][1] / 255.0 );
+				FSText(", ");
+				FSConst( "%f", constantColor[i][2] / 255.0 );
+				FSText(", ");
+				switch( pStage->alphaGen ) {
+				case AGEN_IDENTITY:
+				case AGEN_CONST:
+					FSConst("%f", constantColor[i][3] / 255.0);
+					break;
+				case AGEN_ENTITY:
+					FSText("vColor.a");
+					break;
+				case AGEN_ONE_MINUS_ENTITY:
+					FSText("constants.y - vColor.a");
+					break;
+				default:
+					FSText("constants.x"); // will be overwritten later
+					break;
+				}
+				FSText(");\n");
+				break;
+			case CGEN_ENTITY:
+				FSText("  genColor = vColor;\n");
+				break;
+			case CGEN_ONE_MINUS_ENTITY:
+				FSText("  genColor = constants.yyyy - vColor;\n");
+				break;
+			case CGEN_EXACT_VERTEX:
+				FSText("  genColor = vColor;\n");
+				break;
+			case CGEN_VERTEX:
+				FSText("  genColor = vColor * constants.zzzy;\n");
+				break;
+			case CGEN_ONE_MINUS_VERTEX:
+				FSText("  genColor = constants.zzzy - vColor * constants.zzzy;\n");
+				break;
+			case CGEN_WAVEFORM:
+				FSText("  genColor = vec4(clamp(");
+				FSGenFunc(pStage->rgbWave);
+				FSText(", 0.0, 1.0));\n");
+				break;
+			case CGEN_LIGHTING_DIFFUSE:
+				if( r_perPixelLighting->integer ) {
+					FSText("  genColor.rgb = clamp(vAmbientLight + diffuse * vDirectedLight, 0.0, 1.0);\n");
+				} else {
+					FSText("  genColor.rgb = vDiffuse;\n");
+				}
+				break;
+			case CGEN_FOG:
+				return qfalse;
+			default:
+				return qfalse;
+			}
+			
+			switch( pStage->alphaGen ) {
+			case AGEN_IDENTITY:
+			case AGEN_CONST:
+				if( pStage->rgbGen != CGEN_IDENTITY &&
+				    pStage->rgbGen != CGEN_IDENTITY_LIGHTING &&
+				    pStage->rgbGen != CGEN_CONST ) {
+					FSText("  genColor.a = ");
+					FSConst("%f", constantColor[i][3] / 255.0 );
+					FSText(";\n");
+				}
+				break;
+			case AGEN_ENTITY:
+				if( pStage->rgbGen != CGEN_ENTITY &&
+				    pStage->rgbGen != CGEN_CONST )
+					FSText("  genColor.a = vColor.a;\n");
+				break;
+			case AGEN_ONE_MINUS_ENTITY:
+				if( pStage->rgbGen != CGEN_ONE_MINUS_ENTITY &&
+				    pStage->rgbGen != CGEN_CONST )
+					FSText("  genColor.a = constants.y - vColor.a;\n");
+				break;
+			case AGEN_VERTEX:
+				if( pStage->rgbGen != CGEN_VERTEX &&
+				    pStage->rgbGen != CGEN_EXACT_VERTEX )
+					FSText("  genColor.a = vColor.a;\n");
+				break;
+			case AGEN_ONE_MINUS_VERTEX:
+				if( pStage->rgbGen != CGEN_ONE_MINUS_VERTEX )
+					FSText("  genColor.a = constants.y - vColor.a;\n");
+				break;
+			case AGEN_LIGHTING_SPECULAR:
+				FSText("  genColor.a = specular;\n");
+				break;
+			case AGEN_WAVEFORM:
+				FSText("  genColor.a = clamp(");
+				FSGenFunc(pStage->alphaWave);
+				FSText(", 0.0, 1.0);\n");
+				break;
+			case AGEN_PORTAL:
+				FSText("  genColor.a = clamp(");
+				FSConst("%f", 1.0/shader.portalRange);
+				FSText(" * length(vCameraPos), 0.0, 1.0);\n");
+				break;
+			default:
+				return qfalse;
+			}
+
+			if( pStage->bundle[0].image[0] == tr.whiteImage ) {
+				FSText("  srcColor = genColor;\n");
+			} else if( pStage->bundle[0].image[0] == tr.identityLightImage ) {
+				FSText("  srcColor = constants.zzzy * genColor;\n");
+			} else if( i == lightmapStage && materialStage >= 0 ) {
+				FSText("  srcColor = (texture2D(");
+				FSText(GLSLTexNames[texIndex[i]]);
+				FSText(", tc) + texture2D(");
+				FSText(GLSLTexNames[texIndex[materialStage]]);
+				FSText(", baseTC).x * specular * 5.0) * genColor;\n");
+			} else {
+				FSText("  srcColor = texture2D(");
+				FSText(GLSLTexNames[texIndex[i]]);
+				FSText(", tc) * genColor;\n");
+			}
+		}
+
+		// alpha test
+		switch( pStage->stateBits & GLS_ATEST_BITS ) {
+		case 0:
+			break;
+		case GLS_ATEST_GT_0:
+			FSText("  if( srcColor.a > 0.0 ) {\n");
+			break;
+		case GLS_ATEST_LT_80:
+			FSText("  if( srcColor.a < 0.5 ) {\n");
+			break;
+		case GLS_ATEST_GE_80:
+			FSText("  if( srcColor.a >= 0.5 ) {\n");
+			break;
+		}
+
+		if( blendMode == FILTER ) {
+			FSText("  dstColor *= srcColor;\n");
+		} else {
+			// blend colors
+			switch( pStage->stateBits & GLS_DSTBLEND_BITS ) {
+			case 0:
+			case GLS_DSTBLEND_ZERO:
+				FSText("  dstColor.rgb = ");
+				break;
+			case GLS_DSTBLEND_ONE:
+				FSText("  dstColor.rgb += ");
+				break;
+			case GLS_DSTBLEND_SRC_COLOR:
+				FSText("  dstColor.rgb = dstColor.rgb * srcColor.rgb + ");
+				break;
+			case GLS_DSTBLEND_ONE_MINUS_SRC_COLOR:
+				FSText("  dstColor.rgb = dstColor.rgb * (constants.yyy - srcColor.rgb) + ");
+				break;
+			case GLS_DSTBLEND_SRC_ALPHA:
+				FSText("  dstColor.rgb = dstColor.rgb * srcColor.aaa + ");
+				break;
+			case GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA:
+				FSText("  dstColor.rgb = dstColor.rgb * (constants.yyy - srcColor.aaa) + ");
+				break;
+			}
+			switch( pStage->stateBits & GLS_SRCBLEND_BITS ) {
+			case GLS_SRCBLEND_ZERO:
+				FSText("constants.xxx;\n");
+				break;
+			case 0:
+			case GLS_SRCBLEND_ONE:
+				FSText("srcColor.rgb;\n");
+				break;
+			case GLS_SRCBLEND_DST_COLOR:
+				FSText("srcColor.rgb * dstColor.rgb;\n");
+				break;
+			case GLS_SRCBLEND_ONE_MINUS_DST_COLOR:
+				FSText("srcColor.rgb * (constants.yyy - dstColor.rgb);\n");
+				break;
+			case GLS_SRCBLEND_SRC_ALPHA:
+				FSText("srcColor.rgb * srcColor.aaa;\n");
+				break;
+			case GLS_SRCBLEND_ONE_MINUS_SRC_ALPHA:
+				FSText("srcColor.rgb * (constants.yyy - srcColor.aaa);\n");
+				break;
+			}
+			
+			// blend alpha
+			switch( pStage->stateBits & GLS_DSTBLEND_BITS ) {
+			case 0:
+			case GLS_DSTBLEND_ZERO:
+				if( (pStage->stateBits & GLS_SRCBLEND_BITS) == GLS_SRCBLEND_DST_COLOR )
+					;
+				else if( (pStage->stateBits & GLS_SRCBLEND_BITS) == GLS_SRCBLEND_ONE_MINUS_DST_COLOR )
+					FSText("  dstColor.a = constants.y - dstColor.a;\n");
+				else
+					FSText("  dstColor.a = constants.x;\n");
+				break;
+			case GLS_DSTBLEND_ONE:
+				break;
+			case GLS_DSTBLEND_SRC_COLOR:
+				FSText("  dstColor.a *= srcColor.a;\n");
+				break;
+			case GLS_DSTBLEND_ONE_MINUS_SRC_COLOR:
+				FSText("  dstColor.a *= constants.y - srcColor.a;\n");
+			case GLS_DSTBLEND_SRC_ALPHA:
+				FSText("  dstColor.a *= srcColor.a;\n");
+				break;
+			case GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA:
+				FSText("  dstColor.a *= constants.y - srcColor.a;\n");
+				break;
+			}
+		}
+		if ( pStage->stateBits & GLS_ATEST_BITS ) {
+			FSText("  }\n");
+			if ( i == 0 )
+				FSText("  else\n"
+				       "    discard;\n");
+		}
+
+	}
+	shader.numUnfoggedPasses = i;
+	if( normalStage >= 0 )
+		shader.numUnfoggedPasses++;
+	if( materialStage >= 0 )
+		shader.numUnfoggedPasses++;
+
+	FSText("  gl_FragColor = dstColor;\n"
+	       "}\n");
+	
+	// collect attributes
+	if( shader.lightmapIndex != LIGHTMAP_MD3 &&
+	    (vsFeatures & vsfNormal) )
+		attributes |= (1 << AL_NORMAL);
+	if( vsFeatures & vsfColor )
+		attributes |= (1 << AL_COLOR);
+	if( vsFeatures & vsfTexCoord )
+		attributes |= (1 << AL_TEXCOORD);
+	if( shader.lightmapIndex == LIGHTMAP_MD3 ||
+	    (vsFeatures & vsfShaderTime) )
+		attributes |= (1 << AL_TIMES);
+	if( vsFeatures & vsfCameraPos ) {
+		attributes |= (1 << AL_CAMERAPOS);
+	}
+	if( vsFeatures & vsfLightDir )
+		attributes |= (1 << AL_LIGHTDIR);
+	if( vsFeatures & vsfEntLight )
+		attributes |= (1 << AL_AMBIENTLIGHT) | (1 << AL_DIRECTEDLIGHT);
+
+	// *** compile and link ***
+	shader.GLSLprogram = RB_CompileProgram( shader.name, VS, VSidx,
+						FS, FSidx, attributes );
+	if ( !shader.GLSLprogram )
+		return qfalse;
+	
+	// sampler uniforms are set to the TMU once at the start
+	GL_Program( shader.GLSLprogram );
+	// try to move lightmap to TMU 1 to avoid rebinds
+	// always leave TMU 0 as it may be used for alpha test
+	if( lightmapStage > 1 ) {
+		textureBundle_t temp;
+		
+		j = qglGetUniformLocation( shader.GLSLprogram->handle, GLSLTexNames[0] );
+		if( j != -1 ) {
+			qglUniform1i( j, 0 );
+		}
+
+		Com_Memcpy( &temp, &stages[1].bundle[0], sizeof(textureBundle_t) );
+		Com_Memcpy( &stages[1].bundle[0], &stages[lightmapStage].bundle[0], sizeof(textureBundle_t) );
+		Com_Memcpy( &stages[lightmapStage].bundle[0], &temp, sizeof(textureBundle_t) );
+		j = qglGetUniformLocation( shader.GLSLprogram->handle, GLSLTexNames[lightmapStage] );
+		if( j != -1 ) {
+			qglUniform1i( j, 1 );
+		}
+		
+		for( i = 2; i < lightmapStage; i++ ) {
+			j = qglGetUniformLocation( shader.GLSLprogram->handle, GLSLTexNames[i] );
+			if( j != -1 ) {
+				qglUniform1i( j, i );
+			}
+		}
+		j = qglGetUniformLocation( shader.GLSLprogram->handle, GLSLTexNames[1] );
+		if( j != -1 ) {
+			qglUniform1i( j, lightmapStage );
+		}
+		for( i = lightmapStage + 1; i < shader.numUnfoggedPasses; i++ ) {
+			j = qglGetUniformLocation( shader.GLSLprogram->handle, GLSLTexNames[i] );
+			if( j != -1 ) {
+				qglUniform1i( j, i );
+			}
+		}
+	} else {
+		for( i = 0; i < shader.numUnfoggedPasses; i++ ) {
+			j = qglGetUniformLocation( shader.GLSLprogram->handle, GLSLTexNames[i] );
+			if( j != -1 ) {
+				qglUniform1i( j, i );
+			}
+		}
+		if( shader.lightmapIndex == LIGHTMAP_MD3 ) {
+			j = qglGetUniformLocation( shader.GLSLprogram->handle, "texData" );
+			if( j != -1 ) {
+				qglUniform1i( j, shader.numUnfoggedPasses );
+			}
+		}
+	}
+
+	stages[0].stateBits &= ~(GLS_SRCBLEND_BITS | GLS_DSTBLEND_BITS);
+	switch( blendMode ) {
+	case REPLACE:
+		break;
+	case BLEND:
+		stages[0].stateBits |= GLS_SRCBLEND_ONE | GLS_DSTBLEND_SRC_ALPHA;
+		break;
+	case FILTER:
+		stages[0].stateBits |= GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
+		break;
+	}
+	shader.optimalStageIteratorFunc = RB_StageIteratorGLSL;
+	if ( qglGenBuffersARB && shader.lightmapIndex != LIGHTMAP_2D ) {
+		shader.useVBO = qtrue;
+	}
+	
+	return qtrue;
+}
+
+/*
+=================
 VertexLightingCollapse
 
 If vertex lighting is enabled, only render a single
@@ -2127,6 +3907,7 @@
 	int stage;
 	qboolean		hasLightmapStage;
 	qboolean		vertexLightmap;
+	shader_t		*sh;
 
 	hasLightmapStage = qfalse;
 	vertexLightmap = qfalse;
@@ -2141,7 +3922,7 @@
 	//
 	// set polygon offset
 	//
-	if ( shader.polygonOffset && !shader.sort ) {
+	if ( (stages[0].stateBits & GLS_POLYGON_OFFSET) && !shader.sort ) {
 		shader.sort = SS_DECAL;
 	}
 
@@ -2155,7 +3936,7 @@
 			break;
 		}
 
-    // check for a missing texture
+		// check for a missing texture
 		if ( !pStage->bundle[0].image[0] ) {
 			ri.Printf( PRINT_WARNING, "Shader %s has a stage with no image\n", shader.name );
 			pStage->active = qfalse;
@@ -2254,6 +4035,10 @@
 				}
 			}
 		}
+
+		if( shader.isSky ) {
+			pStage->stateBits |= GLS_DEPTHRANGE_1_TO_1;
+		}
 		
 		stage++;
 	}
@@ -2265,44 +4050,111 @@
 	}
 
 	//
-	// if we are in r_vertexLight mode, never use a lightmap texture
+	// try to generate a GLSL shader if possible
 	//
-	if ( stage > 1 && ( (r_vertexLight->integer && !r_uiFullScreen->integer) || glConfig.hardwareType == GLHW_PERMEDIA2 ) ) {
-		VertexLightingCollapse();
-		stage = 1;
-		hasLightmapStage = qfalse;
+	if ( !CollapseGLSL() ) {
+		//
+		// if we are in r_vertexLight mode, never use a lightmap texture
+		//
+		if ( stage > 1 && ( (r_vertexLight->integer && !r_uiFullScreen->integer) || glConfig.hardwareType == GLHW_PERMEDIA2 ) ) {
+			VertexLightingCollapse();
+			stage = 1;
+			hasLightmapStage = qfalse;
+		}
+		
+		//
+		// look for multitexture potential
+		//
+		if ( stage > 1 ) {
+			stage = CollapseMultitexture();
+		}
+		
+		if ( shader.lightmapIndex >= 0 && !hasLightmapStage ) {
+			if (vertexLightmap) {
+				ri.Printf( PRINT_DEVELOPER, "WARNING: shader '%s' has VERTEX forced lightmap!\n", shader.name );
+			} else {
+				ri.Printf( PRINT_DEVELOPER, "WARNING: shader '%s' has lightmap but no lightmap stage!\n", shader.name );
+				shader.lightmapIndex = LIGHTMAP_NONE;
+			}
+		}
+		
+		
+		//
+		// compute number of passes
+		//
+		shader.numUnfoggedPasses = stage;
+		
+		// fogonly shaders don't have any normal passes
+		if (stage == 0 && !shader.isSky)
+			shader.sort = SS_FOG;
+		
+		// determine which stage iterator function is appropriate
+		ComputeStageIteratorFunc();
 	}
 
-	//
-	// look for multitexture potential
-	//
-	if ( stage > 1 && CollapseMultitexture() ) {
-		stage--;
-	}
+	shader.isDepth = qfalse;
+	sh = GeneratePermanentShader();
 
-	if ( shader.lightmapIndex >= 0 && !hasLightmapStage ) {
-		if (vertexLightmap) {
-			ri.Printf( PRINT_DEVELOPER, "WARNING: shader '%s' has VERTEX forced lightmap!\n", shader.name );
+	// generate depth-only shader if necessary
+	if( r_depthPass->integer && !shader.isSky ) {
+		if( (stages[0].stateBits & GLS_DEPTHMASK_TRUE) &&
+		    !(stages[0].stateBits & GLS_DEPTHFUNC_EQUAL) &&
+		    !(shader.lightmapIndex == LIGHTMAP_2D) ) {
+			// this shader may update depth
+			stages[1].active = qfalse;
+			strcat(shader.name, "*");
+			
+			if( stages[0].stateBits & GLS_ATEST_BITS ) {
+				// alpha test requires a custom depth shader
+				shader.sort = SS_DEPTH;
+				stages[0].stateBits &= ~GLS_SRCBLEND_BITS & ~GLS_DSTBLEND_BITS;
+				stages[0].stateBits |= GLS_COLORMASK_FALSE;
+				
+				if( !CollapseGLSL() ) {
+					shader.numUnfoggedPasses = 1;
+					ComputeStageIteratorFunc();
+				}
+				sh->depthShader = GeneratePermanentShader();
+			} else if ( shader.lightmapIndex == LIGHTMAP_MD3 &&
+				    shader.cullType == 0 &&
+				    shader.numDeforms == 0 &&
+				    tr.defaultMD3Shader ) {
+				// can use the default MD3 depth shader
+				sh->depthShader = tr.defaultMD3Shader->depthShader;
+			} else if ( shader.lightmapIndex != LIGHTMAP_MD3 &&
+				    shader.cullType == 0 &&
+				    shader.numDeforms == 0 &&
+				    tr.defaultShader ) {
+				// can use the default depth shader
+				sh->depthShader = tr.defaultShader->depthShader;
+			} else {
+				// requires a custom depth shader, but can skip
+				// the texturing
+				shader.sort = SS_DEPTH;
+				stages[0].stateBits &= ~GLS_SRCBLEND_BITS & ~GLS_DSTBLEND_BITS;
+				stages[0].stateBits |= GLS_COLORMASK_FALSE;
+				stages[0].bundle[0].image[0] = tr.whiteImage;
+				stages[0].bundle[0].tcGen = TCGEN_IDENTITY;
+				stages[0].bundle[0].numTexMods = 0;
+				stages[0].rgbGen = CGEN_IDENTITY;
+				stages[0].alphaGen = AGEN_IDENTITY;
+
+				if( !CollapseGLSL() ) {
+					shader.numUnfoggedPasses = 1;
+					ComputeStageIteratorFunc();
+				}
+				shader.isDepth = qtrue;
+				sh->depthShader = GeneratePermanentShader();
+			}
+			// disable depth writes in the main pass
+			sh->stages[0]->stateBits &= ~GLS_DEPTHMASK_TRUE;
 		} else {
-			ri.Printf( PRINT_DEVELOPER, "WARNING: shader '%s' has lightmap but no lightmap stage!\n", shader.name );
-  			shader.lightmapIndex = LIGHTMAP_NONE;
+			sh->depthShader = NULL;
 		}
+	} else {
+		sh->depthShader = NULL;
 	}
-
-
-	//
-	// compute number of passes
-	//
-	shader.numUnfoggedPasses = stage;
-
-	// fogonly shaders don't have any normal passes
-	if (stage == 0 && !shader.isSky)
-		shader.sort = SS_FOG;
-
-	// determine which stage iterator function is appropriate
-	ComputeStageIteratorFunc();
-
-	return GeneratePermanentShader();
+	return sh;
 }
 
 //========================================================================================
@@ -2338,7 +4190,7 @@
 				return p;
 		}
 	}
-
+#if 0
 	p = s_shaderText;
 
 	if ( !p ) {
@@ -2360,7 +4212,7 @@
 			SkipBracedSection( &p );
 		}
 	}
-
+#endif
 	return NULL;
 }
 
@@ -2440,7 +4292,7 @@
 	shader_t	*sh;
 
 	if ( name[0] == 0 ) {
-		return tr.defaultShader;
+		return lightmapIndex == LIGHTMAP_MD3 ? tr.defaultMD3Shader : tr.defaultShader;
 	}
 
 	// use (fullbright) vertex lighting if the bsp file doesn't have
@@ -2487,11 +4339,7 @@
 		stages[i].bundle[0].texMods = texMods[i];
 	}
 
-	// FIXME: set these "need" values apropriately
-	shader.needsNormal = qtrue;
-	shader.needsST1 = qtrue;
-	shader.needsST2 = qtrue;
-	shader.needsColor = qtrue;
+	shader.useVBO = qfalse;
 
 	//
 	// attempt to define shader from an explicit parameter file
@@ -2507,8 +4355,10 @@
 		if ( !ParseShader( &shaderText ) ) {
 			// had errors, so use default shader
 			shader.defaultShader = qtrue;
+			sh = FinishShader();
+		} else {
+			sh = FinishShader();
 		}
-		sh = FinishShader();
 		return sh;
 	}
 
@@ -2521,13 +4371,15 @@
 	if ( !image ) {
 		ri.Printf( PRINT_DEVELOPER, "Couldn't find image file for shader %s\n", name );
 		shader.defaultShader = qtrue;
-		return FinishShader();
+		sh = FinishShader();
+		return sh;
 	}
 
 	//
 	// create the default shading commands
 	//
-	if ( shader.lightmapIndex == LIGHTMAP_NONE ) {
+	if ( shader.lightmapIndex == LIGHTMAP_NONE ||
+	     shader.lightmapIndex == LIGHTMAP_MD3 ) {
 		// dynamic colors at vertexes
 		stages[0].bundle[0].image[0] = image;
 		stages[0].active = qtrue;
@@ -2575,7 +4427,8 @@
 		stages[1].stateBits |= GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
 	}
 
-	return FinishShader();
+	sh = FinishShader();
+	return sh;
 }
 
 
@@ -2623,11 +4476,7 @@
 		stages[i].bundle[0].texMods = texMods[i];
 	}
 
-	// FIXME: set these "need" values apropriately
-	shader.needsNormal = qtrue;
-	shader.needsST1 = qtrue;
-	shader.needsST2 = qtrue;
-	shader.needsColor = qtrue;
+	shader.useVBO = qfalse;
 
 	//
 	// create the default shading commands
@@ -2681,7 +4530,7 @@
 	}
 
 	sh = FinishShader();
-  return sh->index; 
+	return sh->index; 
 }
 
 
@@ -2700,7 +4549,7 @@
 	shader_t	*sh;
 
 	if ( strlen( name ) >= MAX_QPATH ) {
-		Com_Printf( "Shader name exceeds MAX_QPATH\n" );
+		ri.Printf( PRINT_WARNING, "Shader name exceeds MAX_QPATH\n" );
 		return 0;
 	}
 
@@ -2734,7 +4583,7 @@
 	shader_t	*sh;
 
 	if ( strlen( name ) >= MAX_QPATH ) {
-		Com_Printf( "Shader name exceeds MAX_QPATH\n" );
+		ri.Printf( PRINT_WARNING, "Shader name exceeds MAX_QPATH\n" );
 		return 0;
 	}
 
@@ -2764,7 +4613,7 @@
 	shader_t	*sh;
 
 	if ( strlen( name ) >= MAX_QPATH ) {
-		Com_Printf( "Shader name exceeds MAX_QPATH\n" );
+		ri.Printf( PRINT_ALL, "Shader name exceeds MAX_QPATH\n" );
 		return 0;
 	}
 
@@ -2792,7 +4641,7 @@
 */
 shader_t *R_GetShaderByHandle( qhandle_t hShader ) {
 	if ( hShader < 0 ) {
-	  ri.Printf( PRINT_WARNING, "R_GetShaderByHandle: out of range hShader '%d'\n", hShader );
+		ri.Printf( PRINT_WARNING, "R_GetShaderByHandle: out of range hShader '%d'\n", hShader );
 		return tr.defaultShader;
 	}
 	if ( hShader >= tr.numShaders ) {
@@ -2811,7 +4660,7 @@
 ===============
 */
 void	R_ShaderList_f (void) {
-	int			i;
+	int			i, j, k;
 	int			count;
 	shader_t	*shader;
 
@@ -2832,15 +4681,6 @@
 		} else {
 			ri.Printf (PRINT_ALL, "  ");
 		}
-		if ( shader->multitextureEnv == GL_ADD ) {
-			ri.Printf( PRINT_ALL, "MT(a) " );
-		} else if ( shader->multitextureEnv == GL_MODULATE ) {
-			ri.Printf( PRINT_ALL, "MT(m) " );
-		} else if ( shader->multitextureEnv == GL_DECAL ) {
-			ri.Printf( PRINT_ALL, "MT(d) " );
-		} else {
-			ri.Printf( PRINT_ALL, "      " );
-		}
 		if ( shader->explicitlyDefined ) {
 			ri.Printf( PRINT_ALL, "E " );
 		} else {
@@ -2855,6 +4695,8 @@
 			ri.Printf( PRINT_ALL, "lmmt" );
 		} else if ( shader->optimalStageIteratorFunc == RB_StageIteratorVertexLitTexture ) {
 			ri.Printf( PRINT_ALL, "vlt " );
+		} else if ( shader->optimalStageIteratorFunc == RB_StageIteratorGLSL ) {
+			ri.Printf( PRINT_ALL, "glsl" );
 		} else {
 			ri.Printf( PRINT_ALL, "    " );
 		}
@@ -2864,6 +4706,21 @@
 		} else {
 			ri.Printf (PRINT_ALL,  ": %s\n", shader->name);
 		}
+		for ( j = 0; j < shader->numUnfoggedPasses; j++ ) {
+			shaderStage_t *stage = shader->stages[j];
+			
+			if ( !stage->active )
+				break;
+
+			ri.Printf (PRINT_DEVELOPER, " %d\n" );
+			
+			for ( k = 0; i < NUM_TEXTURE_BUNDLES; k++ ) {
+				if ( !stage->bundle[k].image[0] )
+					break;
+
+				ri.Printf (PRINT_DEVELOPER, "  %s\n", stage->bundle[k].image[0]->imgName );
+			}
+		}
 		count++;
 	}
 	ri.Printf (PRINT_ALL, "%i total shaders\n", count);
@@ -3014,6 +4871,94 @@
 }
 
 
+static const char *normalVS = 
+	"#version 110\n"
+	"#extension GL_EXT_geometry_shader4 : enable\n"
+	"\n"
+	"// attribute vec4 aVertex;\n"
+	"#define aVertex gl_Vertex\n"
+	"attribute vec4 aTransX, aTransY, aTransZ;\n"
+	"attribute vec3 aNormal;\n"
+	"\n"
+	"varying vec4 vVertex, vNormal;\n"
+	"\n"
+	"vec4 transform4(vec4 point) {\n"
+	"  return vec4( dot( aTransX, point ),\n"
+	"               dot( aTransY, point ),\n"
+	"               dot( aTransZ, point ),\n"
+	"               1.0 );\n"
+	"}\n"
+	"\n"
+	"void main() {\n"
+	"  vec4 vertex = vec4(aVertex.xyz, 1.0);\n"
+	"  vVertex = gl_ModelViewProjectionMatrix * transform4(vertex);\n"
+	"  vNormal = gl_ModelViewProjectionMatrix * transform4(vertex + 2.0 * vec4(aNormal, 0.0));\n"
+	"}\n";
+static const char *normalMD3VS = 
+	"#version 110\n"
+	"#extension GL_EXT_geometry_shader4 : enable\n"
+	"\n"
+	"// attribute vec4 aVertex;\n"
+	"#define aVertex gl_Vertex\n"
+	"attribute vec4 aTransX, aTransY, aTransZ;\n"
+	"attribute vec4 aTimes;\n"
+	"\n"
+	"uniform sampler2D texData;\n"
+	"\n"
+	"varying vec4 vVertex, vNormal;\n"
+	"\n"
+	"vec4 transform4(vec4 point) {\n"
+	"  return vec4( dot( aTransX, point ),\n"
+	"               dot( aTransY, point ),\n"
+	"               dot( aTransZ, point ),\n"
+	"               1.0 );\n"
+	"}\n"
+	"\n"
+	"vec4 fetchVertex(const float frameNo, const vec2 offset,\n"
+	"                 out vec4 normal) {\n"
+	"  vec2 tc = vec2(fract(frameNo), floor(frameNo)/1024.0) + offset;\n"
+	"  vec4 data = texture2D(texData, tc);\n"
+	"  vec4 hi = floor(data);\n"
+	"  vec4 lo = fract(data);\n"
+	"  normal = vec4((hi.xyz - 128.0) / 127.0, 0.0);\n"
+	"  return vec4(lo.xyz * 1024.0 - 512.0,\n"
+	"              1.0);\n"
+	"}\n"
+	"\n"
+	"void main() {\n"
+	"  vec4 normal1, normal2;\n"
+	"  vec4 vertex = mix(fetchVertex(aTimes.z, aVertex.zw, normal1),\n"
+	"                    fetchVertex(aTimes.w, aVertex.zw, normal2),\n"
+	"                    aTimes.y);\n"
+	"  vec3 normal = normalize(mix(normal1.xyz, normal2.xyz, aTimes.y));\n"
+	"  vVertex = gl_ModelViewProjectionMatrix * transform4(vertex);\n"
+	"  vNormal = gl_ModelViewProjectionMatrix * transform4(vertex + 2.0*vec4(normal, 0.0));\n"
+	"}\n";
+static const char *normalGS =
+	"#version 110\n"
+	"#extension GL_EXT_geometry_shader4 : enable\n"
+	"\n"
+	"varying in  vec4 vVertex[], vNormal[];\n"
+	"varying out vec4 vColor;\n"
+	"\n"
+	"void main() {\n"
+	"  vColor = vec4(1.0, 0.0, 0.0, 1.0);\n"
+	"  gl_Position = vVertex[0];\n"
+	"  EmitVertex();\n"
+	"  vColor = vec4(1.0, 0.0, 0.0, 1.0);\n"
+	"  gl_Position = vNormal[0];\n"
+	"  EmitVertex();\n"
+	"  EndPrimitive();\n"
+	"}\n";
+static const char *normalFS =
+	"#version 110\n"
+	"#extension GL_EXT_geometry_shader4 : enable\n"
+	"\n"
+	"varying vec4 vColor;\n"
+	"void main() {\n"
+	"  gl_FragColor = vColor;\n"
+	"}\n";
+
 /*
 ====================
 CreateInternalShaders
@@ -3029,15 +4974,89 @@
 	Q_strncpyz( shader.name, "<default>", sizeof( shader.name ) );
 
 	shader.lightmapIndex = LIGHTMAP_NONE;
+	shader.sort = SS_OPAQUE;
 	stages[0].bundle[0].image[0] = tr.defaultImage;
 	stages[0].active = qtrue;
 	stages[0].stateBits = GLS_DEFAULT;
+	stages[0].rgbGen = CGEN_VERTEX;
+	stages[0].alphaGen = AGEN_VERTEX;
 	tr.defaultShader = FinishShader();
 
+	if( qglCreateShader && qglGenBuffersARB && glGlobals.floatTextures ) {
+		Q_strncpyz( shader.name, "<default md3>", sizeof( shader.name ) );
+		shader.lightmapIndex = LIGHTMAP_MD3;
+		shader.sort = SS_OPAQUE;
+		stages[0].bundle[0].image[0] = tr.defaultImage;
+		stages[0].active = qtrue;
+		stages[0].stateBits = GLS_DEFAULT;
+		stages[0].rgbGen = CGEN_VERTEX;
+		stages[0].alphaGen = AGEN_VERTEX;
+		tr.defaultMD3Shader = FinishShader();
+	} else {
+		tr.defaultMD3Shader = tr.defaultShader;
+	}
+
+	// fogShader exists only to generate a GLSL program for fog blending
+	Q_strncpyz( shader.name, "<fog>", sizeof( shader.name ) );
+	shader.lightmapIndex = LIGHTMAP_NONE;
+	stages[0].bundle[0].image[0] = tr.defaultImage;
+	stages[0].rgbGen = CGEN_VERTEX;
+	stages[0].stateBits = GLS_DEFAULT | GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA;
+	tr.fogShader = FinishShader();
+
 	// shadow shader is just a marker
 	Q_strncpyz( shader.name, "<stencil shadow>", sizeof( shader.name ) );
 	shader.sort = SS_STENCIL_SHADOW;
 	tr.shadowShader = FinishShader();
+
+	// prepare portal shader is just a marker
+	Q_strncpyz( shader.name, "<prepare portal>", sizeof( shader.name ) );
+	shader.sort = SS_PORTAL;
+	tr.preparePortalShader = FinishShader();
+	tr.preparePortalShader->optimalStageIteratorFunc = RB_StageIteratorPreparePortal;
+	tr.preparePortalShader->useVBO = qfalse;
+
+	// finalise portal shader is just a marker
+	Q_strncpyz( shader.name, "<finalise portal>", sizeof( shader.name ) );
+	shader.sort = SS_PORTAL;
+	tr.finalisePortalShader = FinishShader();
+	tr.finalisePortalShader->optimalStageIteratorFunc = RB_StageIteratorFinalisePortal;
+	tr.finalisePortalShader->useVBO = qfalse;
+
+	// internal GLSL programs for r_showNormals mode
+	if( qglCreateShader && qglProgramParameteriEXT ) {
+		int i;
+		backEnd.normalProgram = RB_CompileGSProgram( "<normal>",
+							     &normalVS, 1,
+							     &normalGS, 1,
+							     6, GL_POINTS, GL_LINES,
+							     &normalFS, 1,
+							     (1 << AL_VERTEX) |
+							     (1 << AL_NORMAL) |
+							     (1 << AL_TRANSX) |
+							     (1 << AL_TRANSY) |
+							     (1 << AL_TRANSZ) );
+		backEnd.normalProgramMD3 = RB_CompileGSProgram( "<normal md3>",
+								&normalMD3VS, 1,
+								&normalGS, 1,
+								6, GL_POINTS, GL_LINE_STRIP,
+								&normalFS, 1,
+								(1 << AL_VERTEX) |
+								(1 << AL_NORMAL) |
+								(1 << AL_TRANSX) |
+								(1 << AL_TRANSY) |
+								(1 << AL_TRANSZ) |
+								(1 << AL_TIMES) );
+		if( backEnd.normalProgramMD3 ) {
+			i = qglGetUniformLocation( backEnd.normalProgramMD3->handle, "texData" );
+			if( i != -1 ) {
+				qglUniform1i( i, 0 );
+			}
+		}
+	} else {
+		backEnd.normalProgram = NULL;
+		backEnd.normalProgramMD3 = NULL;
+	}
 }
 
 static void CreateExternalShaders( void ) {
@@ -3058,6 +5077,15 @@
 	}
 
 	tr.sunShader = R_FindShader( "sun", LIGHTMAP_NONE, qtrue );
+	if(!tr.sunShader->defaultShader)
+	{
+		int index;
+
+		for(index = 0; index < tr.sunShader->numUnfoggedPasses; index++)
+		{
+			tr.sunShader->stages[index]->stateBits |= GLS_DEPTHRANGE_1_TO_1;
+		}
+	}
 }
 
 /*
@@ -3066,7 +5094,7 @@
 ==================
 */
 void R_InitShaders( void ) {
-	ri.Printf( PRINT_ALL, "Initializing Shaders\n" );
+	ri.Printf( PRINT_DEVELOPER, "Initializing Shaders\n" );
 
 	Com_Memset(hashTable, 0, sizeof(hashTable));
 
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_shader.c.orig tremulous-ggp1-src/src/renderer/tr_shader.c.orig
--- tremulous-ggp1-src.p/src/renderer/tr_shader.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_shader.c.orig	2012-07-19 04:25:20.321556051 +0200
@@ -0,0 +1,3078 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+#include "tr_local.h"
+
+// tr_shader.c -- this file deals with the parsing and definition of shaders
+
+static char *s_shaderText;
+
+// the shader is parsed into these global variables, then copied into
+// dynamically allocated memory if it is valid.
+static	shaderStage_t	stages[MAX_SHADER_STAGES];		
+static	shader_t		shader;
+static	texModInfo_t	texMods[MAX_SHADER_STAGES][TR_MAX_TEXMODS];
+
+#define FILE_HASH_SIZE		1024
+static	shader_t*		hashTable[FILE_HASH_SIZE];
+
+#define MAX_SHADERTEXT_HASH		2048
+static char **shaderTextHashTable[MAX_SHADERTEXT_HASH];
+
+/*
+================
+return a hash value for the filename
+================
+*/
+#ifdef __GNUCC__
+  #warning TODO: check if long is ok here 
+#endif
+static long generateHashValue( const char *fname, const int size ) {
+	int		i;
+	long	hash;
+	char	letter;
+
+	hash = 0;
+	i = 0;
+	while (fname[i] != '\0') {
+		letter = tolower(fname[i]);
+		if (letter =='.') break;				// don't include extension
+		if (letter =='\\') letter = '/';		// damn path names
+		if (letter == PATH_SEP) letter = '/';		// damn path names
+		hash+=(long)(letter)*(i+119);
+		i++;
+	}
+	hash = (hash ^ (hash >> 10) ^ (hash >> 20));
+	hash &= (size-1);
+	return hash;
+}
+
+void R_RemapShader(const char *shaderName, const char *newShaderName, const char *timeOffset) {
+	char		strippedName[MAX_QPATH];
+	int			hash;
+	shader_t	*sh, *sh2;
+	qhandle_t	h;
+
+	sh = R_FindShaderByName( shaderName );
+	if (sh == NULL || sh == tr.defaultShader) {
+		h = RE_RegisterShaderLightMap(shaderName, 0);
+		sh = R_GetShaderByHandle(h);
+	}
+	if (sh == NULL || sh == tr.defaultShader) {
+		ri.Printf( PRINT_WARNING, "WARNING: R_RemapShader: shader %s not found\n", shaderName );
+		return;
+	}
+
+	sh2 = R_FindShaderByName( newShaderName );
+	if (sh2 == NULL || sh2 == tr.defaultShader) {
+		h = RE_RegisterShaderLightMap(newShaderName, 0);
+		sh2 = R_GetShaderByHandle(h);
+	}
+
+	if (sh2 == NULL || sh2 == tr.defaultShader) {
+		ri.Printf( PRINT_WARNING, "WARNING: R_RemapShader: new shader %s not found\n", newShaderName );
+		return;
+	}
+
+	// remap all the shaders with the given name
+	// even tho they might have different lightmaps
+	COM_StripExtension(shaderName, strippedName, sizeof(strippedName));
+	hash = generateHashValue(strippedName, FILE_HASH_SIZE);
+	for (sh = hashTable[hash]; sh; sh = sh->next) {
+		if (Q_stricmp(sh->name, strippedName) == 0) {
+			if (sh != sh2) {
+				sh->remappedShader = sh2;
+			} else {
+				sh->remappedShader = NULL;
+			}
+		}
+	}
+	if (timeOffset) {
+		sh2->timeOffset = atof(timeOffset);
+	}
+}
+
+/*
+===============
+ParseVector
+===============
+*/
+static qboolean ParseVector( char **text, int count, float *v ) {
+	char	*token;
+	int		i;
+
+	// FIXME: spaces are currently required after parens, should change parseext...
+	token = COM_ParseExt( text, qfalse );
+	if ( strcmp( token, "(" ) ) {
+		ri.Printf( PRINT_WARNING, "WARNING: missing parenthesis in shader '%s'\n", shader.name );
+		return qfalse;
+	}
+
+	for ( i = 0 ; i < count ; i++ ) {
+		token = COM_ParseExt( text, qfalse );
+		if ( !token[0] ) {
+			ri.Printf( PRINT_WARNING, "WARNING: missing vector element in shader '%s'\n", shader.name );
+			return qfalse;
+		}
+		v[i] = atof( token );
+	}
+
+	token = COM_ParseExt( text, qfalse );
+	if ( strcmp( token, ")" ) ) {
+		ri.Printf( PRINT_WARNING, "WARNING: missing parenthesis in shader '%s'\n", shader.name );
+		return qfalse;
+	}
+
+	return qtrue;
+}
+
+
+/*
+===============
+NameToAFunc
+===============
+*/
+static unsigned NameToAFunc( const char *funcname )
+{	
+	if ( !Q_stricmp( funcname, "GT0" ) )
+	{
+		return GLS_ATEST_GT_0;
+	}
+	else if ( !Q_stricmp( funcname, "LT128" ) )
+	{
+		return GLS_ATEST_LT_80;
+	}
+	else if ( !Q_stricmp( funcname, "GE128" ) )
+	{
+		return GLS_ATEST_GE_80;
+	}
+
+	ri.Printf( PRINT_WARNING, "WARNING: invalid alphaFunc name '%s' in shader '%s'\n", funcname, shader.name );
+	return 0;
+}
+
+
+/*
+===============
+NameToSrcBlendMode
+===============
+*/
+static int NameToSrcBlendMode( const char *name )
+{
+	if ( !Q_stricmp( name, "GL_ONE" ) )
+	{
+		return GLS_SRCBLEND_ONE;
+	}
+	else if ( !Q_stricmp( name, "GL_ZERO" ) )
+	{
+		return GLS_SRCBLEND_ZERO;
+	}
+	else if ( !Q_stricmp( name, "GL_DST_COLOR" ) )
+	{
+		return GLS_SRCBLEND_DST_COLOR;
+	}
+	else if ( !Q_stricmp( name, "GL_ONE_MINUS_DST_COLOR" ) )
+	{
+		return GLS_SRCBLEND_ONE_MINUS_DST_COLOR;
+	}
+	else if ( !Q_stricmp( name, "GL_SRC_ALPHA" ) )
+	{
+		return GLS_SRCBLEND_SRC_ALPHA;
+	}
+	else if ( !Q_stricmp( name, "GL_ONE_MINUS_SRC_ALPHA" ) )
+	{
+		return GLS_SRCBLEND_ONE_MINUS_SRC_ALPHA;
+	}
+	else if ( !Q_stricmp( name, "GL_DST_ALPHA" ) )
+	{
+		return GLS_SRCBLEND_DST_ALPHA;
+	}
+	else if ( !Q_stricmp( name, "GL_ONE_MINUS_DST_ALPHA" ) )
+	{
+		return GLS_SRCBLEND_ONE_MINUS_DST_ALPHA;
+	}
+	else if ( !Q_stricmp( name, "GL_SRC_ALPHA_SATURATE" ) )
+	{
+		return GLS_SRCBLEND_ALPHA_SATURATE;
+	}
+
+	ri.Printf( PRINT_WARNING, "WARNING: unknown blend mode '%s' in shader '%s', substituting GL_ONE\n", name, shader.name );
+	return GLS_SRCBLEND_ONE;
+}
+
+/*
+===============
+NameToDstBlendMode
+===============
+*/
+static int NameToDstBlendMode( const char *name )
+{
+	if ( !Q_stricmp( name, "GL_ONE" ) )
+	{
+		return GLS_DSTBLEND_ONE;
+	}
+	else if ( !Q_stricmp( name, "GL_ZERO" ) )
+	{
+		return GLS_DSTBLEND_ZERO;
+	}
+	else if ( !Q_stricmp( name, "GL_SRC_ALPHA" ) )
+	{
+		return GLS_DSTBLEND_SRC_ALPHA;
+	}
+	else if ( !Q_stricmp( name, "GL_ONE_MINUS_SRC_ALPHA" ) )
+	{
+		return GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA;
+	}
+	else if ( !Q_stricmp( name, "GL_DST_ALPHA" ) )
+	{
+		return GLS_DSTBLEND_DST_ALPHA;
+	}
+	else if ( !Q_stricmp( name, "GL_ONE_MINUS_DST_ALPHA" ) )
+	{
+		return GLS_DSTBLEND_ONE_MINUS_DST_ALPHA;
+	}
+	else if ( !Q_stricmp( name, "GL_SRC_COLOR" ) )
+	{
+		return GLS_DSTBLEND_SRC_COLOR;
+	}
+	else if ( !Q_stricmp( name, "GL_ONE_MINUS_SRC_COLOR" ) )
+	{
+		return GLS_DSTBLEND_ONE_MINUS_SRC_COLOR;
+	}
+
+	ri.Printf( PRINT_WARNING, "WARNING: unknown blend mode '%s' in shader '%s', substituting GL_ONE\n", name, shader.name );
+	return GLS_DSTBLEND_ONE;
+}
+
+/*
+===============
+NameToGenFunc
+===============
+*/
+static genFunc_t NameToGenFunc( const char *funcname )
+{
+	if ( !Q_stricmp( funcname, "sin" ) )
+	{
+		return GF_SIN;
+	}
+	else if ( !Q_stricmp( funcname, "square" ) )
+	{
+		return GF_SQUARE;
+	}
+	else if ( !Q_stricmp( funcname, "triangle" ) )
+	{
+		return GF_TRIANGLE;
+	}
+	else if ( !Q_stricmp( funcname, "sawtooth" ) )
+	{
+		return GF_SAWTOOTH;
+	}
+	else if ( !Q_stricmp( funcname, "inversesawtooth" ) )
+	{
+		return GF_INVERSE_SAWTOOTH;
+	}
+	else if ( !Q_stricmp( funcname, "noise" ) )
+	{
+		return GF_NOISE;
+	}
+
+	ri.Printf( PRINT_WARNING, "WARNING: invalid genfunc name '%s' in shader '%s'\n", funcname, shader.name );
+	return GF_SIN;
+}
+
+
+/*
+===================
+ParseWaveForm
+===================
+*/
+static void ParseWaveForm( char **text, waveForm_t *wave )
+{
+	char *token;
+
+	token = COM_ParseExt( text, qfalse );
+	if ( token[0] == 0 )
+	{
+		ri.Printf( PRINT_WARNING, "WARNING: missing waveform parm in shader '%s'\n", shader.name );
+		return;
+	}
+	wave->func = NameToGenFunc( token );
+
+	// BASE, AMP, PHASE, FREQ
+	token = COM_ParseExt( text, qfalse );
+	if ( token[0] == 0 )
+	{
+		ri.Printf( PRINT_WARNING, "WARNING: missing waveform parm in shader '%s'\n", shader.name );
+		return;
+	}
+	wave->base = atof( token );
+
+	token = COM_ParseExt( text, qfalse );
+	if ( token[0] == 0 )
+	{
+		ri.Printf( PRINT_WARNING, "WARNING: missing waveform parm in shader '%s'\n", shader.name );
+		return;
+	}
+	wave->amplitude = atof( token );
+
+	token = COM_ParseExt( text, qfalse );
+	if ( token[0] == 0 )
+	{
+		ri.Printf( PRINT_WARNING, "WARNING: missing waveform parm in shader '%s'\n", shader.name );
+		return;
+	}
+	wave->phase = atof( token );
+
+	token = COM_ParseExt( text, qfalse );
+	if ( token[0] == 0 )
+	{
+		ri.Printf( PRINT_WARNING, "WARNING: missing waveform parm in shader '%s'\n", shader.name );
+		return;
+	}
+	wave->frequency = atof( token );
+}
+
+
+/*
+===================
+ParseTexMod
+===================
+*/
+static void ParseTexMod( char *_text, shaderStage_t *stage )
+{
+	const char *token;
+	char **text = &_text;
+	texModInfo_t *tmi;
+
+	if ( stage->bundle[0].numTexMods == TR_MAX_TEXMODS ) {
+		ri.Error( ERR_DROP, "ERROR: too many tcMod stages in shader '%s'\n", shader.name );
+		return;
+	}
+
+	tmi = &stage->bundle[0].texMods[stage->bundle[0].numTexMods];
+	stage->bundle[0].numTexMods++;
+
+	token = COM_ParseExt( text, qfalse );
+
+	//
+	// turb
+	//
+	if ( !Q_stricmp( token, "turb" ) )
+	{
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing tcMod turb parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->wave.base = atof( token );
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing tcMod turb in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->wave.amplitude = atof( token );
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing tcMod turb in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->wave.phase = atof( token );
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing tcMod turb in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->wave.frequency = atof( token );
+
+		tmi->type = TMOD_TURBULENT;
+	}
+	//
+	// scale
+	//
+	else if ( !Q_stricmp( token, "scale" ) )
+	{
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing scale parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->scale[0] = atof( token );
+
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing scale parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->scale[1] = atof( token );
+		tmi->type = TMOD_SCALE;
+	}
+	//
+	// scroll
+	//
+	else if ( !Q_stricmp( token, "scroll" ) )
+	{
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing scale scroll parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->scroll[0] = atof( token );
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing scale scroll parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->scroll[1] = atof( token );
+		tmi->type = TMOD_SCROLL;
+	}
+	//
+	// stretch
+	//
+	else if ( !Q_stricmp( token, "stretch" ) )
+	{
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing stretch parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->wave.func = NameToGenFunc( token );
+
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing stretch parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->wave.base = atof( token );
+
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing stretch parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->wave.amplitude = atof( token );
+
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing stretch parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->wave.phase = atof( token );
+
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing stretch parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->wave.frequency = atof( token );
+		
+		tmi->type = TMOD_STRETCH;
+	}
+	//
+	// transform
+	//
+	else if ( !Q_stricmp( token, "transform" ) )
+	{
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing transform parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->matrix[0][0] = atof( token );
+
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing transform parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->matrix[0][1] = atof( token );
+
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing transform parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->matrix[1][0] = atof( token );
+
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing transform parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->matrix[1][1] = atof( token );
+
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing transform parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->translate[0] = atof( token );
+
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing transform parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->translate[1] = atof( token );
+
+		tmi->type = TMOD_TRANSFORM;
+	}
+	//
+	// rotate
+	//
+	else if ( !Q_stricmp( token, "rotate" ) )
+	{
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing tcMod rotate parms in shader '%s'\n", shader.name );
+			return;
+		}
+		tmi->rotateSpeed = atof( token );
+		tmi->type = TMOD_ROTATE;
+	}
+	//
+	// entityTranslate
+	//
+	else if ( !Q_stricmp( token, "entityTranslate" ) )
+	{
+		tmi->type = TMOD_ENTITY_TRANSLATE;
+	}
+	else
+	{
+		ri.Printf( PRINT_WARNING, "WARNING: unknown tcMod '%s' in shader '%s'\n", token, shader.name );
+	}
+}
+
+
+/*
+===================
+ParseStage
+===================
+*/
+static qboolean ParseStage( shaderStage_t *stage, char **text )
+{
+	char *token;
+	int depthMaskBits = GLS_DEPTHMASK_TRUE, blendSrcBits = 0, blendDstBits = 0, atestBits = 0, depthFuncBits = 0;
+	qboolean depthMaskExplicit = qfalse;
+
+	stage->active = qtrue;
+
+	while ( 1 )
+	{
+		token = COM_ParseExt( text, qtrue );
+		if ( !token[0] )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: no matching '}' found\n" );
+			return qfalse;
+		}
+
+		if ( token[0] == '}' )
+		{
+			break;
+		}
+		//
+		// map <name>
+		//
+		else if ( !Q_stricmp( token, "map" ) )
+		{
+			token = COM_ParseExt( text, qfalse );
+			if ( !token[0] )
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: missing parameter for 'map' keyword in shader '%s'\n", shader.name );
+				return qfalse;
+			}
+
+			if ( !Q_stricmp( token, "$whiteimage" ) )
+			{
+				stage->bundle[0].image[0] = tr.whiteImage;
+				continue;
+			}
+			else if ( !Q_stricmp( token, "$lightmap" ) )
+			{
+				stage->bundle[0].isLightmap = qtrue;
+				if ( shader.lightmapIndex < 0 ) {
+					stage->bundle[0].image[0] = tr.whiteImage;
+				} else {
+					stage->bundle[0].image[0] = tr.lightmaps[shader.lightmapIndex];
+				}
+				continue;
+			}
+			else
+			{
+				stage->bundle[0].image[0] = R_FindImageFile( token, !shader.noMipMaps, !shader.noPicMip, GL_REPEAT );
+				if ( !stage->bundle[0].image[0] )
+				{
+					ri.Printf( PRINT_WARNING, "WARNING: R_FindImageFile could not find '%s' in shader '%s'\n", token, shader.name );
+					return qfalse;
+				}
+			}
+		}
+		//
+		// clampmap <name>
+		//
+		else if ( !Q_stricmp( token, "clampmap" ) )
+		{
+			token = COM_ParseExt( text, qfalse );
+			if ( !token[0] )
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: missing parameter for 'clampmap' keyword in shader '%s'\n", shader.name );
+				return qfalse;
+			}
+
+			stage->bundle[0].image[0] = R_FindImageFile( token, !shader.noMipMaps, !shader.noPicMip, GL_CLAMP_TO_EDGE );
+			if ( !stage->bundle[0].image[0] )
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: R_FindImageFile could not find '%s' in shader '%s'\n", token, shader.name );
+				return qfalse;
+			}
+		}
+		//
+		// animMap <frequency> <image1> .... <imageN>
+		//
+		else if ( !Q_stricmp( token, "animMap" ) )
+		{
+			token = COM_ParseExt( text, qfalse );
+			if ( !token[0] )
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: missing parameter for 'animMmap' keyword in shader '%s'\n", shader.name );
+				return qfalse;
+			}
+			stage->bundle[0].imageAnimationSpeed = atof( token );
+
+			// parse up to MAX_IMAGE_ANIMATIONS animations
+			while ( 1 ) {
+				int		num;
+
+				token = COM_ParseExt( text, qfalse );
+				if ( !token[0] ) {
+					break;
+				}
+				num = stage->bundle[0].numImageAnimations;
+				if ( num < MAX_IMAGE_ANIMATIONS ) {
+					stage->bundle[0].image[num] = R_FindImageFile( token, !shader.noMipMaps, !shader.noPicMip, GL_REPEAT );
+					if ( !stage->bundle[0].image[num] )
+					{
+						ri.Printf( PRINT_WARNING, "WARNING: R_FindImageFile could not find '%s' in shader '%s'\n", token, shader.name );
+						return qfalse;
+					}
+					stage->bundle[0].numImageAnimations++;
+				}
+			}
+		}
+		else if ( !Q_stricmp( token, "videoMap" ) )
+		{
+			token = COM_ParseExt( text, qfalse );
+			if ( !token[0] )
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: missing parameter for 'videoMmap' keyword in shader '%s'\n", shader.name );
+				return qfalse;
+			}
+			stage->bundle[0].videoMapHandle = ri.CIN_PlayCinematic( token, 0, 0, 256, 256, (CIN_loop | CIN_silent | CIN_shader));
+			if (stage->bundle[0].videoMapHandle != -1) {
+				stage->bundle[0].isVideoMap = qtrue;
+				stage->bundle[0].image[0] = tr.scratchImage[stage->bundle[0].videoMapHandle];
+			}
+		}
+		//
+		// alphafunc <func>
+		//
+		else if ( !Q_stricmp( token, "alphaFunc" ) )
+		{
+			token = COM_ParseExt( text, qfalse );
+			if ( !token[0] )
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: missing parameter for 'alphaFunc' keyword in shader '%s'\n", shader.name );
+				return qfalse;
+			}
+
+			atestBits = NameToAFunc( token );
+		}
+		//
+		// depthFunc <func>
+		//
+		else if ( !Q_stricmp( token, "depthfunc" ) )
+		{
+			token = COM_ParseExt( text, qfalse );
+
+			if ( !token[0] )
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: missing parameter for 'depthfunc' keyword in shader '%s'\n", shader.name );
+				return qfalse;
+			}
+
+			if ( !Q_stricmp( token, "lequal" ) )
+			{
+				depthFuncBits = 0;
+			}
+			else if ( !Q_stricmp( token, "equal" ) )
+			{
+				depthFuncBits = GLS_DEPTHFUNC_EQUAL;
+			}
+			else
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: unknown depthfunc '%s' in shader '%s'\n", token, shader.name );
+				continue;
+			}
+		}
+		//
+		// detail
+		//
+		else if ( !Q_stricmp( token, "detail" ) )
+		{
+			stage->isDetail = qtrue;
+		}
+		//
+		// blendfunc <srcFactor> <dstFactor>
+		// or blendfunc <add|filter|blend>
+		//
+		else if ( !Q_stricmp( token, "blendfunc" ) )
+		{
+			token = COM_ParseExt( text, qfalse );
+			if ( token[0] == 0 )
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: missing parm for blendFunc in shader '%s'\n", shader.name );
+				continue;
+			}
+			// check for "simple" blends first
+			if ( !Q_stricmp( token, "add" ) ) {
+				blendSrcBits = GLS_SRCBLEND_ONE;
+				blendDstBits = GLS_DSTBLEND_ONE;
+			} else if ( !Q_stricmp( token, "filter" ) ) {
+				blendSrcBits = GLS_SRCBLEND_DST_COLOR;
+				blendDstBits = GLS_DSTBLEND_ZERO;
+			} else if ( !Q_stricmp( token, "blend" ) ) {
+				blendSrcBits = GLS_SRCBLEND_SRC_ALPHA;
+				blendDstBits = GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA;
+			} else {
+				// complex double blends
+				blendSrcBits = NameToSrcBlendMode( token );
+
+				token = COM_ParseExt( text, qfalse );
+				if ( token[0] == 0 )
+				{
+					ri.Printf( PRINT_WARNING, "WARNING: missing parm for blendFunc in shader '%s'\n", shader.name );
+					continue;
+				}
+				blendDstBits = NameToDstBlendMode( token );
+			}
+
+			// clear depth mask for blended surfaces
+			if ( !depthMaskExplicit )
+			{
+				depthMaskBits = 0;
+			}
+		}
+		//
+		// rgbGen
+		//
+		else if ( !Q_stricmp( token, "rgbGen" ) )
+		{
+			token = COM_ParseExt( text, qfalse );
+			if ( token[0] == 0 )
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: missing parameters for rgbGen in shader '%s'\n", shader.name );
+				continue;
+			}
+
+			if ( !Q_stricmp( token, "wave" ) )
+			{
+				ParseWaveForm( text, &stage->rgbWave );
+				stage->rgbGen = CGEN_WAVEFORM;
+			}
+			else if ( !Q_stricmp( token, "const" ) )
+			{
+				vec3_t	color;
+
+				ParseVector( text, 3, color );
+				stage->constantColor[0] = 255 * color[0];
+				stage->constantColor[1] = 255 * color[1];
+				stage->constantColor[2] = 255 * color[2];
+
+				stage->rgbGen = CGEN_CONST;
+			}
+			else if ( !Q_stricmp( token, "identity" ) )
+			{
+				stage->rgbGen = CGEN_IDENTITY;
+			}
+			else if ( !Q_stricmp( token, "identityLighting" ) )
+			{
+				stage->rgbGen = CGEN_IDENTITY_LIGHTING;
+			}
+			else if ( !Q_stricmp( token, "entity" ) )
+			{
+				stage->rgbGen = CGEN_ENTITY;
+			}
+			else if ( !Q_stricmp( token, "oneMinusEntity" ) )
+			{
+				stage->rgbGen = CGEN_ONE_MINUS_ENTITY;
+			}
+			else if ( !Q_stricmp( token, "vertex" ) )
+			{
+				stage->rgbGen = CGEN_VERTEX;
+				if ( stage->alphaGen == 0 ) {
+					stage->alphaGen = AGEN_VERTEX;
+				}
+			}
+			else if ( !Q_stricmp( token, "exactVertex" ) )
+			{
+				stage->rgbGen = CGEN_EXACT_VERTEX;
+			}
+			else if ( !Q_stricmp( token, "lightingDiffuse" ) )
+			{
+				stage->rgbGen = CGEN_LIGHTING_DIFFUSE;
+			}
+			else if ( !Q_stricmp( token, "oneMinusVertex" ) )
+			{
+				stage->rgbGen = CGEN_ONE_MINUS_VERTEX;
+			}
+			else
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: unknown rgbGen parameter '%s' in shader '%s'\n", token, shader.name );
+				continue;
+			}
+		}
+		//
+		// alphaGen 
+		//
+		else if ( !Q_stricmp( token, "alphaGen" ) )
+		{
+			token = COM_ParseExt( text, qfalse );
+			if ( token[0] == 0 )
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: missing parameters for alphaGen in shader '%s'\n", shader.name );
+				continue;
+			}
+
+			if ( !Q_stricmp( token, "wave" ) )
+			{
+				ParseWaveForm( text, &stage->alphaWave );
+				stage->alphaGen = AGEN_WAVEFORM;
+			}
+			else if ( !Q_stricmp( token, "const" ) )
+			{
+				token = COM_ParseExt( text, qfalse );
+				stage->constantColor[3] = 255 * atof( token );
+				stage->alphaGen = AGEN_CONST;
+			}
+			else if ( !Q_stricmp( token, "identity" ) )
+			{
+				stage->alphaGen = AGEN_IDENTITY;
+			}
+			else if ( !Q_stricmp( token, "entity" ) )
+			{
+				stage->alphaGen = AGEN_ENTITY;
+			}
+			else if ( !Q_stricmp( token, "oneMinusEntity" ) )
+			{
+				stage->alphaGen = AGEN_ONE_MINUS_ENTITY;
+			}
+			else if ( !Q_stricmp( token, "vertex" ) )
+			{
+				stage->alphaGen = AGEN_VERTEX;
+			}
+			else if ( !Q_stricmp( token, "lightingSpecular" ) )
+			{
+				stage->alphaGen = AGEN_LIGHTING_SPECULAR;
+			}
+			else if ( !Q_stricmp( token, "oneMinusVertex" ) )
+			{
+				stage->alphaGen = AGEN_ONE_MINUS_VERTEX;
+			}
+			else if ( !Q_stricmp( token, "portal" ) )
+			{
+				stage->alphaGen = AGEN_PORTAL;
+				token = COM_ParseExt( text, qfalse );
+				if ( token[0] == 0 )
+				{
+					shader.portalRange = 256;
+					ri.Printf( PRINT_WARNING, "WARNING: missing range parameter for alphaGen portal in shader '%s', defaulting to 256\n", shader.name );
+				}
+				else
+				{
+					shader.portalRange = atof( token );
+				}
+			}
+			else
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: unknown alphaGen parameter '%s' in shader '%s'\n", token, shader.name );
+				continue;
+			}
+		}
+		//
+		// tcGen <function>
+		//
+		else if ( !Q_stricmp(token, "texgen") || !Q_stricmp( token, "tcGen" ) ) 
+		{
+			token = COM_ParseExt( text, qfalse );
+			if ( token[0] == 0 )
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: missing texgen parm in shader '%s'\n", shader.name );
+				continue;
+			}
+
+			if ( !Q_stricmp( token, "environment" ) )
+			{
+				stage->bundle[0].tcGen = TCGEN_ENVIRONMENT_MAPPED;
+			}
+			else if ( !Q_stricmp( token, "lightmap" ) )
+			{
+				stage->bundle[0].tcGen = TCGEN_LIGHTMAP;
+			}
+			else if ( !Q_stricmp( token, "texture" ) || !Q_stricmp( token, "base" ) )
+			{
+				stage->bundle[0].tcGen = TCGEN_TEXTURE;
+			}
+			else if ( !Q_stricmp( token, "vector" ) )
+			{
+				ParseVector( text, 3, stage->bundle[0].tcGenVectors[0] );
+				ParseVector( text, 3, stage->bundle[0].tcGenVectors[1] );
+
+				stage->bundle[0].tcGen = TCGEN_VECTOR;
+			}
+			else 
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: unknown texgen parm in shader '%s'\n", shader.name );
+			}
+		}
+		//
+		// tcMod <type> <...>
+		//
+		else if ( !Q_stricmp( token, "tcMod" ) )
+		{
+			char buffer[1024] = "";
+
+			while ( 1 )
+			{
+				token = COM_ParseExt( text, qfalse );
+				if ( token[0] == 0 )
+					break;
+				strcat( buffer, token );
+				strcat( buffer, " " );
+			}
+
+			ParseTexMod( buffer, stage );
+
+			continue;
+		}
+		//
+		// depthmask
+		//
+		else if ( !Q_stricmp( token, "depthwrite" ) )
+		{
+			depthMaskBits = GLS_DEPTHMASK_TRUE;
+			depthMaskExplicit = qtrue;
+
+			continue;
+		}
+		else
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: unknown parameter '%s' in shader '%s'\n", token, shader.name );
+			return qfalse;
+		}
+	}
+
+	//
+	// if cgen isn't explicitly specified, use either identity or identitylighting
+	//
+	if ( stage->rgbGen == CGEN_BAD ) {
+		if ( blendSrcBits == 0 ||
+			blendSrcBits == GLS_SRCBLEND_ONE || 
+			blendSrcBits == GLS_SRCBLEND_SRC_ALPHA ) {
+			stage->rgbGen = CGEN_IDENTITY_LIGHTING;
+		} else {
+			stage->rgbGen = CGEN_IDENTITY;
+		}
+	}
+
+
+	//
+	// implicitly assume that a GL_ONE GL_ZERO blend mask disables blending
+	//
+	if ( ( blendSrcBits == GLS_SRCBLEND_ONE ) && 
+		 ( blendDstBits == GLS_DSTBLEND_ZERO ) )
+	{
+		blendDstBits = blendSrcBits = 0;
+		depthMaskBits = GLS_DEPTHMASK_TRUE;
+	}
+
+	// decide which agens we can skip
+	if ( stage->alphaGen == AGEN_IDENTITY ) {
+		if ( stage->rgbGen == CGEN_IDENTITY
+			|| stage->rgbGen == CGEN_LIGHTING_DIFFUSE ) {
+			stage->alphaGen = AGEN_SKIP;
+		}
+	}
+
+	//
+	// compute state bits
+	//
+	stage->stateBits = depthMaskBits | 
+		               blendSrcBits | blendDstBits | 
+					   atestBits | 
+					   depthFuncBits;
+
+	return qtrue;
+}
+
+/*
+===============
+ParseDeform
+
+deformVertexes wave <spread> <waveform> <base> <amplitude> <phase> <frequency>
+deformVertexes normal <frequency> <amplitude>
+deformVertexes move <vector> <waveform> <base> <amplitude> <phase> <frequency>
+deformVertexes bulge <bulgeWidth> <bulgeHeight> <bulgeSpeed>
+deformVertexes projectionShadow
+deformVertexes autoSprite
+deformVertexes autoSprite2
+deformVertexes text[0-7]
+===============
+*/
+static void ParseDeform( char **text ) {
+	char	*token;
+	deformStage_t	*ds;
+
+	token = COM_ParseExt( text, qfalse );
+	if ( token[0] == 0 )
+	{
+		ri.Printf( PRINT_WARNING, "WARNING: missing deform parm in shader '%s'\n", shader.name );
+		return;
+	}
+
+	if ( shader.numDeforms == MAX_SHADER_DEFORMS ) {
+		ri.Printf( PRINT_WARNING, "WARNING: MAX_SHADER_DEFORMS in '%s'\n", shader.name );
+		return;
+	}
+
+	ds = &shader.deforms[ shader.numDeforms ];
+	shader.numDeforms++;
+
+	if ( !Q_stricmp( token, "projectionShadow" ) ) {
+		ds->deformation = DEFORM_PROJECTION_SHADOW;
+		return;
+	}
+
+	if ( !Q_stricmp( token, "autosprite" ) ) {
+		ds->deformation = DEFORM_AUTOSPRITE;
+		return;
+	}
+
+	if ( !Q_stricmp( token, "autosprite2" ) ) {
+		ds->deformation = DEFORM_AUTOSPRITE2;
+		return;
+	}
+
+	if ( !Q_stricmpn( token, "text", 4 ) ) {
+		int		n;
+		
+		n = token[4] - '0';
+		if ( n < 0 || n > 7 ) {
+			n = 0;
+		}
+		ds->deformation = DEFORM_TEXT0 + n;
+		return;
+	}
+
+	if ( !Q_stricmp( token, "bulge" ) )	{
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing deformVertexes bulge parm in shader '%s'\n", shader.name );
+			return;
+		}
+		ds->bulgeWidth = atof( token );
+
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing deformVertexes bulge parm in shader '%s'\n", shader.name );
+			return;
+		}
+		ds->bulgeHeight = atof( token );
+
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing deformVertexes bulge parm in shader '%s'\n", shader.name );
+			return;
+		}
+		ds->bulgeSpeed = atof( token );
+
+		ds->deformation = DEFORM_BULGE;
+		return;
+	}
+
+	if ( !Q_stricmp( token, "wave" ) )
+	{
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing deformVertexes parm in shader '%s'\n", shader.name );
+			return;
+		}
+
+		if ( atof( token ) != 0 )
+		{
+			ds->deformationSpread = 1.0f / atof( token );
+		}
+		else
+		{
+			ds->deformationSpread = 100.0f;
+			ri.Printf( PRINT_WARNING, "WARNING: illegal div value of 0 in deformVertexes command for shader '%s'\n", shader.name );
+		}
+
+		ParseWaveForm( text, &ds->deformationWave );
+		ds->deformation = DEFORM_WAVE;
+		return;
+	}
+
+	if ( !Q_stricmp( token, "normal" ) )
+	{
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing deformVertexes parm in shader '%s'\n", shader.name );
+			return;
+		}
+		ds->deformationWave.amplitude = atof( token );
+
+		token = COM_ParseExt( text, qfalse );
+		if ( token[0] == 0 )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: missing deformVertexes parm in shader '%s'\n", shader.name );
+			return;
+		}
+		ds->deformationWave.frequency = atof( token );
+
+		ds->deformation = DEFORM_NORMALS;
+		return;
+	}
+
+	if ( !Q_stricmp( token, "move" ) ) {
+		int		i;
+
+		for ( i = 0 ; i < 3 ; i++ ) {
+			token = COM_ParseExt( text, qfalse );
+			if ( token[0] == 0 ) {
+				ri.Printf( PRINT_WARNING, "WARNING: missing deformVertexes parm in shader '%s'\n", shader.name );
+				return;
+			}
+			ds->moveVector[i] = atof( token );
+		}
+
+		ParseWaveForm( text, &ds->deformationWave );
+		ds->deformation = DEFORM_MOVE;
+		return;
+	}
+
+	ri.Printf( PRINT_WARNING, "WARNING: unknown deformVertexes subtype '%s' found in shader '%s'\n", token, shader.name );
+}
+
+
+/*
+===============
+ParseSkyParms
+
+skyParms <outerbox> <cloudheight> <innerbox>
+===============
+*/
+static void ParseSkyParms( char **text ) {
+	char		*token;
+	static char	*suf[6] = {"rt", "bk", "lf", "ft", "up", "dn"};
+	char		pathname[MAX_QPATH];
+	int			i;
+
+	// outerbox
+	token = COM_ParseExt( text, qfalse );
+	if ( token[0] == 0 ) {
+		ri.Printf( PRINT_WARNING, "WARNING: 'skyParms' missing parameter in shader '%s'\n", shader.name );
+		return;
+	}
+	if ( strcmp( token, "-" ) ) {
+		for (i=0 ; i<6 ; i++) {
+			Com_sprintf( pathname, sizeof(pathname), "%s_%s.tga"
+				, token, suf[i] );
+			shader.sky.outerbox[i] = R_FindImageFile( ( char * ) pathname, qtrue, qtrue, GL_CLAMP_TO_EDGE );
+
+			if ( !shader.sky.outerbox[i] ) {
+				shader.sky.outerbox[i] = tr.defaultImage;
+			}
+		}
+	}
+
+	// cloudheight
+	token = COM_ParseExt( text, qfalse );
+	if ( token[0] == 0 ) {
+		ri.Printf( PRINT_WARNING, "WARNING: 'skyParms' missing parameter in shader '%s'\n", shader.name );
+		return;
+	}
+	shader.sky.cloudHeight = atof( token );
+	if ( !shader.sky.cloudHeight ) {
+		shader.sky.cloudHeight = 512;
+	}
+	R_InitSkyTexCoords( shader.sky.cloudHeight );
+
+
+	// innerbox
+	token = COM_ParseExt( text, qfalse );
+	if ( token[0] == 0 ) {
+		ri.Printf( PRINT_WARNING, "WARNING: 'skyParms' missing parameter in shader '%s'\n", shader.name );
+		return;
+	}
+	if ( strcmp( token, "-" ) ) {
+		for (i=0 ; i<6 ; i++) {
+			Com_sprintf( pathname, sizeof(pathname), "%s_%s.tga"
+				, token, suf[i] );
+			shader.sky.innerbox[i] = R_FindImageFile( ( char * ) pathname, qtrue, qtrue, GL_REPEAT );
+			if ( !shader.sky.innerbox[i] ) {
+				shader.sky.innerbox[i] = tr.defaultImage;
+			}
+		}
+	}
+
+	shader.isSky = qtrue;
+}
+
+
+/*
+=================
+ParseSort
+=================
+*/
+void ParseSort( char **text ) {
+	char	*token;
+
+	token = COM_ParseExt( text, qfalse );
+	if ( token[0] == 0 ) {
+		ri.Printf( PRINT_WARNING, "WARNING: missing sort parameter in shader '%s'\n", shader.name );
+		return;
+	}
+
+	if ( !Q_stricmp( token, "portal" ) ) {
+		shader.sort = SS_PORTAL;
+	} else if ( !Q_stricmp( token, "sky" ) ) {
+		shader.sort = SS_ENVIRONMENT;
+	} else if ( !Q_stricmp( token, "opaque" ) ) {
+		shader.sort = SS_OPAQUE;
+	}else if ( !Q_stricmp( token, "decal" ) ) {
+		shader.sort = SS_DECAL;
+	} else if ( !Q_stricmp( token, "seeThrough" ) ) {
+		shader.sort = SS_SEE_THROUGH;
+	} else if ( !Q_stricmp( token, "banner" ) ) {
+		shader.sort = SS_BANNER;
+	} else if ( !Q_stricmp( token, "additive" ) ) {
+		shader.sort = SS_BLEND1;
+	} else if ( !Q_stricmp( token, "nearest" ) ) {
+		shader.sort = SS_NEAREST;
+	} else if ( !Q_stricmp( token, "underwater" ) ) {
+		shader.sort = SS_UNDERWATER;
+	} else {
+		shader.sort = atof( token );
+	}
+}
+
+
+
+// this table is also present in q3map
+
+typedef struct {
+	char	*name;
+	int		clearSolid, surfaceFlags, contents;
+} infoParm_t;
+
+infoParm_t	infoParms[] = {
+	// server relevant contents
+	{"water",		1,	0,	CONTENTS_WATER },
+	{"slime",		1,	0,	CONTENTS_SLIME },		// mildly damaging
+	{"lava",		1,	0,	CONTENTS_LAVA },		// very damaging
+	{"playerclip",	1,	0,	CONTENTS_PLAYERCLIP },
+	{"monsterclip",	1,	0,	CONTENTS_MONSTERCLIP },
+	{"nodrop",		1,	0,	CONTENTS_NODROP },		// don't drop items or leave bodies (death fog, lava, etc)
+	{"nonsolid",	1,	SURF_NONSOLID,	0},						// clears the solid flag
+
+	// utility relevant attributes
+	{"origin",		1,	0,	CONTENTS_ORIGIN },		// center of rotating brushes
+	{"trans",		0,	0,	CONTENTS_TRANSLUCENT },	// don't eat contained surfaces
+	{"detail",		0,	0,	CONTENTS_DETAIL },		// don't include in structural bsp
+	{"structural",	0,	0,	CONTENTS_STRUCTURAL },	// force into structural bsp even if trnas
+	{"areaportal",	1,	0,	CONTENTS_AREAPORTAL },	// divides areas
+	{"clusterportal", 1,0,  CONTENTS_CLUSTERPORTAL },	// for bots
+	{"donotenter",  1,  0,  CONTENTS_DONOTENTER },		// for bots
+
+	{"fog",			1,	0,	CONTENTS_FOG},			// carves surfaces entering
+	{"sky",			0,	SURF_SKY,		0 },		// emit light from an environment map
+	{"lightfilter",	0,	SURF_LIGHTFILTER, 0 },		// filter light going through it
+	{"alphashadow",	0,	SURF_ALPHASHADOW, 0 },		// test light on a per-pixel basis
+	{"hint",		0,	SURF_HINT,		0 },		// use as a primary splitter
+
+	// server attributes
+	{"slick",		0,	SURF_SLICK,		0 },
+	{"noimpact",	0,	SURF_NOIMPACT,	0 },		// don't make impact explosions or marks
+	{"nomarks",		0,	SURF_NOMARKS,	0 },		// don't make impact marks, but still explode
+	{"ladder",		0,	SURF_LADDER,	0 },
+	{"nodamage",	0,	SURF_NODAMAGE,	0 },
+	{"metalsteps",	0,	SURF_METALSTEPS,0 },
+	{"flesh",		0,	SURF_FLESH,		0 },
+	{"nosteps",		0,	SURF_NOSTEPS,	0 },
+
+	// drawsurf attributes
+	{"nodraw",		0,	SURF_NODRAW,	0 },	// don't generate a drawsurface (or a lightmap)
+	{"pointlight",	0,	SURF_POINTLIGHT, 0 },	// sample lighting at vertexes
+	{"nolightmap",	0,	SURF_NOLIGHTMAP,0 },	// don't generate a lightmap
+	{"nodlight",	0,	SURF_NODLIGHT, 0 },		// don't ever add dynamic lights
+	{"dust",		0,	SURF_DUST, 0}			// leave a dust trail when walking on this surface
+};
+
+
+/*
+===============
+ParseSurfaceParm
+
+surfaceparm <name>
+===============
+*/
+static void ParseSurfaceParm( char **text ) {
+	char	*token;
+	int		numInfoParms = ARRAY_LEN( infoParms );
+	int		i;
+
+	token = COM_ParseExt( text, qfalse );
+	for ( i = 0 ; i < numInfoParms ; i++ ) {
+		if ( !Q_stricmp( token, infoParms[i].name ) ) {
+			shader.surfaceFlags |= infoParms[i].surfaceFlags;
+			shader.contentFlags |= infoParms[i].contents;
+#if 0
+			if ( infoParms[i].clearSolid ) {
+				si->contents &= ~CONTENTS_SOLID;
+			}
+#endif
+			break;
+		}
+	}
+}
+
+/*
+=================
+ParseShader
+
+The current text pointer is at the explicit text definition of the
+shader.  Parse it into the global shader variable.  Later functions
+will optimize it.
+=================
+*/
+static qboolean ParseShader( char **text )
+{
+	char *token;
+	int s;
+
+	s = 0;
+
+	token = COM_ParseExt( text, qtrue );
+	if ( token[0] != '{' )
+	{
+		ri.Printf( PRINT_WARNING, "WARNING: expecting '{', found '%s' instead in shader '%s'\n", token, shader.name );
+		return qfalse;
+	}
+
+	while ( 1 )
+	{
+		token = COM_ParseExt( text, qtrue );
+		if ( !token[0] )
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: no concluding '}' in shader %s\n", shader.name );
+			return qfalse;
+		}
+
+		// end of shader definition
+		if ( token[0] == '}' )
+		{
+			break;
+		}
+		// stage definition
+		else if ( token[0] == '{' )
+		{
+			if ( s >= MAX_SHADER_STAGES ) {
+				ri.Printf( PRINT_WARNING, "WARNING: too many stages in shader %s\n", shader.name );
+				return qfalse;
+			}
+
+			if ( !ParseStage( &stages[s], text ) )
+			{
+				return qfalse;
+			}
+			stages[s].active = qtrue;
+			s++;
+
+			continue;
+		}
+		// skip stuff that only the QuakeEdRadient needs
+		else if ( !Q_stricmpn( token, "qer", 3 ) ) {
+			SkipRestOfLine( text );
+			continue;
+		}
+		// sun parms
+		else if ( !Q_stricmp( token, "q3map_sun" ) ) {
+			float	a, b;
+
+			token = COM_ParseExt( text, qfalse );
+			tr.sunLight[0] = atof( token );
+			token = COM_ParseExt( text, qfalse );
+			tr.sunLight[1] = atof( token );
+			token = COM_ParseExt( text, qfalse );
+			tr.sunLight[2] = atof( token );
+			
+			VectorNormalize( tr.sunLight );
+
+			token = COM_ParseExt( text, qfalse );
+			a = atof( token );
+			VectorScale( tr.sunLight, a, tr.sunLight);
+
+			token = COM_ParseExt( text, qfalse );
+			a = atof( token );
+			a = a / 180 * M_PI;
+
+			token = COM_ParseExt( text, qfalse );
+			b = atof( token );
+			b = b / 180 * M_PI;
+
+			tr.sunDirection[0] = cos( a ) * cos( b );
+			tr.sunDirection[1] = sin( a ) * cos( b );
+			tr.sunDirection[2] = sin( b );
+		}
+		else if ( !Q_stricmp( token, "deformVertexes" ) ) {
+			ParseDeform( text );
+			continue;
+		}
+		else if ( !Q_stricmp( token, "tesssize" ) ) {
+			SkipRestOfLine( text );
+			continue;
+		}
+		else if ( !Q_stricmp( token, "clampTime" ) ) {
+			token = COM_ParseExt( text, qfalse );
+      if (token[0]) {
+        shader.clampTime = atof(token);
+      }
+    }
+		// skip stuff that only the q3map needs
+		else if ( !Q_stricmpn( token, "q3map", 5 ) ) {
+			SkipRestOfLine( text );
+			continue;
+		}
+		// skip stuff that only q3map or the server needs
+		else if ( !Q_stricmp( token, "surfaceParm" ) ) {
+			ParseSurfaceParm( text );
+			continue;
+		}
+		// no mip maps
+		else if ( !Q_stricmp( token, "nomipmaps" ) )
+		{
+			shader.noMipMaps = qtrue;
+			shader.noPicMip = qtrue;
+			continue;
+		}
+		// no picmip adjustment
+		else if ( !Q_stricmp( token, "nopicmip" ) )
+		{
+			shader.noPicMip = qtrue;
+			continue;
+		}
+		// polygonOffset
+		else if ( !Q_stricmp( token, "polygonOffset" ) )
+		{
+			shader.polygonOffset = qtrue;
+			continue;
+		}
+		// entityMergable, allowing sprite surfaces from multiple entities
+		// to be merged into one batch.  This is a savings for smoke
+		// puffs and blood, but can't be used for anything where the
+		// shader calcs (not the surface function) reference the entity color or scroll
+		else if ( !Q_stricmp( token, "entityMergable" ) )
+		{
+			shader.entityMergable = qtrue;
+			continue;
+		}
+		// fogParms
+		else if ( !Q_stricmp( token, "fogParms" ) ) 
+		{
+			if ( !ParseVector( text, 3, shader.fogParms.color ) ) {
+				return qfalse;
+			}
+
+			token = COM_ParseExt( text, qfalse );
+			if ( !token[0] ) 
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: missing parm for 'fogParms' keyword in shader '%s'\n", shader.name );
+				continue;
+			}
+			shader.fogParms.depthForOpaque = atof( token );
+
+			// skip any old gradient directions
+			SkipRestOfLine( text );
+			continue;
+		}
+		// portal
+		else if ( !Q_stricmp(token, "portal") )
+		{
+			shader.sort = SS_PORTAL;
+			continue;
+		}
+		// skyparms <cloudheight> <outerbox> <innerbox>
+		else if ( !Q_stricmp( token, "skyparms" ) )
+		{
+			ParseSkyParms( text );
+			continue;
+		}
+		// light <value> determines flaring in q3map, not needed here
+		else if ( !Q_stricmp(token, "light") ) 
+		{
+			token = COM_ParseExt( text, qfalse );
+			continue;
+		}
+		// cull <face>
+		else if ( !Q_stricmp( token, "cull") ) 
+		{
+			token = COM_ParseExt( text, qfalse );
+			if ( token[0] == 0 )
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: missing cull parms in shader '%s'\n", shader.name );
+				continue;
+			}
+
+			if ( !Q_stricmp( token, "none" ) || !Q_stricmp( token, "twosided" ) || !Q_stricmp( token, "disable" ) )
+			{
+				shader.cullType = CT_TWO_SIDED;
+			}
+			else if ( !Q_stricmp( token, "back" ) || !Q_stricmp( token, "backside" ) || !Q_stricmp( token, "backsided" ) )
+			{
+				shader.cullType = CT_BACK_SIDED;
+			}
+			else
+			{
+				ri.Printf( PRINT_WARNING, "WARNING: invalid cull parm '%s' in shader '%s'\n", token, shader.name );
+			}
+			continue;
+		}
+		// sort
+		else if ( !Q_stricmp( token, "sort" ) )
+		{
+			ParseSort( text );
+			continue;
+		}
+		else
+		{
+			ri.Printf( PRINT_WARNING, "WARNING: unknown general shader parameter '%s' in '%s'\n", token, shader.name );
+			return qfalse;
+		}
+	}
+
+	//
+	// ignore shaders that don't have any stages, unless it is a sky or fog
+	//
+	if ( s == 0 && !shader.isSky && !(shader.contentFlags & CONTENTS_FOG ) ) {
+		return qfalse;
+	}
+
+	shader.explicitlyDefined = qtrue;
+
+	return qtrue;
+}
+
+/*
+========================================================================================
+
+SHADER OPTIMIZATION AND FOGGING
+
+========================================================================================
+*/
+
+/*
+===================
+ComputeStageIteratorFunc
+
+See if we can use on of the simple fastpath stage functions,
+otherwise set to the generic stage function
+===================
+*/
+static void ComputeStageIteratorFunc( void )
+{
+	shader.optimalStageIteratorFunc = RB_StageIteratorGeneric;
+
+	//
+	// see if this should go into the sky path
+	//
+	if ( shader.isSky )
+	{
+		shader.optimalStageIteratorFunc = RB_StageIteratorSky;
+		goto done;
+	}
+
+	if ( r_ignoreFastPath->integer )
+	{
+		return;
+	}
+
+	//
+	// see if this can go into the vertex lit fast path
+	//
+	if ( shader.numUnfoggedPasses == 1 )
+	{
+		if ( stages[0].rgbGen == CGEN_LIGHTING_DIFFUSE )
+		{
+			if ( stages[0].alphaGen == AGEN_IDENTITY )
+			{
+				if ( stages[0].bundle[0].tcGen == TCGEN_TEXTURE )
+				{
+					if ( !shader.polygonOffset )
+					{
+						if ( !shader.multitextureEnv )
+						{
+							if ( !shader.numDeforms )
+							{
+								shader.optimalStageIteratorFunc = RB_StageIteratorVertexLitTexture;
+								goto done;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	//
+	// see if this can go into an optimized LM, multitextured path
+	//
+	if ( shader.numUnfoggedPasses == 1 )
+	{
+		if ( ( stages[0].rgbGen == CGEN_IDENTITY ) && ( stages[0].alphaGen == AGEN_IDENTITY ) )
+		{
+			if ( stages[0].bundle[0].tcGen == TCGEN_TEXTURE && 
+				stages[0].bundle[1].tcGen == TCGEN_LIGHTMAP )
+			{
+				if ( !shader.polygonOffset )
+				{
+					if ( !shader.numDeforms )
+					{
+						if ( shader.multitextureEnv )
+						{
+							shader.optimalStageIteratorFunc = RB_StageIteratorLightmappedMultitexture;
+							goto done;
+						}
+					}
+				}
+			}
+		}
+	}
+
+done:
+	return;
+}
+
+typedef struct {
+	int		blendA;
+	int		blendB;
+
+	int		multitextureEnv;
+	int		multitextureBlend;
+} collapse_t;
+
+static collapse_t	collapse[] = {
+	{ 0, GLS_DSTBLEND_SRC_COLOR | GLS_SRCBLEND_ZERO,	
+		GL_MODULATE, 0 },
+
+	{ 0, GLS_DSTBLEND_ZERO | GLS_SRCBLEND_DST_COLOR,
+		GL_MODULATE, 0 },
+
+	{ GLS_DSTBLEND_ZERO | GLS_SRCBLEND_DST_COLOR, GLS_DSTBLEND_ZERO | GLS_SRCBLEND_DST_COLOR,
+		GL_MODULATE, GLS_DSTBLEND_ZERO | GLS_SRCBLEND_DST_COLOR },
+
+	{ GLS_DSTBLEND_SRC_COLOR | GLS_SRCBLEND_ZERO, GLS_DSTBLEND_ZERO | GLS_SRCBLEND_DST_COLOR,
+		GL_MODULATE, GLS_DSTBLEND_ZERO | GLS_SRCBLEND_DST_COLOR },
+
+	{ GLS_DSTBLEND_ZERO | GLS_SRCBLEND_DST_COLOR, GLS_DSTBLEND_SRC_COLOR | GLS_SRCBLEND_ZERO,
+		GL_MODULATE, GLS_DSTBLEND_ZERO | GLS_SRCBLEND_DST_COLOR },
+
+	{ GLS_DSTBLEND_SRC_COLOR | GLS_SRCBLEND_ZERO, GLS_DSTBLEND_SRC_COLOR | GLS_SRCBLEND_ZERO,
+		GL_MODULATE, GLS_DSTBLEND_ZERO | GLS_SRCBLEND_DST_COLOR },
+
+	{ 0, GLS_DSTBLEND_ONE | GLS_SRCBLEND_ONE,
+		GL_ADD, 0 },
+
+	{ GLS_DSTBLEND_ONE | GLS_SRCBLEND_ONE, GLS_DSTBLEND_ONE | GLS_SRCBLEND_ONE,
+		GL_ADD, GLS_DSTBLEND_ONE | GLS_SRCBLEND_ONE },
+#if 0
+	{ 0, GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA | GLS_SRCBLEND_SRC_ALPHA,
+		GL_DECAL, 0 },
+#endif
+	{ -1 }
+};
+
+/*
+================
+CollapseMultitexture
+
+Attempt to combine two stages into a single multitexture stage
+FIXME: I think modulated add + modulated add collapses incorrectly
+=================
+*/
+static qboolean CollapseMultitexture( void ) {
+	int abits, bbits;
+	int i;
+	textureBundle_t tmpBundle;
+
+	if ( !qglActiveTextureARB ) {
+		return qfalse;
+	}
+
+	// make sure both stages are active
+	if ( !stages[0].active || !stages[1].active ) {
+		return qfalse;
+	}
+
+	// on voodoo2, don't combine different tmus
+	if ( glConfig.driverType == GLDRV_VOODOO ) {
+		if ( stages[0].bundle[0].image[0]->TMU ==
+			 stages[1].bundle[0].image[0]->TMU ) {
+			return qfalse;
+		}
+	}
+
+	abits = stages[0].stateBits;
+	bbits = stages[1].stateBits;
+
+	// make sure that both stages have identical state other than blend modes
+	if ( ( abits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) !=
+		( bbits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) ) {
+		return qfalse;
+	}
+
+	abits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+	bbits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+
+	// search for a valid multitexture blend function
+	for ( i = 0; collapse[i].blendA != -1 ; i++ ) {
+		if ( abits == collapse[i].blendA
+			&& bbits == collapse[i].blendB ) {
+			break;
+		}
+	}
+
+	// nothing found
+	if ( collapse[i].blendA == -1 ) {
+		return qfalse;
+	}
+
+	// GL_ADD is a separate extension
+	if ( collapse[i].multitextureEnv == GL_ADD && !glConfig.textureEnvAddAvailable ) {
+		return qfalse;
+	}
+
+	// make sure waveforms have identical parameters
+	if ( ( stages[0].rgbGen != stages[1].rgbGen ) ||
+		( stages[0].alphaGen != stages[1].alphaGen ) )  {
+		return qfalse;
+	}
+
+	// an add collapse can only have identity colors
+	if ( collapse[i].multitextureEnv == GL_ADD && stages[0].rgbGen != CGEN_IDENTITY ) {
+		return qfalse;
+	}
+
+	if ( stages[0].rgbGen == CGEN_WAVEFORM )
+	{
+		if ( memcmp( &stages[0].rgbWave,
+					 &stages[1].rgbWave,
+					 sizeof( stages[0].rgbWave ) ) )
+		{
+			return qfalse;
+		}
+	}
+	if ( stages[0].alphaGen == AGEN_WAVEFORM )
+	{
+		if ( memcmp( &stages[0].alphaWave,
+					 &stages[1].alphaWave,
+					 sizeof( stages[0].alphaWave ) ) )
+		{
+			return qfalse;
+		}
+	}
+
+
+	// make sure that lightmaps are in bundle 1 for 3dfx
+	if ( stages[0].bundle[0].isLightmap )
+	{
+		tmpBundle = stages[0].bundle[0];
+		stages[0].bundle[0] = stages[1].bundle[0];
+		stages[0].bundle[1] = tmpBundle;
+	}
+	else
+	{
+		stages[0].bundle[1] = stages[1].bundle[0];
+	}
+
+	// set the new blend state bits
+	shader.multitextureEnv = collapse[i].multitextureEnv;
+	stages[0].stateBits &= ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+	stages[0].stateBits |= collapse[i].multitextureBlend;
+
+	//
+	// move down subsequent shaders
+	//
+	memmove( &stages[1], &stages[2], sizeof( stages[0] ) * ( MAX_SHADER_STAGES - 2 ) );
+	Com_Memset( &stages[MAX_SHADER_STAGES-1], 0, sizeof( stages[0] ) );
+
+	return qtrue;
+}
+
+/*
+=============
+
+FixRenderCommandList
+https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=493
+Arnout: this is a nasty issue. Shaders can be registered after drawsurfaces are generated
+but before the frame is rendered. This will, for the duration of one frame, cause drawsurfaces
+to be rendered with bad shaders. To fix this, need to go through all render commands and fix
+sortedIndex.
+==============
+*/
+static void FixRenderCommandList( int newShader ) {
+	renderCommandList_t	*cmdList = &backEndData[tr.smpFrame]->commands;
+
+	if( cmdList ) {
+		const void *curCmd = cmdList->cmds;
+
+		while ( 1 ) {
+			switch ( *(const int *)curCmd ) {
+			case RC_SET_COLOR:
+				{
+				const setColorCommand_t *sc_cmd = (const setColorCommand_t *)curCmd;
+				curCmd = (const void *)(sc_cmd + 1);
+				break;
+				}
+			case RC_STRETCH_PIC:
+				{
+				const stretchPicCommand_t *sp_cmd = (const stretchPicCommand_t *)curCmd;
+				curCmd = (const void *)(sp_cmd + 1);
+				break;
+				}
+			case RC_DRAW_SURFS:
+				{
+				int i;
+				drawSurf_t	*drawSurf;
+				shader_t	*shader;
+				int			fogNum;
+				int			entityNum;
+				int			dlightMap;
+				int			sortedIndex;
+				const drawSurfsCommand_t *ds_cmd =  (const drawSurfsCommand_t *)curCmd;
+
+				for( i = 0, drawSurf = ds_cmd->drawSurfs; i < ds_cmd->numDrawSurfs; i++, drawSurf++ ) {
+					R_DecomposeSort( drawSurf->sort, &entityNum, &shader, &fogNum, &dlightMap );
+                    sortedIndex = (( drawSurf->sort >> QSORT_SHADERNUM_SHIFT ) & (MAX_SHADERS-1));
+					if( sortedIndex >= newShader ) {
+						sortedIndex++;
+						drawSurf->sort = (sortedIndex << QSORT_SHADERNUM_SHIFT) | entityNum | ( fogNum << QSORT_FOGNUM_SHIFT ) | (int)dlightMap;
+					}
+				}
+				curCmd = (const void *)(ds_cmd + 1);
+				break;
+				}
+			case RC_DRAW_BUFFER:
+				{
+				const drawBufferCommand_t *db_cmd = (const drawBufferCommand_t *)curCmd;
+				curCmd = (const void *)(db_cmd + 1);
+				break;
+				}
+			case RC_SWAP_BUFFERS:
+				{
+				const swapBuffersCommand_t *sb_cmd = (const swapBuffersCommand_t *)curCmd;
+				curCmd = (const void *)(sb_cmd + 1);
+				break;
+				}
+			case RC_END_OF_LIST:
+			default:
+				return;
+			}
+		}
+	}
+}
+
+/*
+==============
+SortNewShader
+
+Positions the most recently created shader in the tr.sortedShaders[]
+array so that the shader->sort key is sorted reletive to the other
+shaders.
+
+Sets shader->sortedIndex
+==============
+*/
+static void SortNewShader( void ) {
+	int		i;
+	float	sort;
+	shader_t	*newShader;
+
+	newShader = tr.shaders[ tr.numShaders - 1 ];
+	sort = newShader->sort;
+
+	for ( i = tr.numShaders - 2 ; i >= 0 ; i-- ) {
+		if ( tr.sortedShaders[ i ]->sort <= sort ) {
+			break;
+		}
+		tr.sortedShaders[i+1] = tr.sortedShaders[i];
+		tr.sortedShaders[i+1]->sortedIndex++;
+	}
+
+	// Arnout: fix rendercommandlist
+	// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=493
+	FixRenderCommandList( i+1 );
+
+	newShader->sortedIndex = i+1;
+	tr.sortedShaders[i+1] = newShader;
+}
+
+
+/*
+====================
+GeneratePermanentShader
+====================
+*/
+static shader_t *GeneratePermanentShader( void ) {
+	shader_t	*newShader;
+	int			i, b;
+	int			size, hash;
+
+	if ( tr.numShaders == MAX_SHADERS ) {
+		ri.Printf( PRINT_WARNING, "WARNING: GeneratePermanentShader - MAX_SHADERS hit\n");
+		return tr.defaultShader;
+	}
+
+	newShader = ri.Hunk_Alloc( sizeof( shader_t ), h_low );
+
+	*newShader = shader;
+
+	if ( shader.sort <= SS_OPAQUE ) {
+		newShader->fogPass = FP_EQUAL;
+	} else if ( shader.contentFlags & CONTENTS_FOG ) {
+		newShader->fogPass = FP_LE;
+	}
+
+	tr.shaders[ tr.numShaders ] = newShader;
+	newShader->index = tr.numShaders;
+	
+	tr.sortedShaders[ tr.numShaders ] = newShader;
+	newShader->sortedIndex = tr.numShaders;
+
+	tr.numShaders++;
+
+	for ( i = 0 ; i < newShader->numUnfoggedPasses ; i++ ) {
+		if ( !stages[i].active ) {
+			break;
+		}
+		newShader->stages[i] = ri.Hunk_Alloc( sizeof( stages[i] ), h_low );
+		*newShader->stages[i] = stages[i];
+
+		for ( b = 0 ; b < NUM_TEXTURE_BUNDLES ; b++ ) {
+			size = newShader->stages[i]->bundle[b].numTexMods * sizeof( texModInfo_t );
+			newShader->stages[i]->bundle[b].texMods = ri.Hunk_Alloc( size, h_low );
+			Com_Memcpy( newShader->stages[i]->bundle[b].texMods, stages[i].bundle[b].texMods, size );
+		}
+	}
+
+	SortNewShader();
+
+	hash = generateHashValue(newShader->name, FILE_HASH_SIZE);
+	newShader->next = hashTable[hash];
+	hashTable[hash] = newShader;
+
+	return newShader;
+}
+
+/*
+=================
+VertexLightingCollapse
+
+If vertex lighting is enabled, only render a single
+pass, trying to guess which is the correct one to best aproximate
+what it is supposed to look like.
+=================
+*/
+static void VertexLightingCollapse( void ) {
+	int		stage;
+	shaderStage_t	*bestStage;
+	int		bestImageRank;
+	int		rank;
+
+	// if we aren't opaque, just use the first pass
+	if ( shader.sort == SS_OPAQUE ) {
+
+		// pick the best texture for the single pass
+		bestStage = &stages[0];
+		bestImageRank = -999999;
+
+		for ( stage = 0; stage < MAX_SHADER_STAGES; stage++ ) {
+			shaderStage_t *pStage = &stages[stage];
+
+			if ( !pStage->active ) {
+				break;
+			}
+			rank = 0;
+
+			if ( pStage->bundle[0].isLightmap ) {
+				rank -= 100;
+			}
+			if ( pStage->bundle[0].tcGen != TCGEN_TEXTURE ) {
+				rank -= 5;
+			}
+			if ( pStage->bundle[0].numTexMods ) {
+				rank -= 5;
+			}
+			if ( pStage->rgbGen != CGEN_IDENTITY && pStage->rgbGen != CGEN_IDENTITY_LIGHTING ) {
+				rank -= 3;
+			}
+
+			if ( rank > bestImageRank  ) {
+				bestImageRank = rank;
+				bestStage = pStage;
+			}
+		}
+
+		stages[0].bundle[0] = bestStage->bundle[0];
+		stages[0].stateBits &= ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+		stages[0].stateBits |= GLS_DEPTHMASK_TRUE;
+		if ( shader.lightmapIndex == LIGHTMAP_NONE ) {
+			stages[0].rgbGen = CGEN_LIGHTING_DIFFUSE;
+		} else {
+			stages[0].rgbGen = CGEN_EXACT_VERTEX;
+		}
+		stages[0].alphaGen = AGEN_SKIP;		
+	} else {
+		// don't use a lightmap (tesla coils)
+		if ( stages[0].bundle[0].isLightmap ) {
+			stages[0] = stages[1];
+		}
+
+		// if we were in a cross-fade cgen, hack it to normal
+		if ( stages[0].rgbGen == CGEN_ONE_MINUS_ENTITY || stages[1].rgbGen == CGEN_ONE_MINUS_ENTITY ) {
+			stages[0].rgbGen = CGEN_IDENTITY_LIGHTING;
+		}
+		if ( ( stages[0].rgbGen == CGEN_WAVEFORM && stages[0].rgbWave.func == GF_SAWTOOTH )
+			&& ( stages[1].rgbGen == CGEN_WAVEFORM && stages[1].rgbWave.func == GF_INVERSE_SAWTOOTH ) ) {
+			stages[0].rgbGen = CGEN_IDENTITY_LIGHTING;
+		}
+		if ( ( stages[0].rgbGen == CGEN_WAVEFORM && stages[0].rgbWave.func == GF_INVERSE_SAWTOOTH )
+			&& ( stages[1].rgbGen == CGEN_WAVEFORM && stages[1].rgbWave.func == GF_SAWTOOTH ) ) {
+			stages[0].rgbGen = CGEN_IDENTITY_LIGHTING;
+		}
+	}
+
+	for ( stage = 1; stage < MAX_SHADER_STAGES; stage++ ) {
+		shaderStage_t *pStage = &stages[stage];
+
+		if ( !pStage->active ) {
+			break;
+		}
+
+		Com_Memset( pStage, 0, sizeof( *pStage ) );
+	}
+}
+
+/*
+=========================
+FinishShader
+
+Returns a freshly allocated shader with all the needed info
+from the current global working shader
+=========================
+*/
+static shader_t *FinishShader( void ) {
+	int stage;
+	qboolean		hasLightmapStage;
+	qboolean		vertexLightmap;
+
+	hasLightmapStage = qfalse;
+	vertexLightmap = qfalse;
+
+	//
+	// set sky stuff appropriate
+	//
+	if ( shader.isSky ) {
+		shader.sort = SS_ENVIRONMENT;
+	}
+
+	//
+	// set polygon offset
+	//
+	if ( shader.polygonOffset && !shader.sort ) {
+		shader.sort = SS_DECAL;
+	}
+
+	//
+	// set appropriate stage information
+	//
+	for ( stage = 0; stage < MAX_SHADER_STAGES; ) {
+		shaderStage_t *pStage = &stages[stage];
+
+		if ( !pStage->active ) {
+			break;
+		}
+
+    // check for a missing texture
+		if ( !pStage->bundle[0].image[0] ) {
+			ri.Printf( PRINT_WARNING, "Shader %s has a stage with no image\n", shader.name );
+			pStage->active = qfalse;
+			stage++;
+			continue;
+		}
+
+		//
+		// ditch this stage if it's detail and detail textures are disabled
+		//
+		if ( pStage->isDetail && !r_detailTextures->integer )
+		{
+			int index;
+			
+			for(index = stage + 1; index < MAX_SHADER_STAGES; index++)
+			{
+				if(!stages[index].active)
+					break;
+			}
+			
+			if(index < MAX_SHADER_STAGES)
+				memmove(pStage, pStage + 1, sizeof(*pStage) * (index - stage));
+			else
+			{
+				if(stage + 1 < MAX_SHADER_STAGES)
+					memmove(pStage, pStage + 1, sizeof(*pStage) * (index - stage - 1));
+				
+				Com_Memset(&stages[index - 1], 0, sizeof(*stages));
+			}
+			
+			continue;
+		}
+
+		//
+		// default texture coordinate generation
+		//
+		if ( pStage->bundle[0].isLightmap ) {
+			if ( pStage->bundle[0].tcGen == TCGEN_BAD ) {
+				pStage->bundle[0].tcGen = TCGEN_LIGHTMAP;
+			}
+			hasLightmapStage = qtrue;
+		} else {
+			if ( pStage->bundle[0].tcGen == TCGEN_BAD ) {
+				pStage->bundle[0].tcGen = TCGEN_TEXTURE;
+			}
+		}
+
+
+    // not a true lightmap but we want to leave existing 
+    // behaviour in place and not print out a warning
+    //if (pStage->rgbGen == CGEN_VERTEX) {
+    //  vertexLightmap = qtrue;
+    //}
+
+
+
+		//
+		// determine sort order and fog color adjustment
+		//
+		if ( ( pStage->stateBits & ( GLS_SRCBLEND_BITS | GLS_DSTBLEND_BITS ) ) &&
+			 ( stages[0].stateBits & ( GLS_SRCBLEND_BITS | GLS_DSTBLEND_BITS ) ) ) {
+			int blendSrcBits = pStage->stateBits & GLS_SRCBLEND_BITS;
+			int blendDstBits = pStage->stateBits & GLS_DSTBLEND_BITS;
+
+			// fog color adjustment only works for blend modes that have a contribution
+			// that aproaches 0 as the modulate values aproach 0 --
+			// GL_ONE, GL_ONE
+			// GL_ZERO, GL_ONE_MINUS_SRC_COLOR
+			// GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA
+
+			// modulate, additive
+			if ( ( ( blendSrcBits == GLS_SRCBLEND_ONE ) && ( blendDstBits == GLS_DSTBLEND_ONE ) ) ||
+				( ( blendSrcBits == GLS_SRCBLEND_ZERO ) && ( blendDstBits == GLS_DSTBLEND_ONE_MINUS_SRC_COLOR ) ) ) {
+				pStage->adjustColorsForFog = ACFF_MODULATE_RGB;
+			}
+			// strict blend
+			else if ( ( blendSrcBits == GLS_SRCBLEND_SRC_ALPHA ) && ( blendDstBits == GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA ) )
+			{
+				pStage->adjustColorsForFog = ACFF_MODULATE_ALPHA;
+			}
+			// premultiplied alpha
+			else if ( ( blendSrcBits == GLS_SRCBLEND_ONE ) && ( blendDstBits == GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA ) )
+			{
+				pStage->adjustColorsForFog = ACFF_MODULATE_RGBA;
+			} else {
+				// we can't adjust this one correctly, so it won't be exactly correct in fog
+			}
+
+			// don't screw with sort order if this is a portal or environment
+			if ( !shader.sort ) {
+				// see through item, like a grill or grate
+				if ( pStage->stateBits & GLS_DEPTHMASK_TRUE ) {
+					shader.sort = SS_SEE_THROUGH;
+				} else {
+					shader.sort = SS_BLEND0;
+				}
+			}
+		}
+		
+		stage++;
+	}
+
+	// there are times when you will need to manually apply a sort to
+	// opaque alpha tested shaders that have later blend passes
+	if ( !shader.sort ) {
+		shader.sort = SS_OPAQUE;
+	}
+
+	//
+	// if we are in r_vertexLight mode, never use a lightmap texture
+	//
+	if ( stage > 1 && ( (r_vertexLight->integer && !r_uiFullScreen->integer) || glConfig.hardwareType == GLHW_PERMEDIA2 ) ) {
+		VertexLightingCollapse();
+		stage = 1;
+		hasLightmapStage = qfalse;
+	}
+
+	//
+	// look for multitexture potential
+	//
+	if ( stage > 1 && CollapseMultitexture() ) {
+		stage--;
+	}
+
+	if ( shader.lightmapIndex >= 0 && !hasLightmapStage ) {
+		if (vertexLightmap) {
+			ri.Printf( PRINT_DEVELOPER, "WARNING: shader '%s' has VERTEX forced lightmap!\n", shader.name );
+		} else {
+			ri.Printf( PRINT_DEVELOPER, "WARNING: shader '%s' has lightmap but no lightmap stage!\n", shader.name );
+  			shader.lightmapIndex = LIGHTMAP_NONE;
+		}
+	}
+
+
+	//
+	// compute number of passes
+	//
+	shader.numUnfoggedPasses = stage;
+
+	// fogonly shaders don't have any normal passes
+	if (stage == 0 && !shader.isSky)
+		shader.sort = SS_FOG;
+
+	// determine which stage iterator function is appropriate
+	ComputeStageIteratorFunc();
+
+	return GeneratePermanentShader();
+}
+
+//========================================================================================
+
+/*
+====================
+FindShaderInShaderText
+
+Scans the combined text description of all the shader files for
+the given shader name.
+
+return NULL if not found
+
+If found, it will return a valid shader
+=====================
+*/
+static char *FindShaderInShaderText( const char *shadername ) {
+
+	char *token, *p;
+
+	int i, hash;
+
+	hash = generateHashValue(shadername, MAX_SHADERTEXT_HASH);
+
+	if(shaderTextHashTable[hash])
+	{
+		for (i = 0; shaderTextHashTable[hash][i]; i++)
+		{
+			p = shaderTextHashTable[hash][i];
+			token = COM_ParseExt(&p, qtrue);
+		
+			if(!Q_stricmp(token, shadername))
+				return p;
+		}
+	}
+
+	p = s_shaderText;
+
+	if ( !p ) {
+		return NULL;
+	}
+
+	// look for label
+	while ( 1 ) {
+		token = COM_ParseExt( &p, qtrue );
+		if ( token[0] == 0 ) {
+			break;
+		}
+
+		if ( !Q_stricmp( token, shadername ) ) {
+			return p;
+		}
+		else {
+			// skip the definition
+			SkipBracedSection( &p );
+		}
+	}
+
+	return NULL;
+}
+
+
+/*
+==================
+R_FindShaderByName
+
+Will always return a valid shader, but it might be the
+default shader if the real one can't be found.
+==================
+*/
+shader_t *R_FindShaderByName( const char *name ) {
+	char		strippedName[MAX_QPATH];
+	int			hash;
+	shader_t	*sh;
+
+	if ( (name==NULL) || (name[0] == 0) ) {
+		return tr.defaultShader;
+	}
+
+	COM_StripExtension(name, strippedName, sizeof(strippedName));
+
+	hash = generateHashValue(strippedName, FILE_HASH_SIZE);
+
+	//
+	// see if the shader is already loaded
+	//
+	for (sh=hashTable[hash]; sh; sh=sh->next) {
+		// NOTE: if there was no shader or image available with the name strippedName
+		// then a default shader is created with lightmapIndex == LIGHTMAP_NONE, so we
+		// have to check all default shaders otherwise for every call to R_FindShader
+		// with that same strippedName a new default shader is created.
+		if (Q_stricmp(sh->name, strippedName) == 0) {
+			// match found
+			return sh;
+		}
+	}
+
+	return tr.defaultShader;
+}
+
+
+/*
+===============
+R_FindShader
+
+Will always return a valid shader, but it might be the
+default shader if the real one can't be found.
+
+In the interest of not requiring an explicit shader text entry to
+be defined for every single image used in the game, three default
+shader behaviors can be auto-created for any image:
+
+If lightmapIndex == LIGHTMAP_NONE, then the image will have
+dynamic diffuse lighting applied to it, as apropriate for most
+entity skin surfaces.
+
+If lightmapIndex == LIGHTMAP_2D, then the image will be used
+for 2D rendering unless an explicit shader is found
+
+If lightmapIndex == LIGHTMAP_BY_VERTEX, then the image will use
+the vertex rgba modulate values, as apropriate for misc_model
+pre-lit surfaces.
+
+Other lightmapIndex values will have a lightmap stage created
+and src*dest blending applied with the texture, as apropriate for
+most world construction surfaces.
+
+===============
+*/
+shader_t *R_FindShader( const char *name, int lightmapIndex, qboolean mipRawImage ) {
+	char		strippedName[MAX_QPATH];
+	int			i, hash;
+	char		*shaderText;
+	image_t		*image;
+	shader_t	*sh;
+
+	if ( name[0] == 0 ) {
+		return tr.defaultShader;
+	}
+
+	// use (fullbright) vertex lighting if the bsp file doesn't have
+	// lightmaps
+	if ( lightmapIndex >= 0 && lightmapIndex >= tr.numLightmaps ) {
+		lightmapIndex = LIGHTMAP_BY_VERTEX;
+	} else if ( lightmapIndex < LIGHTMAP_2D ) {
+		// negative lightmap indexes cause stray pointers (think tr.lightmaps[lightmapIndex])
+		ri.Printf( PRINT_WARNING, "WARNING: shader '%s' has invalid lightmap index of %d\n", name, lightmapIndex  );
+		lightmapIndex = LIGHTMAP_BY_VERTEX;
+	}
+
+	COM_StripExtension(name, strippedName, sizeof(strippedName));
+
+	hash = generateHashValue(strippedName, FILE_HASH_SIZE);
+
+	//
+	// see if the shader is already loaded
+	//
+	for (sh = hashTable[hash]; sh; sh = sh->next) {
+		// NOTE: if there was no shader or image available with the name strippedName
+		// then a default shader is created with lightmapIndex == LIGHTMAP_NONE, so we
+		// have to check all default shaders otherwise for every call to R_FindShader
+		// with that same strippedName a new default shader is created.
+		if ( (sh->lightmapIndex == lightmapIndex || sh->defaultShader) &&
+		     !Q_stricmp(sh->name, strippedName)) {
+			// match found
+			return sh;
+		}
+	}
+
+	// make sure the render thread is stopped, because we are probably
+	// going to have to upload an image
+	if (r_smp->integer) {
+		R_SyncRenderThread();
+	}
+
+	// clear the global shader
+	Com_Memset( &shader, 0, sizeof( shader ) );
+	Com_Memset( &stages, 0, sizeof( stages ) );
+	Q_strncpyz(shader.name, strippedName, sizeof(shader.name));
+	shader.lightmapIndex = lightmapIndex;
+	for ( i = 0 ; i < MAX_SHADER_STAGES ; i++ ) {
+		stages[i].bundle[0].texMods = texMods[i];
+	}
+
+	// FIXME: set these "need" values apropriately
+	shader.needsNormal = qtrue;
+	shader.needsST1 = qtrue;
+	shader.needsST2 = qtrue;
+	shader.needsColor = qtrue;
+
+	//
+	// attempt to define shader from an explicit parameter file
+	//
+	shaderText = FindShaderInShaderText( strippedName );
+	if ( shaderText ) {
+		// enable this when building a pak file to get a global list
+		// of all explicit shaders
+		if ( r_printShaders->integer ) {
+			ri.Printf( PRINT_ALL, "*SHADER* %s\n", name );
+		}
+
+		if ( !ParseShader( &shaderText ) ) {
+			// had errors, so use default shader
+			shader.defaultShader = qtrue;
+		}
+		sh = FinishShader();
+		return sh;
+	}
+
+
+	//
+	// if not defined in the in-memory shader descriptions,
+	// look for a single supported image file
+	//
+	image = R_FindImageFile( name, mipRawImage, mipRawImage, mipRawImage ? GL_REPEAT : GL_CLAMP_TO_EDGE );
+	if ( !image ) {
+		ri.Printf( PRINT_DEVELOPER, "Couldn't find image file for shader %s\n", name );
+		shader.defaultShader = qtrue;
+		return FinishShader();
+	}
+
+	//
+	// create the default shading commands
+	//
+	if ( shader.lightmapIndex == LIGHTMAP_NONE ) {
+		// dynamic colors at vertexes
+		stages[0].bundle[0].image[0] = image;
+		stages[0].active = qtrue;
+		stages[0].rgbGen = CGEN_LIGHTING_DIFFUSE;
+		stages[0].stateBits = GLS_DEFAULT;
+	} else if ( shader.lightmapIndex == LIGHTMAP_BY_VERTEX ) {
+		// explicit colors at vertexes
+		stages[0].bundle[0].image[0] = image;
+		stages[0].active = qtrue;
+		stages[0].rgbGen = CGEN_EXACT_VERTEX;
+		stages[0].alphaGen = AGEN_SKIP;
+		stages[0].stateBits = GLS_DEFAULT;
+	} else if ( shader.lightmapIndex == LIGHTMAP_2D ) {
+		// GUI elements
+		stages[0].bundle[0].image[0] = image;
+		stages[0].active = qtrue;
+		stages[0].rgbGen = CGEN_VERTEX;
+		stages[0].alphaGen = AGEN_VERTEX;
+		stages[0].stateBits = GLS_DEPTHTEST_DISABLE |
+			  GLS_SRCBLEND_SRC_ALPHA |
+			  GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA;
+	} else if ( shader.lightmapIndex == LIGHTMAP_WHITEIMAGE ) {
+		// fullbright level
+		stages[0].bundle[0].image[0] = tr.whiteImage;
+		stages[0].active = qtrue;
+		stages[0].rgbGen = CGEN_IDENTITY_LIGHTING;
+		stages[0].stateBits = GLS_DEFAULT;
+
+		stages[1].bundle[0].image[0] = image;
+		stages[1].active = qtrue;
+		stages[1].rgbGen = CGEN_IDENTITY;
+		stages[1].stateBits |= GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
+	} else {
+		// two pass lightmap
+		stages[0].bundle[0].image[0] = tr.lightmaps[shader.lightmapIndex];
+		stages[0].bundle[0].isLightmap = qtrue;
+		stages[0].active = qtrue;
+		stages[0].rgbGen = CGEN_IDENTITY;	// lightmaps are scaled on creation
+													// for identitylight
+		stages[0].stateBits = GLS_DEFAULT;
+
+		stages[1].bundle[0].image[0] = image;
+		stages[1].active = qtrue;
+		stages[1].rgbGen = CGEN_IDENTITY;
+		stages[1].stateBits |= GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
+	}
+
+	return FinishShader();
+}
+
+
+qhandle_t RE_RegisterShaderFromImage(const char *name, int lightmapIndex, image_t *image, qboolean mipRawImage) {
+	int			i, hash;
+	shader_t	*sh;
+
+	hash = generateHashValue(name, FILE_HASH_SIZE);
+
+	// probably not necessary since this function
+	// only gets called from tr_font.c with lightmapIndex == LIGHTMAP_2D
+	// but better safe than sorry.
+	if ( lightmapIndex >= tr.numLightmaps ) {
+		lightmapIndex = LIGHTMAP_WHITEIMAGE;
+	}
+
+	//
+	// see if the shader is already loaded
+	//
+	for (sh=hashTable[hash]; sh; sh=sh->next) {
+		// NOTE: if there was no shader or image available with the name strippedName
+		// then a default shader is created with lightmapIndex == LIGHTMAP_NONE, so we
+		// have to check all default shaders otherwise for every call to R_FindShader
+		// with that same strippedName a new default shader is created.
+		if ( (sh->lightmapIndex == lightmapIndex || sh->defaultShader) &&
+			// index by name
+			!Q_stricmp(sh->name, name)) {
+			// match found
+			return sh->index;
+		}
+	}
+
+	// make sure the render thread is stopped, because we are probably
+	// going to have to upload an image
+	if (r_smp->integer) {
+		R_SyncRenderThread();
+	}
+
+	// clear the global shader
+	Com_Memset( &shader, 0, sizeof( shader ) );
+	Com_Memset( &stages, 0, sizeof( stages ) );
+	Q_strncpyz(shader.name, name, sizeof(shader.name));
+	shader.lightmapIndex = lightmapIndex;
+	for ( i = 0 ; i < MAX_SHADER_STAGES ; i++ ) {
+		stages[i].bundle[0].texMods = texMods[i];
+	}
+
+	// FIXME: set these "need" values apropriately
+	shader.needsNormal = qtrue;
+	shader.needsST1 = qtrue;
+	shader.needsST2 = qtrue;
+	shader.needsColor = qtrue;
+
+	//
+	// create the default shading commands
+	//
+	if ( shader.lightmapIndex == LIGHTMAP_NONE ) {
+		// dynamic colors at vertexes
+		stages[0].bundle[0].image[0] = image;
+		stages[0].active = qtrue;
+		stages[0].rgbGen = CGEN_LIGHTING_DIFFUSE;
+		stages[0].stateBits = GLS_DEFAULT;
+	} else if ( shader.lightmapIndex == LIGHTMAP_BY_VERTEX ) {
+		// explicit colors at vertexes
+		stages[0].bundle[0].image[0] = image;
+		stages[0].active = qtrue;
+		stages[0].rgbGen = CGEN_EXACT_VERTEX;
+		stages[0].alphaGen = AGEN_SKIP;
+		stages[0].stateBits = GLS_DEFAULT;
+	} else if ( shader.lightmapIndex == LIGHTMAP_2D ) {
+		// GUI elements
+		stages[0].bundle[0].image[0] = image;
+		stages[0].active = qtrue;
+		stages[0].rgbGen = CGEN_VERTEX;
+		stages[0].alphaGen = AGEN_VERTEX;
+		stages[0].stateBits = GLS_DEPTHTEST_DISABLE |
+			  GLS_SRCBLEND_SRC_ALPHA |
+			  GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA;
+	} else if ( shader.lightmapIndex == LIGHTMAP_WHITEIMAGE ) {
+		// fullbright level
+		stages[0].bundle[0].image[0] = tr.whiteImage;
+		stages[0].active = qtrue;
+		stages[0].rgbGen = CGEN_IDENTITY_LIGHTING;
+		stages[0].stateBits = GLS_DEFAULT;
+
+		stages[1].bundle[0].image[0] = image;
+		stages[1].active = qtrue;
+		stages[1].rgbGen = CGEN_IDENTITY;
+		stages[1].stateBits |= GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
+	} else {
+		// two pass lightmap
+		stages[0].bundle[0].image[0] = tr.lightmaps[shader.lightmapIndex];
+		stages[0].bundle[0].isLightmap = qtrue;
+		stages[0].active = qtrue;
+		stages[0].rgbGen = CGEN_IDENTITY;	// lightmaps are scaled on creation
+													// for identitylight
+		stages[0].stateBits = GLS_DEFAULT;
+
+		stages[1].bundle[0].image[0] = image;
+		stages[1].active = qtrue;
+		stages[1].rgbGen = CGEN_IDENTITY;
+		stages[1].stateBits |= GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
+	}
+
+	sh = FinishShader();
+  return sh->index; 
+}
+
+
+/* 
+====================
+RE_RegisterShader
+
+This is the exported shader entry point for the rest of the system
+It will always return an index that will be valid.
+
+This should really only be used for explicit shaders, because there is no
+way to ask for different implicit lighting modes (vertex, lightmap, etc)
+====================
+*/
+qhandle_t RE_RegisterShaderLightMap( const char *name, int lightmapIndex ) {
+	shader_t	*sh;
+
+	if ( strlen( name ) >= MAX_QPATH ) {
+		Com_Printf( "Shader name exceeds MAX_QPATH\n" );
+		return 0;
+	}
+
+	sh = R_FindShader( name, lightmapIndex, qtrue );
+
+	// we want to return 0 if the shader failed to
+	// load for some reason, but R_FindShader should
+	// still keep a name allocated for it, so if
+	// something calls RE_RegisterShader again with
+	// the same name, we don't try looking for it again
+	if ( sh->defaultShader ) {
+		return 0;
+	}
+
+	return sh->index;
+}
+
+
+/* 
+====================
+RE_RegisterShader
+
+This is the exported shader entry point for the rest of the system
+It will always return an index that will be valid.
+
+This should really only be used for explicit shaders, because there is no
+way to ask for different implicit lighting modes (vertex, lightmap, etc)
+====================
+*/
+qhandle_t RE_RegisterShader( const char *name ) {
+	shader_t	*sh;
+
+	if ( strlen( name ) >= MAX_QPATH ) {
+		Com_Printf( "Shader name exceeds MAX_QPATH\n" );
+		return 0;
+	}
+
+	sh = R_FindShader( name, LIGHTMAP_2D, qtrue );
+
+	// we want to return 0 if the shader failed to
+	// load for some reason, but R_FindShader should
+	// still keep a name allocated for it, so if
+	// something calls RE_RegisterShader again with
+	// the same name, we don't try looking for it again
+	if ( sh->defaultShader ) {
+		return 0;
+	}
+
+	return sh->index;
+}
+
+
+/*
+====================
+RE_RegisterShaderNoMip
+
+For menu graphics that should never be picmiped
+====================
+*/
+qhandle_t RE_RegisterShaderNoMip( const char *name ) {
+	shader_t	*sh;
+
+	if ( strlen( name ) >= MAX_QPATH ) {
+		Com_Printf( "Shader name exceeds MAX_QPATH\n" );
+		return 0;
+	}
+
+	sh = R_FindShader( name, LIGHTMAP_2D, qfalse );
+
+	// we want to return 0 if the shader failed to
+	// load for some reason, but R_FindShader should
+	// still keep a name allocated for it, so if
+	// something calls RE_RegisterShader again with
+	// the same name, we don't try looking for it again
+	if ( sh->defaultShader ) {
+		return 0;
+	}
+
+	return sh->index;
+}
+
+/*
+====================
+R_GetShaderByHandle
+
+When a handle is passed in by another module, this range checks
+it and returns a valid (possibly default) shader_t to be used internally.
+====================
+*/
+shader_t *R_GetShaderByHandle( qhandle_t hShader ) {
+	if ( hShader < 0 ) {
+	  ri.Printf( PRINT_WARNING, "R_GetShaderByHandle: out of range hShader '%d'\n", hShader );
+		return tr.defaultShader;
+	}
+	if ( hShader >= tr.numShaders ) {
+		ri.Printf( PRINT_WARNING, "R_GetShaderByHandle: out of range hShader '%d'\n", hShader );
+		return tr.defaultShader;
+	}
+	return tr.shaders[hShader];
+}
+
+/*
+===============
+R_ShaderList_f
+
+Dump information on all valid shaders to the console
+A second parameter will cause it to print in sorted order
+===============
+*/
+void	R_ShaderList_f (void) {
+	int			i;
+	int			count;
+	shader_t	*shader;
+
+	ri.Printf (PRINT_ALL, "-----------------------\n");
+
+	count = 0;
+	for ( i = 0 ; i < tr.numShaders ; i++ ) {
+		if ( ri.Cmd_Argc() > 1 ) {
+			shader = tr.sortedShaders[i];
+		} else {
+			shader = tr.shaders[i];
+		}
+
+		ri.Printf( PRINT_ALL, "%i ", shader->numUnfoggedPasses );
+
+		if (shader->lightmapIndex >= 0 ) {
+			ri.Printf (PRINT_ALL, "L ");
+		} else {
+			ri.Printf (PRINT_ALL, "  ");
+		}
+		if ( shader->multitextureEnv == GL_ADD ) {
+			ri.Printf( PRINT_ALL, "MT(a) " );
+		} else if ( shader->multitextureEnv == GL_MODULATE ) {
+			ri.Printf( PRINT_ALL, "MT(m) " );
+		} else if ( shader->multitextureEnv == GL_DECAL ) {
+			ri.Printf( PRINT_ALL, "MT(d) " );
+		} else {
+			ri.Printf( PRINT_ALL, "      " );
+		}
+		if ( shader->explicitlyDefined ) {
+			ri.Printf( PRINT_ALL, "E " );
+		} else {
+			ri.Printf( PRINT_ALL, "  " );
+		}
+
+		if ( shader->optimalStageIteratorFunc == RB_StageIteratorGeneric ) {
+			ri.Printf( PRINT_ALL, "gen " );
+		} else if ( shader->optimalStageIteratorFunc == RB_StageIteratorSky ) {
+			ri.Printf( PRINT_ALL, "sky " );
+		} else if ( shader->optimalStageIteratorFunc == RB_StageIteratorLightmappedMultitexture ) {
+			ri.Printf( PRINT_ALL, "lmmt" );
+		} else if ( shader->optimalStageIteratorFunc == RB_StageIteratorVertexLitTexture ) {
+			ri.Printf( PRINT_ALL, "vlt " );
+		} else {
+			ri.Printf( PRINT_ALL, "    " );
+		}
+
+		if ( shader->defaultShader ) {
+			ri.Printf (PRINT_ALL,  ": %s (DEFAULTED)\n", shader->name);
+		} else {
+			ri.Printf (PRINT_ALL,  ": %s\n", shader->name);
+		}
+		count++;
+	}
+	ri.Printf (PRINT_ALL, "%i total shaders\n", count);
+	ri.Printf (PRINT_ALL, "------------------\n");
+}
+
+/*
+====================
+ScanAndLoadShaderFiles
+
+Finds and loads all .shader files, combining them into
+a single large text block that can be scanned for shader names
+=====================
+*/
+#define	MAX_SHADER_FILES	4096
+static void ScanAndLoadShaderFiles( void )
+{
+	char **shaderFiles;
+	char *buffers[MAX_SHADER_FILES];
+	char *p;
+	int numShaderFiles;
+	int i;
+	char *oldp, *token, *hashMem, *textEnd;
+	int shaderTextHashTableSizes[MAX_SHADERTEXT_HASH], hash, size;
+
+	long sum = 0, summand;
+	// scan for shader files
+	shaderFiles = ri.FS_ListFiles( "scripts", ".shader", &numShaderFiles );
+
+	if ( !shaderFiles || !numShaderFiles )
+	{
+		ri.Printf( PRINT_WARNING, "WARNING: no shader files found\n" );
+		return;
+	}
+
+	if ( numShaderFiles > MAX_SHADER_FILES ) {
+		numShaderFiles = MAX_SHADER_FILES;
+	}
+
+	// load and parse shader files
+	for ( i = 0; i < numShaderFiles; i++ )
+	{
+		char filename[MAX_QPATH];
+
+		Com_sprintf( filename, sizeof( filename ), "scripts/%s", shaderFiles[i] );
+		ri.Printf( PRINT_DEVELOPER, "...loading '%s'\n", filename );
+		summand = ri.FS_ReadFile( filename, (void **)&buffers[i] );
+		
+		if ( !buffers[i] )
+			ri.Error( ERR_DROP, "Couldn't load %s", filename );
+		
+		// Do a simple check on the shader structure in that file to make sure one bad shader file cannot fuck up all other shaders.
+		p = buffers[i];
+		while(1)
+		{
+			token = COM_ParseExt(&p, qtrue);
+			
+			if(!*token)
+				break;
+			
+			oldp = p;
+			
+			token = COM_ParseExt(&p, qtrue);
+			if(token[0] != '{' && token[1] != '\0')
+			{
+				ri.Printf(PRINT_WARNING, "WARNING: Bad shader file %s has incorrect syntax.\n", filename);
+				ri.FS_FreeFile(buffers[i]);
+				buffers[i] = NULL;
+				break;
+			}
+
+			SkipBracedSection(&oldp);
+			p = oldp;
+		}
+			
+		
+		if (buffers[i])
+			sum += summand;		
+	}
+
+	// build single large buffer
+	s_shaderText = ri.Hunk_Alloc( sum + numShaderFiles*2, h_low );
+	s_shaderText[ 0 ] = '\0';
+	textEnd = s_shaderText;
+ 
+	// free in reverse order, so the temp files are all dumped
+	for ( i = numShaderFiles - 1; i >= 0 ; i-- )
+	{
+		if ( !buffers[i] )
+			continue;
+
+		strcat( textEnd, buffers[i] );
+		strcat( textEnd, "\n" );
+		textEnd += strlen( textEnd );
+		ri.FS_FreeFile( buffers[i] );
+	}
+
+	COM_Compress( s_shaderText );
+
+	// free up memory
+	ri.FS_FreeFileList( shaderFiles );
+
+	Com_Memset(shaderTextHashTableSizes, 0, sizeof(shaderTextHashTableSizes));
+	size = 0;
+
+	p = s_shaderText;
+	// look for shader names
+	while ( 1 ) {
+		token = COM_ParseExt( &p, qtrue );
+		if ( token[0] == 0 ) {
+			break;
+		}
+
+		hash = generateHashValue(token, MAX_SHADERTEXT_HASH);
+		shaderTextHashTableSizes[hash]++;
+		size++;
+		SkipBracedSection(&p);
+	}
+
+	size += MAX_SHADERTEXT_HASH;
+
+	hashMem = ri.Hunk_Alloc( size * sizeof(char *), h_low );
+
+	for (i = 0; i < MAX_SHADERTEXT_HASH; i++) {
+		shaderTextHashTable[i] = (char **) hashMem;
+		hashMem = ((char *) hashMem) + ((shaderTextHashTableSizes[i] + 1) * sizeof(char *));
+	}
+
+	Com_Memset(shaderTextHashTableSizes, 0, sizeof(shaderTextHashTableSizes));
+
+	p = s_shaderText;
+	// look for shader names
+	while ( 1 ) {
+		oldp = p;
+		token = COM_ParseExt( &p, qtrue );
+		if ( token[0] == 0 ) {
+			break;
+		}
+
+		hash = generateHashValue(token, MAX_SHADERTEXT_HASH);
+		shaderTextHashTable[hash][shaderTextHashTableSizes[hash]++] = oldp;
+
+		SkipBracedSection(&p);
+	}
+
+	return;
+
+}
+
+
+/*
+====================
+CreateInternalShaders
+====================
+*/
+static void CreateInternalShaders( void ) {
+	tr.numShaders = 0;
+
+	// init the default shader
+	Com_Memset( &shader, 0, sizeof( shader ) );
+	Com_Memset( &stages, 0, sizeof( stages ) );
+
+	Q_strncpyz( shader.name, "<default>", sizeof( shader.name ) );
+
+	shader.lightmapIndex = LIGHTMAP_NONE;
+	stages[0].bundle[0].image[0] = tr.defaultImage;
+	stages[0].active = qtrue;
+	stages[0].stateBits = GLS_DEFAULT;
+	tr.defaultShader = FinishShader();
+
+	// shadow shader is just a marker
+	Q_strncpyz( shader.name, "<stencil shadow>", sizeof( shader.name ) );
+	shader.sort = SS_STENCIL_SHADOW;
+	tr.shadowShader = FinishShader();
+}
+
+static void CreateExternalShaders( void ) {
+	tr.projectionShadowShader = R_FindShader( "projectionShadow", LIGHTMAP_NONE, qtrue );
+	tr.flareShader = R_FindShader( "flareShader", LIGHTMAP_NONE, qtrue );
+
+	// Hack to make fogging work correctly on flares. Fog colors are calculated
+	// in tr_flare.c already.
+	if(!tr.flareShader->defaultShader)
+	{
+		int index;
+		
+		for(index = 0; index < tr.flareShader->numUnfoggedPasses; index++)
+		{
+			tr.flareShader->stages[index]->adjustColorsForFog = ACFF_NONE;
+			tr.flareShader->stages[index]->stateBits |= GLS_DEPTHTEST_DISABLE;
+		}
+	}
+
+	tr.sunShader = R_FindShader( "sun", LIGHTMAP_NONE, qtrue );
+}
+
+/*
+==================
+R_InitShaders
+==================
+*/
+void R_InitShaders( void ) {
+	ri.Printf( PRINT_ALL, "Initializing Shaders\n" );
+
+	Com_Memset(hashTable, 0, sizeof(hashTable));
+
+	CreateInternalShaders();
+
+	ScanAndLoadShaderFiles();
+
+	CreateExternalShaders();
+}
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_shader.c.rej tremulous-ggp1-src/src/renderer/tr_shader.c.rej
--- tremulous-ggp1-src.p/src/renderer/tr_shader.c.rej	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_shader.c.rej	2012-07-19 04:25:52.031556446 +0200
@@ -0,0 +1,447 @@
+--- src/renderer/tr_shader.c	(Revision 2062)
++++ src/renderer/tr_shader.c	(Arbeitskopie)
+@@ -1078,7 +1121,7 @@
+ 	}
+ 
+ 	// decide which agens we can skip
+-	if ( stage->alphaGen == CGEN_IDENTITY ) {
++	if ( stage->alphaGen == AGEN_IDENTITY ) {
+ 		if ( stage->rgbGen == CGEN_IDENTITY
+ 			|| stage->rgbGen == CGEN_LIGHTING_DIFFUSE ) {
+ 			stage->alphaGen = AGEN_SKIP;
+@@ -1930,225 +2111,252 @@
+ ================
+ CollapseMultitexture
+ 
+-Attempt to combine two stages into a single multitexture stage
++Attempt to combine several stages into a single multitexture stage
+ FIXME: I think modulated add + modulated add collapses incorrectly
+ =================
+ */
+-static qboolean CollapseMultitexture( void ) {
++static int CollapseMultitexture( void ) {
++	int stage, bundle;
+ 	int abits, bbits;
+ 	int i;
+ 	textureBundle_t tmpBundle;
+ 
+-	if ( !qglActiveTextureARB ) {
+-		return qfalse;
+-	}
++	stage = 0;
++	bundle = 0;
+ 
+-	// make sure both stages are active
+-	if ( !stages[0].active || !stages[1].active ) {
+-		return qfalse;
+-	}
++	while( stage < MAX_SHADER_STAGES && stages[stage].active ) {
++		if ( bundle + 1 >= glConfig.numTextureUnits ) {
++			// can't add next stage, no more texture units
++			stage++;
++			bundle = 0;
++			continue;
++		}
++		
++		// make sure both stages are active
++		if ( !stages[stage + 1].active ) {
++			// can't add next stage, it doesn't exist
++			stage++;
++			bundle = 0;
++			continue;
++		}
+ 
+-	// on voodoo2, don't combine different tmus
+-	if ( glConfig.driverType == GLDRV_VOODOO ) {
+-		if ( stages[0].bundle[0].image[0]->TMU ==
+-			 stages[1].bundle[0].image[0]->TMU ) {
+-			return qfalse;
++		// on voodoo2, don't combine different tmus
++		if ( glConfig.driverType == GLDRV_VOODOO ) {
++			if ( stages[stage].bundle[0].image[0]->TMU ==
++			     stages[stage + 1].bundle[0].image[0]->TMU ) {
++				stage++;
++				bundle = 0;
++				continue;
++			}
+ 		}
+-	}
+ 
+-	abits = stages[0].stateBits;
+-	bbits = stages[1].stateBits;
++		abits = stages[stage].stateBits;
++		bbits = stages[stage + 1].stateBits;
++		/*
++		// can't combine if the second stage has an alpha test
++		if ( bbits & GLS_ATEST_BITS ) {
++			stage++;
++			bundle = 0;
++			continue;
++		}
+ 
+-	// make sure that both stages have identical state other than blend modes
+-	if ( ( abits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) !=
+-		( bbits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) ) {
+-		return qfalse;
+-	}
+-
+-	abits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+-	bbits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+-
+-	// search for a valid multitexture blend function
+-	for ( i = 0; collapse[i].blendA != -1 ; i++ ) {
+-		if ( abits == collapse[i].blendA
+-			&& bbits == collapse[i].blendB ) {
+-			break;
++		// can combine alphafunc only if depthwrite is enabled and
++		// the second stage has depthfunc equal
++		if ( abits & GLS_ATEST_BITS ) {
++			if (!((abits & GLS_DEPTHMASK_TRUE) &&
++			      (bbits & GLS_DEPTHFUNC_EQUAL)) ) {
++				stage++;
++				bundle = 0;
++				continue;
++			}
++		} else {
++			if ( (abits & GLS_DEPTHFUNC_EQUAL) !=
++			     (bbits & GLS_DEPTHFUNC_EQUAL) ) {
++				stage++;
++				bundle = 0;
++				continue;
++			}
+ 		}
+-	}
+-
+-	// nothing found
+-	if ( collapse[i].blendA == -1 ) {
+-		return qfalse;
+-	}
+-
+-	// GL_ADD is a separate extension
+-	if ( collapse[i].multitextureEnv == GL_ADD && !glConfig.textureEnvAddAvailable ) {
+-		return qfalse;
+-	}
+-
+-	// make sure waveforms have identical parameters
+-	if ( ( stages[0].rgbGen != stages[1].rgbGen ) ||
+-		( stages[0].alphaGen != stages[1].alphaGen ) )  {
+-		return qfalse;
+-	}
+-
+-	// an add collapse can only have identity colors
+-	if ( collapse[i].multitextureEnv == GL_ADD && stages[0].rgbGen != CGEN_IDENTITY ) {
+-		return qfalse;
+-	}
+-
+-	if ( stages[0].rgbGen == CGEN_WAVEFORM )
+-	{
+-		if ( memcmp( &stages[0].rgbWave,
+-					 &stages[1].rgbWave,
+-					 sizeof( stages[0].rgbWave ) ) )
++		*/
++		// make sure that both stages have identical state other than blend modes
++		if ( ( abits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) !=
++		     ( bbits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) ) {
++			stage++;
++			bundle = 0;
++			continue;
++		}
++		
++		abits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
++		bbits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
++		
++		// search for a valid multitexture blend function
++		for ( i = 0; collapse[i].blendA != -1 ; i++ ) {
++			if ( abits == collapse[i].blendA
++			     && bbits == collapse[i].blendB ) {
++				break;
++			}
++		}
++		
++		// nothing found
++		if ( collapse[i].blendA == -1 ) {
++			stage++;
++			bundle = 0;
++			continue;
++		}
++		
++		// GL_ADD is a separate extension
++		if ( collapse[i].multitextureEnv == GL_ADD && !glConfig.textureEnvAddAvailable ) {
++			stage++;
++			bundle = 0;
++			continue;
++		}
++		
++		// make sure waveforms have identical parameters
++		if ( ( stages[stage].rgbGen != stages[stage + 1].rgbGen ) ||
++		     ( stages[stage].alphaGen != stages[stage + 1].alphaGen ) )  {
++			stage++;
++			bundle = 0;
++			continue;
++		}
++		
++		// an add collapse can only have identity colors
++		if ( collapse[i].multitextureEnv == GL_ADD && stages[stage].rgbGen != CGEN_IDENTITY ) {
++			stage++;
++			bundle = 0;
++			continue;
++		}
++		
++		if ( stages[stage].rgbGen == CGEN_WAVEFORM )
+ 		{
+-			return qfalse;
++			if ( memcmp( &stages[stage].rgbWave,
++				     &stages[stage + 1].rgbWave,
++				     sizeof( stages[stage].rgbWave ) ) )
++			{
++				stage++;
++				bundle = 0;
++				continue;
++			}
+ 		}
+-	}
+-	if ( stages[0].alphaGen == CGEN_WAVEFORM )
+-	{
+-		if ( memcmp( &stages[0].alphaWave,
+-					 &stages[1].alphaWave,
+-					 sizeof( stages[0].alphaWave ) ) )
++		if ( stages[stage].alphaGen == AGEN_WAVEFORM )
+ 		{
+-			return qfalse;
++			if ( memcmp( &stages[stage].alphaWave,
++				     &stages[stage + 1].alphaWave,
++				     sizeof( stages[stage].alphaWave ) ) )
++			{
++				stage++;
++				bundle = 0;
++				continue;
++			}
+ 		}
+-	}
++		
++		
++		// make sure that lightmaps are in bundle 1 for 3dfx
++		if ( bundle == 0 && stages[stage].bundle[0].isLightmap )
++		{
++			tmpBundle = stages[stage].bundle[0];
++			stages[stage].bundle[0] = stages[stage + 1].bundle[0];
++			stages[stage].bundle[1] = tmpBundle;
++		}
++		else
++		{
++			stages[stage].bundle[bundle + 1] = stages[stage + 1].bundle[0];
++		}
++		
++		// set the new blend state bits
++		stages[stage].bundle[bundle + 1].multitextureEnv = collapse[i].multitextureEnv;
++		stages[stage].stateBits &= ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
++		stages[stage].stateBits |= collapse[i].multitextureBlend;
+ 
++		bundle++;
+ 
+-	// make sure that lightmaps are in bundle 1 for 3dfx
+-	if ( stages[0].bundle[0].isLightmap )
+-	{
+-		tmpBundle = stages[0].bundle[0];
+-		stages[0].bundle[0] = stages[1].bundle[0];
+-		stages[0].bundle[1] = tmpBundle;
++		//
++		// move down subsequent shaders
++		//
++		memmove( &stages[stage + 1], &stages[stage + 2], sizeof( stages[0] ) * ( MAX_SHADER_STAGES - stage - 2 ) );
++		Com_Memset( &stages[MAX_SHADER_STAGES-1], 0, sizeof( stages[0] ) );
+ 	}
+-	else
+-	{
+-		stages[0].bundle[1] = stages[1].bundle[0];
+-	}
+ 
+-	// set the new blend state bits
+-	shader.multitextureEnv = collapse[i].multitextureEnv;
+-	stages[0].stateBits &= ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+-	stages[0].stateBits |= collapse[i].multitextureBlend;
+-
+-	//
+-	// move down subsequent shaders
+-	//
+-	memmove( &stages[1], &stages[2], sizeof( stages[0] ) * ( MAX_SHADER_STAGES - 2 ) );
+-	Com_Memset( &stages[MAX_SHADER_STAGES-1], 0, sizeof( stages[0] ) );
+-
+-	return qtrue;
++	return stage;
+ }
+ 
+ /*
+-=============
++==============
++R_SortShaders
+ 
+-FixRenderCommandList
+-https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=493
+-Arnout: this is a nasty issue. Shaders can be registered after drawsurfaces are generated
+-but before the frame is rendered. This will, for the duration of one frame, cause drawsurfaces
+-to be rendered with bad shaders. To fix this, need to go through all render commands and fix
+-sortedIndex.
++Positions all shaders in the tr.sortedShaders[]
++array so that the shader->sort key is sorted relative
++to the other shaders. If shaders use the same GLSL
++program, sort them all to the max occluder to avoid
++expensive program switches later.
++
++Uses a stable, in-place variant of odd-even mergeSort
++which is O(n log^2 n) worst case, but should be more
++cache-friendly than pure merge or radix sort, because
++makes several linear passes over the buffer.
++
++Sets shader->sortedIndex
+ ==============
+ */
+-static void FixRenderCommandList( int newShader ) {
+-	renderCommandList_t	*cmdList = &backEndData[tr.smpFrame]->commands;
++static ID_INLINE int cmpShader( int left, int right )
++{
++	shader_t	*l, *r;
++	int		diff;
++	GLuint		resultL, resultR;
++	
++	l = tr.sortedShaders[left];
++	r = tr.sortedShaders[right];
++	
++	diff = l->sort - r->sort;
++	if( !diff ) {
++		if( l->GLSLprogram )
++			resultL = l->GLSLprogram->QuerySum;
++		else
++			resultL = l->QueryResult;
+ 
+-	if( cmdList ) {
+-		const void *curCmd = cmdList->cmds;
++		if( r->GLSLprogram )
++			resultR = r->GLSLprogram->QuerySum;
++		else
++			resultR = r->QueryResult;
+ 
+-		while ( 1 ) {
+-			switch ( *(const int *)curCmd ) {
+-			case RC_SET_COLOR:
+-				{
+-				const setColorCommand_t *sc_cmd = (const setColorCommand_t *)curCmd;
+-				curCmd = (const void *)(sc_cmd + 1);
+-				break;
+-				}
+-			case RC_STRETCH_PIC:
+-				{
+-				const stretchPicCommand_t *sp_cmd = (const stretchPicCommand_t *)curCmd;
+-				curCmd = (const void *)(sp_cmd + 1);
+-				break;
+-				}
+-			case RC_DRAW_SURFS:
+-				{
+-				int i;
+-				drawSurf_t	*drawSurf;
+-				shader_t	*shader;
+-				int			fogNum;
+-				int			entityNum;
+-				int			dlightMap;
+-				int			sortedIndex;
+-				const drawSurfsCommand_t *ds_cmd =  (const drawSurfsCommand_t *)curCmd;
+-
+-				for( i = 0, drawSurf = ds_cmd->drawSurfs; i < ds_cmd->numDrawSurfs; i++, drawSurf++ ) {
+-					R_DecomposeSort( drawSurf->sort, &entityNum, &shader, &fogNum, &dlightMap );
+-                    sortedIndex = (( drawSurf->sort >> QSORT_SHADERNUM_SHIFT ) & (MAX_SHADERS-1));
+-					if( sortedIndex >= newShader ) {
+-						sortedIndex++;
+-						drawSurf->sort = (sortedIndex << QSORT_SHADERNUM_SHIFT) | entityNum | ( fogNum << QSORT_FOGNUM_SHIFT ) | (int)dlightMap;
+-					}
+-				}
+-				curCmd = (const void *)(ds_cmd + 1);
+-				break;
+-				}
+-			case RC_DRAW_BUFFER:
+-				{
+-				const drawBufferCommand_t *db_cmd = (const drawBufferCommand_t *)curCmd;
+-				curCmd = (const void *)(db_cmd + 1);
+-				break;
+-				}
+-			case RC_SWAP_BUFFERS:
+-				{
+-				const swapBuffersCommand_t *sb_cmd = (const swapBuffersCommand_t *)curCmd;
+-				curCmd = (const void *)(sb_cmd + 1);
+-				break;
+-				}
+-			case RC_END_OF_LIST:
+-			default:
+-				return;
+-			}
+-		}
++		diff = resultR - resultL;
+ 	}
++	if( !diff ) {
++		diff = l->GLSLprogram - r->GLSLprogram;
++	}
++	if( !diff ) {
++		diff = r->QueryResult - l->QueryResult;
++	}
++	if( !diff ) {
++		diff = l->index - r->index;
++	}
++	return diff;
+ }
++void R_SortShaders( void ) {
++	int i, j, k;
++	shader_t *tmp;
+ 
+-/*
+-==============
+-SortNewShader
++	for( i = 1; i < tr.numShaders; i++ ) {
++		if( cmpShader( i-1, i ) > 0 ) {
++			tmp = tr.sortedShaders[i];
+ 
+-Positions the most recently created shader in the tr.sortedShaders[]
+-array so that the shader->sort key is sorted reletive to the other
+-shaders.
++			j = 0;
++			k = i;
++			while( j < k ) {
++				int mid = (j + k) >> 1;
++				if( cmpShader( mid, i ) > 0 )
++					k = mid;
++				else
++					j = mid+1;
++			}
+ 
+-Sets shader->sortedIndex
+-==============
+-*/
+-static void SortNewShader( void ) {
+-	int		i;
+-	float	sort;
+-	shader_t	*newShader;
+-
+-	newShader = tr.shaders[ tr.numShaders - 1 ];
+-	sort = newShader->sort;
+-
+-	for ( i = tr.numShaders - 2 ; i >= 0 ; i-- ) {
+-		if ( tr.sortedShaders[ i ]->sort <= sort ) {
+-			break;
++			for( k = i; k > j; k-- ) {
++				tr.sortedShaders[k] = tr.sortedShaders[k-1];
++				tr.sortedShaders[k]->sortedIndex = k;
++			}
++			tr.sortedShaders[j] = tmp;
++			tr.sortedShaders[j]->sortedIndex = j;
+ 		}
+-		tr.sortedShaders[i+1] = tr.sortedShaders[i];
+-		tr.sortedShaders[i+1]->sortedIndex++;
+ 	}
+-
+-	// Arnout: fix rendercommandlist
+-	// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=493
+-	FixRenderCommandList( i+1 );
+-
+-	newShader->sortedIndex = i+1;
+-	tr.sortedShaders[i+1] = newShader;
+ }
+ 
+ 
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_shadows.c tremulous-ggp1-src/src/renderer/tr_shadows.c
--- tremulous-ggp1-src.p/src/renderer/tr_shadows.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_shadows.c	2012-07-19 04:25:52.021556447 +0200
@@ -42,9 +42,9 @@
 
 #define	MAX_EDGE_DEFS	32
 
-static	edgeDef_t	edgeDefs[SHADER_MAX_VERTEXES][MAX_EDGE_DEFS];
-static	int			numEdgeDefs[SHADER_MAX_VERTEXES];
-static	int			facing[SHADER_MAX_INDEXES/3];
+static	edgeDef_t	*edgeDefs;
+static	int		*numEdgeDefs;
+static	int		*facing;
 
 void R_AddEdgeDef( int i1, int i2, int facing ) {
 	int		c;
@@ -53,42 +53,122 @@
 	if ( c == MAX_EDGE_DEFS ) {
 		return;		// overflow
 	}
-	edgeDefs[ i1 ][ c ].i2 = i2;
-	edgeDefs[ i1 ][ c ].facing = facing;
+	edgeDefs[ i1 * MAX_EDGE_DEFS + c ].i2 = i2;
+	edgeDefs[ i1 * MAX_EDGE_DEFS + c ].facing = facing;
 
 	numEdgeDefs[ i1 ]++;
 }
 
-void R_RenderShadowEdges( void ) {
-	int		i;
+void R_RenderShadowEdges( glRenderState_t *state ) {
+	int		i, idx = 0;
+	int		numTris, numShadowTris;
+
+	numTris = tess.numIndexes / 3;
+	numShadowTris = numTris * 6;
 
+	state->program = tr.shadowShader->GLSLprogram;
+	SetAttrVec4f( state, AL_TRANSX,
+		      backEnd.currentEntity->e.axis[0][0],
+		      backEnd.currentEntity->e.axis[1][0],
+		      backEnd.currentEntity->e.axis[2][0],
+		      backEnd.currentEntity->e.origin[0] );
+	SetAttrVec4f( state, AL_TRANSY,
+		      backEnd.currentEntity->e.axis[0][1],
+		      backEnd.currentEntity->e.axis[1][1],
+		      backEnd.currentEntity->e.axis[2][1],
+		      backEnd.currentEntity->e.origin[1] );
+	SetAttrVec4f( state, AL_TRANSZ,
+		      backEnd.currentEntity->e.axis[0][2],
+		      backEnd.currentEntity->e.axis[1][2],
+		      backEnd.currentEntity->e.axis[2][2],
+		      backEnd.currentEntity->e.origin[2] );
 #if 0
-	int		numTris;
 
 	// dumb way -- render every triangle's edges
-	numTris = tess.numIndexes / 3;
-
-	for ( i = 0 ; i < numTris ; i++ ) {
-		int		i1, i2, i3;
+	SetAttrPointer( state, AL_VERTEX, 0,
+			3, GL_FLOAT, sizeof(vaWord2_t),
+			&tess.vertexPtr2[0].xyz );
+	
+	if ( tess.indexInc == sizeof( GLuint ) ) {
+		GLuint *indexPtr32 = tess.indexPtr.p32;
+		GLuint *indexes;
+		
+		indexes = RB_AllocScratch( 3 * numShadowTris * sizeof( GLuint ) );
+	
+		for ( i = 0 ; i < numTris ; i++ ) {
+			int		i1, i2, i3;
+			
+			if ( !facing[i] ) {
+				continue;
+			}
 
-		if ( !facing[i] ) {
-			continue;
+			i1 = indexPtr32[ i*3 + 0 ];
+			i2 = indexPtr32[ i*3 + 1 ];
+			i3 = indexPtr32[ i*3 + 2 ];
+			
+			indexes32[idx++] = i1;
+			indexes32[idx++] = i1 + tess.numVertexes;
+			indexes32[idx++] = i2;
+			indexes32[idx++] = i2;
+			indexes32[idx++] = i1 + tess.numVertexes;
+			indexes32[idx++] = i2 + tess.numVertexes;
+
+			indexes32[idx++] = i2;
+			indexes32[idx++] = i2 + tess.numVertexes;
+			indexes32[idx++] = i3;
+			indexes32[idx++] = i3;
+			indexes32[idx++] = i2 + tess.numVertexes;
+			indexes32[idx++] = i3 + tess.numVertexes;
+
+			indexes32[idx++] = i3;
+			indexes32[idx++] = i3 + tess.numVertexes;
+			indexes32[idx++] = i1;
+			indexes32[idx++] = i1;
+			indexes32[idx++] = i3 + tess.numVertexes;
+			indexes32[idx++] = i1 + tess.numVertexes;
 		}
+		GL_DrawElements( state, idx, 0, indexes32, 0, idx-1, 65537 );
+		RB_FreeScratch( indexes );
+	} else {
+		GLushort	*indexPtr = tess.indexPtr.p16;
+		GLushort	*indexes;
+		
+		indexes = RB_AllocScratch( 3 * numShadowTris * sizeof( GLushort ) );
+	
+		for ( i = 0 ; i < numTris ; i++ ) {
+			int		i1, i2, i3;
+			
+			if ( !facing[i] ) {
+				continue;
+			}
 
-		i1 = tess.indexes[ i*3 + 0 ];
-		i2 = tess.indexes[ i*3 + 1 ];
-		i3 = tess.indexes[ i*3 + 2 ];
-
-		qglBegin( GL_TRIANGLE_STRIP );
-		qglVertex3fv( tess.xyz[ i1 ] );
-		qglVertex3fv( tess.xyz[ i1 + tess.numVertexes ] );
-		qglVertex3fv( tess.xyz[ i2 ] );
-		qglVertex3fv( tess.xyz[ i2 + tess.numVertexes ] );
-		qglVertex3fv( tess.xyz[ i3 ] );
-		qglVertex3fv( tess.xyz[ i3 + tess.numVertexes ] );
-		qglVertex3fv( tess.xyz[ i1 ] );
-		qglVertex3fv( tess.xyz[ i1 + tess.numVertexes ] );
-		qglEnd();
+			i1 = indexPtr[ i*3 + 0 ];
+			i2 = indexPtr[ i*3 + 1 ];
+			i3 = indexPtr[ i*3 + 2 ];
+
+			indexes[idx++] = i1;
+			indexes[idx++] = i1 + tess.numVertexes;
+			indexes[idx++] = i2;
+			indexes[idx++] = i2;
+			indexes[idx++] = i1 + tess.numVertexes;
+			indexes[idx++] = i2 + tess.numVertexes;
+
+			indexes[idx++] = i2;
+			indexes[idx++] = i2 + tess.numVertexes;
+			indexes[idx++] = i3;
+			indexes[idx++] = i3;
+			indexes[idx++] = i2 + tess.numVertexes;
+			indexes[idx++] = i3 + tess.numVertexes;
+
+			indexes[idx++] = i3;
+			indexes[idx++] = i3 + tess.numVertexes;
+			indexes[idx++] = i1;
+			indexes[idx++] = i1;
+			indexes[idx++] = i3 + tess.numVertexes;
+			indexes[idx++] = i1 + tess.numVertexes;
+		}
+		GL_DrawElements( state, idx, 0, indexes, 0, idx-1, 0 );
+		RB_FreeScratch( indexes );
 	}
 #else
 	int		c, c2;
@@ -103,39 +183,92 @@
 	// but lots of models have dangling edges or overfanned edges
 	c_edges = 0;
 	c_rejected = 0;
-
-	for ( i = 0 ; i < tess.numVertexes ; i++ ) {
-		c = numEdgeDefs[ i ];
-		for ( j = 0 ; j < c ; j++ ) {
-			if ( !edgeDefs[ i ][ j ].facing ) {
-				continue;
-			}
-
-			hit[0] = 0;
-			hit[1] = 0;
-
-			i2 = edgeDefs[ i ][ j ].i2;
-			c2 = numEdgeDefs[ i2 ];
-			for ( k = 0 ; k < c2 ; k++ ) {
-				if ( edgeDefs[ i2 ][ k ].i2 == i ) {
-					hit[ edgeDefs[ i2 ][ k ].facing ]++;
+	SetAttrPointer( state, AL_VERTEX, 0,
+			3, GL_FLOAT, sizeof(vaWord2_t),
+			&tess.vertexPtr2[0].xyz );
+
+	if ( tess.indexInc == sizeof( GLuint ) ) {
+		GLuint	*indexes32;
+	
+		indexes32 = RB_AllocScratch( 3 * numShadowTris * sizeof( GLuint ) );
+		
+		for ( i = 0 ; i < tess.numVertexes ; i++ ) {
+			c = numEdgeDefs[ i ];
+			for ( j = 0 ; j < c ; j++ ) {
+				if ( !edgeDefs[ i * MAX_EDGE_DEFS + j ].facing ) {
+					continue;
+				}
+				
+				hit[0] = 0;
+				hit[1] = 0;
+				
+				i2 = edgeDefs[ i * MAX_EDGE_DEFS + j ].i2;
+				c2 = numEdgeDefs[ i2 ];
+				for ( k = 0 ; k < c2 ; k++ ) {
+					if ( edgeDefs[ i2 * MAX_EDGE_DEFS + k ].i2 == i ) {
+						hit[ edgeDefs[ i2 * MAX_EDGE_DEFS + k ].facing ]++;
+					}
+				}
+				
+				// if it doesn't share the edge with another front facing
+				// triangle, it is a sil edge
+				if ( hit[ 1 ] == 0 ) {
+					indexes32[idx++] = i;
+					indexes32[idx++] = i + tess.numVertexes;
+					indexes32[idx++] = i2;
+					indexes32[idx++] = i2;
+					indexes32[idx++] = i + tess.numVertexes;
+					indexes32[idx++] = i2 + tess.numVertexes;
+					c_edges++;
+				} else {
+					c_rejected++;
 				}
 			}
-
-			// if it doesn't share the edge with another front facing
-			// triangle, it is a sil edge
-			if ( hit[ 1 ] == 0 ) {
-				qglBegin( GL_TRIANGLE_STRIP );
-				qglVertex3fv( tess.xyz[ i ] );
-				qglVertex3fv( tess.xyz[ i + tess.numVertexes ] );
-				qglVertex3fv( tess.xyz[ i2 ] );
-				qglVertex3fv( tess.xyz[ i2 + tess.numVertexes ] );
-				qglEnd();
-				c_edges++;
-			} else {
-				c_rejected++;
+		}
+		GL_DrawElements( state, idx, 0, indexes32,
+				 0, 2*tess.numVertexes - 1, 65537 );
+		RB_FreeScratch( indexes32 );
+	} else {
+		GLushort	*indexes;
+	
+		indexes = RB_AllocScratch( 3 * numShadowTris * sizeof( GLushort ) );
+		
+		for ( i = 0 ; i < tess.numVertexes ; i++ ) {
+			c = numEdgeDefs[ i ];
+			for ( j = 0 ; j < c ; j++ ) {
+				if ( !edgeDefs[ i * MAX_EDGE_DEFS + j ].facing ) {
+					continue;
+				}
+				
+				hit[0] = 0;
+				hit[1] = 0;
+				
+				i2 = edgeDefs[ i * MAX_EDGE_DEFS + j ].i2;
+				c2 = numEdgeDefs[ i2 ];
+				for ( k = 0 ; k < c2 ; k++ ) {
+					if ( edgeDefs[ i2 * MAX_EDGE_DEFS + k ].i2 == i ) {
+						hit[ edgeDefs[ i2 * MAX_EDGE_DEFS + k ].facing ]++;
+					}
+				}
+				
+				// if it doesn't share the edge with another front facing
+				// triangle, it is a sil edge
+				if ( hit[ 1 ] == 0 ) {
+					indexes[idx++] = i;
+					indexes[idx++] = i + tess.numVertexes;
+					indexes[idx++] = i2;
+					indexes[idx++] = i2;
+					indexes[idx++] = i + tess.numVertexes;
+					indexes[idx++] = i2 + tess.numVertexes;
+					c_edges++;
+				} else {
+					c_rejected++;
+				}
 			}
 		}
+		GL_DrawElements( state, idx, 0, indexes,
+				 0, 2*tess.numVertexes - 1, 0 );
+		RB_FreeScratch( indexes );
 	}
 #endif
 }
@@ -156,12 +289,7 @@
 	int		i;
 	int		numTris;
 	vec3_t	lightDir;
-	GLboolean rgba[4];
-
-	// we can only do this if we have enough space in the vertex buffers
-	if ( tess.numVertexes >= SHADER_MAX_VERTEXES / 2 ) {
-		return;
-	}
+	glRenderState_t state;
 
 	if ( glConfig.stencilBits < 4 ) {
 		return;
@@ -171,29 +299,41 @@
 
 	// project vertexes away from light direction
 	for ( i = 0 ; i < tess.numVertexes ; i++ ) {
-		VectorMA( tess.xyz[i], -512, lightDir, tess.xyz[i+tess.numVertexes] );
+		VectorMA( tess.vertexPtr2[i].xyz, -512,
+			  lightDir, tess.vertexPtr2[i+tess.numVertexes].xyz );
 	}
 
 	// decide which triangles face the light
-	Com_Memset( numEdgeDefs, 0, 4 * tess.numVertexes );
+	numEdgeDefs = RB_AllocScratch( sizeof( int ) * tess.numVertexes );
+	edgeDefs = RB_AllocScratch( sizeof( edgeDef_t ) * tess.numVertexes * MAX_EDGE_DEFS );
+	facing = RB_AllocScratch( sizeof( int ) * tess.numIndexes / 3 );
+	Com_Memset( numEdgeDefs, 0, sizeof(int) * tess.numVertexes );
 
 	numTris = tess.numIndexes / 3;
 	for ( i = 0 ; i < numTris ; i++ ) {
-		int		i1, i2, i3;
+		GLushort	i1, i2, i3;
 		vec3_t	d1, d2, normal;
-		float	*v1, *v2, *v3;
+		vec3_t	*v1, *v2, *v3;
 		float	d;
 
-		i1 = tess.indexes[ i*3 + 0 ];
-		i2 = tess.indexes[ i*3 + 1 ];
-		i3 = tess.indexes[ i*3 + 2 ];
-
-		v1 = tess.xyz[ i1 ];
-		v2 = tess.xyz[ i2 ];
-		v3 = tess.xyz[ i3 ];
+		if ( tess.indexInc == sizeof( GLuint ) ) {
+			GLuint *indexPtr32 = tess.indexPtr.p32;
+			i1 = indexPtr32[ i*3 + 0 ];
+			i2 = indexPtr32[ i*3 + 1 ];
+			i3 = indexPtr32[ i*3 + 2 ];
+		} else {
+			GLushort *indexPtr = tess.indexPtr.p16;
+			i1 = indexPtr[ i*3 + 0 ];
+			i2 = indexPtr[ i*3 + 1 ];
+			i3 = indexPtr[ i*3 + 2 ];
+		}
+		
+		v1 = &tess.vertexPtr2[i1].xyz;
+		v2 = &tess.vertexPtr2[i2].xyz;
+		v3 = &tess.vertexPtr2[i3].xyz;
 
-		VectorSubtract( v2, v1, d1 );
-		VectorSubtract( v3, v1, d2 );
+		VectorSubtract( *v2, *v1, d1 );
+		VectorSubtract( *v3, *v1, d2 );
 		CrossProduct( d1, d2, normal );
 
 		d = DotProduct( normal, lightDir );
@@ -210,45 +350,42 @@
 	}
 
 	// draw the silhouette edges
+	InitState( &state );
 
-	GL_Bind( tr.whiteImage );
-	qglEnable( GL_CULL_FACE );
-	GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ZERO );
-	qglColor3f( 0.2f, 0.2f, 0.2f );
-
-	// don't write to the color buffer
-	qglGetBooleanv(GL_COLOR_WRITEMASK, rgba);
-	qglColorMask( GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE );
-
-	qglEnable( GL_STENCIL_TEST );
-	qglStencilFunc( GL_ALWAYS, 1, 255 );
-
-	// mirrors have the culling order reversed
-	if ( backEnd.viewParms.isMirror ) {
-		qglCullFace( GL_FRONT );
-		qglStencilOp( GL_KEEP, GL_KEEP, GL_INCR );
-
-		R_RenderShadowEdges();
-
-		qglCullFace( GL_BACK );
-		qglStencilOp( GL_KEEP, GL_KEEP, GL_DECR );
-
-		R_RenderShadowEdges();
+	state.numImages = 1;
+	state.image[0] = tr.whiteImage;
+	state.stateBits = GLS_COLORMASK_FALSE;
+	SetAttrVec4f( &state, AL_COLOR, 1.0f, 0.2f, 1.0f, 1.0f );
+
+	if( !backEnd.viewParms.portalLevel ) {
+		qglEnable( GL_STENCIL_TEST );
+		qglStencilFunc( GL_ALWAYS, 1, glGlobals.shadowMask );
+	}
+	qglStencilMask( glGlobals.shadowMask );
+
+	if( qglStencilOpSeparate ) {
+		// single pass, doesn't matter if we incr or decr as we check
+		// for != 0...
+		state.faceCulling = CT_TWO_SIDED;
+		qglStencilOpSeparate( GL_BACK, GL_KEEP, GL_KEEP, GL_INCR_WRAP );
+		qglStencilOpSeparate( GL_FRONT, GL_KEEP, GL_KEEP, GL_DECR_WRAP );
 	} else {
-		qglCullFace( GL_BACK );
+		// two passes for front/back faces
+		state.faceCulling = CT_BACK_SIDED;
 		qglStencilOp( GL_KEEP, GL_KEEP, GL_INCR );
 
-		R_RenderShadowEdges();
+		R_RenderShadowEdges( &state );
 
-		qglCullFace( GL_FRONT );
+		state.faceCulling = CT_FRONT_SIDED;
 		qglStencilOp( GL_KEEP, GL_KEEP, GL_DECR );
-
-		R_RenderShadowEdges();
 	}
+	R_RenderShadowEdges( &state );
 
+	qglStencilOp( GL_KEEP, GL_KEEP, GL_KEEP );
 
-	// reenable writing to the color buffer
-	qglColorMask(rgba[0], rgba[1], rgba[2], rgba[3]);
+	RB_FreeScratch( facing );
+	RB_FreeScratch( edgeDefs );
+	RB_FreeScratch( numEdgeDefs );
 }
 
 
@@ -263,6 +400,14 @@
 =================
 */
 void RB_ShadowFinish( void ) {
+	static vec3_t	vertexes[4] = {
+		{ -100,  100, -10 },
+		{  100,  100, -10 },
+		{  100, -100, -10 },
+		{ -100, -100, -10 }
+	};
+	glRenderState_t state;
+	
 	if ( r_shadows->integer != 2 ) {
 		return;
 	}
@@ -270,30 +415,39 @@
 		return;
 	}
 	qglEnable( GL_STENCIL_TEST );
-	qglStencilFunc( GL_NOTEQUAL, 0, 255 );
-
-	qglDisable (GL_CLIP_PLANE0);
-	qglDisable (GL_CULL_FACE);
-
-	GL_Bind( tr.whiteImage );
-
-    qglLoadIdentity ();
+	qglStencilFunc( GL_NOTEQUAL, 0, glGlobals.shadowMask );
+	qglStencilMask( glGlobals.shadowMask );
+	qglStencilOp( GL_ZERO, GL_ZERO, GL_ZERO );
+
+	InitState( &state );
+	state.faceCulling = CT_TWO_SIDED;
+
+	state.numImages = 1;
+	state.image[0] = tr.whiteImage;
+
+	qglLoadIdentity ();
+
+	state.program = NULL;
+	SetAttrVec4f( &state, AL_COLOR, 0.6f, 0.6f, 0.6f, 1.0f );
+	state.stateBits = GLS_DEPTHMASK_TRUE |
+		GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO;
+
+	SetAttrPointer( &state, AL_VERTEX, 0,
+			3, GL_FLOAT, sizeof(vec3_t),
+			vertexes );
+	GL_DrawArrays( &state, GL_QUADS, 0, 4 );
 
-	qglColor3f( 0.6f, 0.6f, 0.6f );
-	GL_State( GLS_DEPTHMASK_TRUE | GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO );
-
-//	qglColor3f( 1, 0, 0 );
-//	GL_State( GLS_DEPTHMASK_TRUE | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ZERO );
-
-	qglBegin( GL_QUADS );
-	qglVertex3f( -100, 100, -10 );
-	qglVertex3f( 100, 100, -10 );
-	qglVertex3f( 100, -100, -10 );
-	qglVertex3f( -100, -100, -10 );
-	qglEnd ();
-
-	qglColor4f(1,1,1,1);
-	qglDisable( GL_STENCIL_TEST );
+	if( !backEnd.viewParms.portalLevel ) {
+		qglDisable( GL_STENCIL_TEST );
+	} else {
+		int		level;
+		GLuint		stencilVal;
+		level = backEnd.viewParms.portalLevel;
+		stencilVal = (level ^ (level >> 1)) << glGlobals.shadowBits;
+		
+		qglStencilFunc( GL_EQUAL, stencilVal, glGlobals.portalMask );
+		qglStencilOp( GL_KEEP, GL_KEEP, GL_KEEP );
+	}
 }
 
 
@@ -304,7 +458,6 @@
 =================
 */
 void RB_ProjectionShadowDeform( void ) {
-	float	*xyz;
 	int		i;
 	float	h;
 	vec3_t	ground;
@@ -313,8 +466,6 @@
 	float	d;
 	vec3_t	lightDir;
 
-	xyz = ( float * ) tess.xyz;
-
 	ground[0] = backEnd.or.axis[0][2];
 	ground[1] = backEnd.or.axis[1][2];
 	ground[2] = backEnd.or.axis[2][2];
@@ -334,11 +485,11 @@
 	light[1] = lightDir[1] * d;
 	light[2] = lightDir[2] * d;
 
-	for ( i = 0; i < tess.numVertexes; i++, xyz += 4 ) {
-		h = DotProduct( xyz, ground ) + groundDist;
+	for ( i = 0; i < tess.numVertexes; i++ ) {
+		h = DotProduct( tess.vertexPtr2[i].xyz, ground ) + groundDist;
 
-		xyz[0] -= light[0] * h;
-		xyz[1] -= light[1] * h;
-		xyz[2] -= light[2] * h;
+		tess.vertexPtr2[i].xyz[0] -= light[0] * h;
+		tess.vertexPtr2[i].xyz[1] -= light[1] * h;
+		tess.vertexPtr2[i].xyz[2] -= light[2] * h;
 	}
 }
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_sky.c tremulous-ggp1-src/src/renderer/tr_sky.c
--- tremulous-ggp1-src.p/src/renderer/tr_sky.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_sky.c	2012-07-19 04:25:52.031556446 +0200
@@ -26,6 +26,10 @@
 #define SKY_SUBDIVISIONS		8
 #define HALF_SKY_SUBDIVISIONS	(SKY_SUBDIVISIONS/2)
 
+#define SKY_MAX_QUADS		(5 * SKY_SUBDIVISIONS * SKY_SUBDIVISIONS)
+#define SKY_MAX_VERTEXES	(4 * SKY_MAX_QUADS)
+#define SKY_MAX_INDEXES		(6 * SKY_MAX_QUADS)
+
 static float s_cloudTexCoords[6][SKY_SUBDIVISIONS+1][SKY_SUBDIVISIONS+1][2];
 static float s_cloudTexP[6][SKY_SUBDIVISIONS+1][SKY_SUBDIVISIONS+1];
 
@@ -269,9 +273,9 @@
 	{
 		for (j = 0 ; j < 3 ; j++) 
 		{
-			VectorSubtract( input->xyz[input->indexes[i+j]],
-							backEnd.viewParms.or.origin, 
-							p[j] );
+			VectorSubtract( tess.vertexPtr2[tess.indexPtr.p16[i+j]].xyz,
+					backEnd.viewParms.or.origin, 
+					p[j] );
 		}
 		ClipSkyPolygon( 3, p[0], 0 );
 	}
@@ -364,25 +368,40 @@
 
 static void DrawSkySide( struct image_s *image, const int mins[2], const int maxs[2] )
 {
-	int s, t;
-
-	GL_Bind( image );
+	int s, t, i;
+	GLushort indexes[6*(SKY_SUBDIVISIONS+1)*(SKY_SUBDIVISIONS+1)];
+	glRenderState_t state;
+
+	InitState( &state );
+
+	state.program = NULL;
+	state.numImages = 1;
+	state.image[0] = image;
+	SetAttrPointer( &state, AL_VERTEX, 0,
+			3, GL_FLOAT, sizeof(vec3_t),
+			s_skyPoints );
+	SetAttrPointer( &state, AL_TEXCOORD, 0,
+			2, GL_FLOAT, 0,
+			s_skyTexCoords[0][0] );
+	SetAttrVec4f( &state, AL_COLOR, 1.0f, 1.0f, 1.0f, 1.0f );
+	i = 0;
 
 	for ( t = mins[1]+HALF_SKY_SUBDIVISIONS; t < maxs[1]+HALF_SKY_SUBDIVISIONS; t++ )
 	{
-		qglBegin( GL_TRIANGLE_STRIP );
-
-		for ( s = mins[0]+HALF_SKY_SUBDIVISIONS; s <= maxs[0]+HALF_SKY_SUBDIVISIONS; s++ )
+		for ( s = mins[0]+HALF_SKY_SUBDIVISIONS; s < maxs[0]+HALF_SKY_SUBDIVISIONS; s++ )
 		{
-			qglTexCoord2fv( s_skyTexCoords[t][s] );
-			qglVertex3fv( s_skyPoints[t][s] );
-
-			qglTexCoord2fv( s_skyTexCoords[t+1][s] );
-			qglVertex3fv( s_skyPoints[t+1][s] );
+			indexes[i++] = t * (SKY_SUBDIVISIONS+1) + s;
+			indexes[i++] = (t+1) * (SKY_SUBDIVISIONS+1) + s;
+			indexes[i++] = t * (SKY_SUBDIVISIONS+1) + (s+1);
+			indexes[i++] = t * (SKY_SUBDIVISIONS+1) + (s+1);
+			indexes[i++] = (t+1) * (SKY_SUBDIVISIONS+1) + s;
+			indexes[i++] = (t+1) * (SKY_SUBDIVISIONS+1) + (s+1);
 		}
-
-		qglEnd();
 	}
+	if( i > 0 )
+		// the largest index is always the last one
+		GL_DrawElements( &state, i, 0, indexes,
+				 0, indexes[i - 1], 0 );
 }
 
 static void DrawSkyBox( shader_t *shader )
@@ -449,8 +468,7 @@
 		}
 
 		DrawSkySide( shader->sky.outerbox[sky_texorder[i]],
-			         sky_mins_subd,
-					 sky_maxs_subd );
+			     sky_mins_subd, sky_maxs_subd );
 	}
 
 }
@@ -460,6 +478,8 @@
 	int s, t;
 	int vertexStart = tess.numVertexes;
 	int tHeight, sWidth;
+	vaWord1_t	*vertexPtr1 = tess.vertexPtr1 + tess.numVertexes;
+	vaWord2_t	*vertexPtr2 = tess.vertexPtr2 + tess.numVertexes;
 
 	tHeight = maxs[1] - mins[1] + 1;
 	sWidth = maxs[0] - mins[0] + 1;
@@ -468,37 +488,44 @@
 	{
 		for ( s = mins[0]+HALF_SKY_SUBDIVISIONS; s <= maxs[0]+HALF_SKY_SUBDIVISIONS; s++ )
 		{
-			VectorAdd( s_skyPoints[t][s], backEnd.viewParms.or.origin, tess.xyz[tess.numVertexes] );
-			tess.texCoords[tess.numVertexes][0][0] = s_skyTexCoords[t][s][0];
-			tess.texCoords[tess.numVertexes][0][1] = s_skyTexCoords[t][s][1];
+			VectorAdd( s_skyPoints[t][s], backEnd.viewParms.or.origin, vertexPtr2->xyz );
+			vertexPtr1->tc1[0] = s_skyTexCoords[t][s][0];
+			vertexPtr1->tc1[1] = s_skyTexCoords[t][s][1];
+			vertexPtr2->fogNum = tess.fogNum;
 
 			tess.numVertexes++;
+			vertexPtr1++;
+			vertexPtr2++;
 
-			if ( tess.numVertexes >= SHADER_MAX_VERTEXES )
+			if ( tess.numVertexes >= SKY_MAX_VERTEXES )
 			{
-				ri.Error( ERR_DROP, "SHADER_MAX_VERTEXES hit in FillCloudySkySide()\n" );
+				ri.Error( ERR_DROP, "SKY_MAX_VERTEXES hit in FillCloudySkySide()\n" );
 			}
 		}
 	}
 
 	// only add indexes for one pass, otherwise it would draw multiple times for each pass
 	if ( addIndexes ) {
+		if ( tess.minIndex > vertexStart )
+			tess.minIndex = vertexStart;
+		if ( tess.maxIndex < tess.numVertexes - 1 )
+			tess.maxIndex = tess.numVertexes - 1;
 		for ( t = 0; t < tHeight-1; t++ )
 		{	
 			for ( s = 0; s < sWidth-1; s++ )
 			{
-				tess.indexes[tess.numIndexes] = vertexStart + s + t * ( sWidth );
+				tess.indexPtr.p16[tess.numIndexes] = vertexStart + s + t * ( sWidth );
 				tess.numIndexes++;
-				tess.indexes[tess.numIndexes] = vertexStart + s + ( t + 1 ) * ( sWidth );
+				tess.indexPtr.p16[tess.numIndexes] = vertexStart + s + ( t + 1 ) * ( sWidth );
 				tess.numIndexes++;
-				tess.indexes[tess.numIndexes] = vertexStart + s + 1 + t * ( sWidth );
+				tess.indexPtr.p16[tess.numIndexes] = vertexStart + s + 1 + t * ( sWidth );
 				tess.numIndexes++;
 
-				tess.indexes[tess.numIndexes] = vertexStart + s + ( t + 1 ) * ( sWidth );
+				tess.indexPtr.p16[tess.numIndexes] = vertexStart + s + ( t + 1 ) * ( sWidth );
 				tess.numIndexes++;
-				tess.indexes[tess.numIndexes] = vertexStart + s + 1 + ( t + 1 ) * ( sWidth );
+				tess.indexPtr.p16[tess.numIndexes] = vertexStart + s + 1 + ( t + 1 ) * ( sWidth );
 				tess.numIndexes++;
-				tess.indexes[tess.numIndexes] = vertexStart + s + 1 + t * ( sWidth );
+				tess.indexPtr.p16[tess.numIndexes] = vertexStart + s + 1 + t * ( sWidth );
 				tess.numIndexes++;
 			}
 		}
@@ -615,6 +642,10 @@
 	sky_min = 1.0 / 256.0f;		// FIXME: not correct?
 	sky_max = 255.0 / 256.0f;
 
+	tess.numIndexes = SKY_MAX_INDEXES;
+	tess.numVertexes = SKY_MAX_VERTEXES;
+	RB_SetupVertexBuffer( shader, NULL );
+
 	// set up for drawing
 	tess.numIndexes = 0;
 	tess.numVertexes = 0;
@@ -702,6 +733,10 @@
 	float		dist;
 	vec3_t		origin, vec1, vec2;
 	vec3_t		temp;
+	vaWord1_t	*vertexPtr1;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
+	vaWord4_t	*vertexPtr4;
 
 	if ( !backEnd.skyRenderedThisView ) {
 		return;
@@ -722,66 +757,87 @@
 	VectorScale( vec1, size, vec1 );
 	VectorScale( vec2, size, vec2 );
 
-	// farthest depth range
-	qglDepthRange( 1.0, 1.0 );
-
 	// FIXME: use quad stamp
 	RB_BeginSurface( tr.sunShader, tess.fogNum );
-		VectorCopy( origin, temp );
-		VectorSubtract( temp, vec1, temp );
-		VectorSubtract( temp, vec2, temp );
-		VectorCopy( temp, tess.xyz[tess.numVertexes] );
-		tess.texCoords[tess.numVertexes][0][0] = 0;
-		tess.texCoords[tess.numVertexes][0][1] = 0;
-		tess.vertexColors[tess.numVertexes][0] = 255;
-		tess.vertexColors[tess.numVertexes][1] = 255;
-		tess.vertexColors[tess.numVertexes][2] = 255;
-		tess.numVertexes++;
-
-		VectorCopy( origin, temp );
-		VectorAdd( temp, vec1, temp );
-		VectorSubtract( temp, vec2, temp );
-		VectorCopy( temp, tess.xyz[tess.numVertexes] );
-		tess.texCoords[tess.numVertexes][0][0] = 0;
-		tess.texCoords[tess.numVertexes][0][1] = 1;
-		tess.vertexColors[tess.numVertexes][0] = 255;
-		tess.vertexColors[tess.numVertexes][1] = 255;
-		tess.vertexColors[tess.numVertexes][2] = 255;
-		tess.numVertexes++;
-
-		VectorCopy( origin, temp );
-		VectorAdd( temp, vec1, temp );
-		VectorAdd( temp, vec2, temp );
-		VectorCopy( temp, tess.xyz[tess.numVertexes] );
-		tess.texCoords[tess.numVertexes][0][0] = 1;
-		tess.texCoords[tess.numVertexes][0][1] = 1;
-		tess.vertexColors[tess.numVertexes][0] = 255;
-		tess.vertexColors[tess.numVertexes][1] = 255;
-		tess.vertexColors[tess.numVertexes][2] = 255;
-		tess.numVertexes++;
-
-		VectorCopy( origin, temp );
-		VectorSubtract( temp, vec1, temp );
-		VectorAdd( temp, vec2, temp );
-		VectorCopy( temp, tess.xyz[tess.numVertexes] );
-		tess.texCoords[tess.numVertexes][0][0] = 1;
-		tess.texCoords[tess.numVertexes][0][1] = 0;
-		tess.vertexColors[tess.numVertexes][0] = 255;
-		tess.vertexColors[tess.numVertexes][1] = 255;
-		tess.vertexColors[tess.numVertexes][2] = 255;
-		tess.numVertexes++;
-
-		tess.indexes[tess.numIndexes++] = 0;
-		tess.indexes[tess.numIndexes++] = 1;
-		tess.indexes[tess.numIndexes++] = 2;
-		tess.indexes[tess.numIndexes++] = 0;
-		tess.indexes[tess.numIndexes++] = 2;
-		tess.indexes[tess.numIndexes++] = 3;
 
-	RB_EndSurface();
+	tess.numVertexes = 4;
+	tess.numIndexes  = 6;
+	RB_SetupVertexBuffer( tr.sunShader, NULL );
+
+	vertexPtr1 = tess.vertexPtr1;
+	vertexPtr2 = tess.vertexPtr2;
+	vertexPtr3 = tess.vertexPtr3;
+	vertexPtr4 = tess.vertexPtr4;
+
+	VectorCopy( origin, temp );
+	VectorSubtract( temp, vec1, temp );
+	VectorSubtract( temp, vec2, temp );
+	VectorCopy( temp, vertexPtr2->xyz );
+	vertexPtr1->tc1[0] = 0;
+	vertexPtr1->tc1[1] = 0;
+	vertexPtr4->color[0] = 255;
+	vertexPtr4->color[1] = 255;
+	vertexPtr4->color[2] = 255;
+	vertexPtr2->fogNum = tess.fogNum;
+	vertexPtr1++;
+	vertexPtr2++;
+	vertexPtr3++;
+	vertexPtr4++;
+	
+	VectorCopy( origin, temp );
+	VectorAdd( temp, vec1, temp );
+	VectorSubtract( temp, vec2, temp );
+	VectorCopy( temp, vertexPtr2->xyz );
+	vertexPtr1->tc1[0] = 0;
+	vertexPtr1->tc1[1] = 1;
+	vertexPtr4->color[0] = 255;
+	vertexPtr4->color[1] = 255;
+	vertexPtr4->color[2] = 255;
+	vertexPtr2->fogNum = tess.fogNum;
+	vertexPtr1++;
+	vertexPtr2++;
+	vertexPtr3++;
+	vertexPtr4++;
+	
+	VectorCopy( origin, temp );
+	VectorAdd( temp, vec1, temp );
+	VectorAdd( temp, vec2, temp );
+	VectorCopy( temp, vertexPtr2->xyz );
+	vertexPtr1->tc1[0] = 1;
+	vertexPtr1->tc1[1] = 1;
+	vertexPtr4->color[0] = 255;
+	vertexPtr4->color[1] = 255;
+	vertexPtr4->color[2] = 255;
+	vertexPtr2->fogNum = tess.fogNum;
+	vertexPtr1++;
+	vertexPtr2++;
+	vertexPtr3++;
+	vertexPtr4++;
+	
+	VectorCopy( origin, temp );
+	VectorSubtract( temp, vec1, temp );
+	VectorAdd( temp, vec2, temp );
+	VectorCopy( temp, vertexPtr2->xyz );
+	vertexPtr1->tc1[0] = 1;
+	vertexPtr1->tc1[1] = 0;
+	vertexPtr4->color[0] = 255;
+	vertexPtr4->color[1] = 255;
+	vertexPtr4->color[2] = 255;
+	vertexPtr2->fogNum = tess.fogNum;
+	vertexPtr1++;
+	vertexPtr2++;
+	vertexPtr3++;
+	vertexPtr4++;
+	
+	tess.indexPtr.p16[0] = 0;
+	tess.indexPtr.p16[1] = 1;
+	tess.indexPtr.p16[2] = 2;
+	tess.indexPtr.p16[3] = 0;
+	tess.indexPtr.p16[4] = 2;
+	tess.indexPtr.p16[5] = 3;
 
-	// back to normal depth range
-	qglDepthRange( 0.0, 1.0 );
+	RB_EndSurface();
+	RB_ClearVertexBuffer();
 }
 
 
@@ -809,18 +865,15 @@
 	// r_showsky will let all the sky blocks be drawn in
 	// front of everything to allow developers to see how
 	// much sky is getting sucked in
-	if ( r_showsky->integer ) {
-		qglDepthRange( 0.0, 0.0 );
-	} else {
-		qglDepthRange( 1.0, 1.0 );
-	}
+	//if ( r_showsky->integer ) {
+	//	qglDepthRange( 0.0, 0.0 );
+	//} else {
+	//	qglDepthRange( 1.0, 1.0 );
+	//}
 
 	// draw the outer skybox
 	if ( tess.shader->sky.outerbox[0] && tess.shader->sky.outerbox[0] != tr.defaultImage ) {
-		qglColor3f( tr.identityLight, tr.identityLight, tr.identityLight );
-		
 		qglPushMatrix ();
-		GL_State( 0 );
 		qglTranslatef (backEnd.viewParms.or.origin[0], backEnd.viewParms.or.origin[1], backEnd.viewParms.or.origin[2]);
 
 		DrawSkyBox( tess.shader );
@@ -834,12 +887,6 @@
 
 	RB_StageIteratorGeneric();
 
-	// draw the inner skybox
-
-
-	// back to normal depth range
-	qglDepthRange( 0.0, 1.0 );
-
 	// note that sky was drawn so we will draw a sun later
 	backEnd.skyRenderedThisView = qtrue;
 }
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_surface.c tremulous-ggp1-src/src/renderer/tr_surface.c
--- tremulous-ggp1-src.p/src/renderer/tr_surface.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_surface.c	2012-07-19 04:25:52.031556446 +0200
@@ -46,96 +46,115 @@
 
 /*
 ==============
-RB_CheckOverflow
-==============
-*/
-void RB_CheckOverflow( int verts, int indexes ) {
-	if (tess.numVertexes + verts < SHADER_MAX_VERTEXES
-		&& tess.numIndexes + indexes < SHADER_MAX_INDEXES) {
-		return;
-	}
-
-	RB_EndSurface();
-
-	if ( verts >= SHADER_MAX_VERTEXES ) {
-		ri.Error(ERR_DROP, "RB_CheckOverflow: verts > MAX (%d > %d)", verts, SHADER_MAX_VERTEXES );
-	}
-	if ( indexes >= SHADER_MAX_INDEXES ) {
-		ri.Error(ERR_DROP, "RB_CheckOverflow: indices > MAX (%d > %d)", indexes, SHADER_MAX_INDEXES );
-	}
-
-	RB_BeginSurface(tess.shader, tess.fogNum );
-}
-
-
-/*
-==============
 RB_AddQuadStampExt
 ==============
 */
 void RB_AddQuadStampExt( vec3_t origin, vec3_t left, vec3_t up, byte *color, float s1, float t1, float s2, float t2 ) {
-	vec3_t		normal;
 	int			ndx;
 
-	RB_CHECKOVERFLOW( 4, 6 );
-
-	ndx = tess.numVertexes;
-
-	// triangle indexes for a simple quad
-	tess.indexes[ tess.numIndexes ] = ndx;
-	tess.indexes[ tess.numIndexes + 1 ] = ndx + 1;
-	tess.indexes[ tess.numIndexes + 2 ] = ndx + 3;
-
-	tess.indexes[ tess.numIndexes + 3 ] = ndx + 3;
-	tess.indexes[ tess.numIndexes + 4 ] = ndx + 1;
-	tess.indexes[ tess.numIndexes + 5 ] = ndx + 2;
-
-	tess.xyz[ndx][0] = origin[0] + left[0] + up[0];
-	tess.xyz[ndx][1] = origin[1] + left[1] + up[1];
-	tess.xyz[ndx][2] = origin[2] + left[2] + up[2];
-
-	tess.xyz[ndx+1][0] = origin[0] - left[0] + up[0];
-	tess.xyz[ndx+1][1] = origin[1] - left[1] + up[1];
-	tess.xyz[ndx+1][2] = origin[2] - left[2] + up[2];
-
-	tess.xyz[ndx+2][0] = origin[0] - left[0] - up[0];
-	tess.xyz[ndx+2][1] = origin[1] - left[1] - up[1];
-	tess.xyz[ndx+2][2] = origin[2] - left[2] - up[2];
-
-	tess.xyz[ndx+3][0] = origin[0] + left[0] - up[0];
-	tess.xyz[ndx+3][1] = origin[1] + left[1] - up[1];
-	tess.xyz[ndx+3][2] = origin[2] + left[2] - up[2];
-
-
-	// constant normal all the way around
-	VectorSubtract( vec3_origin, backEnd.viewParms.or.axis[0], normal );
+	if ( tess.vertexPtr1 ) {
+		ndx = tess.numVertexes;
+		
+		tess.vertexPtr2[ndx+0].xyz[0] = origin[0] + left[0] + up[0];
+		tess.vertexPtr2[ndx+0].xyz[1] = origin[1] + left[1] + up[1];
+		tess.vertexPtr2[ndx+0].xyz[2] = origin[2] + left[2] + up[2];
+		tess.vertexPtr2[ndx+0].fogNum = (float)tess.fogNum;
+		
+		tess.vertexPtr2[ndx+1].xyz[0] = origin[0] - left[0] + up[0];
+		tess.vertexPtr2[ndx+1].xyz[1] = origin[1] - left[1] + up[1];
+		tess.vertexPtr2[ndx+1].xyz[2] = origin[2] - left[2] + up[2];
+		tess.vertexPtr2[ndx+1].fogNum = (float)tess.fogNum;
+		
+		tess.vertexPtr2[ndx+2].xyz[0] = origin[0] - left[0] - up[0];
+		tess.vertexPtr2[ndx+2].xyz[1] = origin[1] - left[1] - up[1];
+		tess.vertexPtr2[ndx+2].xyz[2] = origin[2] - left[2] - up[2];
+		tess.vertexPtr2[ndx+2].fogNum = (float)tess.fogNum;
+		
+		tess.vertexPtr2[ndx+3].xyz[0] = origin[0] + left[0] - up[0];
+		tess.vertexPtr2[ndx+3].xyz[1] = origin[1] + left[1] - up[1];
+		tess.vertexPtr2[ndx+3].xyz[2] = origin[2] + left[2] - up[2];
+		tess.vertexPtr2[ndx+3].fogNum = (float)tess.fogNum;
+		
+		// sprites don't use normal, so I reuse it to store the
+		// shadertimes
+		tess.vertexPtr3[ndx+0].normal[0] = tess.shaderTime;
+		tess.vertexPtr3[ndx+0].normal[1] = 0.0f;
+		tess.vertexPtr3[ndx+0].normal[2] = 0.0f;
+		tess.vertexPtr3[ndx+0].reserved = 0.0f;
+ 		tess.vertexPtr3[ndx+1].normal[0] = tess.shaderTime;
+		tess.vertexPtr3[ndx+1].normal[1] = 0.0f;
+		tess.vertexPtr3[ndx+1].normal[2] = 0.0f;
+		tess.vertexPtr3[ndx+1].reserved = 0.0f;
+		tess.vertexPtr3[ndx+2].normal[0] = tess.shaderTime;
+		tess.vertexPtr3[ndx+2].normal[1] = 0.0f;
+		tess.vertexPtr3[ndx+2].normal[2] = 0.0f;
+		tess.vertexPtr3[ndx+2].reserved = 0.0f;
+		tess.vertexPtr3[ndx+3].normal[0] = tess.shaderTime;
+		tess.vertexPtr3[ndx+3].normal[1] = 0.0f;
+		tess.vertexPtr3[ndx+3].normal[2] = 0.0f;
+		tess.vertexPtr3[ndx+3].reserved = 0.0f;
+		
+		// standard square texture coordinates
+		tess.vertexPtr1[ndx].tc1[0] = tess.vertexPtr1[ndx].tc2[0] = s1;
+		tess.vertexPtr1[ndx].tc1[1] = tess.vertexPtr1[ndx].tc2[1] = t1;
+		
+		tess.vertexPtr1[ndx+1].tc1[0] = tess.vertexPtr1[ndx+1].tc2[0] = s2;
+		tess.vertexPtr1[ndx+1].tc1[1] = tess.vertexPtr1[ndx+1].tc2[1] = t1;
+		
+		tess.vertexPtr1[ndx+2].tc1[0] = tess.vertexPtr1[ndx+2].tc2[0] = s2;
+		tess.vertexPtr1[ndx+2].tc1[1] = tess.vertexPtr1[ndx+2].tc2[1] = t2;
+		
+		tess.vertexPtr1[ndx+3].tc1[0] = tess.vertexPtr1[ndx+3].tc2[0] = s1;
+		tess.vertexPtr1[ndx+3].tc1[1] = tess.vertexPtr1[ndx+3].tc2[1] = t2;
+		
+		// constant color all the way around
+		// should this be identity and let the shader specify from entity?
+		tess.vertexPtr4[ndx].color[0] = color[0];
+		tess.vertexPtr4[ndx].color[1] = color[1];
+		tess.vertexPtr4[ndx].color[2] = color[2];
+		tess.vertexPtr4[ndx].color[3] = color[3];
+		tess.vertexPtr4[ndx+1].color[0] = color[0];
+		tess.vertexPtr4[ndx+1].color[1] = color[1];
+		tess.vertexPtr4[ndx+1].color[2] = color[2];
+		tess.vertexPtr4[ndx+1].color[3] = color[3];
+		tess.vertexPtr4[ndx+2].color[0] = color[0];
+		tess.vertexPtr4[ndx+2].color[1] = color[1];
+		tess.vertexPtr4[ndx+2].color[2] = color[2];
+		tess.vertexPtr4[ndx+2].color[3] = color[3];
+		tess.vertexPtr4[ndx+3].color[0] = color[0];
+		tess.vertexPtr4[ndx+3].color[1] = color[1];
+		tess.vertexPtr4[ndx+3].color[2] = color[2];
+		tess.vertexPtr4[ndx+3].color[3] = color[3];
+	} else {
+		ndx = 0; // should never be in a VBO
+	}
 
-	tess.normal[ndx][0] = tess.normal[ndx+1][0] = tess.normal[ndx+2][0] = tess.normal[ndx+3][0] = normal[0];
-	tess.normal[ndx][1] = tess.normal[ndx+1][1] = tess.normal[ndx+2][1] = tess.normal[ndx+3][1] = normal[1];
-	tess.normal[ndx][2] = tess.normal[ndx+1][2] = tess.normal[ndx+2][2] = tess.normal[ndx+3][2] = normal[2];
+	if ( tess.indexPtr.p16 ) {
+		if ( tess.minIndex > ndx )
+			tess.minIndex = ndx;
+		if ( tess.maxIndex < ndx + 3 )
+			tess.maxIndex = ndx + 3;
+		
+		// triangle indexes for a simple quad
+		if ( tess.indexInc == sizeof(GLuint) ) {
+			tess.indexPtr.p32[ tess.numIndexes ] = ndx;
+			tess.indexPtr.p32[ tess.numIndexes + 1 ] = ndx + 1;
+			tess.indexPtr.p32[ tess.numIndexes + 2 ] = ndx + 3;
+			
+			tess.indexPtr.p32[ tess.numIndexes + 3 ] = ndx + 3;
+			tess.indexPtr.p32[ tess.numIndexes + 4 ] = ndx + 1;
+			tess.indexPtr.p32[ tess.numIndexes + 5 ] = ndx + 2;
+		} else {
+			tess.indexPtr.p16[ tess.numIndexes ] = ndx;
+			tess.indexPtr.p16[ tess.numIndexes + 1 ] = ndx + 1;
+			tess.indexPtr.p16[ tess.numIndexes + 2 ] = ndx + 3;
+			
+			tess.indexPtr.p16[ tess.numIndexes + 3 ] = ndx + 3;
+			tess.indexPtr.p16[ tess.numIndexes + 4 ] = ndx + 1;
+			tess.indexPtr.p16[ tess.numIndexes + 5 ] = ndx + 2;
+		}
+	}
 	
-	// standard square texture coordinates
-	tess.texCoords[ndx][0][0] = tess.texCoords[ndx][1][0] = s1;
-	tess.texCoords[ndx][0][1] = tess.texCoords[ndx][1][1] = t1;
-
-	tess.texCoords[ndx+1][0][0] = tess.texCoords[ndx+1][1][0] = s2;
-	tess.texCoords[ndx+1][0][1] = tess.texCoords[ndx+1][1][1] = t1;
-
-	tess.texCoords[ndx+2][0][0] = tess.texCoords[ndx+2][1][0] = s2;
-	tess.texCoords[ndx+2][0][1] = tess.texCoords[ndx+2][1][1] = t2;
-
-	tess.texCoords[ndx+3][0][0] = tess.texCoords[ndx+3][1][0] = s1;
-	tess.texCoords[ndx+3][0][1] = tess.texCoords[ndx+3][1][1] = t2;
-
-	// constant color all the way around
-	// should this be identity and let the shader specify from entity?
-	* ( unsigned int * ) &tess.vertexColors[ndx] = 
-	* ( unsigned int * ) &tess.vertexColors[ndx+1] = 
-	* ( unsigned int * ) &tess.vertexColors[ndx+2] = 
-	* ( unsigned int * ) &tess.vertexColors[ndx+3] = 
-		* ( unsigned int * )color;
-
-
 	tess.numVertexes += 4;
 	tess.numIndexes += 6;
 }
@@ -190,32 +209,66 @@
 RB_SurfacePolychain
 =============
 */
-static void RB_SurfacePolychain( srfPoly_t *p ) {
+static void RB_SurfacePolychain( surfaceType_t *surface ) {
+	srfPoly_t *p = (srfPoly_t *)surface;
 	int		i;
 	int		numv;
-
-	RB_CHECKOVERFLOW( p->numVerts, 3*(p->numVerts - 2) );
-
-	// fan triangles into the tess array
-	numv = tess.numVertexes;
-	for ( i = 0; i < p->numVerts; i++ ) {
-		VectorCopy( p->verts[i].xyz, tess.xyz[numv] );
-		tess.texCoords[numv][0][0] = p->verts[i].st[0];
-		tess.texCoords[numv][0][1] = p->verts[i].st[1];
-		*(int *)&tess.vertexColors[numv] = *(int *)p->verts[ i ].modulate;
-
-		numv++;
+	vaWord1_t	*vertexPtr1;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
+	vaWord4_t	*vertexPtr4;
+
+	if ( tess.vertexPtr1 ) {
+		vertexPtr1 = tess.vertexPtr1 + tess.numVertexes;
+		vertexPtr2 = tess.vertexPtr2 + tess.numVertexes;
+		vertexPtr3 = tess.vertexPtr3 + tess.numVertexes;
+		vertexPtr4 = tess.vertexPtr4 + tess.numVertexes;
+		
+		// fan triangles into the tess array
+		numv = tess.numVertexes;
+		for ( i = 0; i < p->numVerts; i++ ) {
+			VectorCopy ( p->verts[i].xyz, *(vec3_t *)vertexPtr2->xyz );
+			Vector2Copy( p->verts[i].st,  vertexPtr1->tc1 );
+			*(int *)(&vertexPtr4->color) = *(int *)p->verts[ i ].modulate;
+			vertexPtr2->fogNum = tess.fogNum;
+			
+			vertexPtr1++;
+			vertexPtr2++;
+			vertexPtr3++;
+			vertexPtr4++;
+		}
+	} else {
+		numv = 0; //ERROR, should never have coordinates in VBO
 	}
 
-	// generate fan indexes into the tess array
-	for ( i = 0; i < p->numVerts-2; i++ ) {
-		tess.indexes[tess.numIndexes + 0] = tess.numVertexes;
-		tess.indexes[tess.numIndexes + 1] = tess.numVertexes + i + 1;
-		tess.indexes[tess.numIndexes + 2] = tess.numVertexes + i + 2;
-		tess.numIndexes += 3;
+	if ( tess.indexPtr.p16 ) {
+		if ( tess.minIndex > numv )
+			tess.minIndex = numv;
+		if ( tess.maxIndex < numv + p->numVerts - 1 )
+			tess.maxIndex = numv + p->numVerts - 1;
+		
+		// generate fan indexes into the tess array
+		if ( tess.indexInc == sizeof(GLushort) ) {
+			GLushort	*indexPtr = tess.indexPtr.p16 + tess.numIndexes;
+			for ( i = 0; i < p->numVerts-2; i++ ) {
+				indexPtr[0] = (GLushort)numv;
+				indexPtr[1] = (GLushort)(numv + i + 1);
+				indexPtr[2] = (GLushort)(numv + i + 2);
+				indexPtr += 3;
+			}
+		} else {
+			GLuint		*indexPtr32 = tess.indexPtr.p32 + tess.numIndexes;
+			for ( i = 0; i < p->numVerts-2; i++ ) {
+				indexPtr32[0] = numv;
+				indexPtr32[1] = numv + i + 1;
+				indexPtr32[2] = numv+ i + 2;
+				indexPtr32 += 3;
+			}
+		}
 	}
-
-	tess.numVertexes = numv;
+	
+	tess.numVertexes += p->numVerts;
+	tess.numIndexes  += 3*(p->numVerts - 2);
 }
 
 
@@ -224,57 +277,73 @@
 RB_SurfaceTriangles
 =============
 */
-static void RB_SurfaceTriangles( srfTriangles_t *srf ) {
+static void RB_SurfaceTriangles( surfaceType_t *surface ) {
+	srfTriangles_t *srf = (srfTriangles_t *)surface;
 	int			i;
 	drawVert_t	*dv;
-	float		*xyz, *normal, *texCoords;
-	byte		*color;
 	int			dlightBits;
-	qboolean	needsNormal;
+	GLushort	*indexPtr;
+	GLuint		*indexPtr32;
+	vaWord1_t	*vertexPtr1;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
+	vaWord4_t	*vertexPtr4;
+	int             numv;
 
 	dlightBits = srf->dlightBits[backEnd.smpFrame];
 	tess.dlightBits |= dlightBits;
 
-	RB_CHECKOVERFLOW( srf->numVerts, srf->numIndexes );
-
-	for ( i = 0 ; i < srf->numIndexes ; i += 3 ) {
-		tess.indexes[ tess.numIndexes + i + 0 ] = tess.numVertexes + srf->indexes[ i + 0 ];
-		tess.indexes[ tess.numIndexes + i + 1 ] = tess.numVertexes + srf->indexes[ i + 1 ];
-		tess.indexes[ tess.numIndexes + i + 2 ] = tess.numVertexes + srf->indexes[ i + 2 ];
-	}
-	tess.numIndexes += srf->numIndexes;
+	if ( tess.vertexPtr1 ) {
+		numv = tess.numVertexes;
+		
+		vertexPtr1 = tess.vertexPtr1 + numv;
+		vertexPtr2 = tess.vertexPtr2 + numv;
+		vertexPtr3 = tess.vertexPtr3 + numv;
+		vertexPtr4 = tess.vertexPtr4 + numv;
 
-	dv = srf->verts;
-	xyz = tess.xyz[ tess.numVertexes ];
-	normal = tess.normal[ tess.numVertexes ];
-	texCoords = tess.texCoords[ tess.numVertexes ][0];
-	color = tess.vertexColors[ tess.numVertexes ];
-	needsNormal = tess.shader->needsNormal;
-
-	for ( i = 0 ; i < srf->numVerts ; i++, dv++, xyz += 4, normal += 4, texCoords += 4, color += 4 ) {
-		xyz[0] = dv->xyz[0];
-		xyz[1] = dv->xyz[1];
-		xyz[2] = dv->xyz[2];
-
-		if ( needsNormal ) {
-			normal[0] = dv->normal[0];
-			normal[1] = dv->normal[1];
-			normal[2] = dv->normal[2];
+		dv = srf->verts;
+		
+		for ( i = 0 ; i < srf->numVerts ; i++, dv++ ) {
+			VectorCopy( dv->xyz, *(vec3_t *)vertexPtr2->xyz );
+			VectorCopy( dv->normal, vertexPtr3->normal );
+			Vector2Copy( dv->st,       vertexPtr1->tc1 );
+			Vector2Copy( dv->lightmap, vertexPtr1->tc2 );
+			*(int *)&vertexPtr4->color = *(int *)dv->color;
+			vertexPtr2->fogNum = tess.fogNum;
+			vertexPtr1++;
+			vertexPtr2++;
+			vertexPtr3++;
+			vertexPtr4++;
 		}
-
-		texCoords[0] = dv->st[0];
-		texCoords[1] = dv->st[1];
-
-		texCoords[2] = dv->lightmap[0];
-		texCoords[3] = dv->lightmap[1];
-
-		*(int *)color = *(int *)dv->color;
+	} else {
+		numv = srf->vboStart;
 	}
 
-	for ( i = 0 ; i < srf->numVerts ; i++ ) {
-		tess.vertexDlightBits[ tess.numVertexes + i] = dlightBits;
+	if ( tess.indexPtr.p16 ) {
+		if ( tess.minIndex > numv )
+			tess.minIndex = numv;
+		if ( tess.maxIndex < numv + srf->numVerts - 1 )
+			tess.maxIndex = numv + srf->numVerts - 1;
+		
+		if ( tess.indexInc == sizeof(GLushort) ) {
+			indexPtr = tess.indexPtr.p16 + tess.numIndexes;
+			
+			for ( i = 0 ; i < srf->numIndexes ; i += 3 ) {
+				indexPtr[ i + 0 ] = (GLushort)(numv + srf->indexes[ i + 0 ]);
+				indexPtr[ i + 1 ] = (GLushort)(numv + srf->indexes[ i + 1 ]);
+				indexPtr[ i + 2 ] = (GLushort)(numv + srf->indexes[ i + 2 ]);
+			}
+		} else {
+			indexPtr32 = tess.indexPtr.p32 + tess.numIndexes;
+			for ( i = 0 ; i < srf->numIndexes ; i += 3 ) {
+				indexPtr32[ i + 0 ] = numv + srf->indexes[ i + 0 ];
+				indexPtr32[ i + 1 ] = numv + srf->indexes[ i + 1 ];
+				indexPtr32[ i + 2 ] = numv + srf->indexes[ i + 2 ];
+			}
+		}
 	}
 
+	tess.numIndexes += srf->numIndexes;
 	tess.numVertexes += srf->numVerts;
 }
 
@@ -285,15 +354,17 @@
 RB_SurfaceBeam
 ==============
 */
-static void RB_SurfaceBeam( void )
+static void RB_SurfaceBeam( void ) 
 {
 #define NUM_BEAM_SEGS 6
 	refEntity_t *e;
 	int	i;
 	vec3_t perpvec;
 	vec3_t direction, normalized_direction;
-	vec3_t	start_points[NUM_BEAM_SEGS], end_points[NUM_BEAM_SEGS];
+	vec3_t	points[2 * (NUM_BEAM_SEGS+1)];
+	vec3_t	*start_point, *end_point;
 	vec3_t oldorigin, origin;
+	glRenderState_t state;
 
 	e = &backEnd.currentEntity->e;
 
@@ -316,25 +387,32 @@
 
 	VectorScale( perpvec, 4, perpvec );
 
+	start_point = &points[0];
+	end_point = &points[1];
 	for ( i = 0; i < NUM_BEAM_SEGS ; i++ )
 	{
-		RotatePointAroundVector( start_points[i], normalized_direction, perpvec, (360.0/NUM_BEAM_SEGS)*i );
-//		VectorAdd( start_points[i], origin, start_points[i] );
-		VectorAdd( start_points[i], direction, end_points[i] );
+		RotatePointAroundVector( *start_point, normalized_direction, perpvec, (360.0/NUM_BEAM_SEGS)*i );
+//		VectorAdd( *start_point, origin, *start_point );
+		VectorAdd( *start_point, direction, *end_point );
+
+		start_point += 2; end_point += 2;
 	}
+	VectorCopy( points[0], *start_point );
+	VectorCopy( points[1], *end_point );
 
-	GL_Bind( tr.whiteImage );
+	InitState( &state );
 
-	GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE );
+	state.numImages = 1;
+	state.image[0] = tr.whiteImage;
 
-	qglColor3f( 1, 0, 0 );
+	state.stateBits = GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE;
 
-	qglBegin( GL_TRIANGLE_STRIP );
-	for ( i = 0; i <= NUM_BEAM_SEGS; i++ ) {
-		qglVertex3fv( start_points[ i % NUM_BEAM_SEGS] );
-		qglVertex3fv( end_points[ i % NUM_BEAM_SEGS] );
-	}
-	qglEnd();
+	SetAttrVec4f( &state, AL_COLOR, 0.0f, 0.0f, 0.0f, 1.0f );
+
+	SetAttrPointer( &state, AL_VERTEX, 0,
+			3, GL_FLOAT, sizeof(vec3_t),
+			points );
+	GL_DrawArrays( &state, GL_TRIANGLE_STRIP, 0, 2*(NUM_BEAM_SEGS+1) );
 }
 
 //================================================================================
@@ -345,51 +423,55 @@
 	int			vbase;
 	float		t = len / 256.0f;
 
-	vbase = tess.numVertexes;
-
 	spanWidth2 = -spanWidth;
 
-	// FIXME: use quad stamp?
-	VectorMA( start, spanWidth, up, tess.xyz[tess.numVertexes] );
-	tess.texCoords[tess.numVertexes][0][0] = 0;
-	tess.texCoords[tess.numVertexes][0][1] = 0;
-	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0] * 0.25;
-	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1] * 0.25;
-	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2] * 0.25;
-	tess.numVertexes++;
-
-	VectorMA( start, spanWidth2, up, tess.xyz[tess.numVertexes] );
-	tess.texCoords[tess.numVertexes][0][0] = 0;
-	tess.texCoords[tess.numVertexes][0][1] = 1;
-	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0];
-	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1];
-	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2];
-	tess.numVertexes++;
-
-	VectorMA( end, spanWidth, up, tess.xyz[tess.numVertexes] );
-
-	tess.texCoords[tess.numVertexes][0][0] = t;
-	tess.texCoords[tess.numVertexes][0][1] = 0;
-	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0];
-	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1];
-	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2];
-	tess.numVertexes++;
-
-	VectorMA( end, spanWidth2, up, tess.xyz[tess.numVertexes] );
-	tess.texCoords[tess.numVertexes][0][0] = t;
-	tess.texCoords[tess.numVertexes][0][1] = 1;
-	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0];
-	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1];
-	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2];
-	tess.numVertexes++;
-
-	tess.indexes[tess.numIndexes++] = vbase;
-	tess.indexes[tess.numIndexes++] = vbase + 1;
-	tess.indexes[tess.numIndexes++] = vbase + 2;
-
-	tess.indexes[tess.numIndexes++] = vbase + 2;
-	tess.indexes[tess.numIndexes++] = vbase + 1;
-	tess.indexes[tess.numIndexes++] = vbase + 3;
+	if ( tess.vertexPtr1 ) {
+		vbase = tess.numVertexes;
+		
+		// FIXME: use quad stamp?
+		VectorMA( start, spanWidth, up, tess.vertexPtr2[vbase].xyz );
+		tess.vertexPtr1[vbase].tc1[0] = 0;
+		tess.vertexPtr1[vbase].tc1[1] = 0;
+		tess.vertexPtr4[vbase].color[0] = backEnd.currentEntity->e.shaderRGBA[0] * 0.25;
+		tess.vertexPtr4[vbase].color[1] = backEnd.currentEntity->e.shaderRGBA[1] * 0.25;
+		tess.vertexPtr4[vbase].color[2] = backEnd.currentEntity->e.shaderRGBA[2] * 0.25;
+
+		VectorMA( start, spanWidth2, up, tess.vertexPtr2[vbase+1].xyz );
+		tess.vertexPtr1[vbase+1].tc1[0] = 0;
+		tess.vertexPtr1[vbase+1].tc1[1] = 1;
+		tess.vertexPtr4[vbase+1].color[0] = backEnd.currentEntity->e.shaderRGBA[0];
+		tess.vertexPtr4[vbase+1].color[1] = backEnd.currentEntity->e.shaderRGBA[1];
+		tess.vertexPtr4[vbase+1].color[2] = backEnd.currentEntity->e.shaderRGBA[2];
+		
+		VectorMA( start, spanWidth, up, tess.vertexPtr2[vbase+2].xyz );
+		tess.vertexPtr1[vbase+2].tc1[0] = t;
+		tess.vertexPtr1[vbase+2].tc1[1] = 0;
+		tess.vertexPtr4[vbase+2].color[0] = backEnd.currentEntity->e.shaderRGBA[0];
+		tess.vertexPtr4[vbase+2].color[1] = backEnd.currentEntity->e.shaderRGBA[1];
+		tess.vertexPtr4[vbase+2].color[2] = backEnd.currentEntity->e.shaderRGBA[2];
+		
+		VectorMA( start, spanWidth, up, tess.vertexPtr2[vbase+3].xyz );
+		tess.vertexPtr1[vbase+3].tc1[0] = t;
+		tess.vertexPtr1[vbase+3].tc1[1] = 1;
+		tess.vertexPtr4[vbase+3].color[0] = backEnd.currentEntity->e.shaderRGBA[0];
+		tess.vertexPtr4[vbase+3].color[1] = backEnd.currentEntity->e.shaderRGBA[1];
+		tess.vertexPtr4[vbase+3].color[2] = backEnd.currentEntity->e.shaderRGBA[2];
+	} else {
+		vbase = 0;
+	}
+	
+	if ( tess.indexPtr.p16 ) {
+		tess.indexPtr.p16[tess.numIndexes] = vbase;
+		tess.indexPtr.p16[tess.numIndexes+1] = vbase + 1;
+		tess.indexPtr.p16[tess.numIndexes+2] = vbase + 2;
+		
+		tess.indexPtr.p16[tess.numIndexes+3] = vbase + 2;
+		tess.indexPtr.p16[tess.numIndexes+4] = vbase + 1;
+		tess.indexPtr.p16[tess.numIndexes+5] = vbase + 3;
+	}
+
+	tess.numVertexes += 4;
+	tess.numIndexes += 6;
 }
 
 static void DoRailDiscs( int numSegs, const vec3_t start, const vec3_t dir, const vec3_t right, const vec3_t up )
@@ -398,16 +480,15 @@
 	vec3_t	pos[4];
 	vec3_t	v;
 	int		spanWidth = r_railWidth->integer;
+	int		vbase;
 	float c, s;
-	float		scale;
+	float		scale = 0.25;
 
 	if ( numSegs > 1 )
 		numSegs--;
 	if ( !numSegs )
 		return;
 
-	scale = 0.25;
-
 	for ( i = 0; i < 4; i++ )
 	{
 		c = cos( DEG2RAD( 45 + i * 90 ) );
@@ -424,32 +505,46 @@
 		}
 	}
 
-	for ( i = 0; i < numSegs; i++ )
-	{
-		int j;
-
-		RB_CHECKOVERFLOW( 4, 6 );
-
-		for ( j = 0; j < 4; j++ )
+	if ( tess.vertexPtr1 ) {
+		vbase = tess.numVertexes;
+		for ( i = 0; i < numSegs; i++ )
 		{
-			VectorCopy( pos[j], tess.xyz[tess.numVertexes] );
-			tess.texCoords[tess.numVertexes][0][0] = ( j < 2 );
-			tess.texCoords[tess.numVertexes][0][1] = ( j && j != 3 );
-			tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0];
-			tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1];
-			tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2];
-			tess.numVertexes++;
-
-			VectorAdd( pos[j], dir, pos[j] );
+			int j;
+			
+			for ( j = 0; j < 4; j++ )
+			{
+				VectorCopy( pos[j], tess.vertexPtr2[vbase].xyz );
+				tess.vertexPtr1[vbase].tc1[0] = ( j < 2 );
+				tess.vertexPtr1[vbase].tc1[1] = ( j && j != 3 );
+				tess.vertexPtr4[vbase].color[0] = backEnd.currentEntity->e.shaderRGBA[0];
+				tess.vertexPtr4[vbase].color[1] = backEnd.currentEntity->e.shaderRGBA[1];
+				tess.vertexPtr4[vbase].color[2] = backEnd.currentEntity->e.shaderRGBA[2];
+				vbase++;
+				
+				VectorAdd( pos[j], dir, pos[j] );
+			}
 		}
+		vbase = tess.numVertexes;
+	} else {
+		vbase = 0;
+	}
 
-		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 0;
-		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 1;
-		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 3;
-		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 3;
-		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 1;
-		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 2;
+	if ( tess.indexPtr.p16 ) {
+		for ( i = 0; i < numSegs; i++ )
+		{
+			int iwrite = tess.numIndexes;
+			tess.indexPtr.p16[iwrite++] = vbase + 0;
+			tess.indexPtr.p16[iwrite++] = vbase + 1;
+			tess.indexPtr.p16[iwrite++] = vbase + 3;
+			tess.indexPtr.p16[iwrite++] = vbase + 3;
+			tess.indexPtr.p16[iwrite++] = vbase + 1;
+			tess.indexPtr.p16[iwrite++] = vbase + 2;
+			vbase += 4;
+		}
 	}
+
+	tess.numVertexes += numSegs * 4;
+	tess.numIndexes += numSegs * 6;
 }
 
 /*
@@ -550,62 +645,6 @@
 	}
 }
 
-/*
-** VectorArrayNormalize
-*
-* The inputs to this routing seem to always be close to length = 1.0 (about 0.6 to 2.0)
-* This means that we don't have to worry about zero length or enormously long vectors.
-*/
-static void VectorArrayNormalize(vec4_t *normals, unsigned int count)
-{
-//    assert(count);
-        
-#if idppc
-    {
-        register float half = 0.5;
-        register float one  = 1.0;
-        float *components = (float *)normals;
-        
-        // Vanilla PPC code, but since PPC has a reciprocal square root estimate instruction,
-        // runs *much* faster than calling sqrt().  We'll use a single Newton-Raphson
-        // refinement step to get a little more precision.  This seems to yeild results
-        // that are correct to 3 decimal places and usually correct to at least 4 (sometimes 5).
-        // (That is, for the given input range of about 0.6 to 2.0).
-        do {
-            float x, y, z;
-            float B, y0, y1;
-            
-            x = components[0];
-            y = components[1];
-            z = components[2];
-            components += 4;
-            B = x*x + y*y + z*z;
-
-#ifdef __GNUC__            
-            asm("frsqrte %0,%1" : "=f" (y0) : "f" (B));
-#else
-			y0 = __frsqrte(B);
-#endif
-            y1 = y0 + half*y0*(one - B*y0*y0);
-
-            x = x * y1;
-            y = y * y1;
-            components[-4] = x;
-            z = z * y1;
-            components[-3] = y;
-            components[-2] = z;
-        } while(count--);
-    }
-#else // No assembly version for this architecture, or C_ONLY defined
-	// given the input, it's safe to call VectorNormalizeFast
-    while (count--) {
-        VectorNormalizeFast(normals[0]);
-        normals++;
-    }
-#endif
-
-}
-
 
 
 /*
@@ -624,8 +663,8 @@
 	unsigned lat, lng;
 	int		numVerts;
 
-	outXyz = tess.xyz[tess.numVertexes];
-	outNormal = tess.normal[tess.numVertexes];
+	vertexPtr2 = tess.vertexPtr2 + tess.numVertexes;
+	vertexPtr3 = tess.vertexPtr3 + tess.numVertexes;
 
 	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
 		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
@@ -657,8 +696,8 @@
 		// just copy the vertexes
 		//
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
-			newXyz += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+		       newXyz += 4, newNormals += 4,
+		       vertexPtr2++, vertexPtr3++ )
 		{
 			newNormalsLoadPermute = vec_lvsl(0,newXyz);
 			newNormalsStorePermute = vec_lvsr(0,outXyz);
@@ -682,13 +721,14 @@
 			// decode Y as sin( lat ) * sin( long )
 			// decode Z as cos( long )
 
-			outNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
-			outNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
-			outNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
-
-			vec_ste(newNormalsFloatVec,0,outXyz);
-			vec_ste(newNormalsFloatVec,4,outXyz);
-			vec_ste(newNormalsFloatVec,8,outXyz);
+			vertexPtr3->normal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
+			vertexPtr3->normal[1] = tr.sinTable[lat] * tr.sinTable[lng];
+			vertexPtr3->normal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+			vertexPtr3->reserved = 0.0f;
+
+			vec_ste(newNormalsFloatVec,0,vertexPtr2->xyz);
+			vec_ste(newNormalsFloatVec,4,vertexPtr2->xyz);
+			vec_ste(newNormalsFloatVec,8,vertexPtr2->xyz);
 		}
 	} else {
 		//
@@ -702,15 +742,15 @@
 		oldNormalScale = backlerp;
 
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
-			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+			     oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
+			     vertexPtr2++, vertexPtr3++ )
 		{
 			vec3_t uncompressedOldNormal, uncompressedNewNormal;
 
 			// interpolate the xyz
-			outXyz[0] = oldXyz[0] * oldXyzScale + newXyz[0] * newXyzScale;
-			outXyz[1] = oldXyz[1] * oldXyzScale + newXyz[1] * newXyzScale;
-			outXyz[2] = oldXyz[2] * oldXyzScale + newXyz[2] * newXyzScale;
+			vertexPtr2->xyz[0] = oldXyz[0] * oldXyzScale + newXyz[0] * newXyzScale;
+			vertexPtr2->xyz[1] = oldXyz[1] * oldXyzScale + newXyz[1] * newXyzScale;
+			vertexPtr2->xyz[2] = oldXyz[2] * oldXyzScale + newXyz[2] * newXyzScale;
 
 			// FIXME: interpolate lat/long instead?
 			lat = ( newNormals[0] >> 8 ) & 0xff;
@@ -730,13 +770,13 @@
 			uncompressedOldNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
 			uncompressedOldNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
 
-			outNormal[0] = uncompressedOldNormal[0] * oldNormalScale + uncompressedNewNormal[0] * newNormalScale;
-			outNormal[1] = uncompressedOldNormal[1] * oldNormalScale + uncompressedNewNormal[1] * newNormalScale;
-			outNormal[2] = uncompressedOldNormal[2] * oldNormalScale + uncompressedNewNormal[2] * newNormalScale;
+			vertexPtr3->normal[0] = uncompressedOldNormal[0] * oldNormalScale + uncompressedNewNormal[0] * newNormalScale;
+			vertexPtr3->normal[1] = uncompressedOldNormal[1] * oldNormalScale + uncompressedNewNormal[1] * newNormalScale;
+			vertexPtr3->normal[2] = uncompressedOldNormal[2] * oldNormalScale + uncompressedNewNormal[2] * newNormalScale;
+			vertexPtr3->reserved = 0.0f;
 
-//			VectorNormalize (outNormal);
+			VectorNormalize (vertexPtr3->normal);
 		}
-    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
    	}
 }
 #endif
@@ -744,15 +784,16 @@
 static void LerpMeshVertexes_scalar(md3Surface_t *surf, float backlerp)
 {
 	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
-	float	*outXyz, *outNormal;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
 	float	oldXyzScale, newXyzScale;
 	float	oldNormalScale, newNormalScale;
 	int		vertNum;
 	unsigned lat, lng;
 	int		numVerts;
 
-	outXyz = tess.xyz[tess.numVertexes];
-	outNormal = tess.normal[tess.numVertexes];
+	vertexPtr2 = tess.vertexPtr2 + tess.numVertexes;
+	vertexPtr3 = tess.vertexPtr3 + tess.numVertexes;
 
 	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
 		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
@@ -768,13 +809,13 @@
 		// just copy the vertexes
 		//
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
-			newXyz += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+			     newXyz += 4, newNormals += 4,
+			     vertexPtr2++, vertexPtr3++ )
 		{
 
-			outXyz[0] = newXyz[0] * newXyzScale;
-			outXyz[1] = newXyz[1] * newXyzScale;
-			outXyz[2] = newXyz[2] * newXyzScale;
+			vertexPtr2->xyz[0] = newXyz[0] * newXyzScale;
+			vertexPtr2->xyz[1] = newXyz[1] * newXyzScale;
+			vertexPtr2->xyz[2] = newXyz[2] * newXyzScale;
 
 			lat = ( newNormals[0] >> 8 ) & 0xff;
 			lng = ( newNormals[0] & 0xff );
@@ -785,9 +826,10 @@
 			// decode Y as sin( lat ) * sin( long )
 			// decode Z as cos( long )
 
-			outNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
-			outNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
-			outNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+			vertexPtr3->normal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
+			vertexPtr3->normal[1] = tr.sinTable[lat] * tr.sinTable[lng];
+			vertexPtr3->normal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+			vertexPtr3->reserved = 0.0f;
 		}
 	} else {
 		//
@@ -801,15 +843,15 @@
 		oldNormalScale = backlerp;
 
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
-			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+			     oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
+			     vertexPtr2++, vertexPtr3++ )
 		{
 			vec3_t uncompressedOldNormal, uncompressedNewNormal;
 
 			// interpolate the xyz
-			outXyz[0] = oldXyz[0] * oldXyzScale + newXyz[0] * newXyzScale;
-			outXyz[1] = oldXyz[1] * oldXyzScale + newXyz[1] * newXyzScale;
-			outXyz[2] = oldXyz[2] * oldXyzScale + newXyz[2] * newXyzScale;
+			vertexPtr2->xyz[0] = oldXyz[0] * oldXyzScale + newXyz[0] * newXyzScale;
+			vertexPtr2->xyz[1] = oldXyz[1] * oldXyzScale + newXyz[1] * newXyzScale;
+			vertexPtr2->xyz[2] = oldXyz[2] * oldXyzScale + newXyz[2] * newXyzScale;
 
 			// FIXME: interpolate lat/long instead?
 			lat = ( newNormals[0] >> 8 ) & 0xff;
@@ -829,13 +871,13 @@
 			uncompressedOldNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
 			uncompressedOldNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
 
-			outNormal[0] = uncompressedOldNormal[0] * oldNormalScale + uncompressedNewNormal[0] * newNormalScale;
-			outNormal[1] = uncompressedOldNormal[1] * oldNormalScale + uncompressedNewNormal[1] * newNormalScale;
-			outNormal[2] = uncompressedOldNormal[2] * oldNormalScale + uncompressedNewNormal[2] * newNormalScale;
+			vertexPtr3->normal[0] = uncompressedOldNormal[0] * oldNormalScale + uncompressedNewNormal[0] * newNormalScale;
+			vertexPtr3->normal[1] = uncompressedOldNormal[1] * oldNormalScale + uncompressedNewNormal[1] * newNormalScale;
+			vertexPtr3->normal[2] = uncompressedOldNormal[2] * oldNormalScale + uncompressedNewNormal[2] * newNormalScale;
+			vertexPtr3->reserved = 0.0f;
 
-//			VectorNormalize (outNormal);
+			VectorNormalize (vertexPtr3->normal);
 		}
-    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
    	}
 }
 
@@ -857,14 +899,18 @@
 RB_SurfaceMesh
 =============
 */
-static void RB_SurfaceMesh(md3Surface_t *surface) {
+void RB_SurfaceMesh( surfaceType_t *surf) {
+	md3Surface_t *surface = (md3Surface_t *)surf;
 	int				j;
 	float			backlerp;
 	int				*triangles;
 	float			*texCoords;
 	int				indexes;
-	int				Bob, Doug;
+	int				Doug;
 	int				numVerts;
+	vaWord1_t		*vertexPtr1;
+	vaWord2_t		*vertexPtr2;
+	vaWord4_t		*vertexPtr4;
 
 	if (  backEnd.currentEntity->e.oldframe == backEnd.currentEntity->e.frame ) {
 		backlerp = 0;
@@ -872,30 +918,52 @@
 		backlerp = backEnd.currentEntity->e.backlerp;
 	}
 
-	RB_CHECKOVERFLOW( surface->numVerts, surface->numTriangles*3 );
-
-	LerpMeshVertexes (surface, backlerp);
-
-	triangles = (int *) ((byte *)surface + surface->ofsTriangles);
-	indexes = surface->numTriangles * 3;
-	Bob = tess.numIndexes;
-	Doug = tess.numVertexes;
-	for (j = 0 ; j < indexes ; j++) {
-		tess.indexes[Bob + j] = Doug + triangles[j];
-	}
-	tess.numIndexes += indexes;
-
-	texCoords = (float *) ((byte *)surface + surface->ofsSt);
-
-	numVerts = surface->numVerts;
-	for ( j = 0; j < numVerts; j++ ) {
-		tess.texCoords[Doug + j][0][0] = texCoords[j*2+0];
-		tess.texCoords[Doug + j][0][1] = texCoords[j*2+1];
-		// FIXME: fill in lightmapST for completeness?
+	if ( tess.vertexPtr1 ) {
+		LerpMeshVertexes (surface, backlerp);
+		
+		Doug = tess.numVertexes;
+		texCoords = (float *) ((byte *)surface + surface->ofsSt);
+		vertexPtr1 = tess.vertexPtr1 + Doug;
+		vertexPtr2 = tess.vertexPtr2 + Doug;
+		vertexPtr4 = tess.vertexPtr4 + Doug;
+
+		numVerts = surface->numVerts;
+		for ( j = 0; j < numVerts; j++, vertexPtr1++, vertexPtr2++, vertexPtr4++ ) {
+			vertexPtr1->tc1[0] = vertexPtr1->tc2[0] = texCoords[j*2+0];
+			vertexPtr1->tc1[1] = vertexPtr1->tc2[1] = texCoords[j*2+1];
+			vertexPtr2->fogNum = tess.fogNum;
+			vertexPtr4->color[0] = 255;
+			vertexPtr4->color[1] = 255;
+			vertexPtr4->color[2] = 255;
+			vertexPtr4->color[3] = 255;
+		}
+	} else {
+		Doug = 0;
+	}
+	
+	if ( tess.indexPtr.p16 ) {
+		if ( tess.minIndex > Doug )
+			tess.minIndex = Doug;
+		if ( tess.maxIndex < Doug + surface->numVerts - 1 )
+			tess.maxIndex = Doug + surface->numVerts - 1;
+
+		triangles = (int *) ((byte *)surface + surface->ofsTriangles);
+		indexes = surface->numTriangles * 3;
+
+		if ( tess.indexInc == sizeof(GLushort) ) {
+			GLushort *indexPtr = tess.indexPtr.p16 + tess.numIndexes;
+			for (j = 0 ; j < indexes ; j++) {
+				*indexPtr++ = Doug + triangles[j];
+			}
+		} else {
+			GLuint *indexPtr32 = tess.indexPtr.p32 + tess.numIndexes;
+			for (j = 0 ; j < indexes ; j++) {
+				*indexPtr32++ = Doug + triangles[j];
+			}
+		}
 	}
-
 	tess.numVertexes += surface->numVerts;
-
+	tess.numIndexes  += 3*surface->numTriangles;
 }
 
 
@@ -904,56 +972,71 @@
 RB_SurfaceFace
 ==============
 */
-static void RB_SurfaceFace( srfSurfaceFace_t *surf ) {
+static void RB_SurfaceFace( surfaceType_t *surface ) {
+	srfSurfaceFace_t *surf = (srfSurfaceFace_t *)surface;
 	int			i;
-	unsigned	*indices, *tessIndexes;
+	unsigned	*indices;
 	float		*v;
-	float		*normal;
-	int			ndx;
 	int			Bob;
 	int			numPoints;
 	int			dlightBits;
-
-	RB_CHECKOVERFLOW( surf->numPoints, surf->numIndices );
+	vaWord1_t	*vertexPtr1;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
+	vaWord4_t	*vertexPtr4;
 
 	dlightBits = surf->dlightBits[backEnd.smpFrame];
 	tess.dlightBits |= dlightBits;
 
-	indices = ( unsigned * ) ( ( ( char  * ) surf ) + surf->ofsIndices );
-
-	Bob = tess.numVertexes;
-	tessIndexes = tess.indexes + tess.numIndexes;
-	for ( i = surf->numIndices-1 ; i >= 0  ; i-- ) {
-		tessIndexes[i] = indices[i] + Bob;
-	}
-
-	tess.numIndexes += surf->numIndices;
+	if ( tess.vertexPtr1 ) {
+		Bob = tess.numVertexes;
 
-	v = surf->points[0];
-
-	ndx = tess.numVertexes;
-
-	numPoints = surf->numPoints;
-
-	if ( tess.shader->needsNormal ) {
-		normal = surf->plane.normal;
-		for ( i = 0, ndx = tess.numVertexes; i < numPoints; i++, ndx++ ) {
-			VectorCopy( normal, tess.normal[ndx] );
+		v = surf->points[0];
+		
+		numPoints = surf->numPoints;
+		
+		vertexPtr1 = tess.vertexPtr1 + tess.numVertexes;
+		vertexPtr2 = tess.vertexPtr2 + tess.numVertexes;
+		vertexPtr3 = tess.vertexPtr3 + tess.numVertexes;
+		vertexPtr4 = tess.vertexPtr4 + tess.numVertexes;
+		
+		for ( i = 0, v = surf->points[0]; i < numPoints; i++, v += VERTEXSIZE,
+			      vertexPtr1++, vertexPtr2++, vertexPtr3++, vertexPtr4++ ) {
+			VectorCopy( surf->plane.normal, vertexPtr3->normal );
+			vertexPtr3->reserved = 0.0f;
+			
+			VectorCopy ( v, *(vec3_t *)&vertexPtr2->xyz);
+			vertexPtr2->fogNum = tess.fogNum;
+			Vector2Copy( v+3, vertexPtr1->tc1 );
+			Vector2Copy( v+5, vertexPtr1->tc2 );
+			*(unsigned int *)&vertexPtr4->color = *(unsigned int *)&v[7];
 		}
+	} else {
+		Bob = surf->vboStart;
 	}
 
-	for ( i = 0, v = surf->points[0], ndx = tess.numVertexes; i < numPoints; i++, v += VERTEXSIZE, ndx++ ) {
-		VectorCopy( v, tess.xyz[ndx]);
-		tess.texCoords[ndx][0][0] = v[3];
-		tess.texCoords[ndx][0][1] = v[4];
-		tess.texCoords[ndx][1][0] = v[5];
-		tess.texCoords[ndx][1][1] = v[6];
-		* ( unsigned int * ) &tess.vertexColors[ndx] = * ( unsigned int * ) &v[7];
-		tess.vertexDlightBits[ndx] = dlightBits;
+	if ( tess.indexPtr.p16 ) {
+		if ( tess.minIndex > Bob )
+			tess.minIndex = Bob;
+		if ( tess.maxIndex < Bob + surf->numPoints - 1 )
+			tess.maxIndex = Bob + surf->numPoints - 1;
+		
+		indices = ( unsigned * ) ( ( ( char  * ) surf ) + surf->ofsIndices );
+		if ( tess.indexInc == sizeof(GLushort) ) {
+			GLushort *indexPtr = tess.indexPtr.p16 + tess.numIndexes;
+			for ( i = surf->numIndices-1 ; i >= 0  ; i-- ) {
+				indexPtr[i] = (GLushort)(indices[i] + Bob);
+			}
+		} else {
+			GLuint *indexPtr32 = tess.indexPtr.p32 + tess.numIndexes;
+			for ( i = surf->numIndices-1 ; i >= 0  ; i-- ) {
+				indexPtr32[i] = indices[i] + Bob;
+			}
+		}
 	}
 
-
 	tess.numVertexes += surf->numPoints;
+	tess.numIndexes  += surf->numIndices;
 }
 
 
@@ -994,29 +1077,31 @@
 Just copy the grid of points and triangulate
 =============
 */
-static void RB_SurfaceGrid( srfGridMesh_t *cv ) {
+static void RB_SurfaceGrid( surfaceType_t *surface ) {
+	srfGridMesh_t *cv = (srfGridMesh_t *)surface;
 	int		i, j;
-	float	*xyz;
-	float	*texCoords;
-	float	*normal;
-	unsigned char *color;
+	vaWord1_t	*vertexPtr1;
+	vaWord2_t	*vertexPtr2;
+	vaWord3_t	*vertexPtr3;
+	vaWord4_t	*vertexPtr4;
 	drawVert_t	*dv;
-	int		rows, irows, vrows;
-	int		used;
 	int		widthTable[MAX_GRID_SIZE];
 	int		heightTable[MAX_GRID_SIZE];
 	float	lodError;
 	int		lodWidth, lodHeight;
-	int		numVertexes;
+	int		baseVertex;
 	int		dlightBits;
-	int		*vDlightBits;
-	qboolean	needsNormal;
 
 	dlightBits = cv->dlightBits[backEnd.smpFrame];
 	tess.dlightBits |= dlightBits;
 
 	// determine the allowable discrepance
-	lodError = LodErrorForVolume( cv->lodOrigin, cv->lodRadius );
+	if ( r_ext_vertex_buffer_object->integer ) {
+		// always render max res for VBOs
+		lodError = r_lodCurveError->value;
+	} else {
+		lodError = LodErrorForVolume( cv->lodOrigin, cv->lodRadius );
+	}
 
 	// determine which rows and columns of the subdivision
 	// we are actually going to use
@@ -1042,107 +1127,92 @@
 	heightTable[lodHeight] = cv->height-1;
 	lodHeight++;
 
-
-	// very large grids may have more points or indexes than can be fit
-	// in the tess structure, so we may have to issue it in multiple passes
-
-	used = 0;
-	rows = 0;
-	while ( used < lodHeight - 1 ) {
-		// see how many rows of both verts and indexes we can add without overflowing
-		do {
-			vrows = ( SHADER_MAX_VERTEXES - tess.numVertexes ) / lodWidth;
-			irows = ( SHADER_MAX_INDEXES - tess.numIndexes ) / ( lodWidth * 6 );
-
-			// if we don't have enough space for at least one strip, flush the buffer
-			if ( vrows < 2 || irows < 1 ) {
-				RB_EndSurface();
-				RB_BeginSurface(tess.shader, tess.fogNum );
-			} else {
-				break;
-			}
-		} while ( 1 );
+	if ( tess.vertexPtr1 ) {
+		baseVertex = tess.numVertexes;
+		vertexPtr1 = tess.vertexPtr1 + baseVertex;
+		vertexPtr2 = tess.vertexPtr2 + baseVertex;
+		vertexPtr3 = tess.vertexPtr3 + baseVertex;
+		vertexPtr4 = tess.vertexPtr4 + baseVertex;
 		
-		rows = irows;
-		if ( vrows < irows + 1 ) {
-			rows = vrows - 1;
-		}
-		if ( used + rows > lodHeight ) {
-			rows = lodHeight - used;
-		}
-
-		numVertexes = tess.numVertexes;
-
-		xyz = tess.xyz[numVertexes];
-		normal = tess.normal[numVertexes];
-		texCoords = tess.texCoords[numVertexes][0];
-		color = ( unsigned char * ) &tess.vertexColors[numVertexes];
-		vDlightBits = &tess.vertexDlightBits[numVertexes];
-		needsNormal = tess.shader->needsNormal;
-
-		for ( i = 0 ; i < rows ; i++ ) {
-			for ( j = 0 ; j < lodWidth ; j++ ) {
-				dv = cv->verts + heightTable[ used + i ] * cv->width
+		for ( i = 0 ; i < lodHeight ; i++ ) {
+			for ( j = 0 ; j < lodWidth ; j++,
+				      vertexPtr1++, vertexPtr2++,
+				      vertexPtr3++, vertexPtr4++ ) {
+				dv = cv->verts + heightTable[ i ] * cv->width
 					+ widthTable[ j ];
-
-				xyz[0] = dv->xyz[0];
-				xyz[1] = dv->xyz[1];
-				xyz[2] = dv->xyz[2];
-				texCoords[0] = dv->st[0];
-				texCoords[1] = dv->st[1];
-				texCoords[2] = dv->lightmap[0];
-				texCoords[3] = dv->lightmap[1];
-				if ( needsNormal ) {
-					normal[0] = dv->normal[0];
-					normal[1] = dv->normal[1];
-					normal[2] = dv->normal[2];
-				}
-				* ( unsigned int * ) color = * ( unsigned int * ) dv->color;
-				*vDlightBits++ = dlightBits;
-				xyz += 4;
-				normal += 4;
-				texCoords += 4;
-				color += 4;
+				
+				VectorCopy( dv->xyz, vertexPtr2->xyz );
+				Vector2Copy ( dv->st, vertexPtr1->tc1 );
+				Vector2Copy ( dv->lightmap, vertexPtr1->tc2 );
+				VectorCopy( dv->normal, vertexPtr3->normal );
+				vertexPtr3->reserved = 0.0f;
+				*(unsigned int *)&vertexPtr4->color = *(unsigned int *)dv->color;
+				vertexPtr2->fogNum = tess.fogNum;
 			}
 		}
-
+	} else {
+		baseVertex = cv->vboStart;
+	}
+	
+	if ( tess.indexPtr.p16 ) {
+		if ( tess.minIndex > baseVertex )
+			tess.minIndex = baseVertex;
+		if ( tess.maxIndex < baseVertex + lodWidth*lodHeight - 1 )
+			tess.maxIndex = baseVertex + lodWidth*lodHeight - 1;
 
 		// add the indexes
-		{
-			int		numIndexes;
-			int		w, h;
-
-			h = rows - 1;
-			w = lodWidth - 1;
-			numIndexes = tess.numIndexes;
+		int		w, h;
+		
+		h = lodHeight - 1;
+		w = lodWidth - 1;
+		
+		if ( tess.indexInc == sizeof(GLushort) ) {
+			GLushort *indexPtr = tess.indexPtr.p16 + tess.numIndexes;
 			for (i = 0 ; i < h ; i++) {
 				for (j = 0 ; j < w ; j++) {
 					int		v1, v2, v3, v4;
 			
 					// vertex order to be reckognized as tristrips
-					v1 = numVertexes + i*lodWidth + j + 1;
+					v1 = baseVertex + i*lodWidth + j + 1;
 					v2 = v1 - 1;
 					v3 = v2 + lodWidth;
 					v4 = v3 + 1;
-
-					tess.indexes[numIndexes] = v2;
-					tess.indexes[numIndexes+1] = v3;
-					tess.indexes[numIndexes+2] = v1;
 					
-					tess.indexes[numIndexes+3] = v1;
-					tess.indexes[numIndexes+4] = v3;
-					tess.indexes[numIndexes+5] = v4;
-					numIndexes += 6;
+					*indexPtr++ = v2;
+					*indexPtr++ = v3;
+					*indexPtr++ = v1;
+					
+					*indexPtr++ = v1;
+					*indexPtr++ = v3;
+					*indexPtr++ = v4;
+				}
+			}
+		} else {
+			GLuint *indexPtr32 = tess.indexPtr.p32 + tess.numIndexes;
+			for (i = 0 ; i < h ; i++) {
+				for (j = 0 ; j < w ; j++) {
+					int		v1, v2, v3, v4;
+					
+					// vertex order to be reckognized as tristrips
+					v1 = baseVertex + i*lodWidth + j + 1;
+					v2 = v1 - 1;
+					v3 = v2 + lodWidth;
+					v4 = v3 + 1;
+					
+					*indexPtr32++ = v2;
+					*indexPtr32++ = v3;
+					*indexPtr32++ = v1;
+					
+					*indexPtr32++ = v1;
+					*indexPtr32++ = v3;
+					*indexPtr32++ = v4;
 				}
 			}
-
-			tess.numIndexes = numIndexes;
 		}
-
-		tess.numVertexes += rows * lodWidth;
-
-		used += rows - 1;
 	}
+	
+	tess.numVertexes += lodWidth * lodHeight;
+	tess.numIndexes  += 6 * (lodWidth - 1) * (lodHeight - 1);
 }
 
 
@@ -1162,19 +1232,36 @@
 ===================
 */
 static void RB_SurfaceAxis( void ) {
-	GL_Bind( tr.whiteImage );
+	static vec3_t vertexes[6] = {
+		{  0,  0,  0 },
+		{ 16,  0,  0 },
+		{  0,  0,  0 },
+		{  0, 16,  0 },
+		{  0,  0,  0 },
+		{  0,  0, 16 }
+	};
+	static color4ub_t colors[6] = {
+		{ 255,   0,   0, 255 },
+		{ 255,   0,   0, 255 },
+		{   0, 255,   0, 255 },
+		{   0, 255,   0, 255 },
+		{   0,   0, 255, 255 },
+		{   0,   0, 255, 255 }
+	};
+	glRenderState_t state;
+
+	InitState( &state );
+
+	state.numImages = 1;
+	state.image[0] = tr.whiteImage;
 	qglLineWidth( 3 );
-	qglBegin( GL_LINES );
-	qglColor3f( 1,0,0 );
-	qglVertex3f( 0,0,0 );
-	qglVertex3f( 16,0,0 );
-	qglColor3f( 0,1,0 );
-	qglVertex3f( 0,0,0 );
-	qglVertex3f( 0,16,0 );
-	qglColor3f( 0,0,1 );
-	qglVertex3f( 0,0,0 );
-	qglVertex3f( 0,0,16 );
-	qglEnd();
+	SetAttrPointer( &state, AL_VERTEX, 0,
+			3, GL_FLOAT, 0,
+			vertexes );
+	SetAttrPointer( &state, AL_COLOR, 0,
+			4, GL_UNSIGNED_BYTE, sizeof(color4ub_t),
+			colors );
+	GL_DrawArrays( &state, GL_LINES, 0, 6 );
 	qglLineWidth( 1 );
 }
 
@@ -1211,39 +1298,47 @@
 	return;
 }
 
+static void RB_SurfaceMD3Texture( surfaceType_t *surf ) {
+}
+
 static void RB_SurfaceBad( surfaceType_t *surfType ) {
 	ri.Printf( PRINT_ALL, "Bad surface tesselated.\n" );
 }
 
-static void RB_SurfaceFlare(srfFlare_t *surf)
+static void RB_SurfaceFlare( surfaceType_t *surface )
 {
+	srfFlare_t *surf = (srfFlare_t *)surface;
+
 	if (r_flares->integer)
 		RB_AddFlare(surf, tess.fogNum, surf->origin, surf->color, surf->normal);
 }
 
-static void RB_SurfaceDisplayList( srfDisplayList_t *surf ) {
+static void RB_SurfaceDisplayList( surfaceType_t *surface ) {
+	srfDisplayList_t *surf = (srfDisplayList_t *)surface;
 	// all apropriate state must be set in RB_BeginSurface
 	// this isn't implemented yet...
 	qglCallList( surf->listNum );
 }
 
-static void RB_SurfaceSkip( void *surf ) {
+static void RB_SurfaceSkip( surfaceType_t *surf ) {
 }
 
 
-void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])( void *) = {
-	(void(*)(void*))RB_SurfaceBad,			// SF_BAD, 
-	(void(*)(void*))RB_SurfaceSkip,			// SF_SKIP, 
-	(void(*)(void*))RB_SurfaceFace,			// SF_FACE,
-	(void(*)(void*))RB_SurfaceGrid,			// SF_GRID,
-	(void(*)(void*))RB_SurfaceTriangles,		// SF_TRIANGLES,
-	(void(*)(void*))RB_SurfacePolychain,		// SF_POLY,
-	(void(*)(void*))RB_SurfaceMesh,			// SF_MD3,
-	(void(*)(void*))RB_SurfaceAnim,			// SF_MD4,
+void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])( surfaceType_t * ) = {
+	RB_SurfaceBad,			// SF_BAD, 
+	RB_SurfaceSkip,			// SF_SKIP, 
+	RB_SurfaceFace,			// SF_FACE,
+	RB_SurfaceGrid,			// SF_GRID,
+	RB_SurfaceTriangles,		// SF_TRIANGLES,
+	RB_SurfacePolychain,		// SF_POLY,
+	RB_SurfaceMesh,			// SF_MD3,
+	RB_SurfaceAnim,			// SF_MD4,
 #ifdef RAVENMD4
-	(void(*)(void*))RB_MDRSurfaceAnim,		// SF_MDR,
+	RB_MDRSurfaceAnim,		// SF_MDR,
 #endif
-	(void(*)(void*))RB_SurfaceFlare,		// SF_FLARE,
-	(void(*)(void*))RB_SurfaceEntity,		// SF_ENTITY
-	(void(*)(void*))RB_SurfaceDisplayList		// SF_DISPLAY_LIST
+	RB_IQMSurfaceAnim,		// SF_IQM,
+	RB_SurfaceFlare,		// SF_FLARE,
+	RB_SurfaceEntity,		// SF_ENTITY
+	RB_SurfaceDisplayList,		// SF_DISPLAY_LIST
+	RB_SurfaceMD3Texture		// SF_MD3_TEXTURE
 };
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_surface.c.orig tremulous-ggp1-src/src/renderer/tr_surface.c.orig
--- tremulous-ggp1-src.p/src/renderer/tr_surface.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_surface.c.orig	2012-07-19 04:25:20.321556051 +0200
@@ -0,0 +1,1249 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+// tr_surf.c
+#include "tr_local.h"
+#if idppc_altivec && !defined(MACOS_X)
+#include <altivec.h>
+#endif
+
+/*
+
+  THIS ENTIRE FILE IS BACK END
+
+backEnd.currentEntity will be valid.
+
+Tess_Begin has already been called for the surface's shader.
+
+The modelview matrix will be set.
+
+It is safe to actually issue drawing commands here if you don't want to
+use the shader system.
+*/
+
+
+//============================================================================
+
+
+/*
+==============
+RB_CheckOverflow
+==============
+*/
+void RB_CheckOverflow( int verts, int indexes ) {
+	if (tess.numVertexes + verts < SHADER_MAX_VERTEXES
+		&& tess.numIndexes + indexes < SHADER_MAX_INDEXES) {
+		return;
+	}
+
+	RB_EndSurface();
+
+	if ( verts >= SHADER_MAX_VERTEXES ) {
+		ri.Error(ERR_DROP, "RB_CheckOverflow: verts > MAX (%d > %d)", verts, SHADER_MAX_VERTEXES );
+	}
+	if ( indexes >= SHADER_MAX_INDEXES ) {
+		ri.Error(ERR_DROP, "RB_CheckOverflow: indices > MAX (%d > %d)", indexes, SHADER_MAX_INDEXES );
+	}
+
+	RB_BeginSurface(tess.shader, tess.fogNum );
+}
+
+
+/*
+==============
+RB_AddQuadStampExt
+==============
+*/
+void RB_AddQuadStampExt( vec3_t origin, vec3_t left, vec3_t up, byte *color, float s1, float t1, float s2, float t2 ) {
+	vec3_t		normal;
+	int			ndx;
+
+	RB_CHECKOVERFLOW( 4, 6 );
+
+	ndx = tess.numVertexes;
+
+	// triangle indexes for a simple quad
+	tess.indexes[ tess.numIndexes ] = ndx;
+	tess.indexes[ tess.numIndexes + 1 ] = ndx + 1;
+	tess.indexes[ tess.numIndexes + 2 ] = ndx + 3;
+
+	tess.indexes[ tess.numIndexes + 3 ] = ndx + 3;
+	tess.indexes[ tess.numIndexes + 4 ] = ndx + 1;
+	tess.indexes[ tess.numIndexes + 5 ] = ndx + 2;
+
+	tess.xyz[ndx][0] = origin[0] + left[0] + up[0];
+	tess.xyz[ndx][1] = origin[1] + left[1] + up[1];
+	tess.xyz[ndx][2] = origin[2] + left[2] + up[2];
+
+	tess.xyz[ndx+1][0] = origin[0] - left[0] + up[0];
+	tess.xyz[ndx+1][1] = origin[1] - left[1] + up[1];
+	tess.xyz[ndx+1][2] = origin[2] - left[2] + up[2];
+
+	tess.xyz[ndx+2][0] = origin[0] - left[0] - up[0];
+	tess.xyz[ndx+2][1] = origin[1] - left[1] - up[1];
+	tess.xyz[ndx+2][2] = origin[2] - left[2] - up[2];
+
+	tess.xyz[ndx+3][0] = origin[0] + left[0] - up[0];
+	tess.xyz[ndx+3][1] = origin[1] + left[1] - up[1];
+	tess.xyz[ndx+3][2] = origin[2] + left[2] - up[2];
+
+
+	// constant normal all the way around
+	VectorSubtract( vec3_origin, backEnd.viewParms.or.axis[0], normal );
+
+	tess.normal[ndx][0] = tess.normal[ndx+1][0] = tess.normal[ndx+2][0] = tess.normal[ndx+3][0] = normal[0];
+	tess.normal[ndx][1] = tess.normal[ndx+1][1] = tess.normal[ndx+2][1] = tess.normal[ndx+3][1] = normal[1];
+	tess.normal[ndx][2] = tess.normal[ndx+1][2] = tess.normal[ndx+2][2] = tess.normal[ndx+3][2] = normal[2];
+	
+	// standard square texture coordinates
+	tess.texCoords[ndx][0][0] = tess.texCoords[ndx][1][0] = s1;
+	tess.texCoords[ndx][0][1] = tess.texCoords[ndx][1][1] = t1;
+
+	tess.texCoords[ndx+1][0][0] = tess.texCoords[ndx+1][1][0] = s2;
+	tess.texCoords[ndx+1][0][1] = tess.texCoords[ndx+1][1][1] = t1;
+
+	tess.texCoords[ndx+2][0][0] = tess.texCoords[ndx+2][1][0] = s2;
+	tess.texCoords[ndx+2][0][1] = tess.texCoords[ndx+2][1][1] = t2;
+
+	tess.texCoords[ndx+3][0][0] = tess.texCoords[ndx+3][1][0] = s1;
+	tess.texCoords[ndx+3][0][1] = tess.texCoords[ndx+3][1][1] = t2;
+
+	// constant color all the way around
+	// should this be identity and let the shader specify from entity?
+	* ( unsigned int * ) &tess.vertexColors[ndx] = 
+	* ( unsigned int * ) &tess.vertexColors[ndx+1] = 
+	* ( unsigned int * ) &tess.vertexColors[ndx+2] = 
+	* ( unsigned int * ) &tess.vertexColors[ndx+3] = 
+		* ( unsigned int * )color;
+
+
+	tess.numVertexes += 4;
+	tess.numIndexes += 6;
+}
+
+/*
+==============
+RB_AddQuadStamp
+==============
+*/
+void RB_AddQuadStamp( vec3_t origin, vec3_t left, vec3_t up, byte *color ) {
+	RB_AddQuadStampExt( origin, left, up, color, 0, 0, 1, 1 );
+}
+
+/*
+==============
+RB_SurfaceSprite
+==============
+*/
+static void RB_SurfaceSprite( void ) {
+	vec3_t		left, up;
+	float		radius;
+
+	// calculate the xyz locations for the four corners
+	radius = backEnd.currentEntity->e.radius;
+	if ( backEnd.currentEntity->e.rotation == 0 ) {
+		VectorScale( backEnd.viewParms.or.axis[1], radius, left );
+		VectorScale( backEnd.viewParms.or.axis[2], radius, up );
+	} else {
+		float	s, c;
+		float	ang;
+		
+		ang = M_PI * backEnd.currentEntity->e.rotation / 180;
+		s = sin( ang );
+		c = cos( ang );
+
+		VectorScale( backEnd.viewParms.or.axis[1], c * radius, left );
+		VectorMA( left, -s * radius, backEnd.viewParms.or.axis[2], left );
+
+		VectorScale( backEnd.viewParms.or.axis[2], c * radius, up );
+		VectorMA( up, s * radius, backEnd.viewParms.or.axis[1], up );
+	}
+	if ( backEnd.viewParms.isMirror ) {
+		VectorSubtract( vec3_origin, left, left );
+	}
+
+	RB_AddQuadStamp( backEnd.currentEntity->e.origin, left, up, backEnd.currentEntity->e.shaderRGBA );
+}
+
+
+/*
+=============
+RB_SurfacePolychain
+=============
+*/
+static void RB_SurfacePolychain( srfPoly_t *p ) {
+	int		i;
+	int		numv;
+
+	RB_CHECKOVERFLOW( p->numVerts, 3*(p->numVerts - 2) );
+
+	// fan triangles into the tess array
+	numv = tess.numVertexes;
+	for ( i = 0; i < p->numVerts; i++ ) {
+		VectorCopy( p->verts[i].xyz, tess.xyz[numv] );
+		tess.texCoords[numv][0][0] = p->verts[i].st[0];
+		tess.texCoords[numv][0][1] = p->verts[i].st[1];
+		*(int *)&tess.vertexColors[numv] = *(int *)p->verts[ i ].modulate;
+
+		numv++;
+	}
+
+	// generate fan indexes into the tess array
+	for ( i = 0; i < p->numVerts-2; i++ ) {
+		tess.indexes[tess.numIndexes + 0] = tess.numVertexes;
+		tess.indexes[tess.numIndexes + 1] = tess.numVertexes + i + 1;
+		tess.indexes[tess.numIndexes + 2] = tess.numVertexes + i + 2;
+		tess.numIndexes += 3;
+	}
+
+	tess.numVertexes = numv;
+}
+
+
+/*
+=============
+RB_SurfaceTriangles
+=============
+*/
+static void RB_SurfaceTriangles( srfTriangles_t *srf ) {
+	int			i;
+	drawVert_t	*dv;
+	float		*xyz, *normal, *texCoords;
+	byte		*color;
+	int			dlightBits;
+	qboolean	needsNormal;
+
+	dlightBits = srf->dlightBits[backEnd.smpFrame];
+	tess.dlightBits |= dlightBits;
+
+	RB_CHECKOVERFLOW( srf->numVerts, srf->numIndexes );
+
+	for ( i = 0 ; i < srf->numIndexes ; i += 3 ) {
+		tess.indexes[ tess.numIndexes + i + 0 ] = tess.numVertexes + srf->indexes[ i + 0 ];
+		tess.indexes[ tess.numIndexes + i + 1 ] = tess.numVertexes + srf->indexes[ i + 1 ];
+		tess.indexes[ tess.numIndexes + i + 2 ] = tess.numVertexes + srf->indexes[ i + 2 ];
+	}
+	tess.numIndexes += srf->numIndexes;
+
+	dv = srf->verts;
+	xyz = tess.xyz[ tess.numVertexes ];
+	normal = tess.normal[ tess.numVertexes ];
+	texCoords = tess.texCoords[ tess.numVertexes ][0];
+	color = tess.vertexColors[ tess.numVertexes ];
+	needsNormal = tess.shader->needsNormal;
+
+	for ( i = 0 ; i < srf->numVerts ; i++, dv++, xyz += 4, normal += 4, texCoords += 4, color += 4 ) {
+		xyz[0] = dv->xyz[0];
+		xyz[1] = dv->xyz[1];
+		xyz[2] = dv->xyz[2];
+
+		if ( needsNormal ) {
+			normal[0] = dv->normal[0];
+			normal[1] = dv->normal[1];
+			normal[2] = dv->normal[2];
+		}
+
+		texCoords[0] = dv->st[0];
+		texCoords[1] = dv->st[1];
+
+		texCoords[2] = dv->lightmap[0];
+		texCoords[3] = dv->lightmap[1];
+
+		*(int *)color = *(int *)dv->color;
+	}
+
+	for ( i = 0 ; i < srf->numVerts ; i++ ) {
+		tess.vertexDlightBits[ tess.numVertexes + i] = dlightBits;
+	}
+
+	tess.numVertexes += srf->numVerts;
+}
+
+
+
+/*
+==============
+RB_SurfaceBeam
+==============
+*/
+static void RB_SurfaceBeam( void )
+{
+#define NUM_BEAM_SEGS 6
+	refEntity_t *e;
+	int	i;
+	vec3_t perpvec;
+	vec3_t direction, normalized_direction;
+	vec3_t	start_points[NUM_BEAM_SEGS], end_points[NUM_BEAM_SEGS];
+	vec3_t oldorigin, origin;
+
+	e = &backEnd.currentEntity->e;
+
+	oldorigin[0] = e->oldorigin[0];
+	oldorigin[1] = e->oldorigin[1];
+	oldorigin[2] = e->oldorigin[2];
+
+	origin[0] = e->origin[0];
+	origin[1] = e->origin[1];
+	origin[2] = e->origin[2];
+
+	normalized_direction[0] = direction[0] = oldorigin[0] - origin[0];
+	normalized_direction[1] = direction[1] = oldorigin[1] - origin[1];
+	normalized_direction[2] = direction[2] = oldorigin[2] - origin[2];
+
+	if ( VectorNormalize( normalized_direction ) == 0 )
+		return;
+
+	PerpendicularVector( perpvec, normalized_direction );
+
+	VectorScale( perpvec, 4, perpvec );
+
+	for ( i = 0; i < NUM_BEAM_SEGS ; i++ )
+	{
+		RotatePointAroundVector( start_points[i], normalized_direction, perpvec, (360.0/NUM_BEAM_SEGS)*i );
+//		VectorAdd( start_points[i], origin, start_points[i] );
+		VectorAdd( start_points[i], direction, end_points[i] );
+	}
+
+	GL_Bind( tr.whiteImage );
+
+	GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE );
+
+	qglColor3f( 1, 0, 0 );
+
+	qglBegin( GL_TRIANGLE_STRIP );
+	for ( i = 0; i <= NUM_BEAM_SEGS; i++ ) {
+		qglVertex3fv( start_points[ i % NUM_BEAM_SEGS] );
+		qglVertex3fv( end_points[ i % NUM_BEAM_SEGS] );
+	}
+	qglEnd();
+}
+
+//================================================================================
+
+static void DoRailCore( const vec3_t start, const vec3_t end, const vec3_t up, float len, float spanWidth )
+{
+	float		spanWidth2;
+	int			vbase;
+	float		t = len / 256.0f;
+
+	vbase = tess.numVertexes;
+
+	spanWidth2 = -spanWidth;
+
+	// FIXME: use quad stamp?
+	VectorMA( start, spanWidth, up, tess.xyz[tess.numVertexes] );
+	tess.texCoords[tess.numVertexes][0][0] = 0;
+	tess.texCoords[tess.numVertexes][0][1] = 0;
+	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0] * 0.25;
+	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1] * 0.25;
+	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2] * 0.25;
+	tess.numVertexes++;
+
+	VectorMA( start, spanWidth2, up, tess.xyz[tess.numVertexes] );
+	tess.texCoords[tess.numVertexes][0][0] = 0;
+	tess.texCoords[tess.numVertexes][0][1] = 1;
+	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0];
+	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1];
+	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2];
+	tess.numVertexes++;
+
+	VectorMA( end, spanWidth, up, tess.xyz[tess.numVertexes] );
+
+	tess.texCoords[tess.numVertexes][0][0] = t;
+	tess.texCoords[tess.numVertexes][0][1] = 0;
+	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0];
+	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1];
+	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2];
+	tess.numVertexes++;
+
+	VectorMA( end, spanWidth2, up, tess.xyz[tess.numVertexes] );
+	tess.texCoords[tess.numVertexes][0][0] = t;
+	tess.texCoords[tess.numVertexes][0][1] = 1;
+	tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0];
+	tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1];
+	tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2];
+	tess.numVertexes++;
+
+	tess.indexes[tess.numIndexes++] = vbase;
+	tess.indexes[tess.numIndexes++] = vbase + 1;
+	tess.indexes[tess.numIndexes++] = vbase + 2;
+
+	tess.indexes[tess.numIndexes++] = vbase + 2;
+	tess.indexes[tess.numIndexes++] = vbase + 1;
+	tess.indexes[tess.numIndexes++] = vbase + 3;
+}
+
+static void DoRailDiscs( int numSegs, const vec3_t start, const vec3_t dir, const vec3_t right, const vec3_t up )
+{
+	int i;
+	vec3_t	pos[4];
+	vec3_t	v;
+	int		spanWidth = r_railWidth->integer;
+	float c, s;
+	float		scale;
+
+	if ( numSegs > 1 )
+		numSegs--;
+	if ( !numSegs )
+		return;
+
+	scale = 0.25;
+
+	for ( i = 0; i < 4; i++ )
+	{
+		c = cos( DEG2RAD( 45 + i * 90 ) );
+		s = sin( DEG2RAD( 45 + i * 90 ) );
+		v[0] = ( right[0] * c + up[0] * s ) * scale * spanWidth;
+		v[1] = ( right[1] * c + up[1] * s ) * scale * spanWidth;
+		v[2] = ( right[2] * c + up[2] * s ) * scale * spanWidth;
+		VectorAdd( start, v, pos[i] );
+
+		if ( numSegs > 1 )
+		{
+			// offset by 1 segment if we're doing a long distance shot
+			VectorAdd( pos[i], dir, pos[i] );
+		}
+	}
+
+	for ( i = 0; i < numSegs; i++ )
+	{
+		int j;
+
+		RB_CHECKOVERFLOW( 4, 6 );
+
+		for ( j = 0; j < 4; j++ )
+		{
+			VectorCopy( pos[j], tess.xyz[tess.numVertexes] );
+			tess.texCoords[tess.numVertexes][0][0] = ( j < 2 );
+			tess.texCoords[tess.numVertexes][0][1] = ( j && j != 3 );
+			tess.vertexColors[tess.numVertexes][0] = backEnd.currentEntity->e.shaderRGBA[0];
+			tess.vertexColors[tess.numVertexes][1] = backEnd.currentEntity->e.shaderRGBA[1];
+			tess.vertexColors[tess.numVertexes][2] = backEnd.currentEntity->e.shaderRGBA[2];
+			tess.numVertexes++;
+
+			VectorAdd( pos[j], dir, pos[j] );
+		}
+
+		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 0;
+		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 1;
+		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 3;
+		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 3;
+		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 1;
+		tess.indexes[tess.numIndexes++] = tess.numVertexes - 4 + 2;
+	}
+}
+
+/*
+** RB_SurfaceRailRinges
+*/
+static void RB_SurfaceRailRings( void ) {
+	refEntity_t *e;
+	int			numSegs;
+	int			len;
+	vec3_t		vec;
+	vec3_t		right, up;
+	vec3_t		start, end;
+
+	e = &backEnd.currentEntity->e;
+
+	VectorCopy( e->oldorigin, start );
+	VectorCopy( e->origin, end );
+
+	// compute variables
+	VectorSubtract( end, start, vec );
+	len = VectorNormalize( vec );
+	MakeNormalVectors( vec, right, up );
+	numSegs = ( len ) / r_railSegmentLength->value;
+	if ( numSegs <= 0 ) {
+		numSegs = 1;
+	}
+
+	VectorScale( vec, r_railSegmentLength->value, vec );
+
+	DoRailDiscs( numSegs, start, vec, right, up );
+}
+
+/*
+** RB_SurfaceRailCore
+*/
+static void RB_SurfaceRailCore( void ) {
+	refEntity_t *e;
+	int			len;
+	vec3_t		right;
+	vec3_t		vec;
+	vec3_t		start, end;
+	vec3_t		v1, v2;
+
+	e = &backEnd.currentEntity->e;
+
+	VectorCopy( e->oldorigin, start );
+	VectorCopy( e->origin, end );
+
+	VectorSubtract( end, start, vec );
+	len = VectorNormalize( vec );
+
+	// compute side vector
+	VectorSubtract( start, backEnd.viewParms.or.origin, v1 );
+	VectorNormalize( v1 );
+	VectorSubtract( end, backEnd.viewParms.or.origin, v2 );
+	VectorNormalize( v2 );
+	CrossProduct( v1, v2, right );
+	VectorNormalize( right );
+
+	DoRailCore( start, end, right, len, r_railCoreWidth->integer );
+}
+
+/*
+** RB_SurfaceLightningBolt
+*/
+static void RB_SurfaceLightningBolt( void ) {
+	refEntity_t *e;
+	int			len;
+	vec3_t		right;
+	vec3_t		vec;
+	vec3_t		start, end;
+	vec3_t		v1, v2;
+	int			i;
+
+	e = &backEnd.currentEntity->e;
+
+	VectorCopy( e->oldorigin, end );
+	VectorCopy( e->origin, start );
+
+	// compute variables
+	VectorSubtract( end, start, vec );
+	len = VectorNormalize( vec );
+
+	// compute side vector
+	VectorSubtract( start, backEnd.viewParms.or.origin, v1 );
+	VectorNormalize( v1 );
+	VectorSubtract( end, backEnd.viewParms.or.origin, v2 );
+	VectorNormalize( v2 );
+	CrossProduct( v1, v2, right );
+	VectorNormalize( right );
+
+	for ( i = 0 ; i < 4 ; i++ ) {
+		vec3_t	temp;
+
+		DoRailCore( start, end, right, len, 8 );
+		RotatePointAroundVector( temp, vec, right, 45 );
+		VectorCopy( temp, right );
+	}
+}
+
+/*
+** VectorArrayNormalize
+*
+* The inputs to this routing seem to always be close to length = 1.0 (about 0.6 to 2.0)
+* This means that we don't have to worry about zero length or enormously long vectors.
+*/
+static void VectorArrayNormalize(vec4_t *normals, unsigned int count)
+{
+//    assert(count);
+        
+#if idppc
+    {
+        register float half = 0.5;
+        register float one  = 1.0;
+        float *components = (float *)normals;
+        
+        // Vanilla PPC code, but since PPC has a reciprocal square root estimate instruction,
+        // runs *much* faster than calling sqrt().  We'll use a single Newton-Raphson
+        // refinement step to get a little more precision.  This seems to yeild results
+        // that are correct to 3 decimal places and usually correct to at least 4 (sometimes 5).
+        // (That is, for the given input range of about 0.6 to 2.0).
+        do {
+            float x, y, z;
+            float B, y0, y1;
+            
+            x = components[0];
+            y = components[1];
+            z = components[2];
+            components += 4;
+            B = x*x + y*y + z*z;
+
+#ifdef __GNUC__            
+            asm("frsqrte %0,%1" : "=f" (y0) : "f" (B));
+#else
+			y0 = __frsqrte(B);
+#endif
+            y1 = y0 + half*y0*(one - B*y0*y0);
+
+            x = x * y1;
+            y = y * y1;
+            components[-4] = x;
+            z = z * y1;
+            components[-3] = y;
+            components[-2] = z;
+        } while(count--);
+    }
+#else // No assembly version for this architecture, or C_ONLY defined
+	// given the input, it's safe to call VectorNormalizeFast
+    while (count--) {
+        VectorNormalizeFast(normals[0]);
+        normals++;
+    }
+#endif
+
+}
+
+
+
+/*
+** LerpMeshVertexes
+*/
+#if idppc_altivec
+static void LerpMeshVertexes_altivec(md3Surface_t *surf, float backlerp)
+{
+	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
+	float	*outXyz, *outNormal;
+	float	oldXyzScale QALIGN(16);
+	float   newXyzScale QALIGN(16);
+	float	oldNormalScale QALIGN(16);
+	float newNormalScale QALIGN(16);
+	int		vertNum;
+	unsigned lat, lng;
+	int		numVerts;
+
+	outXyz = tess.xyz[tess.numVertexes];
+	outNormal = tess.normal[tess.numVertexes];
+
+	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
+		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
+	newNormals = newXyz + 3;
+
+	newXyzScale = MD3_XYZ_SCALE * (1.0 - backlerp);
+	newNormalScale = 1.0 - backlerp;
+
+	numVerts = surf->numVerts;
+
+	if ( backlerp == 0 ) {
+		vector signed short newNormalsVec0;
+		vector signed short newNormalsVec1;
+		vector signed int newNormalsIntVec;
+		vector float newNormalsFloatVec;
+		vector float newXyzScaleVec;
+		vector unsigned char newNormalsLoadPermute;
+		vector unsigned char newNormalsStorePermute;
+		vector float zero;
+		
+		newNormalsStorePermute = vec_lvsl(0,(float *)&newXyzScaleVec);
+		newXyzScaleVec = *(vector float *)&newXyzScale;
+		newXyzScaleVec = vec_perm(newXyzScaleVec,newXyzScaleVec,newNormalsStorePermute);
+		newXyzScaleVec = vec_splat(newXyzScaleVec,0);		
+		newNormalsLoadPermute = vec_lvsl(0,newXyz);
+		newNormalsStorePermute = vec_lvsr(0,outXyz);
+		zero = (vector float)vec_splat_s8(0);
+		//
+		// just copy the vertexes
+		//
+		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
+			newXyz += 4, newNormals += 4,
+			outXyz += 4, outNormal += 4) 
+		{
+			newNormalsLoadPermute = vec_lvsl(0,newXyz);
+			newNormalsStorePermute = vec_lvsr(0,outXyz);
+			newNormalsVec0 = vec_ld(0,newXyz);
+			newNormalsVec1 = vec_ld(16,newXyz);
+			newNormalsVec0 = vec_perm(newNormalsVec0,newNormalsVec1,newNormalsLoadPermute);
+			newNormalsIntVec = vec_unpackh(newNormalsVec0);
+			newNormalsFloatVec = vec_ctf(newNormalsIntVec,0);
+			newNormalsFloatVec = vec_madd(newNormalsFloatVec,newXyzScaleVec,zero);
+			newNormalsFloatVec = vec_perm(newNormalsFloatVec,newNormalsFloatVec,newNormalsStorePermute);
+			//outXyz[0] = newXyz[0] * newXyzScale;
+			//outXyz[1] = newXyz[1] * newXyzScale;
+			//outXyz[2] = newXyz[2] * newXyzScale;
+
+			lat = ( newNormals[0] >> 8 ) & 0xff;
+			lng = ( newNormals[0] & 0xff );
+			lat *= (FUNCTABLE_SIZE/256);
+			lng *= (FUNCTABLE_SIZE/256);
+
+			// decode X as cos( lat ) * sin( long )
+			// decode Y as sin( lat ) * sin( long )
+			// decode Z as cos( long )
+
+			outNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
+			outNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
+			outNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+
+			vec_ste(newNormalsFloatVec,0,outXyz);
+			vec_ste(newNormalsFloatVec,4,outXyz);
+			vec_ste(newNormalsFloatVec,8,outXyz);
+		}
+	} else {
+		//
+		// interpolate and copy the vertex and normal
+		//
+		oldXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
+			+ (backEnd.currentEntity->e.oldframe * surf->numVerts * 4);
+		oldNormals = oldXyz + 3;
+
+		oldXyzScale = MD3_XYZ_SCALE * backlerp;
+		oldNormalScale = backlerp;
+
+		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
+			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
+			outXyz += 4, outNormal += 4) 
+		{
+			vec3_t uncompressedOldNormal, uncompressedNewNormal;
+
+			// interpolate the xyz
+			outXyz[0] = oldXyz[0] * oldXyzScale + newXyz[0] * newXyzScale;
+			outXyz[1] = oldXyz[1] * oldXyzScale + newXyz[1] * newXyzScale;
+			outXyz[2] = oldXyz[2] * oldXyzScale + newXyz[2] * newXyzScale;
+
+			// FIXME: interpolate lat/long instead?
+			lat = ( newNormals[0] >> 8 ) & 0xff;
+			lng = ( newNormals[0] & 0xff );
+			lat *= 4;
+			lng *= 4;
+			uncompressedNewNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
+			uncompressedNewNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
+			uncompressedNewNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+
+			lat = ( oldNormals[0] >> 8 ) & 0xff;
+			lng = ( oldNormals[0] & 0xff );
+			lat *= 4;
+			lng *= 4;
+
+			uncompressedOldNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
+			uncompressedOldNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
+			uncompressedOldNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+
+			outNormal[0] = uncompressedOldNormal[0] * oldNormalScale + uncompressedNewNormal[0] * newNormalScale;
+			outNormal[1] = uncompressedOldNormal[1] * oldNormalScale + uncompressedNewNormal[1] * newNormalScale;
+			outNormal[2] = uncompressedOldNormal[2] * oldNormalScale + uncompressedNewNormal[2] * newNormalScale;
+
+//			VectorNormalize (outNormal);
+		}
+    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
+   	}
+}
+#endif
+
+static void LerpMeshVertexes_scalar(md3Surface_t *surf, float backlerp)
+{
+	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
+	float	*outXyz, *outNormal;
+	float	oldXyzScale, newXyzScale;
+	float	oldNormalScale, newNormalScale;
+	int		vertNum;
+	unsigned lat, lng;
+	int		numVerts;
+
+	outXyz = tess.xyz[tess.numVertexes];
+	outNormal = tess.normal[tess.numVertexes];
+
+	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
+		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
+	newNormals = newXyz + 3;
+
+	newXyzScale = MD3_XYZ_SCALE * (1.0 - backlerp);
+	newNormalScale = 1.0 - backlerp;
+
+	numVerts = surf->numVerts;
+
+	if ( backlerp == 0 ) {
+		//
+		// just copy the vertexes
+		//
+		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
+			newXyz += 4, newNormals += 4,
+			outXyz += 4, outNormal += 4) 
+		{
+
+			outXyz[0] = newXyz[0] * newXyzScale;
+			outXyz[1] = newXyz[1] * newXyzScale;
+			outXyz[2] = newXyz[2] * newXyzScale;
+
+			lat = ( newNormals[0] >> 8 ) & 0xff;
+			lng = ( newNormals[0] & 0xff );
+			lat *= (FUNCTABLE_SIZE/256);
+			lng *= (FUNCTABLE_SIZE/256);
+
+			// decode X as cos( lat ) * sin( long )
+			// decode Y as sin( lat ) * sin( long )
+			// decode Z as cos( long )
+
+			outNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
+			outNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
+			outNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+		}
+	} else {
+		//
+		// interpolate and copy the vertex and normal
+		//
+		oldXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
+			+ (backEnd.currentEntity->e.oldframe * surf->numVerts * 4);
+		oldNormals = oldXyz + 3;
+
+		oldXyzScale = MD3_XYZ_SCALE * backlerp;
+		oldNormalScale = backlerp;
+
+		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
+			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
+			outXyz += 4, outNormal += 4) 
+		{
+			vec3_t uncompressedOldNormal, uncompressedNewNormal;
+
+			// interpolate the xyz
+			outXyz[0] = oldXyz[0] * oldXyzScale + newXyz[0] * newXyzScale;
+			outXyz[1] = oldXyz[1] * oldXyzScale + newXyz[1] * newXyzScale;
+			outXyz[2] = oldXyz[2] * oldXyzScale + newXyz[2] * newXyzScale;
+
+			// FIXME: interpolate lat/long instead?
+			lat = ( newNormals[0] >> 8 ) & 0xff;
+			lng = ( newNormals[0] & 0xff );
+			lat *= 4;
+			lng *= 4;
+			uncompressedNewNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
+			uncompressedNewNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
+			uncompressedNewNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+
+			lat = ( oldNormals[0] >> 8 ) & 0xff;
+			lng = ( oldNormals[0] & 0xff );
+			lat *= 4;
+			lng *= 4;
+
+			uncompressedOldNormal[0] = tr.sinTable[(lat+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK] * tr.sinTable[lng];
+			uncompressedOldNormal[1] = tr.sinTable[lat] * tr.sinTable[lng];
+			uncompressedOldNormal[2] = tr.sinTable[(lng+(FUNCTABLE_SIZE/4))&FUNCTABLE_MASK];
+
+			outNormal[0] = uncompressedOldNormal[0] * oldNormalScale + uncompressedNewNormal[0] * newNormalScale;
+			outNormal[1] = uncompressedOldNormal[1] * oldNormalScale + uncompressedNewNormal[1] * newNormalScale;
+			outNormal[2] = uncompressedOldNormal[2] * oldNormalScale + uncompressedNewNormal[2] * newNormalScale;
+
+//			VectorNormalize (outNormal);
+		}
+    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
+   	}
+}
+
+static void LerpMeshVertexes(md3Surface_t *surf, float backlerp)
+{
+#if idppc_altivec
+	if (com_altivec->integer) {
+		// must be in a seperate function or G3 systems will crash.
+		LerpMeshVertexes_altivec( surf, backlerp );
+		return;
+	}
+#endif // idppc_altivec
+	LerpMeshVertexes_scalar( surf, backlerp );
+}
+
+
+/*
+=============
+RB_SurfaceMesh
+=============
+*/
+static void RB_SurfaceMesh(md3Surface_t *surface) {
+	int				j;
+	float			backlerp;
+	int				*triangles;
+	float			*texCoords;
+	int				indexes;
+	int				Bob, Doug;
+	int				numVerts;
+
+	if (  backEnd.currentEntity->e.oldframe == backEnd.currentEntity->e.frame ) {
+		backlerp = 0;
+	} else  {
+		backlerp = backEnd.currentEntity->e.backlerp;
+	}
+
+	RB_CHECKOVERFLOW( surface->numVerts, surface->numTriangles*3 );
+
+	LerpMeshVertexes (surface, backlerp);
+
+	triangles = (int *) ((byte *)surface + surface->ofsTriangles);
+	indexes = surface->numTriangles * 3;
+	Bob = tess.numIndexes;
+	Doug = tess.numVertexes;
+	for (j = 0 ; j < indexes ; j++) {
+		tess.indexes[Bob + j] = Doug + triangles[j];
+	}
+	tess.numIndexes += indexes;
+
+	texCoords = (float *) ((byte *)surface + surface->ofsSt);
+
+	numVerts = surface->numVerts;
+	for ( j = 0; j < numVerts; j++ ) {
+		tess.texCoords[Doug + j][0][0] = texCoords[j*2+0];
+		tess.texCoords[Doug + j][0][1] = texCoords[j*2+1];
+		// FIXME: fill in lightmapST for completeness?
+	}
+
+	tess.numVertexes += surface->numVerts;
+
+}
+
+
+/*
+==============
+RB_SurfaceFace
+==============
+*/
+static void RB_SurfaceFace( srfSurfaceFace_t *surf ) {
+	int			i;
+	unsigned	*indices, *tessIndexes;
+	float		*v;
+	float		*normal;
+	int			ndx;
+	int			Bob;
+	int			numPoints;
+	int			dlightBits;
+
+	RB_CHECKOVERFLOW( surf->numPoints, surf->numIndices );
+
+	dlightBits = surf->dlightBits[backEnd.smpFrame];
+	tess.dlightBits |= dlightBits;
+
+	indices = ( unsigned * ) ( ( ( char  * ) surf ) + surf->ofsIndices );
+
+	Bob = tess.numVertexes;
+	tessIndexes = tess.indexes + tess.numIndexes;
+	for ( i = surf->numIndices-1 ; i >= 0  ; i-- ) {
+		tessIndexes[i] = indices[i] + Bob;
+	}
+
+	tess.numIndexes += surf->numIndices;
+
+	v = surf->points[0];
+
+	ndx = tess.numVertexes;
+
+	numPoints = surf->numPoints;
+
+	if ( tess.shader->needsNormal ) {
+		normal = surf->plane.normal;
+		for ( i = 0, ndx = tess.numVertexes; i < numPoints; i++, ndx++ ) {
+			VectorCopy( normal, tess.normal[ndx] );
+		}
+	}
+
+	for ( i = 0, v = surf->points[0], ndx = tess.numVertexes; i < numPoints; i++, v += VERTEXSIZE, ndx++ ) {
+		VectorCopy( v, tess.xyz[ndx]);
+		tess.texCoords[ndx][0][0] = v[3];
+		tess.texCoords[ndx][0][1] = v[4];
+		tess.texCoords[ndx][1][0] = v[5];
+		tess.texCoords[ndx][1][1] = v[6];
+		* ( unsigned int * ) &tess.vertexColors[ndx] = * ( unsigned int * ) &v[7];
+		tess.vertexDlightBits[ndx] = dlightBits;
+	}
+
+
+	tess.numVertexes += surf->numPoints;
+}
+
+
+static float	LodErrorForVolume( vec3_t local, float radius ) {
+	vec3_t		world;
+	float		d;
+
+	// never let it go negative
+	if ( r_lodCurveError->value < 0 ) {
+		return 0;
+	}
+
+	world[0] = local[0] * backEnd.or.axis[0][0] + local[1] * backEnd.or.axis[1][0] + 
+		local[2] * backEnd.or.axis[2][0] + backEnd.or.origin[0];
+	world[1] = local[0] * backEnd.or.axis[0][1] + local[1] * backEnd.or.axis[1][1] + 
+		local[2] * backEnd.or.axis[2][1] + backEnd.or.origin[1];
+	world[2] = local[0] * backEnd.or.axis[0][2] + local[1] * backEnd.or.axis[1][2] + 
+		local[2] * backEnd.or.axis[2][2] + backEnd.or.origin[2];
+
+	VectorSubtract( world, backEnd.viewParms.or.origin, world );
+	d = DotProduct( world, backEnd.viewParms.or.axis[0] );
+
+	if ( d < 0 ) {
+		d = -d;
+	}
+	d -= radius;
+	if ( d < 1 ) {
+		d = 1;
+	}
+
+	return r_lodCurveError->value / d;
+}
+
+/*
+=============
+RB_SurfaceGrid
+
+Just copy the grid of points and triangulate
+=============
+*/
+static void RB_SurfaceGrid( srfGridMesh_t *cv ) {
+	int		i, j;
+	float	*xyz;
+	float	*texCoords;
+	float	*normal;
+	unsigned char *color;
+	drawVert_t	*dv;
+	int		rows, irows, vrows;
+	int		used;
+	int		widthTable[MAX_GRID_SIZE];
+	int		heightTable[MAX_GRID_SIZE];
+	float	lodError;
+	int		lodWidth, lodHeight;
+	int		numVertexes;
+	int		dlightBits;
+	int		*vDlightBits;
+	qboolean	needsNormal;
+
+	dlightBits = cv->dlightBits[backEnd.smpFrame];
+	tess.dlightBits |= dlightBits;
+
+	// determine the allowable discrepance
+	lodError = LodErrorForVolume( cv->lodOrigin, cv->lodRadius );
+
+	// determine which rows and columns of the subdivision
+	// we are actually going to use
+	widthTable[0] = 0;
+	lodWidth = 1;
+	for ( i = 1 ; i < cv->width-1 ; i++ ) {
+		if ( cv->widthLodError[i] <= lodError ) {
+			widthTable[lodWidth] = i;
+			lodWidth++;
+		}
+	}
+	widthTable[lodWidth] = cv->width-1;
+	lodWidth++;
+
+	heightTable[0] = 0;
+	lodHeight = 1;
+	for ( i = 1 ; i < cv->height-1 ; i++ ) {
+		if ( cv->heightLodError[i] <= lodError ) {
+			heightTable[lodHeight] = i;
+			lodHeight++;
+		}
+	}
+	heightTable[lodHeight] = cv->height-1;
+	lodHeight++;
+
+
+	// very large grids may have more points or indexes than can be fit
+	// in the tess structure, so we may have to issue it in multiple passes
+
+	used = 0;
+	rows = 0;
+	while ( used < lodHeight - 1 ) {
+		// see how many rows of both verts and indexes we can add without overflowing
+		do {
+			vrows = ( SHADER_MAX_VERTEXES - tess.numVertexes ) / lodWidth;
+			irows = ( SHADER_MAX_INDEXES - tess.numIndexes ) / ( lodWidth * 6 );
+
+			// if we don't have enough space for at least one strip, flush the buffer
+			if ( vrows < 2 || irows < 1 ) {
+				RB_EndSurface();
+				RB_BeginSurface(tess.shader, tess.fogNum );
+			} else {
+				break;
+			}
+		} while ( 1 );
+		
+		rows = irows;
+		if ( vrows < irows + 1 ) {
+			rows = vrows - 1;
+		}
+		if ( used + rows > lodHeight ) {
+			rows = lodHeight - used;
+		}
+
+		numVertexes = tess.numVertexes;
+
+		xyz = tess.xyz[numVertexes];
+		normal = tess.normal[numVertexes];
+		texCoords = tess.texCoords[numVertexes][0];
+		color = ( unsigned char * ) &tess.vertexColors[numVertexes];
+		vDlightBits = &tess.vertexDlightBits[numVertexes];
+		needsNormal = tess.shader->needsNormal;
+
+		for ( i = 0 ; i < rows ; i++ ) {
+			for ( j = 0 ; j < lodWidth ; j++ ) {
+				dv = cv->verts + heightTable[ used + i ] * cv->width
+					+ widthTable[ j ];
+
+				xyz[0] = dv->xyz[0];
+				xyz[1] = dv->xyz[1];
+				xyz[2] = dv->xyz[2];
+				texCoords[0] = dv->st[0];
+				texCoords[1] = dv->st[1];
+				texCoords[2] = dv->lightmap[0];
+				texCoords[3] = dv->lightmap[1];
+				if ( needsNormal ) {
+					normal[0] = dv->normal[0];
+					normal[1] = dv->normal[1];
+					normal[2] = dv->normal[2];
+				}
+				* ( unsigned int * ) color = * ( unsigned int * ) dv->color;
+				*vDlightBits++ = dlightBits;
+				xyz += 4;
+				normal += 4;
+				texCoords += 4;
+				color += 4;
+			}
+		}
+
+
+		// add the indexes
+		{
+			int		numIndexes;
+			int		w, h;
+
+			h = rows - 1;
+			w = lodWidth - 1;
+			numIndexes = tess.numIndexes;
+			for (i = 0 ; i < h ; i++) {
+				for (j = 0 ; j < w ; j++) {
+					int		v1, v2, v3, v4;
+			
+					// vertex order to be reckognized as tristrips
+					v1 = numVertexes + i*lodWidth + j + 1;
+					v2 = v1 - 1;
+					v3 = v2 + lodWidth;
+					v4 = v3 + 1;
+
+					tess.indexes[numIndexes] = v2;
+					tess.indexes[numIndexes+1] = v3;
+					tess.indexes[numIndexes+2] = v1;
+					
+					tess.indexes[numIndexes+3] = v1;
+					tess.indexes[numIndexes+4] = v3;
+					tess.indexes[numIndexes+5] = v4;
+					numIndexes += 6;
+				}
+			}
+
+			tess.numIndexes = numIndexes;
+		}
+
+		tess.numVertexes += rows * lodWidth;
+
+		used += rows - 1;
+	}
+}
+
+
+/*
+===========================================================================
+
+NULL MODEL
+
+===========================================================================
+*/
+
+/*
+===================
+RB_SurfaceAxis
+
+Draws x/y/z lines from the origin for orientation debugging
+===================
+*/
+static void RB_SurfaceAxis( void ) {
+	GL_Bind( tr.whiteImage );
+	qglLineWidth( 3 );
+	qglBegin( GL_LINES );
+	qglColor3f( 1,0,0 );
+	qglVertex3f( 0,0,0 );
+	qglVertex3f( 16,0,0 );
+	qglColor3f( 0,1,0 );
+	qglVertex3f( 0,0,0 );
+	qglVertex3f( 0,16,0 );
+	qglColor3f( 0,0,1 );
+	qglVertex3f( 0,0,0 );
+	qglVertex3f( 0,0,16 );
+	qglEnd();
+	qglLineWidth( 1 );
+}
+
+//===========================================================================
+
+/*
+====================
+RB_SurfaceEntity
+
+Entities that have a single procedurally generated surface
+====================
+*/
+static void RB_SurfaceEntity( surfaceType_t *surfType ) {
+	switch( backEnd.currentEntity->e.reType ) {
+	case RT_SPRITE:
+		RB_SurfaceSprite();
+		break;
+	case RT_BEAM:
+		RB_SurfaceBeam();
+		break;
+	case RT_RAIL_CORE:
+		RB_SurfaceRailCore();
+		break;
+	case RT_RAIL_RINGS:
+		RB_SurfaceRailRings();
+		break;
+	case RT_LIGHTNING:
+		RB_SurfaceLightningBolt();
+		break;
+	default:
+		RB_SurfaceAxis();
+		break;
+	}
+	return;
+}
+
+static void RB_SurfaceBad( surfaceType_t *surfType ) {
+	ri.Printf( PRINT_ALL, "Bad surface tesselated.\n" );
+}
+
+static void RB_SurfaceFlare(srfFlare_t *surf)
+{
+	if (r_flares->integer)
+		RB_AddFlare(surf, tess.fogNum, surf->origin, surf->color, surf->normal);
+}
+
+static void RB_SurfaceDisplayList( srfDisplayList_t *surf ) {
+	// all apropriate state must be set in RB_BeginSurface
+	// this isn't implemented yet...
+	qglCallList( surf->listNum );
+}
+
+static void RB_SurfaceSkip( void *surf ) {
+}
+
+
+void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])( void *) = {
+	(void(*)(void*))RB_SurfaceBad,			// SF_BAD, 
+	(void(*)(void*))RB_SurfaceSkip,			// SF_SKIP, 
+	(void(*)(void*))RB_SurfaceFace,			// SF_FACE,
+	(void(*)(void*))RB_SurfaceGrid,			// SF_GRID,
+	(void(*)(void*))RB_SurfaceTriangles,		// SF_TRIANGLES,
+	(void(*)(void*))RB_SurfacePolychain,		// SF_POLY,
+	(void(*)(void*))RB_SurfaceMesh,			// SF_MD3,
+	(void(*)(void*))RB_SurfaceAnim,			// SF_MD4,
+#ifdef RAVENMD4
+	(void(*)(void*))RB_MDRSurfaceAnim,		// SF_MDR,
+#endif
+	(void(*)(void*))RB_SurfaceFlare,		// SF_FLARE,
+	(void(*)(void*))RB_SurfaceEntity,		// SF_ENTITY
+	(void(*)(void*))RB_SurfaceDisplayList		// SF_DISPLAY_LIST
+};
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_surface.c.rej tremulous-ggp1-src/src/renderer/tr_surface.c.rej
--- tremulous-ggp1-src.p/src/renderer/tr_surface.c.rej	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_surface.c.rej	2012-07-19 04:25:52.031556446 +0200
@@ -0,0 +1,12 @@
+--- src/renderer/tr_surface.c	(Revision 2062)
++++ src/renderer/tr_surface.c	(Arbeitskopie)
+@@ -654,7 +693,8 @@
+ static void LerpMeshVertexes_altivec(md3Surface_t *surf, float backlerp)
+ {
+ 	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
+-	float	*outXyz, *outNormal;
++	vaWord2_t	*vertexPtr2;
++	vaWord3_t	*vertexPtr3;
+ 	float	oldXyzScale ALIGN(16);
+ 	float   newXyzScale ALIGN(16);
+ 	float	oldNormalScale ALIGN(16);
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_types.h tremulous-ggp1-src/src/renderer/tr_types.h
--- tremulous-ggp1-src.p/src/renderer/tr_types.h	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_types.h	2012-07-19 04:25:52.031556446 +0200
@@ -25,7 +25,8 @@
 #define __TR_TYPES_H
 
 
-#define	MAX_DLIGHTS		32		// can't be increased, because bit flags are used on surfaces
+#define	MAX_DLIGHTS		256
+#define MAX_TEXTURE_DLIGHTS	32		// can't be increased, because because bit flags are used on surfaces
 #define	MAX_ENTITIES		1023		// can't be increased without changing drawsurf bit packing
 
 // renderfx flags
@@ -212,7 +213,6 @@
 
 	qboolean				textureFilterAnisotropic;
 	int							maxAnisotropy;
-                
 } glconfig_t;
 
 #endif	// __TR_TYPES_H
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_world.c tremulous-ggp1-src/src/renderer/tr_world.c
--- tremulous-ggp1-src.p/src/renderer/tr_world.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/renderer/tr_world.c	2012-07-19 04:25:52.041556450 +0200
@@ -166,7 +166,12 @@
 	int			i;
 	dlight_t	*dl;
 
-	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
+        if ( !dlightBits ) { 
+		face->dlightBits[ tr.smpFrame ] = dlightBits; 
+		return dlightBits; 
+	} 
+	
+ 	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
 		if ( ! ( dlightBits & ( 1 << i ) ) ) {
 			continue;
 		}
@@ -190,7 +195,12 @@
 	int			i;
 	dlight_t	*dl;
 
-	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
+        if ( !dlightBits ) { 
+		grid->dlightBits[ tr.smpFrame ] = dlightBits; 
+		return dlightBits; 
+	}
+	
+ 	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
 		if ( ! ( dlightBits & ( 1 << i ) ) ) {
 			continue;
 		}
@@ -216,10 +226,6 @@
 
 
 static int R_DlightTrisurf( srfTriangles_t *surf, int dlightBits ) {
-	// FIXME: more dlight culling to trisurfs...
-	surf->dlightBits[ tr.smpFrame ] = dlightBits;
-	return dlightBits;
-#if 0
 	int			i;
 	dlight_t	*dl;
 
@@ -228,12 +234,12 @@
 			continue;
 		}
 		dl = &tr.refdef.dlights[i];
-		if ( dl->origin[0] - dl->radius > grid->meshBounds[1][0]
-			|| dl->origin[0] + dl->radius < grid->meshBounds[0][0]
-			|| dl->origin[1] - dl->radius > grid->meshBounds[1][1]
-			|| dl->origin[1] + dl->radius < grid->meshBounds[0][1]
-			|| dl->origin[2] - dl->radius > grid->meshBounds[1][2]
-			|| dl->origin[2] + dl->radius < grid->meshBounds[0][2] ) {
+		if ( dl->origin[0] - dl->radius > surf->bounds[1][0]
+			|| dl->origin[0] + dl->radius < surf->bounds[0][0]
+			|| dl->origin[1] - dl->radius > surf->bounds[1][1]
+			|| dl->origin[1] + dl->radius < surf->bounds[0][1]
+			|| dl->origin[2] - dl->radius > surf->bounds[1][2]
+			|| dl->origin[2] + dl->radius < surf->bounds[0][2] ) {
 			// dlight doesn't reach the bounds
 			dlightBits &= ~( 1 << i );
 		}
@@ -243,9 +249,8 @@
 		tr.pc.c_dlightSurfacesCulled++;
 	}
 
-	grid->dlightBits[ tr.smpFrame ] = dlightBits;
+	surf->dlightBits[ tr.smpFrame ] = dlightBits;
 	return dlightBits;
-#endif
 }
 
 /*
@@ -258,11 +263,11 @@
 ====================
 */
 static int R_DlightSurface( msurface_t *surf, int dlightBits ) {
-	if ( *surf->data == SF_FACE ) {
+	if ( surf->type == SF_FACE ) {
 		dlightBits = R_DlightFace( (srfSurfaceFace_t *)surf->data, dlightBits );
-	} else if ( *surf->data == SF_GRID ) {
+	} else if ( surf->type == SF_GRID ) {
 		dlightBits = R_DlightGrid( (srfGridMesh_t *)surf->data, dlightBits );
-	} else if ( *surf->data == SF_TRIANGLES ) {
+	} else if ( surf->type == SF_TRIANGLES ) {
 		dlightBits = R_DlightTrisurf( (srfTriangles_t *)surf->data, dlightBits );
 	} else {
 		dlightBits = 0;
@@ -282,7 +287,7 @@
 R_AddWorldSurface
 ======================
 */
-static void R_AddWorldSurface( msurface_t *surf, int dlightBits ) {
+static void R_AddWorldSurface( msurface_t *surf, int dlightBits, qboolean culled ) {
 	if ( surf->viewCount == tr.viewCount ) {
 		return;		// already in this view
 	}
@@ -291,17 +296,24 @@
 	// FIXME: bmodel fog?
 
 	// try to cull before dlighting or adding
-	if ( R_CullSurface( surf->data, surf->shader ) ) {
+	culled = culled || R_CullSurface( surf->data, surf->shader );
+	if ( !qglBindBufferARB && culled ) {
 		return;
 	}
 
-	// check for dlighting
-	if ( dlightBits ) {
+	if( !culled ) {
+		// check for dlighting
 		dlightBits = R_DlightSurface( surf, dlightBits );
 		dlightBits = ( dlightBits != 0 );
+	} else {
+		dlightBits = 0;
 	}
 
-	R_AddDrawSurf( surf->data, surf->shader, surf->fogIndex, dlightBits );
+	if( surf->shader->depthShader ) {
+		// no fog or light for the depth shader needed
+		R_AddDrawSurf( surf->data, surf->shader->depthShader, 0, 0, culled );
+	}
+	R_AddDrawSurf( surf->data, surf->shader, surf->fogIndex, dlightBits, culled );
 }
 
 /*
@@ -325,7 +337,7 @@
 
 	pModel = R_GetModelByHandle( ent->e.hModel );
 
-	bmodel = pModel->bmodel;
+	bmodel = pModel->modelData.brush.bmodel;
 
 	clip = R_CullLocalBox( bmodel->bounds );
 	if ( clip == CULL_OUT ) {
@@ -336,7 +348,7 @@
 	R_DlightBmodel( bmodel );
 
 	for ( i = 0 ; i < bmodel->numSurfaces ; i++ ) {
-		R_AddWorldSurface( bmodel->firstSurface + i, tr.currentEntity->needDlights );
+		R_AddWorldSurface( bmodel->firstSurface + i, tr.currentEntity->needDlights, qfalse );
 	}
 }
 
@@ -355,10 +367,11 @@
 R_RecursiveWorldNode
 ================
 */
-static void R_RecursiveWorldNode( mnode_t *node, int planeBits, int dlightBits ) {
-
+static void R_RecursiveWorldNode( mnode_t *node, int planeBits, int dlightBits,
+				  mnode_t ***culledNodes, qboolean culled ) {
 	do {
 		int			newDlights[2];
+		int			r;
 
 		// if the node wasn't marked as potentially visible, exit
 		if (node->visframe != tr.visCount) {
@@ -368,49 +381,54 @@
 		// if the bounding volume is outside the frustum, nothing
 		// inside can be visible OPTIMIZE: don't do this all the way to leafs?
 
-		if ( !r_nocull->integer ) {
-			int		r;
-
-			if ( planeBits & 1 ) {
-				r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[0]);
-				if (r == 2) {
-					return;						// culled
-				}
-				if ( r == 1 ) {
-					planeBits &= ~1;			// all descendants will also be in front
-				}
+		if ( planeBits & 1 ) {
+			r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[0]);
+			if (r == 2) {
+				culled = qtrue;				// culled
 			}
-
-			if ( planeBits & 2 ) {
-				r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[1]);
-				if (r == 2) {
-					return;						// culled
-				}
-				if ( r == 1 ) {
-					planeBits &= ~2;			// all descendants will also be in front
-				}
+			if ( r == 1 ) {
+				planeBits &= ~1;			// all descendants will also be in front
 			}
-
-			if ( planeBits & 4 ) {
-				r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[2]);
-				if (r == 2) {
-					return;						// culled
-				}
-				if ( r == 1 ) {
-					planeBits &= ~4;			// all descendants will also be in front
-				}
+		}
+		
+		if ( planeBits & 2 ) {
+			r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[1]);
+			if (r == 2) {
+				culled = qtrue;				// culled
 			}
-
-			if ( planeBits & 8 ) {
-				r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[3]);
-				if (r == 2) {
-					return;						// culled
-				}
-				if ( r == 1 ) {
-					planeBits &= ~8;			// all descendants will also be in front
-				}
+			if ( r == 1 ) {
+				planeBits &= ~2;			// all descendants will also be in front
 			}
+		}
+		
+		if ( planeBits & 4 ) {
+			r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[2]);
+			if (r == 2) {
+				culled = qtrue;				// culled
+			}
+			if ( r == 1 ) {
+				planeBits &= ~4;			// all descendants will also be in front
+			}
+		}
+		
+		if ( planeBits & 8 ) {
+			r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[3]);
+			if (r == 2) {
+				culled = qtrue;				// culled
+			}
+			if ( r == 1 ) {
+				planeBits &= ~8;			// all descendants will also be in front
+			}
+		}
 
+		if ( planeBits & 16 ) {
+			r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[4]);
+			if (r == 2) {
+				return;						// culled
+			}
+			if ( r == 1 ) {
+				planeBits &= ~16;			// all descendants will also be in front
+			}
 		}
 
 		if ( node->contents != -1 ) {
@@ -423,7 +441,7 @@
 		// determine which dlights are needed
 		newDlights[0] = 0;
 		newDlights[1] = 0;
-		if ( dlightBits ) {
+		if ( dlightBits && !culled ) {
 			int	i;
 
 			for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
@@ -445,14 +463,18 @@
 		}
 
 		// recurse down the children, front side first
-		R_RecursiveWorldNode (node->children[0], planeBits, newDlights[0] );
+		R_RecursiveWorldNode (node->children[0], planeBits, newDlights[0], culledNodes, culled );
 
 		// tail recurse
 		node = node->children[1];
 		dlightBits = newDlights[1];
 	} while ( 1 );
 
-	{
+	if( culled ) {
+		// culled nodes are added after the not-culled nodes
+		**culledNodes = node;
+		(*culledNodes)++;
+	} else {
 		// leaf node, so add mark surfaces
 		int			c;
 		msurface_t	*surf, **mark;
@@ -487,11 +509,10 @@
 			// the surface may have already been added if it
 			// spans multiple leafs
 			surf = *mark;
-			R_AddWorldSurface( surf, dlightBits );
+			R_AddWorldSurface( surf, dlightBits, qfalse );
 			mark++;
 		}
 	}
-
 }
 
 
@@ -581,12 +602,13 @@
 	// current viewcluster
 	leaf = R_PointInLeaf( tr.viewParms.pvsOrigin );
 	cluster = leaf->cluster;
+	tr.viewParms.viewCluster = cluster;
 
 	// if the cluster is the same and the area visibility matrix
 	// hasn't changed, we don't need to mark everything again
 
 	// if r_showcluster was just turned on, remark everything 
-	if ( tr.viewCluster == cluster && !tr.refdef.areamaskModified 
+	if ( tr.visCluster == cluster && !tr.refdef.areamaskModified
 		&& !r_showcluster->modified ) {
 		return;
 	}
@@ -599,9 +621,9 @@
 	}
 
 	tr.visCount++;
-	tr.viewCluster = cluster;
+	tr.visCluster = cluster;
 
-	if ( r_novis->integer || tr.viewCluster == -1 ) {
+	if ( r_novis->integer || tr.visCluster == -1 ) {
 		for (i=0 ; i<tr.world->numnodes ; i++) {
 			if (tr.world->nodes[i].contents != CONTENTS_SOLID) {
 				tr.world->nodes[i].visframe = tr.visCount;
@@ -610,7 +632,7 @@
 		return;
 	}
 
-	vis = R_ClusterPVS (tr.viewCluster);
+	vis = R_ClusterPVS (tr.viewParms.viewCluster);
 	
 	for (i=0,leaf=tr.world->nodes ; i<tr.world->numnodes ; i++, leaf++) {
 		cluster = leaf->cluster;
@@ -624,7 +646,8 @@
 		}
 
 		// check for door connection
-		if ( (tr.refdef.areamask[leaf->area>>3] & (1<<(leaf->area&7)) ) ) {
+		if ( !qglBindBufferARB &&
+		     (tr.refdef.areamask[leaf->area>>3] & (1<<(leaf->area&7)) ) ) {
 			continue;		// not visible
 		}
 
@@ -645,6 +668,8 @@
 =============
 */
 void R_AddWorldSurfaces (void) {
+	mnode_t **buf, **ptr;
+
 	if ( !r_drawworld->integer ) {
 		return;
 	}
@@ -661,10 +686,56 @@
 
 	// clear out the visible min/max
 	ClearBounds( tr.viewParms.visBounds[0], tr.viewParms.visBounds[1] );
-
+	
+	switch ( tr.viewParms.frustType ) {
+	case 1:
+		tr.viewParms.frustum[4].dist = tr.clusters[tr.viewParms.viewCluster].mins[0];
+		break;
+	case 2:
+		tr.viewParms.frustum[4].dist = -tr.clusters[tr.viewParms.viewCluster].maxs[0];
+		break;
+	case 3:
+		tr.viewParms.frustum[4].dist = tr.clusters[tr.viewParms.viewCluster].mins[1];
+		break;
+	case 4:
+		tr.viewParms.frustum[4].dist = -tr.clusters[tr.viewParms.viewCluster].maxs[1];
+		break;
+	case 5:
+		tr.viewParms.frustum[4].dist = tr.clusters[tr.viewParms.viewCluster].mins[2];
+		break;
+	case 6:
+		tr.viewParms.frustum[4].dist = -tr.clusters[tr.viewParms.viewCluster].maxs[2];
+		break;
+	}
+	
 	// perform frustum culling and add all the potentially visible surfaces
-	if ( tr.refdef.num_dlights > 32 ) {
-		tr.refdef.num_dlights = 32 ;
+	if ( tr.refdef.num_dlights > MAX_TEXTURE_DLIGHTS ) {
+		tr.refdef.num_dlights = MAX_TEXTURE_DLIGHTS ;
+	}
+	
+	buf = ri.Hunk_AllocateTempMemory( (tr.world->numnodes - tr.world->numDecisionNodes) * sizeof(mnode_t *) );
+	ptr = buf;
+	R_RecursiveWorldNode( tr.world->nodes, tr.viewParms.frustPlanes, ( 1 << tr.refdef.num_dlights ) - 1, &ptr, qfalse );
+	if( qglGenBuffersARB ) {
+		while( ptr > buf ) {
+			int			c;
+			msurface_t	*surf, **mark;
+
+			ptr--;
+
+			tr.pc.c_leafs++;
+
+			// add the individual surfaces
+			mark = (*ptr)->firstmarksurface;
+			c = (*ptr)->nummarksurfaces;
+			while (c--) {
+				// the surface may have already been added if it
+				// spans multiple leafs
+				surf = *mark;
+				R_AddWorldSurface( surf, 0, qtrue );
+				mark++;
+			}
+		}
 	}
-	R_RecursiveWorldNode( tr.world->nodes, 15, ( 1 << tr.refdef.num_dlights ) - 1 );
+	ri.Hunk_FreeTempMemory( buf );
 }
diff -uNr tremulous-ggp1-src.p/src/renderer/tr_world.c.orig tremulous-ggp1-src/src/renderer/tr_world.c.orig
--- tremulous-ggp1-src.p/src/renderer/tr_world.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/renderer/tr_world.c.orig	2012-07-19 04:25:20.321556051 +0200
@@ -0,0 +1,670 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+#include "tr_local.h"
+
+
+
+/*
+=================
+R_CullTriSurf
+
+Returns true if the grid is completely culled away.
+Also sets the clipped hint bit in tess
+=================
+*/
+static qboolean	R_CullTriSurf( srfTriangles_t *cv ) {
+	int 	boxCull;
+
+	boxCull = R_CullLocalBox( cv->bounds );
+
+	if ( boxCull == CULL_OUT ) {
+		return qtrue;
+	}
+	return qfalse;
+}
+
+/*
+=================
+R_CullGrid
+
+Returns true if the grid is completely culled away.
+Also sets the clipped hint bit in tess
+=================
+*/
+static qboolean	R_CullGrid( srfGridMesh_t *cv ) {
+	int 	boxCull;
+	int 	sphereCull;
+
+	if ( r_nocurves->integer ) {
+		return qtrue;
+	}
+
+	if ( tr.currentEntityNum != ENTITYNUM_WORLD ) {
+		sphereCull = R_CullLocalPointAndRadius( cv->localOrigin, cv->meshRadius );
+	} else {
+		sphereCull = R_CullPointAndRadius( cv->localOrigin, cv->meshRadius );
+	}
+	boxCull = CULL_OUT;
+	
+	// check for trivial reject
+	if ( sphereCull == CULL_OUT )
+	{
+		tr.pc.c_sphere_cull_patch_out++;
+		return qtrue;
+	}
+	// check bounding box if necessary
+	else if ( sphereCull == CULL_CLIP )
+	{
+		tr.pc.c_sphere_cull_patch_clip++;
+
+		boxCull = R_CullLocalBox( cv->meshBounds );
+
+		if ( boxCull == CULL_OUT ) 
+		{
+			tr.pc.c_box_cull_patch_out++;
+			return qtrue;
+		}
+		else if ( boxCull == CULL_IN )
+		{
+			tr.pc.c_box_cull_patch_in++;
+		}
+		else
+		{
+			tr.pc.c_box_cull_patch_clip++;
+		}
+	}
+	else
+	{
+		tr.pc.c_sphere_cull_patch_in++;
+	}
+
+	return qfalse;
+}
+
+
+/*
+================
+R_CullSurface
+
+Tries to back face cull surfaces before they are lighted or
+added to the sorting list.
+
+This will also allow mirrors on both sides of a model without recursion.
+================
+*/
+static qboolean	R_CullSurface( surfaceType_t *surface, shader_t *shader ) {
+	srfSurfaceFace_t *sface;
+	float			d;
+
+	if ( r_nocull->integer ) {
+		return qfalse;
+	}
+
+	if ( *surface == SF_GRID ) {
+		return R_CullGrid( (srfGridMesh_t *)surface );
+	}
+
+	if ( *surface == SF_TRIANGLES ) {
+		return R_CullTriSurf( (srfTriangles_t *)surface );
+	}
+
+	if ( *surface != SF_FACE ) {
+		return qfalse;
+	}
+
+	if ( shader->cullType == CT_TWO_SIDED ) {
+		return qfalse;
+	}
+
+	// face culling
+	if ( !r_facePlaneCull->integer ) {
+		return qfalse;
+	}
+
+	sface = ( srfSurfaceFace_t * ) surface;
+	d = DotProduct (tr.or.viewOrigin, sface->plane.normal);
+
+	// don't cull exactly on the plane, because there are levels of rounding
+	// through the BSP, ICD, and hardware that may cause pixel gaps if an
+	// epsilon isn't allowed here 
+	if ( shader->cullType == CT_FRONT_SIDED ) {
+		if ( d < sface->plane.dist - 8 ) {
+			return qtrue;
+		}
+	} else {
+		if ( d > sface->plane.dist + 8 ) {
+			return qtrue;
+		}
+	}
+
+	return qfalse;
+}
+
+
+static int R_DlightFace( srfSurfaceFace_t *face, int dlightBits ) {
+	float		d;
+	int			i;
+	dlight_t	*dl;
+
+	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
+		if ( ! ( dlightBits & ( 1 << i ) ) ) {
+			continue;
+		}
+		dl = &tr.refdef.dlights[i];
+		d = DotProduct( dl->origin, face->plane.normal ) - face->plane.dist;
+		if ( d < -dl->radius || d > dl->radius ) {
+			// dlight doesn't reach the plane
+			dlightBits &= ~( 1 << i );
+		}
+	}
+
+	if ( !dlightBits ) {
+		tr.pc.c_dlightSurfacesCulled++;
+	}
+
+	face->dlightBits[ tr.smpFrame ] = dlightBits;
+	return dlightBits;
+}
+
+static int R_DlightGrid( srfGridMesh_t *grid, int dlightBits ) {
+	int			i;
+	dlight_t	*dl;
+
+	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
+		if ( ! ( dlightBits & ( 1 << i ) ) ) {
+			continue;
+		}
+		dl = &tr.refdef.dlights[i];
+		if ( dl->origin[0] - dl->radius > grid->meshBounds[1][0]
+			|| dl->origin[0] + dl->radius < grid->meshBounds[0][0]
+			|| dl->origin[1] - dl->radius > grid->meshBounds[1][1]
+			|| dl->origin[1] + dl->radius < grid->meshBounds[0][1]
+			|| dl->origin[2] - dl->radius > grid->meshBounds[1][2]
+			|| dl->origin[2] + dl->radius < grid->meshBounds[0][2] ) {
+			// dlight doesn't reach the bounds
+			dlightBits &= ~( 1 << i );
+		}
+	}
+
+	if ( !dlightBits ) {
+		tr.pc.c_dlightSurfacesCulled++;
+	}
+
+	grid->dlightBits[ tr.smpFrame ] = dlightBits;
+	return dlightBits;
+}
+
+
+static int R_DlightTrisurf( srfTriangles_t *surf, int dlightBits ) {
+	// FIXME: more dlight culling to trisurfs...
+	surf->dlightBits[ tr.smpFrame ] = dlightBits;
+	return dlightBits;
+#if 0
+	int			i;
+	dlight_t	*dl;
+
+	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
+		if ( ! ( dlightBits & ( 1 << i ) ) ) {
+			continue;
+		}
+		dl = &tr.refdef.dlights[i];
+		if ( dl->origin[0] - dl->radius > grid->meshBounds[1][0]
+			|| dl->origin[0] + dl->radius < grid->meshBounds[0][0]
+			|| dl->origin[1] - dl->radius > grid->meshBounds[1][1]
+			|| dl->origin[1] + dl->radius < grid->meshBounds[0][1]
+			|| dl->origin[2] - dl->radius > grid->meshBounds[1][2]
+			|| dl->origin[2] + dl->radius < grid->meshBounds[0][2] ) {
+			// dlight doesn't reach the bounds
+			dlightBits &= ~( 1 << i );
+		}
+	}
+
+	if ( !dlightBits ) {
+		tr.pc.c_dlightSurfacesCulled++;
+	}
+
+	grid->dlightBits[ tr.smpFrame ] = dlightBits;
+	return dlightBits;
+#endif
+}
+
+/*
+====================
+R_DlightSurface
+
+The given surface is going to be drawn, and it touches a leaf
+that is touched by one or more dlights, so try to throw out
+more dlights if possible.
+====================
+*/
+static int R_DlightSurface( msurface_t *surf, int dlightBits ) {
+	if ( *surf->data == SF_FACE ) {
+		dlightBits = R_DlightFace( (srfSurfaceFace_t *)surf->data, dlightBits );
+	} else if ( *surf->data == SF_GRID ) {
+		dlightBits = R_DlightGrid( (srfGridMesh_t *)surf->data, dlightBits );
+	} else if ( *surf->data == SF_TRIANGLES ) {
+		dlightBits = R_DlightTrisurf( (srfTriangles_t *)surf->data, dlightBits );
+	} else {
+		dlightBits = 0;
+	}
+
+	if ( dlightBits ) {
+		tr.pc.c_dlightSurfaces++;
+	}
+
+	return dlightBits;
+}
+
+
+
+/*
+======================
+R_AddWorldSurface
+======================
+*/
+static void R_AddWorldSurface( msurface_t *surf, int dlightBits ) {
+	if ( surf->viewCount == tr.viewCount ) {
+		return;		// already in this view
+	}
+
+	surf->viewCount = tr.viewCount;
+	// FIXME: bmodel fog?
+
+	// try to cull before dlighting or adding
+	if ( R_CullSurface( surf->data, surf->shader ) ) {
+		return;
+	}
+
+	// check for dlighting
+	if ( dlightBits ) {
+		dlightBits = R_DlightSurface( surf, dlightBits );
+		dlightBits = ( dlightBits != 0 );
+	}
+
+	R_AddDrawSurf( surf->data, surf->shader, surf->fogIndex, dlightBits );
+}
+
+/*
+=============================================================
+
+	BRUSH MODELS
+
+=============================================================
+*/
+
+/*
+=================
+R_AddBrushModelSurfaces
+=================
+*/
+void R_AddBrushModelSurfaces ( trRefEntity_t *ent ) {
+	bmodel_t	*bmodel;
+	int			clip;
+	model_t		*pModel;
+	int			i;
+
+	pModel = R_GetModelByHandle( ent->e.hModel );
+
+	bmodel = pModel->bmodel;
+
+	clip = R_CullLocalBox( bmodel->bounds );
+	if ( clip == CULL_OUT ) {
+		return;
+	}
+	
+	R_SetupEntityLighting( &tr.refdef, ent );
+	R_DlightBmodel( bmodel );
+
+	for ( i = 0 ; i < bmodel->numSurfaces ; i++ ) {
+		R_AddWorldSurface( bmodel->firstSurface + i, tr.currentEntity->needDlights );
+	}
+}
+
+
+/*
+=============================================================
+
+	WORLD MODEL
+
+=============================================================
+*/
+
+
+/*
+================
+R_RecursiveWorldNode
+================
+*/
+static void R_RecursiveWorldNode( mnode_t *node, int planeBits, int dlightBits ) {
+
+	do {
+		int			newDlights[2];
+
+		// if the node wasn't marked as potentially visible, exit
+		if (node->visframe != tr.visCount) {
+			return;
+		}
+
+		// if the bounding volume is outside the frustum, nothing
+		// inside can be visible OPTIMIZE: don't do this all the way to leafs?
+
+		if ( !r_nocull->integer ) {
+			int		r;
+
+			if ( planeBits & 1 ) {
+				r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[0]);
+				if (r == 2) {
+					return;						// culled
+				}
+				if ( r == 1 ) {
+					planeBits &= ~1;			// all descendants will also be in front
+				}
+			}
+
+			if ( planeBits & 2 ) {
+				r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[1]);
+				if (r == 2) {
+					return;						// culled
+				}
+				if ( r == 1 ) {
+					planeBits &= ~2;			// all descendants will also be in front
+				}
+			}
+
+			if ( planeBits & 4 ) {
+				r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[2]);
+				if (r == 2) {
+					return;						// culled
+				}
+				if ( r == 1 ) {
+					planeBits &= ~4;			// all descendants will also be in front
+				}
+			}
+
+			if ( planeBits & 8 ) {
+				r = BoxOnPlaneSide(node->mins, node->maxs, &tr.viewParms.frustum[3]);
+				if (r == 2) {
+					return;						// culled
+				}
+				if ( r == 1 ) {
+					planeBits &= ~8;			// all descendants will also be in front
+				}
+			}
+
+		}
+
+		if ( node->contents != -1 ) {
+			break;
+		}
+
+		// node is just a decision point, so go down both sides
+		// since we don't care about sort orders, just go positive to negative
+
+		// determine which dlights are needed
+		newDlights[0] = 0;
+		newDlights[1] = 0;
+		if ( dlightBits ) {
+			int	i;
+
+			for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
+				dlight_t	*dl;
+				float		dist;
+
+				if ( dlightBits & ( 1 << i ) ) {
+					dl = &tr.refdef.dlights[i];
+					dist = DotProduct( dl->origin, node->plane->normal ) - node->plane->dist;
+					
+					if ( dist > -dl->radius ) {
+						newDlights[0] |= ( 1 << i );
+					}
+					if ( dist < dl->radius ) {
+						newDlights[1] |= ( 1 << i );
+					}
+				}
+			}
+		}
+
+		// recurse down the children, front side first
+		R_RecursiveWorldNode (node->children[0], planeBits, newDlights[0] );
+
+		// tail recurse
+		node = node->children[1];
+		dlightBits = newDlights[1];
+	} while ( 1 );
+
+	{
+		// leaf node, so add mark surfaces
+		int			c;
+		msurface_t	*surf, **mark;
+
+		tr.pc.c_leafs++;
+
+		// add to z buffer bounds
+		if ( node->mins[0] < tr.viewParms.visBounds[0][0] ) {
+			tr.viewParms.visBounds[0][0] = node->mins[0];
+		}
+		if ( node->mins[1] < tr.viewParms.visBounds[0][1] ) {
+			tr.viewParms.visBounds[0][1] = node->mins[1];
+		}
+		if ( node->mins[2] < tr.viewParms.visBounds[0][2] ) {
+			tr.viewParms.visBounds[0][2] = node->mins[2];
+		}
+
+		if ( node->maxs[0] > tr.viewParms.visBounds[1][0] ) {
+			tr.viewParms.visBounds[1][0] = node->maxs[0];
+		}
+		if ( node->maxs[1] > tr.viewParms.visBounds[1][1] ) {
+			tr.viewParms.visBounds[1][1] = node->maxs[1];
+		}
+		if ( node->maxs[2] > tr.viewParms.visBounds[1][2] ) {
+			tr.viewParms.visBounds[1][2] = node->maxs[2];
+		}
+
+		// add the individual surfaces
+		mark = node->firstmarksurface;
+		c = node->nummarksurfaces;
+		while (c--) {
+			// the surface may have already been added if it
+			// spans multiple leafs
+			surf = *mark;
+			R_AddWorldSurface( surf, dlightBits );
+			mark++;
+		}
+	}
+
+}
+
+
+/*
+===============
+R_PointInLeaf
+===============
+*/
+static mnode_t *R_PointInLeaf( const vec3_t p ) {
+	mnode_t		*node;
+	float		d;
+	cplane_t	*plane;
+	
+	if ( !tr.world ) {
+		ri.Error (ERR_DROP, "R_PointInLeaf: bad model");
+	}
+
+	node = tr.world->nodes;
+	while( 1 ) {
+		if (node->contents != -1) {
+			break;
+		}
+		plane = node->plane;
+		d = DotProduct (p,plane->normal) - plane->dist;
+		if (d > 0) {
+			node = node->children[0];
+		} else {
+			node = node->children[1];
+		}
+	}
+	
+	return node;
+}
+
+/*
+==============
+R_ClusterPVS
+==============
+*/
+static const byte *R_ClusterPVS (int cluster) {
+	if (!tr.world || !tr.world->vis || cluster < 0 || cluster >= tr.world->numClusters ) {
+		return tr.world->novis;
+	}
+
+	return tr.world->vis + cluster * tr.world->clusterBytes;
+}
+
+/*
+=================
+R_inPVS
+=================
+*/
+qboolean R_inPVS( const vec3_t p1, const vec3_t p2 ) {
+	mnode_t *leaf;
+	byte	*vis;
+
+	leaf = R_PointInLeaf( p1 );
+	vis = CM_ClusterPVS( leaf->cluster );
+	leaf = R_PointInLeaf( p2 );
+
+	if ( !(vis[leaf->cluster>>3] & (1<<(leaf->cluster&7))) ) {
+		return qfalse;
+	}
+	return qtrue;
+}
+
+/*
+===============
+R_MarkLeaves
+
+Mark the leaves and nodes that are in the PVS for the current
+cluster
+===============
+*/
+static void R_MarkLeaves (void) {
+	const byte	*vis;
+	mnode_t	*leaf, *parent;
+	int		i;
+	int		cluster;
+
+	// lockpvs lets designers walk around to determine the
+	// extent of the current pvs
+	if ( r_lockpvs->integer ) {
+		return;
+	}
+
+	// current viewcluster
+	leaf = R_PointInLeaf( tr.viewParms.pvsOrigin );
+	cluster = leaf->cluster;
+
+	// if the cluster is the same and the area visibility matrix
+	// hasn't changed, we don't need to mark everything again
+
+	// if r_showcluster was just turned on, remark everything 
+	if ( tr.viewCluster == cluster && !tr.refdef.areamaskModified 
+		&& !r_showcluster->modified ) {
+		return;
+	}
+
+	if ( r_showcluster->modified || r_showcluster->integer ) {
+		r_showcluster->modified = qfalse;
+		if ( r_showcluster->integer ) {
+			ri.Printf( PRINT_ALL, "cluster:%i  area:%i\n", cluster, leaf->area );
+		}
+	}
+
+	tr.visCount++;
+	tr.viewCluster = cluster;
+
+	if ( r_novis->integer || tr.viewCluster == -1 ) {
+		for (i=0 ; i<tr.world->numnodes ; i++) {
+			if (tr.world->nodes[i].contents != CONTENTS_SOLID) {
+				tr.world->nodes[i].visframe = tr.visCount;
+			}
+		}
+		return;
+	}
+
+	vis = R_ClusterPVS (tr.viewCluster);
+	
+	for (i=0,leaf=tr.world->nodes ; i<tr.world->numnodes ; i++, leaf++) {
+		cluster = leaf->cluster;
+		if ( cluster < 0 || cluster >= tr.world->numClusters ) {
+			continue;
+		}
+
+		// check general pvs
+		if ( !(vis[cluster>>3] & (1<<(cluster&7))) ) {
+			continue;
+		}
+
+		// check for door connection
+		if ( (tr.refdef.areamask[leaf->area>>3] & (1<<(leaf->area&7)) ) ) {
+			continue;		// not visible
+		}
+
+		parent = leaf;
+		do {
+			if (parent->visframe == tr.visCount)
+				break;
+			parent->visframe = tr.visCount;
+			parent = parent->parent;
+		} while (parent);
+	}
+}
+
+
+/*
+=============
+R_AddWorldSurfaces
+=============
+*/
+void R_AddWorldSurfaces (void) {
+	if ( !r_drawworld->integer ) {
+		return;
+	}
+
+	if ( tr.refdef.rdflags & RDF_NOWORLDMODEL ) {
+		return;
+	}
+
+	tr.currentEntityNum = ENTITYNUM_WORLD;
+	tr.shiftedEntityNum = tr.currentEntityNum << QSORT_ENTITYNUM_SHIFT;
+
+	// determine which leaves are in the PVS / areamask
+	R_MarkLeaves ();
+
+	// clear out the visible min/max
+	ClearBounds( tr.viewParms.visBounds[0], tr.viewParms.visBounds[1] );
+
+	// perform frustum culling and add all the potentially visible surfaces
+	if ( tr.refdef.num_dlights > 32 ) {
+		tr.refdef.num_dlights = 32 ;
+	}
+	R_RecursiveWorldNode( tr.world->nodes, 15, ( 1 << tr.refdef.num_dlights ) - 1 );
+}
diff -uNr tremulous-ggp1-src.p/src/sdl/sdl_glimp.c tremulous-ggp1-src/src/sdl/sdl_glimp.c
--- tremulous-ggp1-src.p/src/sdl/sdl_glimp.c	2012-07-19 04:25:20.000000000 +0200
+++ tremulous-ggp1-src/src/sdl/sdl_glimp.c	2012-07-19 04:25:52.021556447 +0200
@@ -33,6 +33,9 @@
 #	else
 #		include <SDL_thread.h>
 #	endif
+#	ifdef SDL_VIDEO_DRIVER_X11
+#		include <X11/Xlib.h>
+#	endif
 #endif
 
 #include <stdarg.h>
@@ -44,20 +47,211 @@
 #include "../client/client.h"
 #include "../sys/sys_local.h"
 #include "sdl_icon.h"
+#include "SDL_syswm.h"
 
 /* Just hack it for now. */
 #ifdef MACOS_X
 #include <OpenGL/OpenGL.h>
+
 typedef CGLContextObj QGLContext;
-#define GLimp_GetCurrentContext() CGLGetCurrentContext()
-#define GLimp_SetCurrentContext(ctx) CGLSetCurrentContext(ctx)
+
+static void GLimp_GetCurrentContext( QGLContext *ctx )
+{
+	*ctx = CGLGetCurrentContext();
+}
+
+static void GLimp_SetCurrentContext( QGLContext *ctx )
+{
+	CGLSetCurrentContext( ctx ? *ctx : NULL );
+}
+static void GLimp_CreateSharedContext( QGLContext *old, qboolean debug,
+				       qboolean nodraw, QGLContext *new ) {
+	// AFAIK debug contexts are not supported
+	CGLCreateContext ( CGLPixelFormatObj pix, *old, new );
+
+	if( nodraw ) {
+		glDrawBuffer( GL_NONE );
+	}
+}
+static void GLimp_DestroyContext( QGLContext *parent, QGLContext *ctx ) {
+	if( *parent != *ctx ) {
+		CGLDestroyContext( *ctx );
+		*ctx = *parent;
+	}
+}
+#elif SDL_VIDEO_DRIVER_X11
+#include <GL/glx.h>
+typedef struct
+{
+	GLXContext      ctx;
+	Display         *dpy;
+	GLXDrawable     drawable;
+} QGLContext;
+
+static void GLimp_GetCurrentContext( QGLContext *ctx )
+{
+	ctx->ctx = glXGetCurrentContext();
+	ctx->dpy = glXGetCurrentDisplay();
+	ctx->drawable = glXGetCurrentDrawable();
+}
+
+static void GLimp_SetCurrentContext( QGLContext *ctx )
+{
+	if( ctx )
+		glXMakeCurrent( ctx->dpy, ctx->drawable, ctx->ctx );
+	else
+		glXMakeCurrent( glXGetCurrentDisplay(), 0, NULL );
+}
+static void GLimp_CreateSharedContext( QGLContext *old, qboolean debug,
+				       qboolean nodraw, QGLContext *new ) {
+	GLubyte *procName = (GLubyte *)"glXCreateContextAttribsARB";
+	GLXContext (APIENTRYP glXCreateContextAttribsARB)( Display *dpy,
+							   GLXFBConfig config,
+							   GLXContext share_context,
+							   Bool direct,
+							   const int *attrib_list);
+	int config_attrib_list[] = {
+		GLX_FBCONFIG_ID, 0,
+		None
+	};
+	int attrib_list[] = {
+		GLX_RENDER_TYPE, GLX_RGBA_TYPE,
+		GLX_CONTEXT_FLAGS_ARB, GLX_CONTEXT_DEBUG_BIT_ARB,
+		None
+	};
+	GLXFBConfig *config;
+	int         count;
+
+	if( glXQueryContext(old->dpy, old->ctx,
+			    GLX_FBCONFIG_ID,
+			    &config_attrib_list[1]) != Success )
+		return;
+
+	config = glXChooseFBConfig( old->dpy, 0,
+				    config_attrib_list,
+				    &count );
+	if( count != 1 )
+		return;
+
+	if( debug ) {
+		glXCreateContextAttribsARB = (void *)glXGetProcAddress(procName);
+		if( !glXCreateContextAttribsARB )
+			debug = qfalse;
+	} else {
+		glXCreateContextAttribsARB = NULL;
+	}
+
+	new->dpy = old->dpy;
+	if( nodraw ) {
+		new->drawable = glXCreatePbuffer(old->dpy,
+						 config[0],
+						 NULL);
+	} else {
+		new->drawable = old->drawable;
+	}
+	if( debug ) {
+		new->ctx = glXCreateContextAttribsARB(old->dpy,
+						      config[0],
+						      old->ctx,
+						      GL_TRUE,
+						      attrib_list);
+	} else {
+		new->ctx = glXCreateNewContext(old->dpy,
+					       config[0],
+					       GLX_RGBA_TYPE,
+					       old->ctx,
+					       GL_TRUE);
+	}
+
+	if( nodraw ) {
+		glDrawBuffer( GL_NONE );
+	}
+}
+static void GLimp_DestroyContext( QGLContext *parent, QGLContext *ctx ) {
+	if( parent->ctx != ctx->ctx ) {
+		glXDestroyContext( ctx->dpy, ctx->ctx );
+		ctx->ctx = parent->ctx;
+	}
+	if( parent->drawable != ctx->drawable ) {
+		glXDestroyPbuffer( ctx->dpy, ctx->drawable );
+		ctx->drawable = parent->drawable;
+	}
+}
+#elif WIN32
+typedef struct
+{
+	HDC             hDC;		// handle to device context
+	HGLRC           hGLRC;		// handle to GL rendering context
+} QGLContext;
+
+static void GLimp_GetCurrentContext( QGLContext *ctx ) {
+	SDL_SysWMinfo info;
+
+	SDL_VERSION(&info.version);
+	if(!SDL_GetWMInfo(&info))
+	{
+		ri.Printf(PRINT_WARNING, "Failed to obtain HWND from SDL (InputRegistry)");
+		return;
+	}
+
+	ctx->hDC = GetDC(info.window);
+	ctx->hGLRC = info.hglrc;
+}
+
+static void GLimp_SetCurrentContext( QGLContext *ctx ) {
+	if( ctx ) {
+		wglMakeCurrent( ctx->hDC, ctx->hGLRC );
+	} else {
+		wglMakeCurrent( NULL, NULL );
+	}
+}
+static void GLimp_CreateSharedContext( QGLContext *old, qboolean debug,
+				       qboolean nodraw, QGLContext *new ) {
+	LPCSTR procName = "wglCreateContextAttribsARB";
+	HGLRC (APIENTRYP wglCreateContextAttribsARB) (HDC hDC,
+						      HGLRC hshareContext,
+						      const int *attribList);
+	int attrib_list[] = {
+		WGL_CONTEXT_FLAGS_ARB, WGL_CONTEXT_DEBUG_BIT_ARB,
+		0
+	};
+
+	if( debug ) {
+		wglCreateContextAttribsARB = (void *)wglGetProcAddress(procName);
+		if( !wglCreateContextAttribsARB )
+			debug = qfalse;
+	}
+
+	new->hDC = old->hDC;
+	if( debug ) {
+		new->hGLRC = wglCreateContextAttribsARB(old->hDC,
+							old->hGLRC,
+							attrib_list);
+	} else {
+		new->hGLRC = wglCreateContext(old->hDC);
+		wglShareLists( old->hGLRC, new->hGLRC );
+	}
+
+	if( nodraw ) {
+		glDrawBuffer( GL_NONE );
+	}
+}
+static void GLimp_DestroyContext( QGLContext *parent, QGLContext *ctx ) {
+	if( parent->hGLRC != ctx->hGLRC ) {
+		wglDeleteContext( ctx->hGLRC );
+		ctx->hGLRC = parent->hGLRC;
+	}
+}
 #else
-typedef void *QGLContext;
-#define GLimp_GetCurrentContext() (NULL)
-#define GLimp_SetCurrentContext(ctx)
+typedef int QGLContext;  // dummy
+static void GLimp_GetCurrentContext( QGLContext *ctx ) {}
+static void GLimp_SetCurrentContext( QGLContext *ctx ) {}
+static void GLimp_CreateSharedContext( QGLContext *old, qboolean debug,
+				       qboolean nodraw, QGLContext *new ) {}
+static void GLimp_DestroyContext( QGLContext *parent, QGLContext *ctx ) {}
 #endif
 
-static QGLContext opengl_context;
+static QGLContext initial_context, frontend_context, backend_context;
 
 typedef enum
 {
@@ -77,13 +271,274 @@
 cvar_t *r_centerWindow;
 cvar_t *r_sdlDriver;
 
+void (APIENTRYP qglDrawRangeElementsEXT) (GLenum mode, GLsizei count, GLuint start, GLuint end, GLenum type, const GLvoid *indices);
+
 void (APIENTRYP qglActiveTextureARB) (GLenum texture);
 void (APIENTRYP qglClientActiveTextureARB) (GLenum texture);
 void (APIENTRYP qglMultiTexCoord2fARB) (GLenum target, GLfloat s, GLfloat t);
+void (APIENTRYP qglMultiTexCoord4fvARB) (GLenum target, GLfloat *v);
 
 void (APIENTRYP qglLockArraysEXT) (GLint first, GLsizei count);
 void (APIENTRYP qglUnlockArraysEXT) (void);
 
+// GL_ARB_texture_compression
+void (APIENTRYP qglCompressedTexImage3DARB) (GLenum target, GLint level,
+					     GLenum internalformat, GLsizei width,
+					     GLsizei height, GLsizei depth,
+					     GLint border, GLsizei imageSize,
+					     const GLvoid *data);
+void (APIENTRYP qglCompressedTexImage2DARB) (GLenum target, GLint level,
+					     GLenum internalformat, GLsizei width,
+					     GLsizei height, GLint border, 
+					     GLsizei imageSize, const GLvoid *data);
+void (APIENTRYP qglCompressedTexImage1DARB) (GLenum target, GLint level,
+					     GLenum internalformat, GLsizei width,
+					     GLint border, GLsizei imageSize,
+					     const GLvoid *data);
+void (APIENTRYP qglCompressedTexSubImage3DARB) (GLenum target, GLint level, 
+						GLint xoffset, GLint yoffset,
+						GLint zoffset, GLsizei width,
+						GLsizei height, GLsizei depth,
+						GLenum format, GLsizei imageSize,
+						const GLvoid *data);
+void (APIENTRYP qglCompressedTexSubImage2DARB) (GLenum target, GLint level, 
+						GLint xoffset, GLint yoffset,
+						GLsizei width, GLsizei height,
+						GLenum format, GLsizei imageSize,
+						const GLvoid *data);
+void (APIENTRYP qglCompressedTexSubImage1DARB) (GLenum target, GLint level, 
+						GLint xoffset, GLsizei width,
+						GLenum format, GLsizei imageSize,
+						const GLvoid *data);
+void (APIENTRYP qglGetCompressedTexImageARB) (GLenum target, GLint lod,
+					      GLvoid *img);
+
+// GL_ARB_vertex_buffer_object
+void (APIENTRYP qglBindBufferARB) (GLenum target, GLuint buffer);
+void (APIENTRYP qglDeleteBuffersARB) (GLsizei n, const GLuint *buffers);
+void (APIENTRYP qglGenBuffersARB) (GLsizei n, GLuint *buffers);
+GLboolean (APIENTRYP qglIsBufferARB) (GLuint buffer);
+void (APIENTRYP qglBufferDataARB) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
+void (APIENTRYP qglBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
+void (APIENTRYP qglGetBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
+GLvoid *(APIENTRYP qglMapBufferARB) (GLenum target, GLenum access);
+GLboolean (APIENTRYP qglUnmapBufferARB) (GLenum target);
+void (APIENTRYP qglGetBufferParameterivARB) (GLenum target, GLenum pname, GLint *params);
+void (APIENTRYP qglGetBufferPointervARB) (GLenum target, GLenum pname, GLvoid **params);
+
+// GL_ARB_shader_objects
+GLvoid (APIENTRYP qglDeleteShader) (GLuint shader);
+GLvoid (APIENTRYP qglDeleteProgram) (GLuint program);
+GLvoid (APIENTRYP qglDetachShader) (GLuint program, GLuint shader);
+GLuint (APIENTRYP qglCreateShader) (GLenum type);
+GLvoid (APIENTRYP qglShaderSource) (GLuint shader, GLsizei count, const char **string,
+				    const GLint *length);
+GLvoid (APIENTRYP qglCompileShader) (GLuint shader);
+GLuint (APIENTRYP qglCreateProgram) (void);
+GLvoid (APIENTRYP qglAttachShader) (GLuint program, GLuint shader);
+GLvoid (APIENTRYP qglLinkProgram) (GLuint program);
+GLvoid (APIENTRYP qglUseProgram) (GLuint program);
+GLvoid (APIENTRYP qglValidateProgram) (GLuint program);
+GLvoid (APIENTRYP qglUniform1f) (GLint location, GLfloat v0);
+GLvoid (APIENTRYP qglUniform2f) (GLint location, GLfloat v0, GLfloat v1);
+GLvoid (APIENTRYP qglUniform3f) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+GLvoid (APIENTRYP qglUniform4f) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+GLvoid (APIENTRYP qglUniform1i) (GLint location, GLint v0);
+GLvoid (APIENTRYP qglUniform2i) (GLint location, GLint v0, GLint v1);
+GLvoid (APIENTRYP qglUniform3i) (GLint location, GLint v0, GLint v1, GLint v2);
+GLvoid (APIENTRYP qglUniform4i) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+GLvoid (APIENTRYP qglUniform1fv) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRYP qglUniform2fv) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRYP qglUniform3fv) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRYP qglUniform4fv) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRYP qglUniform1iv) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRYP qglUniform2iv) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRYP qglUniform3iv) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRYP qglUniform4iv) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRYP qglUniformMatrix2fv) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+GLvoid (APIENTRYP qglUniformMatrix3fv) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+GLvoid (APIENTRYP qglUniformMatrix4fv) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+GLvoid (APIENTRYP qglGetShaderiv) (GLuint shader, GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglGetProgramiv) (GLuint program, GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglGetShaderInfoLog) (GLuint shader, GLsizei maxLength, GLsizei *length, char *infoLog);
+GLvoid (APIENTRYP qglGetProgramInfoLog) (GLuint program, GLsizei maxLength, GLsizei *length, char *infoLog);
+GLvoid (APIENTRYP qglGetAttachedShaders) (GLuint program, GLsizei maxCount, GLsizei *count,
+					  GLuint *shaders);
+GLint (APIENTRYP qglGetUniformLocation) (GLuint program, const char *name);
+GLvoid (APIENTRYP qglGetActiveUniform) (GLuint program, GLuint index, GLsizei maxLength,
+					GLsizei *length, GLint *size, GLenum *type, char *name);
+GLvoid (APIENTRYP qglGetUniformfv) (GLuint program, GLint location, GLfloat *params);
+GLvoid (APIENTRYP qglGetUniformiv) (GLuint program, GLint location, GLint *params);
+GLvoid (APIENTRYP qglGetShaderSource) (GLuint shader, GLsizei maxLength, GLsizei *length,
+				       char *source);
+
+// GL_ARB_vertex_shader
+GLvoid (APIENTRYP qglVertexAttrib1fARB) (GLuint index, GLfloat v0);
+GLvoid (APIENTRYP qglVertexAttrib1sARB) (GLuint index, GLshort v0);
+GLvoid (APIENTRYP qglVertexAttrib1dARB) (GLuint index, GLdouble v0);
+GLvoid (APIENTRYP qglVertexAttrib2fARB) (GLuint index, GLfloat v0, GLfloat v1);
+GLvoid (APIENTRYP qglVertexAttrib2sARB) (GLuint index, GLshort v0, GLshort v1);
+GLvoid (APIENTRYP qglVertexAttrib2dARB) (GLuint index, GLdouble v0, GLdouble v1);
+GLvoid (APIENTRYP qglVertexAttrib3fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);
+GLvoid (APIENTRYP qglVertexAttrib3sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2);
+GLvoid (APIENTRYP qglVertexAttrib3dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
+GLvoid (APIENTRYP qglVertexAttrib4fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+GLvoid (APIENTRYP qglVertexAttrib4sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);
+GLvoid (APIENTRYP qglVertexAttrib4dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
+GLvoid (APIENTRYP qglVertexAttrib4NubARB) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+GLvoid (APIENTRYP qglVertexAttrib1fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRYP qglVertexAttrib1svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib1dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRYP qglVertexAttrib2fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRYP qglVertexAttrib2svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib2dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRYP qglVertexAttrib3fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRYP qglVertexAttrib3svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib3dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRYP qglVertexAttrib4fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRYP qglVertexAttrib4svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib4dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRYP qglVertexAttrib4ivARB) (GLuint index, GLint *v);
+GLvoid (APIENTRYP qglVertexAttrib4bvARB) (GLuint index, GLbyte *v);
+GLvoid (APIENTRYP qglVertexAttrib4ubvARB) (GLuint index, GLubyte *v);
+GLvoid (APIENTRYP qglVertexAttrib4usvARB) (GLuint index, GLushort *v);
+GLvoid (APIENTRYP qglVertexAttrib4uivARB) (GLuint index, GLuint *v);
+GLvoid (APIENTRYP qglVertexAttrib4NbvARB) (GLuint index, const GLbyte *v);
+GLvoid (APIENTRYP qglVertexAttrib4NsvARB) (GLuint index, const GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib4NivARB) (GLuint index, const GLint *v);
+GLvoid (APIENTRYP qglVertexAttrib4NubvARB) (GLuint index, const GLubyte *v);
+GLvoid (APIENTRYP qglVertexAttrib4NusvARB) (GLuint index, const GLushort *v);
+GLvoid (APIENTRYP qglVertexAttrib4NuivARB) (GLuint index, const GLuint *v);
+GLvoid (APIENTRYP qglVertexAttribPointerARB) (GLuint index, GLint size, GLenum type, GLboolean normalized,
+					      GLsizei stride, const GLvoid *pointer);
+GLvoid (APIENTRYP qglEnableVertexAttribArrayARB) (GLuint index);
+GLvoid (APIENTRYP qglDisableVertexAttribArrayARB) (GLuint index);
+GLvoid (APIENTRYP qglBindAttribLocationARB) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
+GLvoid (APIENTRYP qglGetActiveAttribARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
+					  GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+GLint (APIENTRYP qglGetAttribLocationARB) (GLhandleARB programObj, const GLcharARB *name);
+GLvoid (APIENTRYP qglGetVertexAttribdvARB) (GLuint index, GLenum pname, GLdouble *params);
+GLvoid (APIENTRYP qglGetVertexAttribfvARB) (GLuint index, GLenum pname, GLfloat *params);
+GLvoid (APIENTRYP qglGetVertexAttribivARB) (GLuint index, GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglGetVertexAttribPointervARB) (GLuint index, GLenum pname, GLvoid **pointer);
+
+// GL_EXT_geometry_shader4
+GLvoid (APIENTRYP qglProgramParameteriEXT) (GLuint program, GLenum pname, GLint value);
+GLvoid (APIENTRYP qglFramebufferTextureEXT) (GLenum target, GLenum attachment,
+					     GLuint texture, GLint level);
+GLvoid (APIENTRYP qglFramebufferTextureLayerEXT) (GLenum target, GLenum attachment,
+						  GLuint texture, GLint level, int layer);
+GLvoid (APIENTRYP qglFramebufferTextureFaceEXT) (GLenum target, GLenum attachment,
+						 GLuint texture, GLint level, GLenum face);
+
+// GL_EXT_texture3D
+GLvoid (APIENTRYP qglTexImage3DEXT) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+
+// GL_ARB_framebuffer_object
+GLboolean (APIENTRYP qglIsRenderbuffer) (GLuint renderbuffer);
+GLvoid (APIENTRYP qglBindRenderbuffer) (GLenum target, GLuint renderbuffer);
+GLvoid (APIENTRYP qglDeleteRenderbuffers) (GLsizei n, const GLuint *renderbuffers);
+GLvoid (APIENTRYP qglGenRenderbuffers) (GLsizei n, GLuint *renderbuffers);
+GLvoid (APIENTRYP qglRenderbufferStorage) (GLenum target, GLenum internalformat,
+					   GLsizei width, GLsizei height);
+GLvoid (APIENTRYP qglRenderbufferStorageMultisample) (GLenum target, GLsizei samples,
+						      GLenum internalformat,
+						      GLsizei width, GLsizei height);
+GLvoid (APIENTRYP qglGetRenderbufferParameteriv) (GLenum target, GLenum pname, GLint *params);
+GLboolean (APIENTRYP qglIsFramebuffer) (GLuint framebuffer);
+GLvoid (APIENTRYP qglBindFramebuffer) (GLenum target, GLuint framebuffer);
+GLvoid (APIENTRYP qglDeleteFramebuffers) (GLsizei n, const GLuint *framebuffers);
+GLvoid (APIENTRYP qglGenFramebuffers) (GLsizei n, GLuint *framebuffers);
+GLenum (APIENTRYP qglCheckFramebufferStatus) (GLenum target);
+GLvoid (APIENTRYP qglFramebufferTexture1D) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture, GLint level);
+GLvoid (APIENTRYP qglFramebufferTexture2D) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture, GLint level);
+GLvoid (APIENTRYP qglFramebufferTexture3D) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture,
+					    GLint level, GLint layer);
+GLvoid (APIENTRYP qglFramebufferTextureLayer) (GLenum target, GLenum attachment,
+					       GLuint texture, GLint level, GLint layer);
+GLvoid (APIENTRYP qglFramebufferRenderbuffer) (GLenum target, GLenum attachment,
+					       GLenum renderbuffertarget, GLuint renderbuffer);
+GLvoid (APIENTRYP qglGetFramebufferAttachmentParameteriv) (GLenum target, GLenum attachment,
+							   GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglBlitFramebuffer) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
+				       GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
+				       GLbitfield mask, GLenum filter);
+GLvoid (APIENTRYP qglGenerateMipmap) (GLenum target);
+
+// GL_EXT_occlusion_query
+GLvoid (APIENTRYP qglGenQueriesARB) (GLsizei n, GLuint *ids);
+GLvoid (APIENTRYP qglDeleteQueriesARB) (GLsizei n, const GLuint *ids);
+GLboolean (APIENTRYP qglIsQueryARB) (GLuint id);
+GLvoid (APIENTRYP qglBeginQueryARB) (GLenum target, GLuint id);
+GLvoid (APIENTRYP qglEndQueryARB) (GLenum target);
+GLvoid (APIENTRYP qglGetQueryivARB) (GLenum target, GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglGetQueryObjectivARB) (GLuint id, GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglGetQueryObjectuivARB) (GLuint id, GLenum pname, GLuint *params);
+
+// GL_EXT_timer_query
+GLvoid (APIENTRYP qglGetQueryObjecti64vEXT) (GLuint id, GLenum pname, GLint64EXT *params);
+GLvoid (APIENTRYP qglGetQueryObjectui64vEXT) (GLuint id, GLenum pname, GLuint64EXT *params);
+
+// GL_ARB_instanced_arrays
+GLvoid (APIENTRYP qglVertexAttribDivisorARB) (GLuint index, GLuint divisor);
+GLvoid (APIENTRYP qglDrawArraysInstancedARB) (GLenum mode, GLint first, GLsizei count,
+					      GLsizei primcount);
+GLvoid (APIENTRYP qglDrawElementsInstancedARB) (GLenum mode, GLsizei count, GLenum type,
+						const GLvoid *indices, GLsizei primcount);
+
+// GL_ARB_separate_stencil
+GLvoid (APIENTRYP qglStencilOpSeparate) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
+GLvoid (APIENTRYP qglStencilFuncSeparate) (GLenum face, GLenum func, GLint ref, GLuint mask);
+GLvoid (APIENTRYP qglStencilMaskSeparate) (GLenum face, GLuint mask);
+
+// GL_ARB_debug_output, not in core
+GLvoid (APIENTRYP qglDebugMessageControlARB) (GLenum source,
+					      GLenum type,
+					      GLenum severity,
+					      GLsizei count,
+					      const GLuint* ids,
+					      GLboolean enabled);
+GLvoid (APIENTRYP qglDebugMessageInsertARB) (GLenum source,
+					     GLenum type,
+					     GLuint id,
+					     GLenum severity,
+					     GLsizei length, 
+					     const GLchar* buf);
+GLvoid (APIENTRYP qglDebugMessageCallbackARB) (GLDEBUGPROCARB callback,
+					       GLvoid *userParam);
+GLuint (APIENTRYP qglGetDebugMessageLogARB) (GLuint count,
+					     GLsizei bufsize,
+					     GLenum *sources,
+					     GLenum *types,
+					     GLuint *ids,
+					     GLenum *severities,
+					     GLsizei *lengths, 
+					     GLchar *messageLog);
+// GL_AMD_debug_output, predecessor to GL_ARB_debug_output, but has only
+// a category parameter instead of source and type
+GLvoid (APIENTRYP qglDebugMessageEnableAMD) (GLenum category,
+					     GLenum severity,
+					     GLsizei count,
+					     const GLuint* ids,
+					     GLboolean enabled);
+GLvoid (APIENTRYP qglDebugMessageInsertAMD) (GLenum category,
+					     GLuint id,
+					     GLenum severity,
+					     GLsizei length, 
+					     const GLchar* buf);
+GLvoid (APIENTRYP qglDebugMessageCallbackAMD) (GLDEBUGPROCAMD callback,
+					       GLvoid *userParam);
+GLuint (APIENTRYP qglGetDebugMessageLogAMD) (GLuint count,
+					     GLsizei bufsize,
+					     GLenum *categories,
+					     GLuint *ids,
+					     GLenum *severities,
+					     GLsizei *lengths, 
+					     GLchar *messageLog);
+
 /*
 ===============
 GLimp_Shutdown
@@ -93,8 +548,21 @@
 {
 	float oldDisplayAspect = glConfig.displayAspect;
 
+	if( glGlobals.timerQuery ) {
+		qglDeleteQueriesARB( 1, &glGlobals.timerQuery );
+	}
+
 	IN_Shutdown();
 
+	GLimp_SetCurrentContext( &initial_context );
+
+	if( r_smp->integer ) {
+		GLimp_DestroyContext( &backend_context, &frontend_context );
+	}
+	if( r_ext_debug_output->integer ) {
+		GLimp_DestroyContext( &initial_context, &backend_context );
+	}
+
 	SDL_QuitSubSystem( SDL_INIT_VIDEO );
 	screen = NULL;
 
@@ -435,7 +903,26 @@
 			continue;
 		}
 
-		opengl_context = GLimp_GetCurrentContext();
+		GLimp_GetCurrentContext( &initial_context );
+		GLimp_SetCurrentContext( NULL );
+
+		if( r_ext_debug_output->integer ) {
+			GLimp_CreateSharedContext( &initial_context,
+						   qtrue, qfalse,
+						   &backend_context );
+		} else {
+			backend_context = initial_context;
+		}
+		if( r_smp->integer ) {
+			GLimp_CreateSharedContext( &initial_context,
+						   !!r_ext_debug_output->integer,
+						   qtrue,
+						   &frontend_context );
+		} else {
+			frontend_context = backend_context;
+		}
+
+		GLimp_SetCurrentContext( &frontend_context );
 
 		ri.Printf( PRINT_ALL, "Using %d/%d/%d Color bits, %d depth, %d stencil display.\n",
 				sdlcolorbits, sdlcolorbits, sdlcolorbits, tdepthbits, tstencilbits);
@@ -521,171 +1008,1111 @@
 	return ((*ptr == ' ') || (*ptr == '\0'));  // verify it's complete string.
 }
 
-
 /*
 ===============
 GLimp_InitExtensions
 ===============
 */
-static void GLimp_InitExtensions( void )
+static void GLimp_InitExtensions( int GLversion )
 {
+#define qglGetProc2(var,proc) q##var = (typeof(q##var))SDL_GL_GetProcAddress( #proc )
+#define qglGetProc(name,ext) qglGetProc2(name##ext,name)
+
 	if ( !r_allowExtensions->integer )
 	{
 		ri.Printf( PRINT_ALL, "* IGNORING OPENGL EXTENSIONS *\n" );
-		return;
+		GLversion = 0x0000;
+	} else {
+		ri.Printf( PRINT_DEVELOPER, "Initializing OpenGL extensions\n" );
 	}
 
-	ri.Printf( PRINT_ALL, "Initializing OpenGL extensions\n" );
+	// GL_EXT_draw_range_elements, mandatory since OpenGL 1.2
+	if ( GLversion >= 0x0102 ) {
+		qglGetProc(glDrawRangeElements, EXT );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_EXT_draw_range_elements" ) ) {
+		qglGetProc(glDrawRangeElementsEXT, );
+	} else {
+		qglDrawRangeElementsEXT = NULL;
+	}
 
 	glConfig.textureCompression = TC_NONE;
 
 	// GL_EXT_texture_compression_s3tc
-	if ( GLimp_HaveExtension( "GL_ARB_texture_compression" ) &&
+	if ( GLversion &&
+	     GLimp_HaveExtension( "GL_ARB_texture_compression" ) &&
 	     GLimp_HaveExtension( "GL_EXT_texture_compression_s3tc" ) )
 	{
 		if ( r_ext_compressed_textures->value )
 		{
 			glConfig.textureCompression = TC_S3TC_ARB;
-			ri.Printf( PRINT_ALL, "...using GL_EXT_texture_compression_s3tc\n" );
+			ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_texture_compression_s3tc\n" );
 		}
 		else
 		{
-			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_compression_s3tc\n" );
+			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_texture_compression_s3tc\n" );
 		}
 	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...GL_EXT_texture_compression_s3tc not found\n" );
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_compression_s3tc not found\n" );
 	}
 
 	// GL_S3_s3tc ... legacy extension before GL_EXT_texture_compression_s3tc.
 	if (glConfig.textureCompression == TC_NONE)
 	{
-		if ( GLimp_HaveExtension( "GL_S3_s3tc" ) )
+		if ( GLversion &&
+		     GLimp_HaveExtension( "GL_S3_s3tc" ) )
 		{
 			if ( r_ext_compressed_textures->value )
 			{
 				glConfig.textureCompression = TC_S3TC;
-				ri.Printf( PRINT_ALL, "...using GL_S3_s3tc\n" );
+				ri.Printf( PRINT_DEVELOPER, "...using GL_S3_s3tc\n" );
 			}
 			else
 			{
-				ri.Printf( PRINT_ALL, "...ignoring GL_S3_s3tc\n" );
+				ri.Printf( PRINT_DEVELOPER, "...ignoring GL_S3_s3tc\n" );
 			}
 		}
 		else
 		{
-			ri.Printf( PRINT_ALL, "...GL_S3_s3tc not found\n" );
+			ri.Printf( PRINT_DEVELOPER, "...GL_S3_s3tc not found\n" );
 		}
 	}
 
 
-	// GL_EXT_texture_env_add
-	glConfig.textureEnvAddAvailable = qfalse;
-	if ( GLimp_HaveExtension( "EXT_texture_env_add" ) )
-	{
-		if ( r_ext_texture_env_add->integer )
-		{
-			glConfig.textureEnvAddAvailable = qtrue;
-			ri.Printf( PRINT_ALL, "...using GL_EXT_texture_env_add\n" );
-		}
-		else
-		{
-			glConfig.textureEnvAddAvailable = qfalse;
-			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_env_add\n" );
-		}
+	// GL_EXT_texture_env_add, mandatory since OpenGL 1.3
+	if ( !r_ext_texture_env_add->integer ) {
+		glConfig.textureEnvAddAvailable = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_texture_env_add\n" );
+	} else if ( GLversion >= 0x0103 ) {
+		glConfig.textureEnvAddAvailable = qtrue;
+		ri.Printf( PRINT_DEVELOPER, "...using GL_texture_env_add\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "EXT_texture_env_add" ) ) {
+		glConfig.textureEnvAddAvailable = qtrue;
+		ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_texture_env_add\n" );
 	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...GL_EXT_texture_env_add not found\n" );
+		glConfig.textureEnvAddAvailable = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_env_add not found\n" );
 	}
 
-	// GL_ARB_multitexture
-	qglMultiTexCoord2fARB = NULL;
-	qglActiveTextureARB = NULL;
-	qglClientActiveTextureARB = NULL;
-	if ( GLimp_HaveExtension( "GL_ARB_multitexture" ) )
-	{
-		if ( r_ext_multitexture->value )
+	// GL_ARB_multitexture, mandatory since OpenGL 1.3
+	if ( !r_ext_multitexture->value ) {
+		qglMultiTexCoord2fARB = NULL;
+		qglMultiTexCoord4fvARB = NULL;
+		qglActiveTextureARB = NULL;
+		qglClientActiveTextureARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_multitexture\n" );
+	} else if ( GLversion >= 0x0103 ) {
+		qglGetProc(glMultiTexCoord2f, ARB);
+		qglGetProc(glMultiTexCoord4fv, ARB);
+		qglGetProc(glActiveTexture, ARB);
+		qglGetProc(glClientActiveTexture, ARB);
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_multitexture" ) ) {
+		qglGetProc(glMultiTexCoord2fARB, );
+		qglGetProc(glMultiTexCoord4fvARB, );
+		qglGetProc(glActiveTextureARB, );
+		qglGetProc(glClientActiveTextureARB, );
+	} else {
+		qglMultiTexCoord2fARB = NULL;
+		qglMultiTexCoord4fvARB = NULL;
+		qglActiveTextureARB = NULL;
+		qglClientActiveTextureARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_multitexture not found\n" );
+	}
+	if ( qglActiveTextureARB )
+	{
+		qglGetIntegerv( GL_MAX_TEXTURE_UNITS_ARB, &glGlobals.maxTextureUnits );
+		glConfig.numTextureUnits = (int) glGlobals.maxTextureUnits;
+		if ( glConfig.numTextureUnits > NUM_TEXTURE_BUNDLES )
+			glConfig.numTextureUnits = NUM_TEXTURE_BUNDLES;
+		if ( r_ext_multitexture->integer > 1 &&
+		     glConfig.numTextureUnits > r_ext_multitexture->integer )
+			glConfig.numTextureUnits = r_ext_multitexture->integer;
+		if ( glConfig.numTextureUnits > 1 )
 		{
-			qglMultiTexCoord2fARB = SDL_GL_GetProcAddress( "glMultiTexCoord2fARB" );
-			qglActiveTextureARB = SDL_GL_GetProcAddress( "glActiveTextureARB" );
-			qglClientActiveTextureARB = SDL_GL_GetProcAddress( "glClientActiveTextureARB" );
-
-			if ( qglActiveTextureARB )
-			{
-				GLint glint = 0;
-				qglGetIntegerv( GL_MAX_TEXTURE_UNITS_ARB, &glint );
-				glConfig.numTextureUnits = (int) glint;
-				if ( glConfig.numTextureUnits > 1 )
-				{
-					ri.Printf( PRINT_ALL, "...using GL_ARB_multitexture\n" );
-				}
-				else
-				{
-					qglMultiTexCoord2fARB = NULL;
-					qglActiveTextureARB = NULL;
-					qglClientActiveTextureARB = NULL;
-					ri.Printf( PRINT_ALL, "...not using GL_ARB_multitexture, < 2 texture units\n" );
-				}
-			}
+			ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_multitexture (%d of %d units)\n", glConfig.numTextureUnits, glGlobals.maxTextureUnits );
 		}
 		else
 		{
-			ri.Printf( PRINT_ALL, "...ignoring GL_ARB_multitexture\n" );
-		}
-	}
-	else
-	{
-		ri.Printf( PRINT_ALL, "...GL_ARB_multitexture not found\n" );
+			qglMultiTexCoord2fARB = NULL;
+			qglActiveTextureARB = NULL;
+			qglClientActiveTextureARB = NULL;
+			ri.Printf( PRINT_DEVELOPER, "...not using GL_ARB_multitexture, < 2 texture units\n" );
+		}
+	}
+	
+	// GL_ARB_texture_compression, mandatory since OpenGL 1.3
+	if( !r_ext_texture_compression->integer ) {
+		qglCompressedTexImage3DARB = NULL;
+		qglCompressedTexImage2DARB = NULL;
+		qglCompressedTexImage1DARB = NULL;
+		qglCompressedTexSubImage3DARB = NULL;
+		qglCompressedTexSubImage2DARB = NULL;
+		qglCompressedTexSubImage1DARB = NULL;
+		qglGetCompressedTexImageARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_texture_compression\n" );
+	} else if ( GLversion >= 0x0103 ) {
+		qglGetProc(glCompressedTexImage3D, ARB);
+		qglGetProc(glCompressedTexImage2D, ARB);
+		qglGetProc(glCompressedTexImage1D, ARB);
+		qglGetProc(glCompressedTexSubImage3D, ARB);
+		qglGetProc(glCompressedTexSubImage2D, ARB);
+		qglGetProc(glCompressedTexSubImage1D, ARB);
+		qglGetProc(glGetCompressedTexImage, ARB);
+		ri.Printf( PRINT_DEVELOPER, "...using GL_texture_compression\n");
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_texture_compression" ) ) {
+		qglGetProc(glCompressedTexImage3DARB, );
+		qglGetProc(glCompressedTexImage2DARB, );
+		qglGetProc(glCompressedTexImage1DARB, );
+		qglGetProc(glCompressedTexSubImage3DARB, );
+		qglGetProc(glCompressedTexSubImage2DARB, );
+		qglGetProc(glCompressedTexSubImage1DARB, );
+		qglGetProc(glGetCompressedTexImageARB, );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_texture_compression\n");
+	} else {
+		qglCompressedTexImage3DARB = NULL;
+		qglCompressedTexImage2DARB = NULL;
+		qglCompressedTexImage1DARB = NULL;
+		qglCompressedTexSubImage3DARB = NULL;
+		qglCompressedTexSubImage2DARB = NULL;
+		qglCompressedTexSubImage1DARB = NULL;
+		qglGetCompressedTexImageARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_texture_compression not found\n" );
+	}
+
+	// GL_ARB_vertex_buffer_object, mandatory since OpenGL 1.5
+	if ( !r_ext_vertex_buffer_object->integer ) {
+		qglBindBufferARB = NULL;
+		qglDeleteBuffersARB = NULL;
+		qglGenBuffersARB = NULL;
+		qglIsBufferARB = NULL;
+		qglBufferDataARB = NULL;
+		qglBufferSubDataARB = NULL;
+		qglGetBufferSubDataARB = NULL;
+		qglMapBufferARB = NULL;
+		qglUnmapBufferARB = NULL;
+		qglGetBufferParameterivARB = NULL;
+		qglGetBufferPointervARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_vertex_buffer_object\n" );
+	} else if ( GLversion >= 0x0105 ) {
+		qglGetProc(glBindBuffer, ARB);
+		qglGetProc(glDeleteBuffers, ARB);
+		qglGetProc(glGenBuffers, ARB);
+		qglGetProc(glIsBuffer, ARB);
+		qglGetProc(glBufferData, ARB);
+		qglGetProc(glBufferSubData, ARB);
+		qglGetProc(glGetBufferSubData, ARB);
+		qglGetProc(glMapBuffer, ARB);
+		qglGetProc(glUnmapBuffer, ARB);
+		qglGetProc(glGetBufferParameteriv, ARB);
+		qglGetProc(glGetBufferPointerv, ARB);
+		ri.Printf( PRINT_DEVELOPER, "...using GL_vertex_buffer_object\n");
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_vertex_buffer_object" ) ) {
+		qglGetProc(glBindBufferARB, );
+		qglGetProc(glDeleteBuffersARB, );
+		qglGetProc(glGenBuffersARB, );
+		qglGetProc(glIsBufferARB, );
+		qglGetProc(glBufferDataARB, );
+		qglGetProc(glBufferSubDataARB, );
+		qglGetProc(glGetBufferSubDataARB, );
+		qglGetProc(glMapBufferARB, );
+		qglGetProc(glUnmapBufferARB, );
+		qglGetProc(glGetBufferParameterivARB, );
+		qglGetProc(glGetBufferPointervARB, );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_vertex_buffer_object\n" );
+	} else {
+		qglBindBufferARB = NULL;
+		qglDeleteBuffersARB = NULL;
+		qglGenBuffersARB = NULL;
+		qglIsBufferARB = NULL;
+		qglBufferDataARB = NULL;
+		qglBufferSubDataARB = NULL;
+		qglGetBufferSubDataARB = NULL;
+		qglMapBufferARB = NULL;
+		qglUnmapBufferARB = NULL;
+		qglGetBufferParameterivARB = NULL;
+		qglGetBufferPointervARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_vertex_buffer_object not found\n" );
+	}
+
+	// GL_ARB_pixel_buffer_object, mandatory since OpenGL 2.1
+	if ( !r_ext_pixel_buffer_object->integer ) {
+		glGlobals.pixelBufferObjects = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_pixel_buffer_object\n" );
+	} else if ( GLversion >= 0x0201 && qglGenBuffersARB ) {
+		glGlobals.pixelBufferObjects = qtrue;
+		ri.Printf( PRINT_DEVELOPER, "...using GL_pixel_buffer_object\n");
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_pixel_buffer_object" ) &&
+		    qglGenBuffersARB ) {
+		glGlobals.pixelBufferObjects = qtrue;
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_pixel_buffer_object\n" );
+	} else {
+		glGlobals.pixelBufferObjects = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_pixel_buffer_object not found\n" );
 	}
 
 	// GL_EXT_compiled_vertex_array
-	if ( GLimp_HaveExtension( "GL_EXT_compiled_vertex_array" ) )
-	{
-		if ( r_ext_compiled_vertex_array->value )
-		{
-			ri.Printf( PRINT_ALL, "...using GL_EXT_compiled_vertex_array\n" );
-			qglLockArraysEXT = ( void ( APIENTRY * )( GLint, GLint ) ) SDL_GL_GetProcAddress( "glLockArraysEXT" );
-			qglUnlockArraysEXT = ( void ( APIENTRY * )( void ) ) SDL_GL_GetProcAddress( "glUnlockArraysEXT" );
-			if (!qglLockArraysEXT || !qglUnlockArraysEXT)
-			{
-				ri.Error (ERR_FATAL, "bad getprocaddress");
-			}
+	if ( !r_ext_compiled_vertex_array->value ) {
+		qglLockArraysEXT = NULL;
+		qglUnlockArraysEXT = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_compiled_vertex_array\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_EXT_compiled_vertex_array" ) ) {
+		qglGetProc(glLockArraysEXT, );
+		qglGetProc(glUnlockArraysEXT, );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_compiled_vertex_array\n" );
+	} else {
+		qglLockArraysEXT = NULL;
+		qglUnlockArraysEXT = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_compiled_vertex_array not found\n" );
+	}
+
+	// GL_EXT_texture_filter_anisotropic
+	if ( !r_ext_texture_filter_anisotropic->integer ) {
+		glConfig.textureFilterAnisotropic = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_texture_filter_anisotropic\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_EXT_texture_filter_anisotropic" ) ) {
+		qglGetIntegerv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, (GLint *)&glConfig.maxAnisotropy );
+		if ( glConfig.maxAnisotropy <= 0 ) {
+			ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_filter_anisotropic not properly supported!\n" );
+			glConfig.maxAnisotropy = 0;
 		}
 		else
 		{
-			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_compiled_vertex_array\n" );
+			ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_texture_filter_anisotropic (max: %i)\n", glConfig.maxAnisotropy );
+			glConfig.textureFilterAnisotropic = qtrue;
 		}
+	} else {
+		glConfig.textureFilterAnisotropic = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_filter_anisotropic not found\n" );
+	}
+
+	// GLSL support, mandatory since OpenGL 2.0
+	if ( !r_ext_vertex_shader->integer ) {
+		qglDeleteShader = NULL;
+		qglDeleteProgram = NULL;
+		qglDetachShader = NULL;
+		qglCreateShader = NULL;
+		qglShaderSource = NULL;
+		qglCompileShader = NULL;
+		qglCreateProgram = NULL;
+		qglAttachShader = NULL;
+		qglLinkProgram = NULL;
+		qglUseProgram = NULL;
+		qglValidateProgram = NULL;
+		qglUniform1f = NULL;
+		qglUniform2f = NULL;
+		qglUniform3f = NULL;
+		qglUniform4f = NULL;
+		qglUniform1i = NULL;
+		qglUniform2i = NULL;
+		qglUniform3i = NULL;
+		qglUniform4i = NULL;
+		qglUniform1fv = NULL;
+		qglUniform2fv = NULL;
+		qglUniform3fv = NULL;
+		qglUniform4fv = NULL;
+		qglUniform1iv = NULL;
+		qglUniform2iv = NULL;
+		qglUniform3iv = NULL;
+		qglUniform4iv = NULL;
+		qglUniformMatrix2fv = NULL;
+		qglUniformMatrix3fv = NULL;
+		qglUniformMatrix4fv = NULL;
+		qglGetShaderiv = NULL;
+		qglGetProgramiv = NULL;
+		qglGetShaderInfoLog = NULL;
+		qglGetProgramInfoLog = NULL;
+		qglGetAttachedShaders = NULL;
+		qglGetUniformLocation = NULL;
+		qglGetActiveUniform = NULL;
+		qglGetUniformfv = NULL;
+		qglGetUniformiv = NULL;
+		qglGetShaderSource = NULL;
+		
+		qglVertexAttrib1fARB = NULL;
+		qglVertexAttrib1sARB = NULL;
+		qglVertexAttrib1dARB = NULL;
+		qglVertexAttrib2fARB = NULL;
+		qglVertexAttrib2sARB = NULL;
+		qglVertexAttrib2dARB = NULL;
+		qglVertexAttrib3fARB = NULL;
+		qglVertexAttrib3sARB = NULL;
+		qglVertexAttrib3dARB = NULL;
+		qglVertexAttrib4fARB = NULL;
+		qglVertexAttrib4sARB = NULL;
+		qglVertexAttrib4dARB = NULL;
+		qglVertexAttrib4NubARB = NULL;
+		qglVertexAttrib1fvARB = NULL;
+		qglVertexAttrib1svARB = NULL;
+		qglVertexAttrib1dvARB = NULL;
+		qglVertexAttrib2fvARB = NULL;
+		qglVertexAttrib2svARB = NULL;
+		qglVertexAttrib2dvARB = NULL;
+		qglVertexAttrib3fvARB = NULL;
+		qglVertexAttrib3svARB = NULL;
+		qglVertexAttrib3dvARB = NULL;
+		qglVertexAttrib4fvARB = NULL;
+		qglVertexAttrib4svARB = NULL;
+		qglVertexAttrib4dvARB = NULL;
+		qglVertexAttrib4ivARB = NULL;
+		qglVertexAttrib4bvARB = NULL;
+		qglVertexAttrib4ubvARB = NULL;
+		qglVertexAttrib4usvARB = NULL;
+		qglVertexAttrib4uivARB = NULL;
+		qglVertexAttrib4NbvARB = NULL;
+		qglVertexAttrib4NsvARB = NULL;
+		qglVertexAttrib4NivARB = NULL;
+		qglVertexAttrib4NubvARB = NULL;
+		qglVertexAttrib4NusvARB = NULL;
+		qglVertexAttrib4NuivARB = NULL;
+		qglVertexAttribPointerARB = NULL;
+		qglEnableVertexAttribArrayARB = NULL;
+		qglDisableVertexAttribArrayARB = NULL;
+		qglBindAttribLocationARB = NULL;
+		qglGetActiveAttribARB = NULL;
+		qglGetAttribLocationARB = NULL;
+		qglGetVertexAttribdvARB = NULL;
+		qglGetVertexAttribfvARB = NULL;
+		qglGetVertexAttribivARB = NULL;
+		qglGetVertexAttribPointervARB = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_vertex_shader\n" );
+	} else if ( GLversion >= 0x0200 ) {
+		qglGetProc(glDeleteShader, );
+		qglGetProc(glDeleteProgram, );
+		qglGetProc(glDetachShader, );
+		qglGetProc(glCreateShader, );
+		qglGetProc(glShaderSource, );
+		qglGetProc(glCompileShader, );
+		qglGetProc(glCreateProgram, );
+		qglGetProc(glAttachShader, );
+		qglGetProc(glLinkProgram, );
+		qglGetProc(glUseProgram, );
+		qglGetProc(glValidateProgram, );
+		qglGetProc(glUniform1f, );
+		qglGetProc(glUniform2f, );
+		qglGetProc(glUniform3f, );
+		qglGetProc(glUniform4f, );
+		qglGetProc(glUniform1i, );
+		qglGetProc(glUniform2i, );
+		qglGetProc(glUniform3i, );
+		qglGetProc(glUniform4i, );
+		qglGetProc(glUniform1fv, );
+		qglGetProc(glUniform2fv, );
+		qglGetProc(glUniform3fv, );
+		qglGetProc(glUniform4fv, );
+		qglGetProc(glUniform1iv, );
+		qglGetProc(glUniform2iv, );
+		qglGetProc(glUniform3iv, );
+		qglGetProc(glUniform4iv, );
+		qglGetProc(glUniformMatrix2fv, );
+		qglGetProc(glUniformMatrix3fv, );
+		qglGetProc(glUniformMatrix4fv, );
+		qglGetProc(glGetShaderiv, );
+		qglGetProc(glGetProgramiv, );
+		qglGetProc(glGetShaderInfoLog, );
+		qglGetProc(glGetProgramInfoLog, );
+		qglGetProc(glGetAttachedShaders, );
+		qglGetProc(glGetUniformLocation, );
+		qglGetProc(glGetActiveUniform, );
+		qglGetProc(glGetUniformfv, );
+		qglGetProc(glGetUniformiv, );
+		qglGetProc(glGetShaderSource, );
+		
+		qglGetProc(glVertexAttrib1f, ARB);
+		qglGetProc(glVertexAttrib1s, ARB);
+		qglGetProc(glVertexAttrib1d, ARB);
+		qglGetProc(glVertexAttrib2f, ARB);
+		qglGetProc(glVertexAttrib2s, ARB);
+		qglGetProc(glVertexAttrib2d, ARB);
+		qglGetProc(glVertexAttrib3f, ARB);
+		qglGetProc(glVertexAttrib3s, ARB);
+		qglGetProc(glVertexAttrib3d, ARB);
+		qglGetProc(glVertexAttrib4f, ARB);
+		qglGetProc(glVertexAttrib4s, ARB);
+		qglGetProc(glVertexAttrib4d, ARB);
+		qglGetProc(glVertexAttrib4Nub, ARB);
+		qglGetProc(glVertexAttrib1fv, ARB);
+		qglGetProc(glVertexAttrib1sv, ARB);
+		qglGetProc(glVertexAttrib1dv, ARB);
+		qglGetProc(glVertexAttrib2fv, ARB);
+		qglGetProc(glVertexAttrib2sv, ARB);
+		qglGetProc(glVertexAttrib2dv, ARB);
+		qglGetProc(glVertexAttrib3fv, ARB);
+		qglGetProc(glVertexAttrib3sv, ARB);
+		qglGetProc(glVertexAttrib3dv, ARB);
+		qglGetProc(glVertexAttrib4fv, ARB);
+		qglGetProc(glVertexAttrib4sv, ARB);
+		qglGetProc(glVertexAttrib4dv, ARB);
+		qglGetProc(glVertexAttrib4iv, ARB);
+		qglGetProc(glVertexAttrib4bv, ARB);
+		qglGetProc(glVertexAttrib4ubv, ARB);
+		qglGetProc(glVertexAttrib4usv, ARB);
+		qglGetProc(glVertexAttrib4uiv, ARB);
+		qglGetProc(glVertexAttrib4Nbv, ARB);
+		qglGetProc(glVertexAttrib4Nsv, ARB);
+		qglGetProc(glVertexAttrib4Niv, ARB);
+		qglGetProc(glVertexAttrib4Nubv, ARB);
+		qglGetProc(glVertexAttrib4Nusv, ARB);
+		qglGetProc(glVertexAttrib4Nuiv, ARB);
+		qglGetProc(glVertexAttribPointer, ARB);
+		qglGetProc(glEnableVertexAttribArray, ARB);
+		qglGetProc(glDisableVertexAttribArray, ARB);
+		qglGetProc(glBindAttribLocation, ARB);
+		qglGetProc(glGetActiveAttrib, ARB);
+		qglGetProc(glGetAttribLocation, ARB);
+		qglGetProc(glGetVertexAttribdv, ARB);
+		qglGetProc(glGetVertexAttribfv, ARB);
+		qglGetProc(glGetVertexAttribiv, ARB);
+		qglGetProc(glGetVertexAttribPointerv, ARB);
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_vertex_shader\n" );
+		
+	} else if ( GLversion &&
+	     GLimp_HaveExtension( "GL_ARB_shader_objects" ) &&
+	     GLimp_HaveExtension( "GL_ARB_fragment_shader" ) &&
+	     GLimp_HaveExtension( "GL_ARB_vertex_shader" ) &&
+	     GLimp_HaveExtension( "GL_ARB_shading_language_100" ) )
+	{
+		// many functions have been renamed from the ARB ext to GL 2.0
+		qglGetProc2(glDeleteShader, glDeleteObjectARB);
+		qglGetProc2(glDeleteProgram, glDeleteObjectARB);
+		qglGetProc2(glDetachShader, glDetachObjectARB);
+		qglGetProc2(glCreateShader, glCreateShaderObjectARB);
+		qglGetProc2(glShaderSource, glShaderSourceARB);
+		qglGetProc2(glCompileShader, glCompileShaderARB);
+		qglGetProc2(glCreateProgram, glCreateProgramObjectARB);
+		qglGetProc2(glAttachShader, glAttachObjectARB);
+		qglGetProc2(glLinkProgram, glLinkProgramARB);
+		qglGetProc2(glUseProgram, glUseProgramObjectARB);
+		qglGetProc2(glValidateProgram, glValidateProgramARB);
+		qglGetProc2(glUniform1f, glUniform1fARB);
+		qglGetProc2(glUniform2f, glUniform2fARB);
+		qglGetProc2(glUniform3f, glUniform3fARB);
+		qglGetProc2(glUniform4f, glUniform4fARB);
+		qglGetProc2(glUniform1i, glUniform1iARB);
+		qglGetProc2(glUniform2i, glUniform2iARB);
+		qglGetProc2(glUniform3i, glUniform3iARB);
+		qglGetProc2(glUniform4i, glUniform4iARB);
+		qglGetProc2(glUniform1fv, glUniform1fvARB);
+		qglGetProc2(glUniform2fv, glUniform2fvARB);
+		qglGetProc2(glUniform3fv, glUniform3fvARB);
+		qglGetProc2(glUniform4fv, glUniform4fvARB);
+		qglGetProc2(glUniform1iv, glUniform1ivARB);
+		qglGetProc2(glUniform2iv, glUniform2ivARB);
+		qglGetProc2(glUniform3iv, glUniform3ivARB);
+		qglGetProc2(glUniform4iv, glUniform4ivARB);
+		qglGetProc2(glUniform2fv, glUniformMatrix2fvARB);
+		qglGetProc2(glUniform3fv, glUniformMatrix3fvARB);
+		qglGetProc2(glUniform4fv, glUniformMatrix4fvARB);
+		qglGetProc2(glGetShaderiv, glGetObjectParameterivARB);
+		qglGetProc2(glGetProgramiv, glGetObjectParameterivARB);
+		qglGetProc2(glGetShaderInfoLog, glGetInfoLogARB);
+		qglGetProc2(glGetProgramInfoLog, glGetInfoLogARB);
+		qglGetProc2(glGetAttachedShaders, glGetAttachedObjectsARB);
+		qglGetProc2(glGetUniformLocation, glGetUniformLocationARB);
+		qglGetProc2(glGetActiveUniform, glGetActiveUniformARB);
+		qglGetProc2(glGetUniformfv, glGetUniformfvARB);
+		qglGetProc2(glGetUniformiv, glGetUniformivARB);
+		qglGetProc2(glGetShaderSource, glGetShaderSourceARB);
+		
+		qglGetProc(glVertexAttrib1fARB, );
+		qglGetProc(glVertexAttrib1sARB, );
+		qglGetProc(glVertexAttrib1dARB, );
+		qglGetProc(glVertexAttrib2fARB, );
+		qglGetProc(glVertexAttrib2sARB, );
+		qglGetProc(glVertexAttrib2dARB, );
+		qglGetProc(glVertexAttrib3fARB, );
+		qglGetProc(glVertexAttrib3sARB, );
+		qglGetProc(glVertexAttrib3dARB, );
+		qglGetProc(glVertexAttrib4fARB, );
+		qglGetProc(glVertexAttrib4sARB, );
+		qglGetProc(glVertexAttrib4dARB, );
+		qglGetProc(glVertexAttrib4NubARB, );
+		qglGetProc(glVertexAttrib1fvARB, );
+		qglGetProc(glVertexAttrib1svARB, );
+		qglGetProc(glVertexAttrib1dvARB, );
+		qglGetProc(glVertexAttrib2fvARB, );
+		qglGetProc(glVertexAttrib2svARB, );
+		qglGetProc(glVertexAttrib2dvARB, );
+		qglGetProc(glVertexAttrib3fvARB, );
+		qglGetProc(glVertexAttrib3svARB, );
+		qglGetProc(glVertexAttrib3dvARB, );
+		qglGetProc(glVertexAttrib4fvARB, );
+		qglGetProc(glVertexAttrib4svARB, );
+		qglGetProc(glVertexAttrib4dvARB, );
+		qglGetProc(glVertexAttrib4ivARB, );
+		qglGetProc(glVertexAttrib4bvARB, );
+		qglGetProc(glVertexAttrib4ubvARB, );
+		qglGetProc(glVertexAttrib4usvARB, );
+		qglGetProc(glVertexAttrib4uivARB, );
+		qglGetProc(glVertexAttrib4NbvARB, );
+		qglGetProc(glVertexAttrib4NsvARB, );
+		qglGetProc(glVertexAttrib4NivARB, );
+		qglGetProc(glVertexAttrib4NubvARB, );
+		qglGetProc(glVertexAttrib4NusvARB, );
+		qglGetProc(glVertexAttrib4NuivARB, );
+		qglGetProc(glVertexAttribPointerARB, );
+		qglGetProc(glEnableVertexAttribArrayARB, );
+		qglGetProc(glDisableVertexAttribArrayARB, );
+		qglGetProc(glBindAttribLocationARB, );
+		qglGetProc(glGetActiveAttribARB, );
+		qglGetProc(glGetAttribLocationARB, );
+		qglGetProc(glGetVertexAttribdvARB, );
+		qglGetProc(glGetVertexAttribfvARB, );
+		qglGetProc(glGetVertexAttribivARB, );
+		qglGetProc(glGetVertexAttribPointervARB, );
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_vertex_shader\n" );
 	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...GL_EXT_compiled_vertex_array not found\n" );
+		qglDeleteShader = NULL;
+		qglDeleteProgram = NULL;
+		qglDetachShader = NULL;
+		qglCreateShader = NULL;
+		qglShaderSource = NULL;
+		qglCompileShader = NULL;
+		qglCreateProgram = NULL;
+		qglAttachShader = NULL;
+		qglLinkProgram = NULL;
+		qglUseProgram = NULL;
+		qglValidateProgram = NULL;
+		qglUniform1f = NULL;
+		qglUniform2f = NULL;
+		qglUniform3f = NULL;
+		qglUniform4f = NULL;
+		qglUniform1i = NULL;
+		qglUniform2i = NULL;
+		qglUniform3i = NULL;
+		qglUniform4i = NULL;
+		qglUniform1fv = NULL;
+		qglUniform2fv = NULL;
+		qglUniform3fv = NULL;
+		qglUniform4fv = NULL;
+		qglUniform1iv = NULL;
+		qglUniform2iv = NULL;
+		qglUniform3iv = NULL;
+		qglUniform4iv = NULL;
+		qglUniformMatrix2fv = NULL;
+		qglUniformMatrix3fv = NULL;
+		qglUniformMatrix4fv = NULL;
+		qglGetShaderiv = NULL;
+		qglGetProgramiv = NULL;
+		qglGetShaderInfoLog = NULL;
+		qglGetProgramInfoLog = NULL;
+		qglGetAttachedShaders = NULL;
+		qglGetUniformLocation = NULL;
+		qglGetActiveUniform = NULL;
+		qglGetUniformfv = NULL;
+		qglGetUniformiv = NULL;
+		qglGetShaderSource = NULL;
+		
+		qglVertexAttrib1fARB = NULL;
+		qglVertexAttrib1sARB = NULL;
+		qglVertexAttrib1dARB = NULL;
+		qglVertexAttrib2fARB = NULL;
+		qglVertexAttrib2sARB = NULL;
+		qglVertexAttrib2dARB = NULL;
+		qglVertexAttrib3fARB = NULL;
+		qglVertexAttrib3sARB = NULL;
+		qglVertexAttrib3dARB = NULL;
+		qglVertexAttrib4fARB = NULL;
+		qglVertexAttrib4sARB = NULL;
+		qglVertexAttrib4dARB = NULL;
+		qglVertexAttrib4NubARB = NULL;
+		qglVertexAttrib1fvARB = NULL;
+		qglVertexAttrib1svARB = NULL;
+		qglVertexAttrib1dvARB = NULL;
+		qglVertexAttrib2fvARB = NULL;
+		qglVertexAttrib2svARB = NULL;
+		qglVertexAttrib2dvARB = NULL;
+		qglVertexAttrib3fvARB = NULL;
+		qglVertexAttrib3svARB = NULL;
+		qglVertexAttrib3dvARB = NULL;
+		qglVertexAttrib4fvARB = NULL;
+		qglVertexAttrib4svARB = NULL;
+		qglVertexAttrib4dvARB = NULL;
+		qglVertexAttrib4ivARB = NULL;
+		qglVertexAttrib4bvARB = NULL;
+		qglVertexAttrib4ubvARB = NULL;
+		qglVertexAttrib4usvARB = NULL;
+		qglVertexAttrib4uivARB = NULL;
+		qglVertexAttrib4NbvARB = NULL;
+		qglVertexAttrib4NsvARB = NULL;
+		qglVertexAttrib4NivARB = NULL;
+		qglVertexAttrib4NubvARB = NULL;
+		qglVertexAttrib4NusvARB = NULL;
+		qglVertexAttrib4NuivARB = NULL;
+		qglVertexAttribPointerARB = NULL;
+		qglEnableVertexAttribArrayARB = NULL;
+		qglDisableVertexAttribArrayARB = NULL;
+		qglBindAttribLocationARB = NULL;
+		qglGetActiveAttribARB = NULL;
+		qglGetAttribLocationARB = NULL;
+		qglGetVertexAttribdvARB = NULL;
+		qglGetVertexAttribfvARB = NULL;
+		qglGetVertexAttribivARB = NULL;
+		qglGetVertexAttribPointervARB = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_vertex_shader not found\n" );
+	}
+
+	if ( qglCreateShader ) {
+		// check that fragment shaders may access enough texture image units
+		// to render a whole shader in one pass
+		qglGetIntegerv( GL_MAX_TEXTURE_IMAGE_UNITS_ARB, &glGlobals.maxTextureImageUnits );
+		qglGetIntegerv( GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB, &glGlobals.maxVertexTextureImageUnits );
+		if ( glGlobals.maxTextureImageUnits < MAX_SHADER_STAGES + 4 ||
+		     glGlobals.maxVertexTextureImageUnits < 4 ) {
+			qglDeleteShader = NULL;
+			qglDeleteProgram = NULL;
+			qglDetachShader = NULL;
+			qglCreateShader = NULL;
+			qglShaderSource = NULL;
+			qglCompileShader = NULL;
+			qglCreateProgram = NULL;
+			qglAttachShader = NULL;
+			qglLinkProgram = NULL;
+			qglUseProgram = NULL;
+			qglValidateProgram = NULL;
+			qglUniform1f = NULL;
+			qglUniform2f = NULL;
+			qglUniform3f = NULL;
+			qglUniform4f = NULL;
+			qglUniform1i = NULL;
+			qglUniform2i = NULL;
+			qglUniform3i = NULL;
+			qglUniform4i = NULL;
+			qglUniform1fv = NULL;
+			qglUniform2fv = NULL;
+			qglUniform3fv = NULL;
+			qglUniform4fv = NULL;
+			qglUniform1iv = NULL;
+			qglUniform2iv = NULL;
+			qglUniform3iv = NULL;
+			qglUniform4iv = NULL;
+			qglUniformMatrix2fv = NULL;
+			qglUniformMatrix3fv = NULL;
+			qglUniformMatrix4fv = NULL;
+			qglGetShaderiv = NULL;
+			qglGetProgramiv = NULL;
+			qglGetShaderInfoLog = NULL;
+			qglGetProgramInfoLog = NULL;
+			qglGetAttachedShaders = NULL;
+			qglGetUniformLocation = NULL;
+			qglGetActiveUniform = NULL;
+			qglGetUniformfv = NULL;
+			qglGetUniformiv = NULL;
+			qglGetShaderSource = NULL;
+			
+			qglVertexAttrib1fARB = NULL;
+			qglVertexAttrib1sARB = NULL;
+			qglVertexAttrib1dARB = NULL;
+			qglVertexAttrib2fARB = NULL;
+			qglVertexAttrib2sARB = NULL;
+			qglVertexAttrib2dARB = NULL;
+			qglVertexAttrib3fARB = NULL;
+			qglVertexAttrib3sARB = NULL;
+			qglVertexAttrib3dARB = NULL;
+			qglVertexAttrib4fARB = NULL;
+			qglVertexAttrib4sARB = NULL;
+			qglVertexAttrib4dARB = NULL;
+			qglVertexAttrib4NubARB = NULL;
+			qglVertexAttrib1fvARB = NULL;
+			qglVertexAttrib1svARB = NULL;
+			qglVertexAttrib1dvARB = NULL;
+			qglVertexAttrib2fvARB = NULL;
+			qglVertexAttrib2svARB = NULL;
+			qglVertexAttrib2dvARB = NULL;
+			qglVertexAttrib3fvARB = NULL;
+			qglVertexAttrib3svARB = NULL;
+			qglVertexAttrib3dvARB = NULL;
+			qglVertexAttrib4fvARB = NULL;
+			qglVertexAttrib4svARB = NULL;
+			qglVertexAttrib4dvARB = NULL;
+			qglVertexAttrib4ivARB = NULL;
+			qglVertexAttrib4bvARB = NULL;
+			qglVertexAttrib4ubvARB = NULL;
+			qglVertexAttrib4usvARB = NULL;
+			qglVertexAttrib4uivARB = NULL;
+			qglVertexAttrib4NbvARB = NULL;
+			qglVertexAttrib4NsvARB = NULL;
+			qglVertexAttrib4NivARB = NULL;
+			qglVertexAttrib4NubvARB = NULL;
+			qglVertexAttrib4NusvARB = NULL;
+			qglVertexAttrib4NuivARB = NULL;
+			qglVertexAttribPointerARB = NULL;
+			qglEnableVertexAttribArrayARB = NULL;
+			qglDisableVertexAttribArrayARB = NULL;
+			qglBindAttribLocationARB = NULL;
+			qglGetActiveAttribARB = NULL;
+			qglGetAttribLocationARB = NULL;
+			qglGetVertexAttribdvARB = NULL;
+			qglGetVertexAttribfvARB = NULL;
+			qglGetVertexAttribivARB = NULL;
+			qglGetVertexAttribPointervARB = NULL;
+			
+			ri.Printf( PRINT_DEVELOPER, "Fragment/Vertex shaders support only %d/%d texture image units - disabled\n",
+				   glGlobals.maxTextureImageUnits,
+				   glGlobals.maxVertexTextureImageUnits );
+		}
+	} else {
+		glGlobals.maxTextureImageUnits = glGlobals.maxTextureUnits;
+	}
+
+	// GL_EXT_geometry_shader4, mandatory since OpenGL 3.2
+	if ( !r_ext_geometry_shader->integer ) {
+		qglProgramParameteriEXT = NULL;
+		qglFramebufferTextureEXT = NULL;
+		qglFramebufferTextureLayerEXT = NULL;
+		qglFramebufferTextureFaceEXT = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_geometry_shader4\n" );
+	} else if ( GLversion >= 0x0302 ) {
+		qglGetProc(glProgramParameteri, EXT);
+		qglGetProc(glFramebufferTexture, EXT);
+		qglGetProc(glFramebufferTextureLayer, EXT);
+		qglGetProc(glFramebufferTextureFace, EXT);
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_geometry_shader\n" );
+		
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_EXT_geometry_shader4" ) )
+	{
+		qglGetProc(glProgramParameteriEXT, );
+		qglGetProc(glFramebufferTextureEXT, );
+		qglGetProc(glFramebufferTextureLayerEXT, );
+		qglGetProc(glFramebufferTextureFaceEXT, );
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_geometry_shader4\n" );
 	}
+	else
+	{
+		qglProgramParameteriEXT = NULL;
+		qglFramebufferTextureEXT = NULL;
+		qglFramebufferTextureLayerEXT = NULL;
+		qglFramebufferTextureFaceEXT = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_geometry_shader4 not found\n" );
+	}
+
+	// GL_ARB_texture_float, mandatory since OpenGL 3.0
+	if ( !r_ext_texture_float->integer ) {
+		glGlobals.floatTextures = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_texture_float\n" );
+	} else if ( GLversion >= 0x0300 ) {
+		glGlobals.floatTextures = qtrue;
+		ri.Printf( PRINT_DEVELOPER, "...using GL_texture_float\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_texture_float" ) ) {
+		glGlobals.floatTextures = qtrue;
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_texture_float\n" );
+	} else {
+		glGlobals.floatTextures = qfalse;
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_texture_float not found\n" );
+	}
+
+	// GL_EXT_texture3D, mandatory since OpenGL 1.2
+	if ( !r_ext_texture3D->integer ) {
+		qglTexImage3DEXT = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_EXT_texture3D\n" );
+	} else if ( GLversion >= 0x0102 ) {
+		qglGetProc(glTexImage3D, EXT);
+		ri.Printf( PRINT_DEVELOPER, "...using GL_texture3D\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_EXT_texture3D" ) ) {
+		qglGetProc(glTexImage3DEXT, );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_EXT_texture3D\n" );
+	} else {
+		qglTexImage3DEXT = NULL;
+		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture3D not found\n" );
+	}
+
+	// GL_ARB_framebuffer_object, mandatory since OpenGL 3.0
+	if ( !r_ext_framebuffer_object->integer ) {
+		qglIsRenderbuffer = NULL;
+		qglBindRenderbuffer = NULL;
+		qglDeleteRenderbuffers = NULL;
+		qglGenRenderbuffers = NULL;
+		qglRenderbufferStorage = NULL;
+		qglRenderbufferStorageMultisample = NULL;
+		qglGetRenderbufferParameteriv = NULL;
+		qglIsFramebuffer = NULL;
+		qglBindFramebuffer = NULL;
+		qglDeleteFramebuffers = NULL;
+		qglGenFramebuffers = NULL;
+		qglCheckFramebufferStatus = NULL;
+		qglFramebufferTexture1D = NULL;
+		qglFramebufferTexture2D = NULL;
+		qglFramebufferTexture3D = NULL;
+		qglFramebufferTextureLayer = NULL;
+		qglFramebufferRenderbuffer = NULL;
+		qglGetFramebufferAttachmentParameteriv = NULL;
+		qglBlitFramebuffer = NULL;
+		qglGenerateMipmap = NULL;
+		
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_framebuffer_object\n" );
+	} else if ( GLversion >= 0x0300 ) {
+		qglGetProc(glIsRenderbuffer, );
+		qglGetProc(glBindRenderbuffer, );
+		qglGetProc(glDeleteRenderbuffers, );
+		qglGetProc(glGenRenderbuffers, );
+		qglGetProc(glRenderbufferStorage, );
+		qglGetProc(glRenderbufferStorageMultisample, );
+		qglGetProc(glGetRenderbufferParameteriv, );
+		qglGetProc(glIsFramebuffer, );
+		qglGetProc(glBindFramebuffer, );
+		qglGetProc(glDeleteFramebuffers, );
+		qglGetProc(glGenFramebuffers, );
+		qglGetProc(glCheckFramebufferStatus, );
+		qglGetProc(glFramebufferTexture1D, );
+		qglGetProc(glFramebufferTexture2D, );
+		qglGetProc(glFramebufferTexture3D, );
+		qglGetProc(glFramebufferTextureLayer, );
+		qglGetProc(glFramebufferRenderbuffer, );
+		qglGetProc(glGetFramebufferAttachmentParameteriv, );
+		qglGetProc(glBlitFramebuffer, );
+		qglGetProc(glGenerateMipmap, );
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_framebuffer_object\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_framebuffer_object" ) )
+	{
+		qglGetProc(glIsRenderbuffer, );
+		qglGetProc(glBindRenderbuffer, );
+		qglGetProc(glDeleteRenderbuffers, );
+		qglGetProc(glGenRenderbuffers, );
+		qglGetProc(glRenderbufferStorage, );
+		qglGetProc(glRenderbufferStorageMultisample, );
+		qglGetProc(glGetRenderbufferParameteriv, );
+		qglGetProc(glIsFramebuffer, );
+		qglGetProc(glBindFramebuffer, );
+		qglGetProc(glDeleteFramebuffers, );
+		qglGetProc(glGenFramebuffers, );
+		qglGetProc(glCheckFramebufferStatus, );
+		qglGetProc(glFramebufferTexture1D, );
+		qglGetProc(glFramebufferTexture2D, );
+		qglGetProc(glFramebufferTexture3D, );
+		qglGetProc(glFramebufferTextureLayer, );
+		qglGetProc(glFramebufferRenderbuffer, );
+		qglGetProc(glGetFramebufferAttachmentParameteriv, );
+		qglGetProc(glBlitFramebuffer, );
+		qglGetProc(glGenerateMipmap, );
 
-	glConfig.textureFilterAnisotropic = qfalse;
-	if ( GLimp_HaveExtension( "GL_EXT_texture_filter_anisotropic" ) )
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_framebuffer_object\n" );
+	}
+	else
 	{
-		if ( r_ext_texture_filter_anisotropic->integer ) {
-			qglGetIntegerv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, (GLint *)&glConfig.maxAnisotropy );
-			if ( glConfig.maxAnisotropy <= 0 ) {
-				ri.Printf( PRINT_ALL, "...GL_EXT_texture_filter_anisotropic not properly supported!\n" );
-				glConfig.maxAnisotropy = 0;
-			}
-			else
-			{
-				ri.Printf( PRINT_ALL, "...using GL_EXT_texture_filter_anisotropic (max: %i)\n", glConfig.maxAnisotropy );
-				glConfig.textureFilterAnisotropic = qtrue;
-			}
-		}
-		else
-		{
-			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_filter_anisotropic\n" );
-		}
+		qglIsRenderbuffer = NULL;
+		qglBindRenderbuffer = NULL;
+		qglDeleteRenderbuffers = NULL;
+		qglGenRenderbuffers = NULL;
+		qglRenderbufferStorage = NULL;
+		qglRenderbufferStorageMultisample = NULL;
+		qglGetRenderbufferParameteriv = NULL;
+		qglIsFramebuffer = NULL;
+		qglBindFramebuffer = NULL;
+		qglDeleteFramebuffers = NULL;
+		qglGenFramebuffers = NULL;
+		qglCheckFramebufferStatus = NULL;
+		qglFramebufferTexture1D = NULL;
+		qglFramebufferTexture2D = NULL;
+		qglFramebufferTexture3D = NULL;
+		qglFramebufferTextureLayer = NULL;
+		qglFramebufferRenderbuffer = NULL;
+		qglGetFramebufferAttachmentParameteriv = NULL;
+		qglBlitFramebuffer = NULL;
+		qglGenerateMipmap = NULL;
+		
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_framebuffer_object not found\n" );
+	}
+
+	// GL_ARB_occlusion_query, mandatory since OpenGL 1.5
+	if ( !r_ext_occlusion_query->integer ) {
+		qglGenQueriesARB = NULL;
+		qglDeleteQueriesARB = NULL;
+		qglIsQueryARB = NULL;
+		qglBeginQueryARB = NULL;
+		qglEndQueryARB = NULL;
+		qglGetQueryivARB = NULL;
+		qglGetQueryObjectivARB = NULL;
+		qglGetQueryObjectuivARB = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_occlusion_query\n" );
+	} else if ( GLversion >= 0x0105 ) {
+		qglGetProc(glGenQueries, ARB);
+		qglGetProc(glDeleteQueries, ARB);
+		qglGetProc(glIsQuery, ARB);
+		qglGetProc(glBeginQuery, ARB);
+		qglGetProc(glEndQuery, ARB);
+		qglGetProc(glGetQueryiv, ARB);
+		qglGetProc(glGetQueryObjectiv, ARB);
+		qglGetProc(glGetQueryObjectuiv, ARB);
+		ri.Printf( PRINT_DEVELOPER, "...using GL_occlusion_query\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_occlusion_query" ) ) {
+		qglGetProc(glGenQueriesARB, );
+		qglGetProc(glDeleteQueriesARB, );
+		qglGetProc(glIsQueryARB, );
+		qglGetProc(glBeginQueryARB, );
+		qglGetProc(glEndQueryARB, );
+		qglGetProc(glGetQueryivARB, );
+		qglGetProc(glGetQueryObjectivARB, );
+		qglGetProc(glGetQueryObjectuivARB, );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_occlusion_query\n" );
+	} else {
+		qglGenQueriesARB = NULL;
+		qglDeleteQueriesARB = NULL;
+		qglIsQueryARB = NULL;
+		qglBeginQueryARB = NULL;
+		qglEndQueryARB = NULL;
+		qglGetQueryivARB = NULL;
+		qglGetQueryObjectivARB = NULL;
+		qglGetQueryObjectuivARB = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_occlusion_query not found\n" );
+	}
+
+	// GL_EXT_timer_query, in core since OpenGL 3.3
+	if ( !r_ext_timer_query->integer || !qglGenQueriesARB ) {
+		glGlobals.timerQuery = 0;
+		qglGetQueryObjecti64vEXT = NULL;
+		qglGetQueryObjectui64vEXT = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_timer_query\n" );
+	} else if ( GLversion >= 0x0303 ) {
+		qglGetProc(glGetQueryObjecti64v, EXT);
+		qglGetProc(glGetQueryObjectui64v, EXT);
+		qglGenQueriesARB( 1, &glGlobals.timerQuery );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_timer_query\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_EXT_timer_query" ) ) {
+		qglGetProc(glGetQueryObjecti64vEXT, );
+		qglGetProc(glGetQueryObjectui64vEXT, );
+		qglGenQueriesARB( 1, &glGlobals.timerQuery );
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_timer_query\n" );
 	}
 	else
 	{
-		ri.Printf( PRINT_ALL, "...GL_EXT_texture_filter_anisotropic not found\n" );
+		glGlobals.timerQuery = 0;
+		qglGetQueryObjecti64vEXT = NULL;
+		qglGetQueryObjectui64vEXT = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_timer_query not found\n" );
+	}
+
+	// GL_ARB_instanced_arrays, in core since OpenGL 3.3
+	if ( !r_ext_instanced_arrays->integer ) {
+		qglVertexAttribDivisorARB = NULL;
+		qglDrawArraysInstancedARB = NULL;
+		qglDrawElementsInstancedARB = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_instanced_arrays\n" );
+	} else if ( GLversion >= 0x0303 ) {
+		qglGetProc(glVertexAttribDivisor, ARB);
+		qglGetProc(glDrawArraysInstanced, ARB);
+		qglGetProc(glDrawElementsInstanced, ARB);
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_instanced_arrays\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_instanced_arrays" ) ) {
+		qglGetProc(glVertexAttribDivisorARB, );
+		qglGetProc(glDrawArraysInstancedARB, );
+		qglGetProc(glDrawElementsInstancedARB, );
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_instanced_arrays\n" );
+	}
+	else
+	{
+		qglVertexAttribDivisorARB = NULL;
+		qglDrawArraysInstancedARB = NULL;
+		qglDrawElementsInstancedARB = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_instanced_arrays not found\n" );
+	}
+
+	// GL_ARB_separate_stencil, part of 2.0 but not a separate extension
+	if ( !r_ext_separate_stencil->integer ) {
+		qglStencilFuncSeparate = NULL;
+		qglStencilOpSeparate = NULL;
+		qglStencilMaskSeparate = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_separate_stencil\n" );
+	} else if ( GLversion >= 0x0200 ) {
+		qglGetProc(glStencilFuncSeparate, );
+		qglGetProc(glStencilOpSeparate, );
+		qglGetProc(glStencilMaskSeparate, );
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_separate_stencil\n" );
+	} else {
+		qglStencilFuncSeparate = NULL;
+		qglStencilOpSeparate = NULL;
+		qglStencilMaskSeparate = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_separate_stencil not found\n" );
+	}
+
+	// GL_{AMD/ARB}_debug_output, not in core
+	if ( !r_ext_debug_output->integer ) {
+		qglDebugMessageControlARB = NULL;
+		qglDebugMessageInsertARB = NULL;
+		qglDebugMessageCallbackARB = NULL;
+		qglGetDebugMessageLogARB = NULL;
+
+		qglDebugMessageEnableAMD = NULL;
+		qglDebugMessageInsertAMD = NULL;
+		qglDebugMessageCallbackAMD = NULL;
+		qglGetDebugMessageLogAMD = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_debug_output\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_ARB_debug_output" ) ) {
+		qglGetProc(glDebugMessageControlARB, );
+		qglGetProc(glDebugMessageInsertARB, );
+		qglGetProc(glDebugMessageCallbackARB, );
+		qglGetProc(glGetDebugMessageLogARB, );
+
+		qglDebugMessageEnableAMD = NULL;
+		qglDebugMessageInsertAMD = NULL;
+		qglDebugMessageCallbackAMD = NULL;
+		qglGetDebugMessageLogAMD = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_debug_output\n" );
+	} else if ( GLversion &&
+		    GLimp_HaveExtension( "GL_AMD_debug_output" ) ) {
+		qglDebugMessageControlARB = NULL;
+		qglDebugMessageInsertARB = NULL;
+		qglDebugMessageCallbackARB = NULL;
+		qglGetDebugMessageLogARB = NULL;
+
+		qglGetProc(glDebugMessageEnableAMD, );
+		qglGetProc(glDebugMessageInsertAMD, );
+		qglGetProc(glDebugMessageCallbackAMD, );
+		qglGetProc(glGetDebugMessageLogAMD, );
+
+		ri.Printf( PRINT_DEVELOPER, "...using GL_AMD_debug_output\n" );
+	} else {
+		qglDebugMessageControlARB = NULL;
+		qglDebugMessageInsertARB = NULL;
+		qglDebugMessageCallbackARB = NULL;
+		qglGetDebugMessageLogARB = NULL;
+
+		qglDebugMessageEnableAMD = NULL;
+		qglDebugMessageInsertAMD = NULL;
+		qglDebugMessageCallbackAMD = NULL;
+		qglGetDebugMessageLogAMD = NULL;
+
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_debug_output not found\n" );
 	}
 }
 
@@ -699,6 +2126,8 @@
 */
 void GLimp_Init( void )
 {
+	int GLmajor, GLminor;
+
 	r_allowSoftwareGL = ri.Cvar_Get( "r_allowSoftwareGL", "0", CVAR_LATCH );
 	r_sdlDriver = ri.Cvar_Get( "r_sdlDriver", "", CVAR_ROM );
 	r_allowResize = ri.Cvar_Get( "r_allowResize", "0", CVAR_ARCHIVE );
@@ -717,6 +2146,10 @@
 
 	Sys_GLimpInit( );
 
+#ifdef SDL_VIDEO_DRIVER_X11
+	XInitThreads( );
+#endif
+
 	// Create the window and set up the context
 	if( GLimp_StartDriverAndSetMode( qfalse, r_fullscreen->integer, r_noborder->integer ) )
 		goto success;
@@ -752,10 +2185,11 @@
 	if (*glConfig.renderer_string && glConfig.renderer_string[strlen(glConfig.renderer_string) - 1] == '\n')
 		glConfig.renderer_string[strlen(glConfig.renderer_string) - 1] = 0;
 	Q_strncpyz( glConfig.version_string, (char *) qglGetString (GL_VERSION), sizeof( glConfig.version_string ) );
+	sscanf( glConfig.version_string, "%d.%d", &GLmajor, &GLminor );
 	Q_strncpyz( glConfig.extensions_string, (char *) qglGetString (GL_EXTENSIONS), sizeof( glConfig.extensions_string ) );
 
 	// initialize extensions
-	GLimp_InitExtensions( );
+	GLimp_InitExtensions( (GLmajor << 8) | GLminor );
 
 	ri.Cvar_Get( "r_availableModes", "", CVAR_ROM );
 
@@ -820,7 +2254,6 @@
 
 
 
-#ifdef SMP
 /*
 ===========================================================
 
@@ -849,6 +2282,12 @@
 */
 static void GLimp_ShutdownRenderThread(void)
 {
+	if (renderThread != NULL)
+	{
+		SDL_WaitThread(renderThread, NULL);
+		renderThread = NULL;
+	}
+
 	if (smpMutex != NULL)
 	{
 		SDL_DestroyMutex(smpMutex);
@@ -877,13 +2316,13 @@
 */
 static int GLimp_RenderThreadWrapper( void *arg )
 {
-	Com_Printf( "Render thread starting\n" );
+	ri.Printf( PRINT_ALL, "Render thread starting\n" );
+	GLimp_SetCurrentContext( &backend_context );
 
 	glimpRenderThread();
 
-	GLimp_SetCurrentContext(NULL);
-
-	Com_Printf( "Render thread terminating\n" );
+	GLimp_SetCurrentContext( NULL );
+	ri.Printf( PRINT_ALL, "Render thread terminating\n" );
 
 	return 0;
 }
@@ -898,26 +2337,24 @@
 	static qboolean warned = qfalse;
 	if (!warned)
 	{
-		Com_Printf("WARNING: You enable r_smp at your own risk!\n");
+		ri.Printf( PRINT_ALL, "WARNING: You enable r_smp at your own risk!\n" );
 		warned = qtrue;
 	}
 
-#ifndef MACOS_X
+#if !defined(MACOS_X) && !defined(WIN32) && !defined (SDL_VIDEO_DRIVER_X11)
 	return qfalse;  /* better safe than sorry for now. */
 #endif
 
 	if (renderThread != NULL)  /* hopefully just a zombie at this point... */
 	{
-		Com_Printf("Already a render thread? Trying to clean it up...\n");
-		SDL_WaitThread(renderThread, NULL);
-		renderThread = NULL;
+		ri.Printf( PRINT_ALL, "Already a render thread? Trying to clean it up...\n" );
 		GLimp_ShutdownRenderThread();
 	}
 
 	smpMutex = SDL_CreateMutex();
 	if (smpMutex == NULL)
 	{
-		Com_Printf( "smpMutex creation failed: %s\n", SDL_GetError() );
+		ri.Printf( PRINT_ALL, "smpMutex creation failed: %s\n", SDL_GetError() );
 		GLimp_ShutdownRenderThread();
 		return qfalse;
 	}
@@ -925,7 +2362,7 @@
 	renderCommandsEvent = SDL_CreateCond();
 	if (renderCommandsEvent == NULL)
 	{
-		Com_Printf( "renderCommandsEvent creation failed: %s\n", SDL_GetError() );
+		ri.Printf( PRINT_ALL, "renderCommandsEvent creation failed: %s\n", SDL_GetError() );
 		GLimp_ShutdownRenderThread();
 		return qfalse;
 	}
@@ -933,7 +2370,7 @@
 	renderCompletedEvent = SDL_CreateCond();
 	if (renderCompletedEvent == NULL)
 	{
-		Com_Printf( "renderCompletedEvent creation failed: %s\n", SDL_GetError() );
+		ri.Printf( PRINT_ALL, "renderCompletedEvent creation failed: %s\n", SDL_GetError() );
 		GLimp_ShutdownRenderThread();
 		return qfalse;
 	}
@@ -972,25 +2409,21 @@
 {
 	void  *data = NULL;
 
-	GLimp_SetCurrentContext(NULL);
-
 	SDL_LockMutex(smpMutex);
 	{
 		smpData = NULL;
 		smpDataReady = qfalse;
 
 		// after this, the front end can exit GLimp_FrontEndSleep
-		SDL_CondSignal(renderCompletedEvent);
-
-		while ( !smpDataReady )
+		do {
+			SDL_CondSignal(renderCompletedEvent);
 			SDL_CondWait(renderCommandsEvent, smpMutex);
+		} while( !smpDataReady);
 
 		data = (void *)smpData;
 	}
 	SDL_UnlockMutex(smpMutex);
 
-	GLimp_SetCurrentContext(opengl_context);
-
 	return data;
 }
 
@@ -1007,8 +2440,6 @@
 			SDL_CondWait(renderCompletedEvent, smpMutex);
 	}
 	SDL_UnlockMutex(smpMutex);
-
-	GLimp_SetCurrentContext(opengl_context);
 }
 
 /*
@@ -1018,8 +2449,6 @@
 */
 void GLimp_WakeRenderer( void *data )
 {
-	GLimp_SetCurrentContext(NULL);
-
 	SDL_LockMutex(smpMutex);
 	{
 		assert( smpData == NULL );
@@ -1032,30 +2461,12 @@
 	SDL_UnlockMutex(smpMutex);
 }
 
-#else
-
-// No SMP - stubs
-void GLimp_RenderThreadWrapper( void *arg )
-{
-}
-
-qboolean GLimp_SpawnRenderThread( void (*function)( void ) )
-{
-	ri.Printf( PRINT_WARNING, "ERROR: SMP support was disabled at compile time\n");
-	return qfalse;
-}
-
-void *GLimp_RendererSleep( void )
-{
-	return NULL;
-}
-
-void GLimp_FrontEndSleep( void )
-{
-}
-
-void GLimp_WakeRenderer( void *data )
+/*
+===============
+GLimp_IsSMPActive
+===============
+*/
+qboolean GLimp_IsSMPActive( void )
 {
+	return (renderThread != NULL);
 }
-
-#endif
diff -uNr tremulous-ggp1-src.p/src/sdl/sdl_glimp.c.orig tremulous-ggp1-src/src/sdl/sdl_glimp.c.orig
--- tremulous-ggp1-src.p/src/sdl/sdl_glimp.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ tremulous-ggp1-src/src/sdl/sdl_glimp.c.orig	2012-07-19 04:25:20.321556051 +0200
@@ -0,0 +1,1061 @@
+/*
+===========================================================================
+Copyright (C) 1999-2005 Id Software, Inc.
+Copyright (C) 2000-2009 Darklegion Development
+
+This file is part of Tremulous.
+
+Tremulous is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremulous is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremulous; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+
+#ifdef USE_LOCAL_HEADERS
+#	include "SDL.h"
+#else
+#	include <SDL.h>
+#endif
+
+#ifdef SMP
+#	ifdef USE_LOCAL_HEADERS
+#		include "SDL_thread.h"
+#	else
+#		include <SDL_thread.h>
+#	endif
+#endif
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include "../renderer/tr_local.h"
+#include "../client/client.h"
+#include "../sys/sys_local.h"
+#include "sdl_icon.h"
+
+/* Just hack it for now. */
+#ifdef MACOS_X
+#include <OpenGL/OpenGL.h>
+typedef CGLContextObj QGLContext;
+#define GLimp_GetCurrentContext() CGLGetCurrentContext()
+#define GLimp_SetCurrentContext(ctx) CGLSetCurrentContext(ctx)
+#else
+typedef void *QGLContext;
+#define GLimp_GetCurrentContext() (NULL)
+#define GLimp_SetCurrentContext(ctx)
+#endif
+
+static QGLContext opengl_context;
+
+typedef enum
+{
+	RSERR_OK,
+
+	RSERR_INVALID_FULLSCREEN,
+	RSERR_INVALID_MODE,
+
+	RSERR_UNKNOWN
+} rserr_t;
+
+static SDL_Surface *screen = NULL;
+static const SDL_VideoInfo *videoInfo = NULL;
+
+cvar_t *r_allowSoftwareGL; // Don't abort out if a hardware visual can't be obtained
+cvar_t *r_allowResize; // make window resizable
+cvar_t *r_centerWindow;
+cvar_t *r_sdlDriver;
+
+void (APIENTRYP qglActiveTextureARB) (GLenum texture);
+void (APIENTRYP qglClientActiveTextureARB) (GLenum texture);
+void (APIENTRYP qglMultiTexCoord2fARB) (GLenum target, GLfloat s, GLfloat t);
+
+void (APIENTRYP qglLockArraysEXT) (GLint first, GLsizei count);
+void (APIENTRYP qglUnlockArraysEXT) (void);
+
+/*
+===============
+GLimp_Shutdown
+===============
+*/
+void GLimp_Shutdown( void )
+{
+	float oldDisplayAspect = glConfig.displayAspect;
+
+	IN_Shutdown();
+
+	SDL_QuitSubSystem( SDL_INIT_VIDEO );
+	screen = NULL;
+
+	Com_Memset( &glConfig, 0, sizeof( glConfig ) );
+	glConfig.displayAspect = oldDisplayAspect;
+	Com_Memset( &glState, 0, sizeof( glState ) );
+}
+
+/*
+===============
+GLimp_Minimize
+
+Minimize the game so that user is back at the desktop
+===============
+*/
+void GLimp_Minimize(void)
+{
+	SDL_WM_IconifyWindow();
+}
+
+
+/*
+===============
+GLimp_LogComment
+===============
+*/
+void GLimp_LogComment( char *comment )
+{
+}
+
+/*
+===============
+GLimp_CompareModes
+===============
+*/
+static int GLimp_CompareModes( const void *a, const void *b )
+{
+	const float ASPECT_EPSILON = 0.001f;
+	SDL_Rect *modeA = *(SDL_Rect **)a;
+	SDL_Rect *modeB = *(SDL_Rect **)b;
+	float aspectA = (float)modeA->w / (float)modeA->h;
+	float aspectB = (float)modeB->w / (float)modeB->h;
+	int areaA = modeA->w * modeA->h;
+	int areaB = modeB->w * modeB->h;
+	float aspectDiffA = fabs( aspectA - glConfig.displayAspect );
+	float aspectDiffB = fabs( aspectB - glConfig.displayAspect );
+	float aspectDiffsDiff = aspectDiffA - aspectDiffB;
+
+	if( aspectDiffsDiff > ASPECT_EPSILON )
+		return 1;
+	else if( aspectDiffsDiff < -ASPECT_EPSILON )
+		return -1;
+	else
+		return areaA - areaB;
+}
+
+
+/*
+===============
+GLimp_DetectAvailableModes
+===============
+*/
+static void GLimp_DetectAvailableModes(void)
+{
+	char buf[ MAX_STRING_CHARS ] = { 0 };
+	SDL_Rect **modes;
+	int numModes;
+	int i;
+
+	modes = SDL_ListModes( videoInfo->vfmt, SDL_OPENGL | SDL_FULLSCREEN );
+
+	if( !modes )
+	{
+		ri.Printf( PRINT_WARNING, "Can't get list of available modes\n" );
+		return;
+	}
+
+	if( modes == (SDL_Rect **)-1 )
+	{
+		ri.Printf( PRINT_ALL, "Display supports any resolution\n" );
+		return; // can set any resolution
+	}
+
+	for( numModes = 0; modes[ numModes ]; numModes++ );
+
+	if( numModes > 1 )
+		qsort( modes, numModes, sizeof( SDL_Rect* ), GLimp_CompareModes );
+
+	for( i = 0; i < numModes; i++ )
+	{
+		const char *newModeString = va( "%ux%u ", modes[ i ]->w, modes[ i ]->h );
+
+		if( strlen( newModeString ) < (int)sizeof( buf ) - strlen( buf ) )
+			Q_strcat( buf, sizeof( buf ), newModeString );
+		else
+			ri.Printf( PRINT_WARNING, "Skipping mode %ux%x, buffer too small\n", modes[i]->w, modes[i]->h );
+	}
+
+	if( *buf )
+	{
+		buf[ strlen( buf ) - 1 ] = 0;
+		ri.Printf( PRINT_ALL, "Available modes: '%s'\n", buf );
+		ri.Cvar_Set( "r_availableModes", buf );
+	}
+}
+
+#define R_FAILSAFE_WIDTH  640
+#define R_FAILSAFE_HEIGHT 480
+
+/*
+===============
+GLimp_SetMode
+===============
+*/
+static int GLimp_SetMode( qboolean failSafe, qboolean fullscreen, qboolean noborder )
+{
+	const char*   glstring;
+	int sdlcolorbits;
+	int colorbits, depthbits, stencilbits;
+	int tcolorbits, tdepthbits, tstencilbits;
+	int samples;
+	int i = 0;
+	SDL_Surface *vidscreen = NULL;
+	Uint32 flags = SDL_OPENGL;
+
+	ri.Printf( PRINT_ALL, "Initializing OpenGL display\n");
+
+	if ( r_allowResize->integer )
+		flags |= SDL_RESIZABLE;
+
+	if( videoInfo == NULL )
+	{
+		static SDL_VideoInfo sVideoInfo;
+		static SDL_PixelFormat sPixelFormat;
+
+		videoInfo = SDL_GetVideoInfo( );
+
+		// Take a copy of the videoInfo
+		Com_Memcpy( &sPixelFormat, videoInfo->vfmt, sizeof( SDL_PixelFormat ) );
+		sPixelFormat.palette = NULL; // Should already be the case
+		Com_Memcpy( &sVideoInfo, videoInfo, sizeof( SDL_VideoInfo ) );
+		sVideoInfo.vfmt = &sPixelFormat;
+		videoInfo = &sVideoInfo;
+
+		if( videoInfo->current_h > 0 )
+		{
+			// Guess the display aspect ratio through the desktop resolution
+			// by assuming (relatively safely) that it is set at or close to
+			// the display's native aspect ratio
+			glConfig.displayAspect = (float)videoInfo->current_w / (float)videoInfo->current_h;
+
+			ri.Printf( PRINT_ALL, "Estimated display aspect: %.3f\n", glConfig.displayAspect );
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL,
+					"Cannot estimate display aspect, assuming 1.333\n" );
+		}
+	}
+
+	if( !failSafe )
+	{
+		glConfig.vidWidth = r_width->integer;
+		glConfig.vidHeight = r_height->integer;
+		glConfig.windowAspect = r_width->value /
+			( r_height->value * r_pixelAspect->value );
+	}
+	else if( glConfig.vidWidth != R_FAILSAFE_WIDTH &&
+			glConfig.vidHeight != R_FAILSAFE_HEIGHT )
+	{
+		ri.Printf( PRINT_ALL, "Setting mode %dx%d failed, falling back on mode %dx%d\n",
+			glConfig.vidWidth, glConfig.vidHeight, R_FAILSAFE_WIDTH, R_FAILSAFE_HEIGHT );
+
+		glConfig.vidWidth = R_FAILSAFE_WIDTH;
+		glConfig.vidHeight = R_FAILSAFE_HEIGHT;
+		glConfig.windowAspect = 1.0f;
+	}
+	else
+		return RSERR_INVALID_MODE;
+
+	ri.Printf (PRINT_ALL, "...setting mode %dx%d\n", glConfig.vidWidth, glConfig.vidHeight);
+
+	if (fullscreen)
+	{
+		flags |= SDL_FULLSCREEN;
+		glConfig.isFullscreen = qtrue;
+	}
+	else
+	{
+		if (noborder)
+			flags |= SDL_NOFRAME;
+
+		glConfig.isFullscreen = qfalse;
+	}
+
+	colorbits = r_colorbits->value;
+	if ((!colorbits) || (colorbits >= 32))
+		colorbits = 24;
+
+	if (!r_depthbits->value)
+		depthbits = 24;
+	else
+		depthbits = r_depthbits->value;
+	stencilbits = r_stencilbits->value;
+	samples = r_ext_multisample->value;
+
+	for (i = 0; i < 16; i++)
+	{
+		// 0 - default
+		// 1 - minus colorbits
+		// 2 - minus depthbits
+		// 3 - minus stencil
+		if ((i % 4) == 0 && i)
+		{
+			// one pass, reduce
+			switch (i / 4)
+			{
+				case 2 :
+					if (colorbits == 24)
+						colorbits = 16;
+					break;
+				case 1 :
+					if (depthbits == 24)
+						depthbits = 16;
+					else if (depthbits == 16)
+						depthbits = 8;
+				case 3 :
+					if (stencilbits == 24)
+						stencilbits = 16;
+					else if (stencilbits == 16)
+						stencilbits = 8;
+			}
+		}
+
+		tcolorbits = colorbits;
+		tdepthbits = depthbits;
+		tstencilbits = stencilbits;
+
+		if ((i % 4) == 3)
+		{ // reduce colorbits
+			if (tcolorbits == 24)
+				tcolorbits = 16;
+		}
+
+		if ((i % 4) == 2)
+		{ // reduce depthbits
+			if (tdepthbits == 24)
+				tdepthbits = 16;
+			else if (tdepthbits == 16)
+				tdepthbits = 8;
+		}
+
+		if ((i % 4) == 1)
+		{ // reduce stencilbits
+			if (tstencilbits == 24)
+				tstencilbits = 16;
+			else if (tstencilbits == 16)
+				tstencilbits = 8;
+			else
+				tstencilbits = 0;
+		}
+
+		sdlcolorbits = 4;
+		if (tcolorbits == 24)
+			sdlcolorbits = 8;
+
+#ifdef __sgi /* Fix for SGIs grabbing too many bits of color */
+		if (sdlcolorbits == 4)
+			sdlcolorbits = 0; /* Use minimum size for 16-bit color */
+
+		/* Need alpha or else SGIs choose 36+ bit RGB mode */
+		SDL_GL_SetAttribute( SDL_GL_ALPHA_SIZE, 1);
+#endif
+
+		SDL_GL_SetAttribute( SDL_GL_RED_SIZE, sdlcolorbits );
+		SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, sdlcolorbits );
+		SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, sdlcolorbits );
+		SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, tdepthbits );
+		SDL_GL_SetAttribute( SDL_GL_STENCIL_SIZE, tstencilbits );
+
+		SDL_GL_SetAttribute( SDL_GL_MULTISAMPLEBUFFERS, samples ? 1 : 0 );
+		SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, samples );
+
+		if(r_stereoEnabled->integer)
+		{
+			glConfig.stereoEnabled = qtrue;
+			SDL_GL_SetAttribute(SDL_GL_STEREO, 1);
+		}
+		else
+		{
+			glConfig.stereoEnabled = qfalse;
+			SDL_GL_SetAttribute(SDL_GL_STEREO, 0);
+		}
+		
+		SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
+
+#if 0 // See http://bugzilla.icculus.org/show_bug.cgi?id=3526
+		// If not allowing software GL, demand accelerated
+		if( !r_allowSoftwareGL->integer )
+		{
+			if( SDL_GL_SetAttribute( SDL_GL_ACCELERATED_VISUAL, 1 ) < 0 )
+			{
+				ri.Printf( PRINT_ALL, "Unable to guarantee accelerated "
+						"visual with libSDL < 1.2.10\n" );
+			}
+		}
+#endif
+
+		if( SDL_GL_SetAttribute( SDL_GL_SWAP_CONTROL, r_swapInterval->integer ) < 0 )
+			ri.Printf( PRINT_ALL, "r_swapInterval requires libSDL >= 1.2.10\n" );
+
+#ifdef USE_ICON
+		{
+			SDL_Surface *icon = SDL_CreateRGBSurfaceFrom(
+					(void *)CLIENT_WINDOW_ICON.pixel_data,
+					CLIENT_WINDOW_ICON.width,
+					CLIENT_WINDOW_ICON.height,
+					CLIENT_WINDOW_ICON.bytes_per_pixel * 8,
+					CLIENT_WINDOW_ICON.bytes_per_pixel * CLIENT_WINDOW_ICON.width,
+#ifdef Q3_LITTLE_ENDIAN
+					0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000
+#else
+					0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF
+#endif
+					);
+
+			SDL_WM_SetIcon( icon, NULL );
+			SDL_FreeSurface( icon );
+		}
+#endif
+
+		SDL_WM_SetCaption(CLIENT_WINDOW_TITLE, CLIENT_WINDOW_MIN_TITLE);
+		SDL_ShowCursor(0);
+
+		if (!(vidscreen = SDL_SetVideoMode(glConfig.vidWidth, glConfig.vidHeight, colorbits, flags)))
+		{
+			ri.Printf( PRINT_DEVELOPER, "SDL_SetVideoMode failed: %s\n", SDL_GetError( ) );
+			continue;
+		}
+
+		opengl_context = GLimp_GetCurrentContext();
+
+		ri.Printf( PRINT_ALL, "Using %d/%d/%d Color bits, %d depth, %d stencil display.\n",
+				sdlcolorbits, sdlcolorbits, sdlcolorbits, tdepthbits, tstencilbits);
+
+		glConfig.colorBits = tcolorbits;
+		glConfig.depthBits = tdepthbits;
+		glConfig.stencilBits = tstencilbits;
+		break;
+	}
+
+	GLimp_DetectAvailableModes();
+
+	if (!vidscreen)
+	{
+		ri.Printf( PRINT_ALL, "Couldn't get a visual\n" );
+		return RSERR_INVALID_MODE;
+	}
+
+	screen = vidscreen;
+
+	glstring = (char *) qglGetString (GL_RENDERER);
+	ri.Printf( PRINT_ALL, "GL_RENDERER: %s\n", glstring );
+
+	return RSERR_OK;
+}
+
+/*
+===============
+GLimp_StartDriverAndSetMode
+===============
+*/
+static qboolean GLimp_StartDriverAndSetMode( qboolean failSafe, qboolean fullscreen, qboolean noborder )
+{
+	rserr_t err;
+
+	if (!SDL_WasInit(SDL_INIT_VIDEO))
+	{
+		char driverName[ 64 ];
+
+		if (SDL_Init(SDL_INIT_VIDEO) == -1)
+		{
+			ri.Printf( PRINT_ALL, "SDL_Init( SDL_INIT_VIDEO ) FAILED (%s)\n",
+					SDL_GetError());
+			return qfalse;
+		}
+
+		SDL_VideoDriverName( driverName, sizeof( driverName ) - 1 );
+		ri.Printf( PRINT_ALL, "SDL using driver \"%s\"\n", driverName );
+		Cvar_Set( "r_sdlDriver", driverName );
+	}
+
+	if (fullscreen && Cvar_VariableIntegerValue( "in_nograb" ) )
+	{
+		ri.Printf( PRINT_ALL, "Fullscreen not allowed with in_nograb 1\n");
+		ri.Cvar_Set( "r_fullscreen", "0" );
+		r_fullscreen->modified = qfalse;
+		fullscreen = qfalse;
+	}
+
+	err = GLimp_SetMode( failSafe, fullscreen, noborder );
+
+	switch ( err )
+	{
+		case RSERR_INVALID_FULLSCREEN:
+			ri.Printf( PRINT_ALL, "...WARNING: fullscreen unavailable in this mode\n" );
+			return qfalse;
+		case RSERR_INVALID_MODE:
+			ri.Printf( PRINT_ALL, "...WARNING: could not set the given mode\n" );
+			return qfalse;
+		default:
+			break;
+	}
+
+	return qtrue;
+}
+
+static qboolean GLimp_HaveExtension(const char *ext)
+{
+	const char *ptr = Q_stristr( glConfig.extensions_string, ext );
+	if (ptr == NULL)
+		return qfalse;
+	ptr += strlen(ext);
+	return ((*ptr == ' ') || (*ptr == '\0'));  // verify it's complete string.
+}
+
+
+/*
+===============
+GLimp_InitExtensions
+===============
+*/
+static void GLimp_InitExtensions( void )
+{
+	if ( !r_allowExtensions->integer )
+	{
+		ri.Printf( PRINT_ALL, "* IGNORING OPENGL EXTENSIONS *\n" );
+		return;
+	}
+
+	ri.Printf( PRINT_ALL, "Initializing OpenGL extensions\n" );
+
+	glConfig.textureCompression = TC_NONE;
+
+	// GL_EXT_texture_compression_s3tc
+	if ( GLimp_HaveExtension( "GL_ARB_texture_compression" ) &&
+	     GLimp_HaveExtension( "GL_EXT_texture_compression_s3tc" ) )
+	{
+		if ( r_ext_compressed_textures->value )
+		{
+			glConfig.textureCompression = TC_S3TC_ARB;
+			ri.Printf( PRINT_ALL, "...using GL_EXT_texture_compression_s3tc\n" );
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_compression_s3tc\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_ALL, "...GL_EXT_texture_compression_s3tc not found\n" );
+	}
+
+	// GL_S3_s3tc ... legacy extension before GL_EXT_texture_compression_s3tc.
+	if (glConfig.textureCompression == TC_NONE)
+	{
+		if ( GLimp_HaveExtension( "GL_S3_s3tc" ) )
+		{
+			if ( r_ext_compressed_textures->value )
+			{
+				glConfig.textureCompression = TC_S3TC;
+				ri.Printf( PRINT_ALL, "...using GL_S3_s3tc\n" );
+			}
+			else
+			{
+				ri.Printf( PRINT_ALL, "...ignoring GL_S3_s3tc\n" );
+			}
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...GL_S3_s3tc not found\n" );
+		}
+	}
+
+
+	// GL_EXT_texture_env_add
+	glConfig.textureEnvAddAvailable = qfalse;
+	if ( GLimp_HaveExtension( "EXT_texture_env_add" ) )
+	{
+		if ( r_ext_texture_env_add->integer )
+		{
+			glConfig.textureEnvAddAvailable = qtrue;
+			ri.Printf( PRINT_ALL, "...using GL_EXT_texture_env_add\n" );
+		}
+		else
+		{
+			glConfig.textureEnvAddAvailable = qfalse;
+			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_env_add\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_ALL, "...GL_EXT_texture_env_add not found\n" );
+	}
+
+	// GL_ARB_multitexture
+	qglMultiTexCoord2fARB = NULL;
+	qglActiveTextureARB = NULL;
+	qglClientActiveTextureARB = NULL;
+	if ( GLimp_HaveExtension( "GL_ARB_multitexture" ) )
+	{
+		if ( r_ext_multitexture->value )
+		{
+			qglMultiTexCoord2fARB = SDL_GL_GetProcAddress( "glMultiTexCoord2fARB" );
+			qglActiveTextureARB = SDL_GL_GetProcAddress( "glActiveTextureARB" );
+			qglClientActiveTextureARB = SDL_GL_GetProcAddress( "glClientActiveTextureARB" );
+
+			if ( qglActiveTextureARB )
+			{
+				GLint glint = 0;
+				qglGetIntegerv( GL_MAX_TEXTURE_UNITS_ARB, &glint );
+				glConfig.numTextureUnits = (int) glint;
+				if ( glConfig.numTextureUnits > 1 )
+				{
+					ri.Printf( PRINT_ALL, "...using GL_ARB_multitexture\n" );
+				}
+				else
+				{
+					qglMultiTexCoord2fARB = NULL;
+					qglActiveTextureARB = NULL;
+					qglClientActiveTextureARB = NULL;
+					ri.Printf( PRINT_ALL, "...not using GL_ARB_multitexture, < 2 texture units\n" );
+				}
+			}
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...ignoring GL_ARB_multitexture\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_ALL, "...GL_ARB_multitexture not found\n" );
+	}
+
+	// GL_EXT_compiled_vertex_array
+	if ( GLimp_HaveExtension( "GL_EXT_compiled_vertex_array" ) )
+	{
+		if ( r_ext_compiled_vertex_array->value )
+		{
+			ri.Printf( PRINT_ALL, "...using GL_EXT_compiled_vertex_array\n" );
+			qglLockArraysEXT = ( void ( APIENTRY * )( GLint, GLint ) ) SDL_GL_GetProcAddress( "glLockArraysEXT" );
+			qglUnlockArraysEXT = ( void ( APIENTRY * )( void ) ) SDL_GL_GetProcAddress( "glUnlockArraysEXT" );
+			if (!qglLockArraysEXT || !qglUnlockArraysEXT)
+			{
+				ri.Error (ERR_FATAL, "bad getprocaddress");
+			}
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_compiled_vertex_array\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_ALL, "...GL_EXT_compiled_vertex_array not found\n" );
+	}
+
+	glConfig.textureFilterAnisotropic = qfalse;
+	if ( GLimp_HaveExtension( "GL_EXT_texture_filter_anisotropic" ) )
+	{
+		if ( r_ext_texture_filter_anisotropic->integer ) {
+			qglGetIntegerv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, (GLint *)&glConfig.maxAnisotropy );
+			if ( glConfig.maxAnisotropy <= 0 ) {
+				ri.Printf( PRINT_ALL, "...GL_EXT_texture_filter_anisotropic not properly supported!\n" );
+				glConfig.maxAnisotropy = 0;
+			}
+			else
+			{
+				ri.Printf( PRINT_ALL, "...using GL_EXT_texture_filter_anisotropic (max: %i)\n", glConfig.maxAnisotropy );
+				glConfig.textureFilterAnisotropic = qtrue;
+			}
+		}
+		else
+		{
+			ri.Printf( PRINT_ALL, "...ignoring GL_EXT_texture_filter_anisotropic\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_ALL, "...GL_EXT_texture_filter_anisotropic not found\n" );
+	}
+}
+
+/*
+===============
+GLimp_Init
+
+This routine is responsible for initializing the OS specific portions
+of OpenGL
+===============
+*/
+void GLimp_Init( void )
+{
+	r_allowSoftwareGL = ri.Cvar_Get( "r_allowSoftwareGL", "0", CVAR_LATCH );
+	r_sdlDriver = ri.Cvar_Get( "r_sdlDriver", "", CVAR_ROM );
+	r_allowResize = ri.Cvar_Get( "r_allowResize", "0", CVAR_ARCHIVE );
+	r_centerWindow = ri.Cvar_Get( "r_centerWindow", "0", CVAR_ARCHIVE );
+
+	if( Cvar_VariableIntegerValue( "com_abnormalExit" ) )
+	{
+		ri.Cvar_Set( "r_width", va( "%d", R_FAILSAFE_WIDTH ) );
+		ri.Cvar_Set( "r_height", va( "%d", R_FAILSAFE_HEIGHT ) );
+		ri.Cvar_Set( "r_fullscreen", "0" );
+		ri.Cvar_Set( "r_centerWindow", "0" );
+		ri.Cvar_Set( "com_abnormalExit", "0" );
+	}
+
+	Sys_SetEnv( "SDL_VIDEO_CENTERED", r_centerWindow->integer ? "1" : "" );
+
+	Sys_GLimpInit( );
+
+	// Create the window and set up the context
+	if( GLimp_StartDriverAndSetMode( qfalse, r_fullscreen->integer, r_noborder->integer ) )
+		goto success;
+
+	// Try again, this time in a platform specific "safe mode"
+	Sys_GLimpSafeInit( );
+
+	if( GLimp_StartDriverAndSetMode( qfalse, r_fullscreen->integer, qfalse ) )
+		goto success;
+
+	// Finally, try the default screen resolution
+	if( GLimp_StartDriverAndSetMode( qtrue, r_fullscreen->integer, qfalse ) )
+		goto success;
+
+	// Nothing worked, give up
+	ri.Error( ERR_FATAL, "GLimp_Init() - could not load OpenGL subsystem\n" );
+
+success:
+	// This values force the UI to disable driver selection
+	glConfig.driverType = GLDRV_ICD;
+	glConfig.hardwareType = GLHW_GENERIC;
+	glConfig.deviceSupportsGamma = SDL_SetGamma( 1.0f, 1.0f, 1.0f ) >= 0;
+
+	// Mysteriously, if you use an NVidia graphics card and multiple monitors,
+	// SDL_SetGamma will incorrectly return false... the first time; ask
+	// again and you get the correct answer. This is a suspected driver bug, see
+	// http://bugzilla.icculus.org/show_bug.cgi?id=4316
+	glConfig.deviceSupportsGamma = SDL_SetGamma( 1.0f, 1.0f, 1.0f ) >= 0;
+
+	// get our config strings
+	Q_strncpyz( glConfig.vendor_string, (char *) qglGetString (GL_VENDOR), sizeof( glConfig.vendor_string ) );
+	Q_strncpyz( glConfig.renderer_string, (char *) qglGetString (GL_RENDERER), sizeof( glConfig.renderer_string ) );
+	if (*glConfig.renderer_string && glConfig.renderer_string[strlen(glConfig.renderer_string) - 1] == '\n')
+		glConfig.renderer_string[strlen(glConfig.renderer_string) - 1] = 0;
+	Q_strncpyz( glConfig.version_string, (char *) qglGetString (GL_VERSION), sizeof( glConfig.version_string ) );
+	Q_strncpyz( glConfig.extensions_string, (char *) qglGetString (GL_EXTENSIONS), sizeof( glConfig.extensions_string ) );
+
+	// initialize extensions
+	GLimp_InitExtensions( );
+
+	ri.Cvar_Get( "r_availableModes", "", CVAR_ROM );
+
+	// This depends on SDL_INIT_VIDEO, hence having it here
+	IN_Init( );
+}
+
+
+/*
+===============
+GLimp_EndFrame
+
+Responsible for doing a swapbuffers
+===============
+*/
+void GLimp_EndFrame( void )
+{
+	// don't flip if drawing to front buffer
+	if ( Q_stricmp( r_drawBuffer->string, "GL_FRONT" ) != 0 )
+	{
+		SDL_GL_SwapBuffers();
+	}
+
+	if( r_fullscreen->modified )
+	{
+		qboolean    fullscreen;
+		qboolean    needToToggle = qtrue;
+		qboolean    sdlToggled = qfalse;
+		SDL_Surface *s = SDL_GetVideoSurface( );
+
+		if( s )
+		{
+			// Find out the current state
+			fullscreen = !!( s->flags & SDL_FULLSCREEN );
+				
+			if( r_fullscreen->integer && Cvar_VariableIntegerValue( "in_nograb" ) )
+			{
+				ri.Printf( PRINT_ALL, "Fullscreen not allowed with in_nograb 1\n");
+				ri.Cvar_Set( "r_fullscreen", "0" );
+				r_fullscreen->modified = qfalse;
+			}
+
+			// Is the state we want different from the current state?
+			needToToggle = !!r_fullscreen->integer != fullscreen;
+
+			if( needToToggle )
+				sdlToggled = SDL_WM_ToggleFullScreen( s );
+		}
+
+		if( needToToggle )
+		{
+			// SDL_WM_ToggleFullScreen didn't work, so do it the slow way
+			if( !sdlToggled )
+				Cbuf_AddText( "vid_restart" );
+
+			IN_Restart( );
+		}
+
+		r_fullscreen->modified = qfalse;
+	}
+}
+
+
+
+#ifdef SMP
+/*
+===========================================================
+
+SMP acceleration
+
+===========================================================
+*/
+
+/*
+ * I have no idea if this will even work...most platforms don't offer
+ * thread-safe OpenGL libraries, and it looks like the original Linux
+ * code counted on each thread claiming the GL context with glXMakeCurrent(),
+ * which you can't currently do in SDL. We'll just have to hope for the best.
+ */
+
+static SDL_mutex *smpMutex = NULL;
+static SDL_cond *renderCommandsEvent = NULL;
+static SDL_cond *renderCompletedEvent = NULL;
+static void (*glimpRenderThread)( void ) = NULL;
+static SDL_Thread *renderThread = NULL;
+
+/*
+===============
+GLimp_ShutdownRenderThread
+===============
+*/
+static void GLimp_ShutdownRenderThread(void)
+{
+	if (smpMutex != NULL)
+	{
+		SDL_DestroyMutex(smpMutex);
+		smpMutex = NULL;
+	}
+
+	if (renderCommandsEvent != NULL)
+	{
+		SDL_DestroyCond(renderCommandsEvent);
+		renderCommandsEvent = NULL;
+	}
+
+	if (renderCompletedEvent != NULL)
+	{
+		SDL_DestroyCond(renderCompletedEvent);
+		renderCompletedEvent = NULL;
+	}
+
+	glimpRenderThread = NULL;
+}
+
+/*
+===============
+GLimp_RenderThreadWrapper
+===============
+*/
+static int GLimp_RenderThreadWrapper( void *arg )
+{
+	Com_Printf( "Render thread starting\n" );
+
+	glimpRenderThread();
+
+	GLimp_SetCurrentContext(NULL);
+
+	Com_Printf( "Render thread terminating\n" );
+
+	return 0;
+}
+
+/*
+===============
+GLimp_SpawnRenderThread
+===============
+*/
+qboolean GLimp_SpawnRenderThread( void (*function)( void ) )
+{
+	static qboolean warned = qfalse;
+	if (!warned)
+	{
+		Com_Printf("WARNING: You enable r_smp at your own risk!\n");
+		warned = qtrue;
+	}
+
+#ifndef MACOS_X
+	return qfalse;  /* better safe than sorry for now. */
+#endif
+
+	if (renderThread != NULL)  /* hopefully just a zombie at this point... */
+	{
+		Com_Printf("Already a render thread? Trying to clean it up...\n");
+		SDL_WaitThread(renderThread, NULL);
+		renderThread = NULL;
+		GLimp_ShutdownRenderThread();
+	}
+
+	smpMutex = SDL_CreateMutex();
+	if (smpMutex == NULL)
+	{
+		Com_Printf( "smpMutex creation failed: %s\n", SDL_GetError() );
+		GLimp_ShutdownRenderThread();
+		return qfalse;
+	}
+
+	renderCommandsEvent = SDL_CreateCond();
+	if (renderCommandsEvent == NULL)
+	{
+		Com_Printf( "renderCommandsEvent creation failed: %s\n", SDL_GetError() );
+		GLimp_ShutdownRenderThread();
+		return qfalse;
+	}
+
+	renderCompletedEvent = SDL_CreateCond();
+	if (renderCompletedEvent == NULL)
+	{
+		Com_Printf( "renderCompletedEvent creation failed: %s\n", SDL_GetError() );
+		GLimp_ShutdownRenderThread();
+		return qfalse;
+	}
+
+	glimpRenderThread = function;
+	renderThread = SDL_CreateThread(GLimp_RenderThreadWrapper, NULL);
+	if ( renderThread == NULL )
+	{
+		ri.Printf( PRINT_ALL, "SDL_CreateThread() returned %s", SDL_GetError() );
+		GLimp_ShutdownRenderThread();
+		return qfalse;
+	}
+	else
+	{
+		// tma 01/09/07: don't think this is necessary anyway?
+		//
+		// !!! FIXME: No detach API available in SDL!
+		//ret = pthread_detach( renderThread );
+		//if ( ret ) {
+		//ri.Printf( PRINT_ALL, "pthread_detach returned %d: %s", ret, strerror( ret ) );
+		//}
+	}
+
+	return qtrue;
+}
+
+static volatile void    *smpData = NULL;
+static volatile qboolean smpDataReady;
+
+/*
+===============
+GLimp_RendererSleep
+===============
+*/
+void *GLimp_RendererSleep( void )
+{
+	void  *data = NULL;
+
+	GLimp_SetCurrentContext(NULL);
+
+	SDL_LockMutex(smpMutex);
+	{
+		smpData = NULL;
+		smpDataReady = qfalse;
+
+		// after this, the front end can exit GLimp_FrontEndSleep
+		SDL_CondSignal(renderCompletedEvent);
+
+		while ( !smpDataReady )
+			SDL_CondWait(renderCommandsEvent, smpMutex);
+
+		data = (void *)smpData;
+	}
+	SDL_UnlockMutex(smpMutex);
+
+	GLimp_SetCurrentContext(opengl_context);
+
+	return data;
+}
+
+/*
+===============
+GLimp_FrontEndSleep
+===============
+*/
+void GLimp_FrontEndSleep( void )
+{
+	SDL_LockMutex(smpMutex);
+	{
+		while ( smpData )
+			SDL_CondWait(renderCompletedEvent, smpMutex);
+	}
+	SDL_UnlockMutex(smpMutex);
+
+	GLimp_SetCurrentContext(opengl_context);
+}
+
+/*
+===============
+GLimp_WakeRenderer
+===============
+*/
+void GLimp_WakeRenderer( void *data )
+{
+	GLimp_SetCurrentContext(NULL);
+
+	SDL_LockMutex(smpMutex);
+	{
+		assert( smpData == NULL );
+		smpData = data;
+		smpDataReady = qtrue;
+
+		// after this, the renderer can continue through GLimp_RendererSleep
+		SDL_CondSignal(renderCommandsEvent);
+	}
+	SDL_UnlockMutex(smpMutex);
+}
+
+#else
+
+// No SMP - stubs
+void GLimp_RenderThreadWrapper( void *arg )
+{
+}
+
+qboolean GLimp_SpawnRenderThread( void (*function)( void ) )
+{
+	ri.Printf( PRINT_WARNING, "ERROR: SMP support was disabled at compile time\n");
+	return qfalse;
+}
+
+void *GLimp_RendererSleep( void )
+{
+	return NULL;
+}
+
+void GLimp_FrontEndSleep( void )
+{
+}
+
+void GLimp_WakeRenderer( void *data )
+{
+}
+
+#endif
